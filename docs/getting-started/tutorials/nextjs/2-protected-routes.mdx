---
title: Protecting Routes and Content in Next.js
description: Learn how to protect routes and content in a Next.js application using Nhost authentication.
sidebarTitle: "Protecting Routes"
icon: lock
---

This tutorial demonstrates how to implement robust route protection in a Next.js application using Nhost authentication. You'll build a complete authentication system with a protected `/profile` page that includes server-side rendering, cross-tab session synchronization, and automatic redirects. In addition, we will see how to show conditional navigation and content based on authentication status.

<Info>
This is **Part 2** in the Full-Stack Next.js Development with Nhost series. This tutorial builds a foundation for authentication-protected routes that you can extend to secure any part of your application.
</Info>

## Full-Stack Next.js Development with Nhost

<CardGroup cols={3}>
<Card title="1. Create Project" icon="plus" href="/getting-started/tutorials/nextjs/1-introduction">
Set up your Nhost project
</Card>

<Card title="2. Protected Routes" icon="lock" href="/getting-started/tutorials/nextjs/2-protected-routes">
**Current** - Route protection basics
</Card>

<Card title="3. User Authentication" icon="user" href="/getting-started/tutorials/nextjs/3-user-authentication">
Complete auth flow
</Card>

<Card title="4. GraphQL Operations" icon="list-check" href="/getting-started/tutorials/nextjs/4-graphql-operations">
CRUD operations with GraphQL
</Card>

<Card title="5. File Uploads" icon="upload" href="/getting-started/tutorials/nextjs/5-file-uploads">
File upload and management
</Card>
</CardGroup>

## Prerequisites

- An [Nhost project](/getting-started/tutorials/create-nhost-project)
- Node.js 20+ installed
- Basic knowledge of React and Next.js

## Step-by-Step Guide

<Steps>
<Step>

### Create a New Next.js App

We'll start by creating a fresh Next.js application with TypeScript support. Next.js provides server-side rendering, file-based routing, and optimized builds for modern React applications.

```bash
npx create-next-app@15 nhost-nextjs-tutorial --typescript --eslint --app --no-tailwind --yes
cd nhost-nextjs-tutorial
npm install
```
</Step>

<Step>

### Install Required Dependencies

Install the Nhost JavaScript SDK for authentication and session management. The Nhost SDK handles authentication with built-in Next.js support for server-side rendering.

```bash
npm install @nhost/nhost-js
```
</Step>

<Step>

### Environment Configuration

Configure your Nhost project connection by creating environment variables. This allows the app to connect to your specific Nhost backend from both server and client sides.

Create a `.env.local` file in your project root:

```env
NHOST_REGION=<region>
NHOST_SUBDOMAIN=<subdomain>
```

<Warning>
Replace `<region>` and `<subdomain>` with the actual values from your Nhost project dashboard.
</Warning>
</Step>

<Step>

### Create Server-Side Nhost Helper

Create server-side utilities for handling authentication in Next.js server components and middleware. This enables server-side session access and token refresh functionality.

```tsx src/lib/nhost/server.tsx lines
import { createServerClient, type NhostClient } from "@nhost/nhost-js";
import { DEFAULT_SESSION_KEY, type Session } from "@nhost/nhost-js/session";
import { cookies } from "next/headers";
import type { NextRequest, NextResponse } from "next/server";

const key = DEFAULT_SESSION_KEY;

/**
 * Creates an Nhost client for use in server components.
 *
 * We rely on the vanilla createClient method from the Nhost JS SDK and a SessionStorage
 * customized to be able to retrieve the session from cookies in Next.js server components.
 *
 * IMPORTANT!!! We need to disable the auto-refresh token feature as we are handling it in
 * the middleware and server components are not allowed to write to cookies. Any session
 * refreshed in a server component will not be persisted and might lead to issues with the session.
 */
export async function createNhostClient(): Promise<NhostClient> {
  const cookieStore = await cookies();

  const nhost = createServerClient({
    region: process.env["NHOST_REGION"] || "local",
    subdomain: process.env["NHOST_SUBDOMAIN"] || "local",
    storage: {
      // storage compatible with Next.js server components
      get: (): Session | null => {
        const s = cookieStore.get(key)?.value || null;
        if (!s) {
          return null;
        }
        const session = JSON.parse(s) as Session;
        return session;
      },
      set: (value: Session) => {
        cookieStore.set(key, JSON.stringify(value));
      },
      remove: () => {
        cookieStore.delete(key);
      },
    },
  });

  return nhost;
}

/**
 * Middleware function to handle Nhost authentication and session management.
 *
 * This function is designed to be used in Next.js middleware to manage user sessions
 * and refresh tokens. Refreshing the session needs to be done in the middleware
 * to ensure that the session is always up-to-date an accessible by both server and client components.
 *
 * @param {NextRequest} request - The incoming Next.js request object
 * @param {NextResponse} response - The outgoing Next.js response object
 */
export async function handleNhostMiddleware(
  request: NextRequest,
  response: NextResponse<unknown>,
): Promise<Session | null> {
  const nhost = createServerClient({
    region: process.env["NHOST_REGION"] || "local",
    subdomain: process.env["NHOST_SUBDOMAIN"] || "local",
    storage: {
      // storage compatible with Next.js middleware
      get: (): Session | null => {
        const raw = request.cookies.get(key)?.value || null;
        if (!raw) {
          return null;
        }
        const session = JSON.parse(raw) as Session;
        return session;
      },
      set: (value: Session) => {
        response.cookies.set({
          name: key,
          value: JSON.stringify(value),
          path: "/",
          httpOnly: false, //if set to true we can't access it in the client
          secure: process.env.NODE_ENV === "production",
          sameSite: "lax",
          maxAge: 60 * 60 * 24 * 30, // 30 days in seconds
        });
      },
      remove: () => {
        response.cookies.delete(key);
      },
    },
  });

  // we only want to refresh the session if  the token will
  // expire in the next 60 seconds
  return await nhost.refreshSession(60);
}
```

</Step>

<Step>

### Create the Client-Side Auth Provider

Build the client-side authentication provider that manages user sessions across your Next.js application. This component provides authentication state to client components and handles cross-tab synchronization with server-side session management.

```tsx src/lib/nhost/AuthProvider.tsx lines
"use client";

import { createClient, type NhostClient } from "@nhost/nhost-js";
import type { Session } from "@nhost/nhost-js/auth";
import { CookieStorage } from "@nhost/nhost-js/session";
import { useRouter } from "next/navigation";
import {
  createContext,
  type ReactNode,
  useCallback,
  useContext,
  useEffect,
  useMemo,
  useRef,
  useState,
} from "react";

/**
 * Authentication context interface providing access to user session state and Nhost client.
 * Used throughout the application to access authentication-related data and operations.
 */
interface AuthContextType {
  /** Current authenticated user object, null if not authenticated */
  user: Session["user"] | null;
  /** Current session object containing tokens and user data, null if no active session */
  session: Session | null;
  /** Boolean indicating if user is currently authenticated */
  isAuthenticated: boolean;
  /** Boolean indicating if authentication state is still loading */
  isLoading: boolean;
  /** Nhost client instance for making authenticated requests */
  nhost: NhostClient;
}

const AuthContext = createContext<AuthContextType | null>(null);

interface AuthProviderProps {
  children: ReactNode;
}

/**
 * AuthProvider component that provides authentication context to the Next.js application.
 *
 * This component handles:
 * - Initializing the Nhost client with cookie-based session storage
 * - Managing authentication state (user, session, loading, authenticated status)
 * - Cross-tab session synchronization using sessionStorage.onChange events
 * - Detecting middleware-driven session changes through refresh token monitoring
 * - Page visibility and focus event handling to maintain session consistency
 * - Server-side state synchronization via router.refresh() when sessions change
 *
 * Key features:
 * - Uses CookieStorage for session persistence across server/client boundaries
 * - Tracks refresh token changes to detect server-side session updates
 * - Automatically refreshes page when session state changes from other sources
 * - Provides reactive authentication state for client components
 */
export const AuthProvider = ({ children }: AuthProviderProps) => {
  const [user, setUser] = useState<Session["user"] | null>(null);
  const [session, setSession] = useState<Session | null>(null);
  const [isLoading, setIsLoading] = useState<boolean>(true);
  const [isAuthenticated, setIsAuthenticated] = useState<boolean>(false);
  const lastRefreshTokenIdRef = useRef<string | null>(null);
  const router = useRouter();

  // Initialize Nhost client with cookie-based storage for server/client session sharing
  const nhost = useMemo(
    () =>
      createClient({
        region: process.env["NHOST_REGION"] || "local",
        subdomain: process.env["NHOST_SUBDOMAIN"] || "local",
        storage: new CookieStorage({
          secure: process.env.NODE_ENV === "production",
          sameSite: "lax",
        }),
      }),
    [],
  );

  /**
   * Handles session reload when refresh token changes.
   * This detects when the session has been updated by middleware or other tabs.
   *
   * @param currentRefreshTokenId - The current refresh token ID to compare against stored value
   */
  const reloadSession = useCallback(
    (currentRefreshTokenId: string | null) => {
      if (currentRefreshTokenId !== lastRefreshTokenIdRef.current) {
        lastRefreshTokenIdRef.current = currentRefreshTokenId;

        // Update local authentication state to match current session
        const currentSession = nhost.getUserSession();
        setUser(currentSession?.user || null);
        setSession(currentSession);
        setIsAuthenticated(!!currentSession);

        // Trigger Next.js page refresh to sync server-side state with client changes
        router.refresh();
      }
    },
    [nhost, router],
  );

  // Initialize authentication state and set up cross-tab session synchronization
  useEffect(() => {
    setIsLoading(true);

    // Load initial session state from Nhost client
    const currentSession = nhost.getUserSession();
    setUser(currentSession?.user || null);
    setSession(currentSession);
    setIsAuthenticated(!!currentSession);
    lastRefreshTokenIdRef.current = currentSession?.refreshTokenId ?? null;
    setIsLoading(false);

    // Subscribe to session changes from other browser tabs
    // This enables real-time synchronization when user signs in/out in another tab
    const unsubscribe = nhost.sessionStorage.onChange((session) => {
      reloadSession(session?.refreshTokenId ?? null);
    });

    return unsubscribe;
  }, [nhost, reloadSession]);

  // Handle session changes from server-side middleware and page focus events
  useEffect(() => {
    /**
     * Checks for session changes when page becomes visible or focused.
     * This catches middleware-driven session updates that occur server-side.
     */
    const checkSessionOnFocus = () => {
      reloadSession(nhost.getUserSession()?.refreshTokenId ?? null);
    };

    // Monitor page visibility changes (tab switching, window minimizing)
    document.addEventListener("visibilitychange", () => {
      if (!document.hidden) {
        checkSessionOnFocus();
      }
    });

    // Monitor window focus events (clicking back into the browser window)
    window.addEventListener("focus", checkSessionOnFocus);

    // Cleanup event listeners on component unmount
    return () => {
      document.removeEventListener("visibilitychange", checkSessionOnFocus);
      window.removeEventListener("focus", checkSessionOnFocus);
    };
  }, [nhost, reloadSession]);

  const value: AuthContextType = {
    user,
    session,
    isAuthenticated,
    isLoading,
    nhost,
  };

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
};

/**
 * Custom hook to access the authentication context.
 *
 * Must be used within a component wrapped by AuthProvider.
 * Provides access to current user session, authentication state, and Nhost client.
 *
 * @throws {Error} When used outside of AuthProvider
 * @returns {AuthContextType} Authentication context containing user, session, and client
 *
 * @example
 * ```tsx
 * function MyComponent() {
 *   const { user, isAuthenticated, nhost } = useAuth();
 *
 *   if (!isAuthenticated) {
 *     return <div>Please sign in</div>;
 *   }
 *
 *   return <div>Welcome, {user?.displayName}!</div>;
 * }
 * ```
 */
export const useAuth = (): AuthContextType => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error("useAuth must be used within an AuthProvider");
  }
  return context;
};
```

</Step>

<Step>

### Create the Protected Profile Page

Create a server-side protected page that displays user information. Since middleware handles route protection, this page can assume the user is authenticated and focus on rendering user data.

```tsx src/app/profile/page.tsx lines
import { createNhostClient } from "../../lib/nhost/server";

export default async function Profile() {
  // Create the client with async cookie access
  const nhost = await createNhostClient();
  const session = nhost.getUserSession();

  // At this point, middleware has ensured we have a session

  return (
    <div className="container">
      <header>
        <h1>Your Profile</h1>
      </header>

      <div className="profile-section">
        <h3>User Information</h3>
        <div className="user-info">
          <div className="info-item">
            <strong>Display Name:</strong>
            <span>{session?.user?.displayName || "Not set"}</span>
          </div>
          <div className="info-item">
            <strong>Email:</strong>
            <span>{session?.user?.email || "Not available"}</span>
          </div>
          <div className="info-item">
            <strong>User ID:</strong>
            <span className="user-id">{session?.user?.id || "Not available"}</span>
          </div>
          <div className="info-item">
            <strong>Roles:</strong>
            <span>{session?.user?.roles?.join(", ") || "None"}</span>
          </div>
          <div className="info-item">
            <strong>Email Verified:</strong>
            <span className={session?.user?.emailVerified ? 'verified' : 'unverified'}>
              {session?.user?.emailVerified ? "✓ Yes" : "✗ No"}
            </span>
          </div>
        </div>
      </div>

      <div className="session-section">
        <h3>Session Information</h3>
        <pre className="session-data">
          {JSON.stringify(session, null, 2)}
        </pre>
      </div>
    </div>
  );
}
```

</Step>

<Step>

### Create a Simple Home Page

Build a public homepage that adapts its content based on authentication status. This shows users different options depending on whether they're signed in.

```tsx src/app/page.tsx lines
import { createNhostClient } from "../lib/nhost/server";

export default async function Home() {
  const nhost = await createNhostClient();
  const session = nhost.getUserSession();

  return (
    <div className="container">
      <header>
        <h1>Welcome to Nhost Next.js Demo</h1>
      </header>

      {session ? (
        <div>
          <p>Hello, {session.user?.displayName || session.user?.email}!</p>
        </div>
      ) : (
        <div>
          <p>You are not signed in.</p>
        </div>
      )}
    </div>
  );
}
```
</Step>

<Step>

### Create the Navigation Component

Create a server-side navigation component that provides consistent navigation across all pages. This component adapts its links based on authentication status - showing different options for signed-in and signed-out users with server-side rendering.

```tsx src/components/Navigation.tsx lines
import Link from "next/link";
import { createNhostClient } from "../lib/nhost/server";
import SignOutButton from "./SignOutButton";

export default async function Navigation() {
  const nhost = await createNhostClient();
  const session = nhost.getUserSession();

  return (
    <nav className="navigation">
      <div className="nav-container">
        <div className="nav-content">
          <Link href="/" className="logo">
            Nhost Next.js Demo
          </Link>

          <div className="nav-links">
            <Link href="/" className="nav-link">
              Home
            </Link>

            {session ? (
              <>
                <Link href="/profile" className="nav-link">
                  Profile
                </Link>
                <SignOutButton />
              </>
            ) : (
              <>
               Placeholder for signin/signup links
              </>
            )}
          </div>
        </div>
      </div>
    </nav>
  );
}
```

Create the client-side SignOutButton component:

```tsx src/components/SignOutButton.tsx lines
"use client";

import { useRouter } from "next/navigation";
import { useAuth } from "../lib/nhost/AuthProvider";

export default function SignOutButton() {
  const { session, nhost } = useAuth();
  const router = useRouter();

  const handleSignOut = async () => {
    try {
      if (session) {
        await nhost.auth.signOut({
          refreshToken: session.refreshToken,
        });
      }
      router.push("/");
    } catch (err: any) {
      console.error("Error signing out:", err);
    }
  };

  return (
    <button
      onClick={handleSignOut}
      className="sign-out-btn"
    >
      Sign Out
    </button>
  );
}
```
</Step>

<Step>

### Create Middleware for Route Protection

Create Next.js middleware to handle route protection at the server level. This middleware runs before any page renders and automatically redirects unauthenticated users from protected routes.

```tsx src/middleware.ts lines
import type { NextRequest } from "next/server";
import { NextResponse } from "next/server";
import { handleNhostMiddleware } from "./lib/nhost/server";

// Define public routes that don't require authentication
const publicRoutes = ["/"];

export async function middleware(request: NextRequest) {
  // Create a response that we'll modify as needed
  const response = NextResponse.next();

  // Get the current path
  const path = request.nextUrl.pathname;

  // Check if this is a public route or a public asset
  const isPublicRoute = publicRoutes.some(
    (route) => path === route || path.startsWith(`${route}/`),
  );

  // Handle Nhost authentication and token refresh
  // Always call this to ensure session is up-to-date
  // even for public routes, so that session changes are detected
  const session = await handleNhostMiddleware(request, response);

  // If it's a public route, allow access without checking auth
  if (isPublicRoute) {
    return response;
  }

  // If no session and not a public route, redirect to signin
  if (!session) {
    const homeUrl = new URL("/", request.url);
    return NextResponse.redirect(homeUrl);
  }

  // Session exists, allow access to protected route
  return response;
}

// Define which routes this middleware should run on
export const config = {
  matcher: [
    /*
     * Match all request paths except:
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     * - public files (public directory)
     */
    "/((?!_next/static|_next/image|favicon.ico|public).*)",
  ],
};
```

</Step>

<Step>

### Create CSS Styles

Create a `src/app/globals.css` file with the following styles for the application:

```css src/app/globals.css lines
body {
  font-family: Arial, sans-serif;
  margin: 0;
  padding: 0;
  background-color: #f9f9f9;
}

.app {
  min-height: 100vh;
}

/* Navigation Styles */
.navigation {
  background-color: white;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  border-bottom: 1px solid #e5e5e5;
}

.nav-container {
  max-width: 800px;
  margin: 0 auto;
  padding: 0 24px;
}

.nav-content {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 16px 0;
}

.logo {
  font-size: 20px;
  font-weight: bold;
  color: #333;
  text-decoration: none;
}

.logo:hover {
  color: #0066cc;
}

.nav-links {
  display: flex;
  align-items: center;
  gap: 16px;
}

.nav-link {
  color: #666;
  text-decoration: none;
}

.nav-link:hover {
  color: #333;
}

.sign-out-btn {
  color: #dc2626;
  background: none;
  border: none;
  cursor: pointer;
  font-weight: 500;
}

.sign-out-btn:hover {
  color: #991b1b;
}

/* Container Styles */
.container {
  max-width: 800px;
  margin: 0 auto;
  padding: 24px;
}

header {
  margin-bottom: 32px;
}

header h1 {
  font-size: 32px;
  font-weight: bold;
  color: #333;
  margin: 0;
}

/* Profile Page Styles */
.profile-section,
.session-section {
  background-color: white;
  box-shadow: 0 1px 3px rgba(0,0,0,0.1);
  border-radius: 8px;
  padding: 24px;
  margin-bottom: 24px;
}

.profile-section h3,
.session-section h3 {
  font-size: 18px;
  font-weight: 500;
  color: #333;
  margin: 0 0 16px 0;
}

.user-info {
  display: flex;
  flex-direction: column;
  gap: 16px;
}

.info-item {
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.info-item strong {
  color: #555;
  font-weight: 600;
}

.info-item span {
  color: #333;
}

.user-id {
  font-family: monospace;
  font-size: 14px;
}

.verified {
  color: #16a34a;
  font-weight: 500;
}

.unverified {
  color: #dc2626;
  font-weight: 500;
}

.session-data {
  font-size: 14px;
  color: #666;
  background-color: #f8f8f8;
  padding: 16px;
  border-radius: 4px;
  overflow: auto;
  white-space: pre-wrap;
  margin: 0;
}
```

</Step>

<Step>

### Update the Root Layout

Configure the Next.js root layout to include the authentication provider and navigation. This provides authentication context to all client components and includes the navigation bar on every page.

```tsx src/app/layout.tsx lines
import type { Metadata } from "next";
import "./globals.css";
import Navigation from "../components/Navigation";
import { AuthProvider } from "../lib/nhost/AuthProvider";

export const metadata: Metadata = {
  title: "Nhost Next.js Tutorial",
  description: "Next.js tutorial with Nhost authentication",
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body>
        <AuthProvider>
          <div className="app">
            <Navigation />
            <main>{children}</main>
          </div>
        </AuthProvider>
      </body>
    </html>
  );
}
```
</Step>

<Step>

### Run the Application

Start the development server to test your route protection implementation:

```bash
npm run dev
```

<Tip>
Navigate to `http://localhost:3000/profile` to see the route protection in action - you'll be redirected to `/signin` since you're not authenticated yet. Notice how the navigation bar shows different options based on your authentication status, all rendered server-side for optimal performance.
</Tip>
</Step>
</Steps>

## How It Works

1. **Server-Side Helpers**: Utilities for handling authentication in Next.js server components and middleware
2. **Middleware Route Protection**: Next.js middleware runs before any page renders, automatically redirecting unauthenticated users from protected routes and refreshing tokens
3. **AuthProvider**: Client-side provider that manages authentication state using Nhost's client with cookie-based storage for server/client synchronization
4. **Protected Pages**: Server components can assume authentication since middleware handles protection, focusing purely on rendering authenticated content
5. **Navigation**: Server-side navigation component that adapts its links based on authentication status
6. **Automatic Redirects**: All route protection and redirects are handled at the middleware level for optimal performance and security

## Key Features Demonstrated

<AccordionGroup>
<Accordion title="Middleware Route Protection" icon="shield-check">
Routes are protected at the middleware level, running before any page renders to provide the highest level of security and performance by preventing unauthorized access before components load.
</Accordion>

<Accordion title="No Loading States" icon="zap">
Server-side authentication checks eliminate the need for loading spinners during authentication verification, providing instant feedback to users.
</Accordion>

<Accordion title="Automatic Server Redirects" icon="arrow-right">
Users are automatically redirected based on their authentication status using Next.js server-side redirects, ensuring proper navigation flow before any client-side rendering.
</Accordion>

<Accordion title="Cross-tab Synchronization" icon="arrows-rotate">
Authentication state is synchronized across multiple browser tabs using Nhost's session storage events with Next.js router refresh for server-side state updates.
</Accordion>

<Accordion title="Cookie-Based Session Management" icon="circle-user">
Complete user session and profile information is shared between server and client using cookie-based storage, enabling seamless SSR and client-side functionality.
</Accordion>

<Accordion title="Server-Side Rendering" icon="server">
Authentication-dependent content is rendered server-side for improved SEO, performance, and security compared to client-only approaches.
</Accordion>

<Accordion title="Automatic Token Refresh" icon="refresh">
Middleware automatically refreshes authentication tokens before they expire, ensuring seamless user experience without manual token management.
</Accordion>
</AccordionGroup>
