// Code generated by github.com/cshum/vipsgen from libvips 8.17.2; DO NOT EDIT.

package vips

// #cgo pkg-config: vips
// #include "util.h"
import "C"
import (
	"fmt"
	"runtime"
	"sync"
	"unsafe"
)

// Version is the full libvips version string (x.y.z)
const Version = string(C.VIPS_VERSION)

// MajorVersion is the libvips major component of the version string (x in x.y.z)
const MajorVersion = int(C.VIPS_MAJOR_VERSION)

// MinorVersion is the libvips minor component of the version string (y in x.y.z)
const MinorVersion = int(C.VIPS_MINOR_VERSION)

// MicroVersion is the libvips micro component of the version string (z in x.y.z)
// Also known as patch version
const MicroVersion = int(C.VIPS_MICRO_VERSION)

var (
	lock       sync.Mutex
	once       sync.Once
	isStarted  bool
	isShutdown bool
)

type Config struct {
	ConcurrencyLevel int
	MaxCacheFiles    int
	MaxCacheMem      int
	MaxCacheSize     int
	ReportLeaks      bool
	CacheTrace       bool
	VectorEnabled    bool
}

// LogLevel log level
type LogLevel int

// LogLevel enum
const (
	LogLevelError    LogLevel = C.G_LOG_LEVEL_ERROR
	LogLevelCritical LogLevel = C.G_LOG_LEVEL_CRITICAL
	LogLevelWarning  LogLevel = C.G_LOG_LEVEL_WARNING
	LogLevelMessage  LogLevel = C.G_LOG_LEVEL_MESSAGE
	LogLevelInfo     LogLevel = C.G_LOG_LEVEL_INFO
	LogLevelDebug    LogLevel = C.G_LOG_LEVEL_DEBUG
)

var (
	currentLoggingHandlerFunction = noopLoggingHandler
	currentLoggingVerbosity       LogLevel
)

// LoggingHandlerFunction logging handler function
type LoggingHandlerFunction func(messageDomain string, messageLevel LogLevel, message string)

// SetLogging set logging handler and verbosity
func SetLogging(handler LoggingHandlerFunction, verbosity LogLevel) {
	if handler != nil {
		currentLoggingHandlerFunction = handler
	}
	currentLoggingVerbosity = verbosity
}

func noopLoggingHandler(_ string, _ LogLevel, _ string) {
}

func log(domain string, level LogLevel, message string) {
	if level <= currentLoggingVerbosity {
		currentLoggingHandlerFunction(domain, level, message)
	}
}

func enableLogging() {
	C.set_logging_handler()
}

func disableLogging() {
	C.unset_logging_handler()
}

// Startup sets up libvips and ensures the versions are correct. Pass in nil for default config.
func Startup(config *Config) {
	once.Do(func() {
		startup(config)
	})
}

func startup(config *Config) {
	lock.Lock()
	defer lock.Unlock()

	if isStarted || isShutdown {
		return
	}

	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	if MajorVersion < 8 || (MajorVersion == 8 && MinorVersion < 10) {
		panic("requires libvips version 8.10+")
	}

	cName := C.CString("vips")
	defer freeCString(cName)

	// Override default glib logging handler to intercept logging messages
	enableLogging()

	err := C.vips_init(cName)
	if err != 0 {
		panic(fmt.Sprintf("Failed to start vips code=%v", err))
	}

	if config != nil {
		C.vips_leak_set(toGboolean(config.ReportLeaks))
	}

	if config != nil && config.ConcurrencyLevel >= 0 {
		C.vips_concurrency_set(C.int(config.ConcurrencyLevel))
	} else {
		C.vips_concurrency_set(1)
	}

	if config != nil && config.MaxCacheFiles >= 0 {
		C.vips_cache_set_max_files(C.int(config.MaxCacheFiles))
	} else {
		C.vips_cache_set_max_files(0)
	}

	if config != nil && config.MaxCacheMem >= 0 {
		C.vips_cache_set_max_mem(C.size_t(config.MaxCacheMem))
	} else {
		C.vips_cache_set_max_mem(0)
	}

	if config != nil && config.MaxCacheSize >= 0 {
		C.vips_cache_set_max(C.int(config.MaxCacheSize))
	} else {
		C.vips_cache_set_max(0)
	}

	if config != nil && config.VectorEnabled {
		C.vips_vector_set_enabled(1)
	} else {
		C.vips_vector_set_enabled(0)
	}

	if config != nil && config.CacheTrace {
		C.vips_cache_set_trace(toGboolean(true))
	}

	log("vipsgen", LogLevelInfo, fmt.Sprintf("vips %s started with concurrency=%d cache_max_files=%d cache_max_mem=%d cache_max=%d",
		Version,
		int(C.vips_concurrency_get()),
		int(C.vips_cache_get_max_files()),
		int(C.vips_cache_get_max_mem()),
		int(C.vips_cache_get_max())))

	isStarted = true
}

// Shutdown libvips
func Shutdown() {
	lock.Lock()
	defer lock.Unlock()

	if !isStarted || isShutdown {
		return
	}

	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	C.vips_shutdown()
	disableLogging()

	isShutdown = true
}

// MemoryStats is a data structure that houses various memory statistics from ReadVipsMemStats()
type MemoryStats struct {
	Mem     int64
	MemHigh int64
	Files   int64
	Allocs  int64
}

// ReadVipsMemStats returns various memory statistics such as allocated memory and open files.
func ReadVipsMemStats(stats *MemoryStats) {
	stats.Mem = int64(C.vips_tracked_get_mem())
	stats.MemHigh = int64(C.vips_tracked_get_mem_highwater())
	stats.Allocs = int64(C.vips_tracked_get_allocs())
	stats.Files = int64(C.vips_tracked_get_files())
}

// HasOperation checks if a libvips operation exists
func HasOperation(name string) bool {
	Startup(nil)
	cName := C.CString(name)
	defer freeCString(cName)
	vop := C.vips_operation_new(cName)
	if vop == nil {
		C.vips_error_clear()
		return false
	}
	if C.is_gobject(unsafe.Pointer(vop)) != 0 {
		C.g_object_unref(C.gpointer(vop))
	}
	return true
}

func handleImageError(out *C.VipsImage) error {
	if out != nil {
		clearImage(out)
	}
	return handleVipsError()
}

func handleVipsError() error {
	s := C.GoString(C.vips_error_buffer())
	C.vips_error_clear()

	return fmt.Errorf("%v", s)
}

func freeCString(s *C.char) {
	C.free(unsafe.Pointer(s))
}

func gFreePointer(ref unsafe.Pointer) {
	C.g_free(C.gpointer(ref))
}

func boolToInt(b bool) int {
	if b {
		return 1
	}
	return 0
}

func boolToStr(v bool) string {
	if v {
		return "TRUE"
	}
	return "FALSE"
}

func toGboolean(b bool) C.gboolean {
	if b {
		return C.gboolean(1)
	}
	return C.gboolean(0)
}

func fromGboolean(b C.gboolean) bool {
	return b != 0
}

var cStringsCache sync.Map

func cachedCString(str string) *C.char {
	if cstr, ok := cStringsCache.Load(str); ok {
		return cstr.(*C.char)
	}
	cstr := C.CString(str)
	cStringsCache.Store(str, cstr)
	return cstr
}

// bufferToBytes converts a C buffer to Go bytes and frees the original buffer.
// This function takes ownership of the buffer and will free it after conversion.
func bufferToBytes(buf unsafe.Pointer, length C.size_t) []byte {
	if buf == nil {
		return nil
	}
	bytes := C.GoBytes(buf, C.int(length))
	C.g_free(C.gpointer(buf))
	return bytes
}

// convertImagesToVipsImages converts from Image slice to VipsImage slice
func convertImagesToVipsImages(images []*Image) []*C.VipsImage {
	vipsImages := make([]*C.VipsImage, len(images))
	for i, img := range images {
		vipsImages[i] = img.image
	}
	return vipsImages
}

// convertVipsImagesToImages converts a slice of *C.VipsImage to []*Image
func convertVipsImagesToImages(vipsImages []*C.VipsImage) []*Image {
	images := make([]*Image, len(vipsImages))
	for i, vipsImg := range vipsImages {
		images[i] = newImageRef(vipsImg, ImageTypeUnknown, nil)
	}
	return images
}

// vipsInterpolateToC converts a Go Interpolate to a C VipsInterpolate pointer
func vipsInterpolateToC(interp *Interpolate) *C.VipsInterpolate {
	if interp == nil {
		return nil
	}
	return interp.interp
}

// vipsInterpolateFromC converts a C VipsInterpolate pointer to a Go Interpolate
func vipsInterpolateFromC(interp *C.VipsInterpolate) *Interpolate {
	if interp == nil {
		return nil
	}
	return &Interpolate{interp: interp}
}

// convertToDoubleArray converts a Go float64 slice to a C double array and returns the length
func convertToDoubleArray(values []float64) (*C.double, C.int, error) {
	if len(values) == 0 {
		return nil, 0, nil
	}

	// Allocate C memory
	size := C.size_t(len(values)) * C.size_t(unsafe.Sizeof(C.double(0)))
	cArray := (*C.double)(C.malloc(size))
	if cArray == nil {
		return nil, 0, fmt.Errorf("failed to allocate memory for double array")
	}

	// Copy values to C array
	for i, v := range values {
		ptr := unsafe.Pointer(uintptr(unsafe.Pointer(cArray)) + uintptr(i)*unsafe.Sizeof(C.double(0)))
		*(*C.double)(ptr) = C.double(v)
	}

	return cArray, C.int(len(values)), nil
}

// freeDoubleArray frees memory allocated for a C double array
func freeDoubleArray(array *C.double) {
	if array != nil {
		C.free(unsafe.Pointer(array))
	}
}

func fromCArrayDouble(out *C.double, n int) []float64 {
	if out == nil || n <= 0 {
		return nil
	}
	data := make([]float64, n)
	for i := 0; i < n; i++ {
		data[i] = float64(*(*C.double)(unsafe.Pointer(uintptr(unsafe.Pointer(out)) + uintptr(i)*unsafe.Sizeof(C.double(0)))))
	}
	return data
}

func fromCArrayInt(out *C.int, n int) []int {
	if out == nil || n <= 0 {
		return nil
	}
	data := make([]int, n)
	for i := 0; i < n; i++ {
		data[i] = int(*(*C.int)(unsafe.Pointer(uintptr(unsafe.Pointer(out)) + uintptr(i)*unsafe.Sizeof(C.int(0)))))
	}
	return data
}

// convertToIntArray converts a Go int slice to a C int array and returns the length
func convertToIntArray(values []int) (*C.int, C.int, error) {
	if len(values) == 0 {
		return nil, 0, nil
	}

	// Allocate C memory
	size := C.size_t(len(values)) * C.size_t(unsafe.Sizeof(C.int(0)))
	cArray := (*C.int)(C.malloc(size))
	if cArray == nil {
		return nil, 0, fmt.Errorf("failed to allocate memory for int array")
	}

	// Copy values to C array
	for i, v := range values {
		ptr := unsafe.Pointer(uintptr(unsafe.Pointer(cArray)) + uintptr(i)*unsafe.Sizeof(C.int(0)))
		*(*C.int)(ptr) = C.int(v)
	}

	return cArray, C.int(len(values)), nil
}

// freeIntArray frees memory allocated for a C int array
func freeIntArray(array *C.int) {
	if array != nil {
		C.free(unsafe.Pointer(array))
	}
}

// convertToBlendModeArray converts a Go BlendMode slice to a C int array and returns the length
func convertToBlendModeArray(values []BlendMode) (*C.int, C.int, error) {
	if len(values) == 0 {
		return nil, 0, nil
	}

	// Allocate C memory
	size := C.size_t(len(values)) * C.size_t(unsafe.Sizeof(C.int(0)))
	cArray := (*C.int)(C.malloc(size))
	if cArray == nil {
		return nil, 0, fmt.Errorf("failed to allocate memory for BlendMode array")
	}

	// Copy values to C array
	for i, v := range values {
		ptr := unsafe.Pointer(uintptr(unsafe.Pointer(cArray)) + uintptr(i)*unsafe.Sizeof(C.int(0)))
		*(*C.int)(ptr) = C.int(v)
	}

	return cArray, C.int(len(values)), nil
}

// convertToImageArray converts a Go []*Image slice to a C VipsImage** array and returns the length
func convertToImageArray(images []*C.VipsImage) (**C.VipsImage, C.int, error) {
	if len(images) == 0 {
		return nil, 0, nil
	}

	// Allocate C memory for array of VipsImage pointers
	size := C.size_t(len(images)) * C.size_t(unsafe.Sizeof((*C.VipsImage)(nil)))
	cArray := (**C.VipsImage)(C.malloc(size))
	if cArray == nil {
		return nil, 0, fmt.Errorf("failed to allocate memory for image array")
	}

	// Convert each Image to a C VipsImage pointer and store in array
	for i, img := range images {
		ptr := unsafe.Pointer(uintptr(unsafe.Pointer(cArray)) + uintptr(i)*unsafe.Sizeof((*C.VipsImage)(nil)))
		*(**C.VipsImage)(ptr) = img
	}

	return cArray, C.int(len(images)), nil
}

// freeImageArray frees memory allocated for a C VipsImage** array
func freeImageArray(array **C.VipsImage) {
	if array != nil {
		C.free(unsafe.Pointer(array))
	}
}

// vipsBlobToBytes converts a VipsBlob to a Go byte slice and unrefs the blob
func vipsBlobToBytes(blob *C.VipsBlob) []byte {
	if blob == nil {
		return nil
	}
	var size C.size_t
	ptr := C.vips_blob_get(blob, &size)
	data := C.GoBytes(ptr, C.int(size))
	C.vips_area_unref((*C.VipsArea)(unsafe.Pointer(blob)))
	return data
}

// getImagePointer safely extracts the C.VipsImage pointer from an Image, returning nil if the Image is nil
func getImagePointer(img *Image) *C.VipsImage {
	if img == nil {
		return nil
	}
	return img.image
}
