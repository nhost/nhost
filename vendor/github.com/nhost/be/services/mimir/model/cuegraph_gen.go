// Code generated by github.com/nhost/be/tools/cuegraph, DO NOT EDIT.

package model

import (
	"encoding/json"
	"fmt"
	"io"
)

type Matcher[T any] interface {
	Matches(T) bool
}

func all[T any, U Matcher[T]](list []U, element T) bool {
	for _, e := range list {
		if !e.Matches(element) {
			return false
		}
	}
	return true
}

func or[T any, U Matcher[T]](list []U, element T) bool {
	for _, e := range list {
		if e.Matches(element) {
			return true
		}
	}
	return false
}

func contains[T comparable](slice []T, item T) bool {
	for _, s := range slice {
		if s == item {
			return true
		}
	}
	return false
}

type GenericComparisonExp[T comparable] struct {
	Eq  *T  `json:"_eq,omitempty"`
	Neq *T  `json:"_neq,omitempty"`
	In  []T `json:"_in,omitempty"`
	Nin []T `json:"_nin,omitempty"`
}

func (exp *GenericComparisonExp[T]) Matches(o T) bool {
	if exp == nil {
		return true
	}

	if exp.Eq != nil && *exp.Eq != o {
		return false
	}

	if exp.Neq != nil && *exp.Neq == o {
		return false
	}

	if exp.In != nil && !contains(exp.In, o) {
		return false
	}

	if exp.Nin != nil && contains(exp.Nin, o) {
		return false
	}

	return true
}

type (
	ConfigIntComparisonExp   = GenericComparisonExp[int]
	ConfigInt8ComparisonExp  = GenericComparisonExp[int8]
	ConfigInt16ComparisonExp = GenericComparisonExp[int16]
	ConfigInt32ComparisonExp = GenericComparisonExp[int32]
	ConfigInt64ComparisonExp = GenericComparisonExp[int64]
)

type (
	ConfigUintComparisonExp   = GenericComparisonExp[uint]
	ConfigUint8ComparisonExp  = GenericComparisonExp[uint8]
	ConfigUint16ComparisonExp = GenericComparisonExp[uint16]
	ConfigUint32ComparisonExp = GenericComparisonExp[uint32]
	ConfigUint64ComparisonExp = GenericComparisonExp[uint64]
)

type ConfigStringComparisonExp = GenericComparisonExp[string]

type ConfigBooleanComparisonExp = GenericComparisonExp[bool]

type (
	ConfigFloatComparisonExp = GenericComparisonExp[float64]
	// Configuration for auth service
	// You can find more information about the configuration here:
	// https://github.com/nhost/hasura-auth/blob/main/docs/environment-variables.md
	ConfigAuth struct {
		// Version of auth, you can see available versions in the URL below:
		// https://hub.docker.com/r/nhost/hasura-auth/tags
		//
		// Releases:
		//
		// https://github.com/nhost/hasura-auth/releases
		Version *string `json:"version" toml:"version"`
		// Resources for the service
		Resources *ConfigResources `json:"resources,omitempty" toml:"resources,omitempty"`

		Redirections *ConfigAuthRedirections `json:"redirections,omitempty" toml:"redirections,omitempty"`

		SignUp *ConfigAuthSignUp `json:"signUp,omitempty" toml:"signUp,omitempty"`

		User *ConfigAuthUser `json:"user,omitempty" toml:"user,omitempty"`

		Session *ConfigAuthSession `json:"session,omitempty" toml:"session,omitempty"`

		Method *ConfigAuthMethod `json:"method,omitempty" toml:"method,omitempty"`

		Totp *ConfigAuthTotp `json:"totp,omitempty" toml:"totp,omitempty"`
	}
)

func (o *ConfigAuth) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Version != nil {
		m["version"] = o.Version
	}
	if o.Resources != nil {
		m["resources"] = o.Resources
	}
	if o.Redirections != nil {
		m["redirections"] = o.Redirections
	}
	if o.SignUp != nil {
		m["signUp"] = o.SignUp
	}
	if o.User != nil {
		m["user"] = o.User
	}
	if o.Session != nil {
		m["session"] = o.Session
	}
	if o.Method != nil {
		m["method"] = o.Method
	}
	if o.Totp != nil {
		m["totp"] = o.Totp
	}
	return json.Marshal(m)
}

func (o *ConfigAuth) GetVersion() *string {
	if o == nil {
		o = &ConfigAuth{}
	}
	return o.Version
}

func (o *ConfigAuth) GetResources() *ConfigResources {
	if o == nil {
		return nil
	}
	return o.Resources
}

func (o *ConfigAuth) GetRedirections() *ConfigAuthRedirections {
	if o == nil {
		return nil
	}
	return o.Redirections
}

func (o *ConfigAuth) GetSignUp() *ConfigAuthSignUp {
	if o == nil {
		return nil
	}
	return o.SignUp
}

func (o *ConfigAuth) GetUser() *ConfigAuthUser {
	if o == nil {
		return nil
	}
	return o.User
}

func (o *ConfigAuth) GetSession() *ConfigAuthSession {
	if o == nil {
		return nil
	}
	return o.Session
}

func (o *ConfigAuth) GetMethod() *ConfigAuthMethod {
	if o == nil {
		return nil
	}
	return o.Method
}

func (o *ConfigAuth) GetTotp() *ConfigAuthTotp {
	if o == nil {
		return nil
	}
	return o.Totp
}

type ConfigAuthUpdateInput struct {
	Version           *string                            `json:"version,omitempty" toml:"version,omitempty"`
	IsSetVersion      bool                               `json:"-"`
	Resources         *ConfigResourcesUpdateInput        `json:"resources,omitempty" toml:"resources,omitempty"`
	IsSetResources    bool                               `json:"-"`
	Redirections      *ConfigAuthRedirectionsUpdateInput `json:"redirections,omitempty" toml:"redirections,omitempty"`
	IsSetRedirections bool                               `json:"-"`
	SignUp            *ConfigAuthSignUpUpdateInput       `json:"signUp,omitempty" toml:"signUp,omitempty"`
	IsSetSignUp       bool                               `json:"-"`
	User              *ConfigAuthUserUpdateInput         `json:"user,omitempty" toml:"user,omitempty"`
	IsSetUser         bool                               `json:"-"`
	Session           *ConfigAuthSessionUpdateInput      `json:"session,omitempty" toml:"session,omitempty"`
	IsSetSession      bool                               `json:"-"`
	Method            *ConfigAuthMethodUpdateInput       `json:"method,omitempty" toml:"method,omitempty"`
	IsSetMethod       bool                               `json:"-"`
	Totp              *ConfigAuthTotpUpdateInput         `json:"totp,omitempty" toml:"totp,omitempty"`
	IsSetTotp         bool                               `json:"-"`
}

func (o *ConfigAuthUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["version"]; ok {
		if v == nil {
			o.Version = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Version = &x
		}
		o.IsSetVersion = true
	}
	if x, ok := m["resources"]; ok {
		if x != nil {
			t := &ConfigResourcesUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Resources = t
		}
		o.IsSetResources = true
	}
	if x, ok := m["redirections"]; ok {
		if x != nil {
			t := &ConfigAuthRedirectionsUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Redirections = t
		}
		o.IsSetRedirections = true
	}
	if x, ok := m["signUp"]; ok {
		if x != nil {
			t := &ConfigAuthSignUpUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.SignUp = t
		}
		o.IsSetSignUp = true
	}
	if x, ok := m["user"]; ok {
		if x != nil {
			t := &ConfigAuthUserUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.User = t
		}
		o.IsSetUser = true
	}
	if x, ok := m["session"]; ok {
		if x != nil {
			t := &ConfigAuthSessionUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Session = t
		}
		o.IsSetSession = true
	}
	if x, ok := m["method"]; ok {
		if x != nil {
			t := &ConfigAuthMethodUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Method = t
		}
		o.IsSetMethod = true
	}
	if x, ok := m["totp"]; ok {
		if x != nil {
			t := &ConfigAuthTotpUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Totp = t
		}
		o.IsSetTotp = true
	}

	return nil
}

func (o *ConfigAuthUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigAuthUpdateInput) GetVersion() *string {
	if o == nil {
		o = &ConfigAuthUpdateInput{}
	}
	return o.Version
}

func (o *ConfigAuthUpdateInput) GetResources() *ConfigResourcesUpdateInput {
	if o == nil {
		return nil
	}
	return o.Resources
}

func (o *ConfigAuthUpdateInput) GetRedirections() *ConfigAuthRedirectionsUpdateInput {
	if o == nil {
		return nil
	}
	return o.Redirections
}

func (o *ConfigAuthUpdateInput) GetSignUp() *ConfigAuthSignUpUpdateInput {
	if o == nil {
		return nil
	}
	return o.SignUp
}

func (o *ConfigAuthUpdateInput) GetUser() *ConfigAuthUserUpdateInput {
	if o == nil {
		return nil
	}
	return o.User
}

func (o *ConfigAuthUpdateInput) GetSession() *ConfigAuthSessionUpdateInput {
	if o == nil {
		return nil
	}
	return o.Session
}

func (o *ConfigAuthUpdateInput) GetMethod() *ConfigAuthMethodUpdateInput {
	if o == nil {
		return nil
	}
	return o.Method
}

func (o *ConfigAuthUpdateInput) GetTotp() *ConfigAuthTotpUpdateInput {
	if o == nil {
		return nil
	}
	return o.Totp
}

func (s *ConfigAuth) Update(v *ConfigAuthUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetVersion || v.Version != nil {
		s.Version = v.Version
	}
	if v.IsSetResources || v.Resources != nil {
		if v.Resources == nil {
			s.Resources = nil
		} else {
			if s.Resources == nil {
				s.Resources = &ConfigResources{}
			}
			s.Resources.Update(v.Resources)
		}
	}
	if v.IsSetRedirections || v.Redirections != nil {
		if v.Redirections == nil {
			s.Redirections = nil
		} else {
			if s.Redirections == nil {
				s.Redirections = &ConfigAuthRedirections{}
			}
			s.Redirections.Update(v.Redirections)
		}
	}
	if v.IsSetSignUp || v.SignUp != nil {
		if v.SignUp == nil {
			s.SignUp = nil
		} else {
			if s.SignUp == nil {
				s.SignUp = &ConfigAuthSignUp{}
			}
			s.SignUp.Update(v.SignUp)
		}
	}
	if v.IsSetUser || v.User != nil {
		if v.User == nil {
			s.User = nil
		} else {
			if s.User == nil {
				s.User = &ConfigAuthUser{}
			}
			s.User.Update(v.User)
		}
	}
	if v.IsSetSession || v.Session != nil {
		if v.Session == nil {
			s.Session = nil
		} else {
			if s.Session == nil {
				s.Session = &ConfigAuthSession{}
			}
			s.Session.Update(v.Session)
		}
	}
	if v.IsSetMethod || v.Method != nil {
		if v.Method == nil {
			s.Method = nil
		} else {
			if s.Method == nil {
				s.Method = &ConfigAuthMethod{}
			}
			s.Method.Update(v.Method)
		}
	}
	if v.IsSetTotp || v.Totp != nil {
		if v.Totp == nil {
			s.Totp = nil
		} else {
			if s.Totp == nil {
				s.Totp = &ConfigAuthTotp{}
			}
			s.Totp.Update(v.Totp)
		}
	}
}

type ConfigAuthInsertInput struct {
	Version      *string                            `json:"version,omitempty" toml:"version,omitempty"`
	Resources    *ConfigResourcesInsertInput        `json:"resources,omitempty" toml:"resources,omitempty"`
	Redirections *ConfigAuthRedirectionsInsertInput `json:"redirections,omitempty" toml:"redirections,omitempty"`
	SignUp       *ConfigAuthSignUpInsertInput       `json:"signUp,omitempty" toml:"signUp,omitempty"`
	User         *ConfigAuthUserInsertInput         `json:"user,omitempty" toml:"user,omitempty"`
	Session      *ConfigAuthSessionInsertInput      `json:"session,omitempty" toml:"session,omitempty"`
	Method       *ConfigAuthMethodInsertInput       `json:"method,omitempty" toml:"method,omitempty"`
	Totp         *ConfigAuthTotpInsertInput         `json:"totp,omitempty" toml:"totp,omitempty"`
}

func (o *ConfigAuthInsertInput) GetVersion() *string {
	if o == nil {
		o = &ConfigAuthInsertInput{}
	}
	return o.Version
}

func (o *ConfigAuthInsertInput) GetResources() *ConfigResourcesInsertInput {
	if o == nil {
		return nil
	}
	return o.Resources
}

func (o *ConfigAuthInsertInput) GetRedirections() *ConfigAuthRedirectionsInsertInput {
	if o == nil {
		return nil
	}
	return o.Redirections
}

func (o *ConfigAuthInsertInput) GetSignUp() *ConfigAuthSignUpInsertInput {
	if o == nil {
		return nil
	}
	return o.SignUp
}

func (o *ConfigAuthInsertInput) GetUser() *ConfigAuthUserInsertInput {
	if o == nil {
		return nil
	}
	return o.User
}

func (o *ConfigAuthInsertInput) GetSession() *ConfigAuthSessionInsertInput {
	if o == nil {
		return nil
	}
	return o.Session
}

func (o *ConfigAuthInsertInput) GetMethod() *ConfigAuthMethodInsertInput {
	if o == nil {
		return nil
	}
	return o.Method
}

func (o *ConfigAuthInsertInput) GetTotp() *ConfigAuthTotpInsertInput {
	if o == nil {
		return nil
	}
	return o.Totp
}

func (s *ConfigAuth) Insert(v *ConfigAuthInsertInput) {
	s.Version = v.Version
	if v.Resources != nil {
		if s.Resources == nil {
			s.Resources = &ConfigResources{}
		}
		s.Resources.Insert(v.Resources)
	}
	if v.Redirections != nil {
		if s.Redirections == nil {
			s.Redirections = &ConfigAuthRedirections{}
		}
		s.Redirections.Insert(v.Redirections)
	}
	if v.SignUp != nil {
		if s.SignUp == nil {
			s.SignUp = &ConfigAuthSignUp{}
		}
		s.SignUp.Insert(v.SignUp)
	}
	if v.User != nil {
		if s.User == nil {
			s.User = &ConfigAuthUser{}
		}
		s.User.Insert(v.User)
	}
	if v.Session != nil {
		if s.Session == nil {
			s.Session = &ConfigAuthSession{}
		}
		s.Session.Insert(v.Session)
	}
	if v.Method != nil {
		if s.Method == nil {
			s.Method = &ConfigAuthMethod{}
		}
		s.Method.Insert(v.Method)
	}
	if v.Totp != nil {
		if s.Totp == nil {
			s.Totp = &ConfigAuthTotp{}
		}
		s.Totp.Insert(v.Totp)
	}
}

func (s *ConfigAuth) Clone() *ConfigAuth {
	if s == nil {
		return nil
	}

	v := &ConfigAuth{}
	v.Version = s.Version
	v.Resources = s.Resources.Clone()
	v.Redirections = s.Redirections.Clone()
	v.SignUp = s.SignUp.Clone()
	v.User = s.User.Clone()
	v.Session = s.Session.Clone()
	v.Method = s.Method.Clone()
	v.Totp = s.Totp.Clone()
	return v
}

type ConfigAuthComparisonExp struct {
	And          []*ConfigAuthComparisonExp           `json:"_and,omitempty"`
	Not          *ConfigAuthComparisonExp             `json:"_not,omitempty"`
	Or           []*ConfigAuthComparisonExp           `json:"_or,omitempty"`
	Version      *ConfigStringComparisonExp           `json:"version,omitempty"`
	Resources    *ConfigResourcesComparisonExp        `json:"resources,omitempty"`
	Redirections *ConfigAuthRedirectionsComparisonExp `json:"redirections,omitempty"`
	SignUp       *ConfigAuthSignUpComparisonExp       `json:"signUp,omitempty"`
	User         *ConfigAuthUserComparisonExp         `json:"user,omitempty"`
	Session      *ConfigAuthSessionComparisonExp      `json:"session,omitempty"`
	Method       *ConfigAuthMethodComparisonExp       `json:"method,omitempty"`
	Totp         *ConfigAuthTotpComparisonExp         `json:"totp,omitempty"`
}

func (exp *ConfigAuthComparisonExp) Matches(o *ConfigAuth) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuth{
			Resources:    &ConfigResources{},
			Redirections: &ConfigAuthRedirections{},
			SignUp:       &ConfigAuthSignUp{},
			User:         &ConfigAuthUser{},
			Session:      &ConfigAuthSession{},
			Method:       &ConfigAuthMethod{},
			Totp:         &ConfigAuthTotp{},
		}
	}
	if o.Version != nil && !exp.Version.Matches(*o.Version) {
		return false
	}
	if !exp.Resources.Matches(o.Resources) {
		return false
	}
	if !exp.Redirections.Matches(o.Redirections) {
		return false
	}
	if !exp.SignUp.Matches(o.SignUp) {
		return false
	}
	if !exp.User.Matches(o.User) {
		return false
	}
	if !exp.Session.Matches(o.Session) {
		return false
	}
	if !exp.Method.Matches(o.Method) {
		return false
	}
	if !exp.Totp.Matches(o.Totp) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAuthMethod struct {
	Anonymous *ConfigAuthMethodAnonymous `json:"anonymous,omitempty" toml:"anonymous,omitempty"`

	EmailPasswordless *ConfigAuthMethodEmailPasswordless `json:"emailPasswordless,omitempty" toml:"emailPasswordless,omitempty"`

	EmailPassword *ConfigAuthMethodEmailPassword `json:"emailPassword,omitempty" toml:"emailPassword,omitempty"`

	SmsPasswordless *ConfigAuthMethodSmsPasswordless `json:"smsPasswordless,omitempty" toml:"smsPasswordless,omitempty"`

	Oauth *ConfigAuthMethodOauth `json:"oauth,omitempty" toml:"oauth,omitempty"`

	Webauthn *ConfigAuthMethodWebauthn `json:"webauthn,omitempty" toml:"webauthn,omitempty"`
}

func (o *ConfigAuthMethod) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Anonymous != nil {
		m["anonymous"] = o.Anonymous
	}
	if o.EmailPasswordless != nil {
		m["emailPasswordless"] = o.EmailPasswordless
	}
	if o.EmailPassword != nil {
		m["emailPassword"] = o.EmailPassword
	}
	if o.SmsPasswordless != nil {
		m["smsPasswordless"] = o.SmsPasswordless
	}
	if o.Oauth != nil {
		m["oauth"] = o.Oauth
	}
	if o.Webauthn != nil {
		m["webauthn"] = o.Webauthn
	}
	return json.Marshal(m)
}

func (o *ConfigAuthMethod) GetAnonymous() *ConfigAuthMethodAnonymous {
	if o == nil {
		return nil
	}
	return o.Anonymous
}

func (o *ConfigAuthMethod) GetEmailPasswordless() *ConfigAuthMethodEmailPasswordless {
	if o == nil {
		return nil
	}
	return o.EmailPasswordless
}

func (o *ConfigAuthMethod) GetEmailPassword() *ConfigAuthMethodEmailPassword {
	if o == nil {
		return nil
	}
	return o.EmailPassword
}

func (o *ConfigAuthMethod) GetSmsPasswordless() *ConfigAuthMethodSmsPasswordless {
	if o == nil {
		return nil
	}
	return o.SmsPasswordless
}

func (o *ConfigAuthMethod) GetOauth() *ConfigAuthMethodOauth {
	if o == nil {
		return nil
	}
	return o.Oauth
}

func (o *ConfigAuthMethod) GetWebauthn() *ConfigAuthMethodWebauthn {
	if o == nil {
		return nil
	}
	return o.Webauthn
}

type ConfigAuthMethodUpdateInput struct {
	Anonymous              *ConfigAuthMethodAnonymousUpdateInput         `json:"anonymous,omitempty" toml:"anonymous,omitempty"`
	IsSetAnonymous         bool                                          `json:"-"`
	EmailPasswordless      *ConfigAuthMethodEmailPasswordlessUpdateInput `json:"emailPasswordless,omitempty" toml:"emailPasswordless,omitempty"`
	IsSetEmailPasswordless bool                                          `json:"-"`
	EmailPassword          *ConfigAuthMethodEmailPasswordUpdateInput     `json:"emailPassword,omitempty" toml:"emailPassword,omitempty"`
	IsSetEmailPassword     bool                                          `json:"-"`
	SmsPasswordless        *ConfigAuthMethodSmsPasswordlessUpdateInput   `json:"smsPasswordless,omitempty" toml:"smsPasswordless,omitempty"`
	IsSetSmsPasswordless   bool                                          `json:"-"`
	Oauth                  *ConfigAuthMethodOauthUpdateInput             `json:"oauth,omitempty" toml:"oauth,omitempty"`
	IsSetOauth             bool                                          `json:"-"`
	Webauthn               *ConfigAuthMethodWebauthnUpdateInput          `json:"webauthn,omitempty" toml:"webauthn,omitempty"`
	IsSetWebauthn          bool                                          `json:"-"`
}

func (o *ConfigAuthMethodUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if x, ok := m["anonymous"]; ok {
		if x != nil {
			t := &ConfigAuthMethodAnonymousUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Anonymous = t
		}
		o.IsSetAnonymous = true
	}
	if x, ok := m["emailPasswordless"]; ok {
		if x != nil {
			t := &ConfigAuthMethodEmailPasswordlessUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.EmailPasswordless = t
		}
		o.IsSetEmailPasswordless = true
	}
	if x, ok := m["emailPassword"]; ok {
		if x != nil {
			t := &ConfigAuthMethodEmailPasswordUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.EmailPassword = t
		}
		o.IsSetEmailPassword = true
	}
	if x, ok := m["smsPasswordless"]; ok {
		if x != nil {
			t := &ConfigAuthMethodSmsPasswordlessUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.SmsPasswordless = t
		}
		o.IsSetSmsPasswordless = true
	}
	if x, ok := m["oauth"]; ok {
		if x != nil {
			t := &ConfigAuthMethodOauthUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Oauth = t
		}
		o.IsSetOauth = true
	}
	if x, ok := m["webauthn"]; ok {
		if x != nil {
			t := &ConfigAuthMethodWebauthnUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Webauthn = t
		}
		o.IsSetWebauthn = true
	}

	return nil
}

func (o *ConfigAuthMethodUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigAuthMethodUpdateInput) GetAnonymous() *ConfigAuthMethodAnonymousUpdateInput {
	if o == nil {
		return nil
	}
	return o.Anonymous
}

func (o *ConfigAuthMethodUpdateInput) GetEmailPasswordless() *ConfigAuthMethodEmailPasswordlessUpdateInput {
	if o == nil {
		return nil
	}
	return o.EmailPasswordless
}

func (o *ConfigAuthMethodUpdateInput) GetEmailPassword() *ConfigAuthMethodEmailPasswordUpdateInput {
	if o == nil {
		return nil
	}
	return o.EmailPassword
}

func (o *ConfigAuthMethodUpdateInput) GetSmsPasswordless() *ConfigAuthMethodSmsPasswordlessUpdateInput {
	if o == nil {
		return nil
	}
	return o.SmsPasswordless
}

func (o *ConfigAuthMethodUpdateInput) GetOauth() *ConfigAuthMethodOauthUpdateInput {
	if o == nil {
		return nil
	}
	return o.Oauth
}

func (o *ConfigAuthMethodUpdateInput) GetWebauthn() *ConfigAuthMethodWebauthnUpdateInput {
	if o == nil {
		return nil
	}
	return o.Webauthn
}

func (s *ConfigAuthMethod) Update(v *ConfigAuthMethodUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetAnonymous || v.Anonymous != nil {
		if v.Anonymous == nil {
			s.Anonymous = nil
		} else {
			if s.Anonymous == nil {
				s.Anonymous = &ConfigAuthMethodAnonymous{}
			}
			s.Anonymous.Update(v.Anonymous)
		}
	}
	if v.IsSetEmailPasswordless || v.EmailPasswordless != nil {
		if v.EmailPasswordless == nil {
			s.EmailPasswordless = nil
		} else {
			if s.EmailPasswordless == nil {
				s.EmailPasswordless = &ConfigAuthMethodEmailPasswordless{}
			}
			s.EmailPasswordless.Update(v.EmailPasswordless)
		}
	}
	if v.IsSetEmailPassword || v.EmailPassword != nil {
		if v.EmailPassword == nil {
			s.EmailPassword = nil
		} else {
			if s.EmailPassword == nil {
				s.EmailPassword = &ConfigAuthMethodEmailPassword{}
			}
			s.EmailPassword.Update(v.EmailPassword)
		}
	}
	if v.IsSetSmsPasswordless || v.SmsPasswordless != nil {
		if v.SmsPasswordless == nil {
			s.SmsPasswordless = nil
		} else {
			if s.SmsPasswordless == nil {
				s.SmsPasswordless = &ConfigAuthMethodSmsPasswordless{}
			}
			s.SmsPasswordless.Update(v.SmsPasswordless)
		}
	}
	if v.IsSetOauth || v.Oauth != nil {
		if v.Oauth == nil {
			s.Oauth = nil
		} else {
			if s.Oauth == nil {
				s.Oauth = &ConfigAuthMethodOauth{}
			}
			s.Oauth.Update(v.Oauth)
		}
	}
	if v.IsSetWebauthn || v.Webauthn != nil {
		if v.Webauthn == nil {
			s.Webauthn = nil
		} else {
			if s.Webauthn == nil {
				s.Webauthn = &ConfigAuthMethodWebauthn{}
			}
			s.Webauthn.Update(v.Webauthn)
		}
	}
}

type ConfigAuthMethodInsertInput struct {
	Anonymous         *ConfigAuthMethodAnonymousInsertInput         `json:"anonymous,omitempty" toml:"anonymous,omitempty"`
	EmailPasswordless *ConfigAuthMethodEmailPasswordlessInsertInput `json:"emailPasswordless,omitempty" toml:"emailPasswordless,omitempty"`
	EmailPassword     *ConfigAuthMethodEmailPasswordInsertInput     `json:"emailPassword,omitempty" toml:"emailPassword,omitempty"`
	SmsPasswordless   *ConfigAuthMethodSmsPasswordlessInsertInput   `json:"smsPasswordless,omitempty" toml:"smsPasswordless,omitempty"`
	Oauth             *ConfigAuthMethodOauthInsertInput             `json:"oauth,omitempty" toml:"oauth,omitempty"`
	Webauthn          *ConfigAuthMethodWebauthnInsertInput          `json:"webauthn,omitempty" toml:"webauthn,omitempty"`
}

func (o *ConfigAuthMethodInsertInput) GetAnonymous() *ConfigAuthMethodAnonymousInsertInput {
	if o == nil {
		return nil
	}
	return o.Anonymous
}

func (o *ConfigAuthMethodInsertInput) GetEmailPasswordless() *ConfigAuthMethodEmailPasswordlessInsertInput {
	if o == nil {
		return nil
	}
	return o.EmailPasswordless
}

func (o *ConfigAuthMethodInsertInput) GetEmailPassword() *ConfigAuthMethodEmailPasswordInsertInput {
	if o == nil {
		return nil
	}
	return o.EmailPassword
}

func (o *ConfigAuthMethodInsertInput) GetSmsPasswordless() *ConfigAuthMethodSmsPasswordlessInsertInput {
	if o == nil {
		return nil
	}
	return o.SmsPasswordless
}

func (o *ConfigAuthMethodInsertInput) GetOauth() *ConfigAuthMethodOauthInsertInput {
	if o == nil {
		return nil
	}
	return o.Oauth
}

func (o *ConfigAuthMethodInsertInput) GetWebauthn() *ConfigAuthMethodWebauthnInsertInput {
	if o == nil {
		return nil
	}
	return o.Webauthn
}

func (s *ConfigAuthMethod) Insert(v *ConfigAuthMethodInsertInput) {
	if v.Anonymous != nil {
		if s.Anonymous == nil {
			s.Anonymous = &ConfigAuthMethodAnonymous{}
		}
		s.Anonymous.Insert(v.Anonymous)
	}
	if v.EmailPasswordless != nil {
		if s.EmailPasswordless == nil {
			s.EmailPasswordless = &ConfigAuthMethodEmailPasswordless{}
		}
		s.EmailPasswordless.Insert(v.EmailPasswordless)
	}
	if v.EmailPassword != nil {
		if s.EmailPassword == nil {
			s.EmailPassword = &ConfigAuthMethodEmailPassword{}
		}
		s.EmailPassword.Insert(v.EmailPassword)
	}
	if v.SmsPasswordless != nil {
		if s.SmsPasswordless == nil {
			s.SmsPasswordless = &ConfigAuthMethodSmsPasswordless{}
		}
		s.SmsPasswordless.Insert(v.SmsPasswordless)
	}
	if v.Oauth != nil {
		if s.Oauth == nil {
			s.Oauth = &ConfigAuthMethodOauth{}
		}
		s.Oauth.Insert(v.Oauth)
	}
	if v.Webauthn != nil {
		if s.Webauthn == nil {
			s.Webauthn = &ConfigAuthMethodWebauthn{}
		}
		s.Webauthn.Insert(v.Webauthn)
	}
}

func (s *ConfigAuthMethod) Clone() *ConfigAuthMethod {
	if s == nil {
		return nil
	}

	v := &ConfigAuthMethod{}
	v.Anonymous = s.Anonymous.Clone()
	v.EmailPasswordless = s.EmailPasswordless.Clone()
	v.EmailPassword = s.EmailPassword.Clone()
	v.SmsPasswordless = s.SmsPasswordless.Clone()
	v.Oauth = s.Oauth.Clone()
	v.Webauthn = s.Webauthn.Clone()
	return v
}

type ConfigAuthMethodComparisonExp struct {
	And               []*ConfigAuthMethodComparisonExp                `json:"_and,omitempty"`
	Not               *ConfigAuthMethodComparisonExp                  `json:"_not,omitempty"`
	Or                []*ConfigAuthMethodComparisonExp                `json:"_or,omitempty"`
	Anonymous         *ConfigAuthMethodAnonymousComparisonExp         `json:"anonymous,omitempty"`
	EmailPasswordless *ConfigAuthMethodEmailPasswordlessComparisonExp `json:"emailPasswordless,omitempty"`
	EmailPassword     *ConfigAuthMethodEmailPasswordComparisonExp     `json:"emailPassword,omitempty"`
	SmsPasswordless   *ConfigAuthMethodSmsPasswordlessComparisonExp   `json:"smsPasswordless,omitempty"`
	Oauth             *ConfigAuthMethodOauthComparisonExp             `json:"oauth,omitempty"`
	Webauthn          *ConfigAuthMethodWebauthnComparisonExp          `json:"webauthn,omitempty"`
}

func (exp *ConfigAuthMethodComparisonExp) Matches(o *ConfigAuthMethod) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthMethod{
			Anonymous:         &ConfigAuthMethodAnonymous{},
			EmailPasswordless: &ConfigAuthMethodEmailPasswordless{},
			EmailPassword:     &ConfigAuthMethodEmailPassword{},
			SmsPasswordless:   &ConfigAuthMethodSmsPasswordless{},
			Oauth:             &ConfigAuthMethodOauth{},
			Webauthn:          &ConfigAuthMethodWebauthn{},
		}
	}
	if !exp.Anonymous.Matches(o.Anonymous) {
		return false
	}
	if !exp.EmailPasswordless.Matches(o.EmailPasswordless) {
		return false
	}
	if !exp.EmailPassword.Matches(o.EmailPassword) {
		return false
	}
	if !exp.SmsPasswordless.Matches(o.SmsPasswordless) {
		return false
	}
	if !exp.Oauth.Matches(o.Oauth) {
		return false
	}
	if !exp.Webauthn.Matches(o.Webauthn) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAuthMethodAnonymous struct {
	Enabled *bool `json:"enabled" toml:"enabled"`
}

func (o *ConfigAuthMethodAnonymous) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Enabled != nil {
		m["enabled"] = o.Enabled
	}
	return json.Marshal(m)
}

func (o *ConfigAuthMethodAnonymous) GetEnabled() *bool {
	if o == nil {
		o = &ConfigAuthMethodAnonymous{}
	}
	return o.Enabled
}

type ConfigAuthMethodAnonymousUpdateInput struct {
	Enabled      *bool `json:"enabled,omitempty" toml:"enabled,omitempty"`
	IsSetEnabled bool  `json:"-"`
}

func (o *ConfigAuthMethodAnonymousUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["enabled"]; ok {
		if v == nil {
			o.Enabled = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x bool
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Enabled = &x
		}
		o.IsSetEnabled = true
	}

	return nil
}

func (o *ConfigAuthMethodAnonymousUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigAuthMethodAnonymousUpdateInput) GetEnabled() *bool {
	if o == nil {
		o = &ConfigAuthMethodAnonymousUpdateInput{}
	}
	return o.Enabled
}

func (s *ConfigAuthMethodAnonymous) Update(v *ConfigAuthMethodAnonymousUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetEnabled || v.Enabled != nil {
		s.Enabled = v.Enabled
	}
}

type ConfigAuthMethodAnonymousInsertInput struct {
	Enabled *bool `json:"enabled,omitempty" toml:"enabled,omitempty"`
}

func (o *ConfigAuthMethodAnonymousInsertInput) GetEnabled() *bool {
	if o == nil {
		o = &ConfigAuthMethodAnonymousInsertInput{}
	}
	return o.Enabled
}

func (s *ConfigAuthMethodAnonymous) Insert(v *ConfigAuthMethodAnonymousInsertInput) {
	s.Enabled = v.Enabled
}

func (s *ConfigAuthMethodAnonymous) Clone() *ConfigAuthMethodAnonymous {
	if s == nil {
		return nil
	}

	v := &ConfigAuthMethodAnonymous{}
	v.Enabled = s.Enabled
	return v
}

type ConfigAuthMethodAnonymousComparisonExp struct {
	And     []*ConfigAuthMethodAnonymousComparisonExp `json:"_and,omitempty"`
	Not     *ConfigAuthMethodAnonymousComparisonExp   `json:"_not,omitempty"`
	Or      []*ConfigAuthMethodAnonymousComparisonExp `json:"_or,omitempty"`
	Enabled *ConfigBooleanComparisonExp               `json:"enabled,omitempty"`
}

func (exp *ConfigAuthMethodAnonymousComparisonExp) Matches(o *ConfigAuthMethodAnonymous) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthMethodAnonymous{}
	}
	if o.Enabled != nil && !exp.Enabled.Matches(*o.Enabled) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAuthMethodEmailPassword struct {
	// Disabling email+password sign in is not implmented yet
	// enabled: bool | *true
	HibpEnabled *bool `json:"hibpEnabled" toml:"hibpEnabled"`

	EmailVerificationRequired *bool `json:"emailVerificationRequired" toml:"emailVerificationRequired"`

	PasswordMinLength *uint8 `json:"passwordMinLength" toml:"passwordMinLength"`
}

func (o *ConfigAuthMethodEmailPassword) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.HibpEnabled != nil {
		m["hibpEnabled"] = o.HibpEnabled
	}
	if o.EmailVerificationRequired != nil {
		m["emailVerificationRequired"] = o.EmailVerificationRequired
	}
	if o.PasswordMinLength != nil {
		m["passwordMinLength"] = o.PasswordMinLength
	}
	return json.Marshal(m)
}

func (o *ConfigAuthMethodEmailPassword) GetHibpEnabled() *bool {
	if o == nil {
		o = &ConfigAuthMethodEmailPassword{}
	}
	return o.HibpEnabled
}

func (o *ConfigAuthMethodEmailPassword) GetEmailVerificationRequired() *bool {
	if o == nil {
		o = &ConfigAuthMethodEmailPassword{}
	}
	return o.EmailVerificationRequired
}

func (o *ConfigAuthMethodEmailPassword) GetPasswordMinLength() *uint8 {
	if o == nil {
		o = &ConfigAuthMethodEmailPassword{}
	}
	return o.PasswordMinLength
}

type ConfigAuthMethodEmailPasswordUpdateInput struct {
	HibpEnabled                    *bool  `json:"hibpEnabled,omitempty" toml:"hibpEnabled,omitempty"`
	IsSetHibpEnabled               bool   `json:"-"`
	EmailVerificationRequired      *bool  `json:"emailVerificationRequired,omitempty" toml:"emailVerificationRequired,omitempty"`
	IsSetEmailVerificationRequired bool   `json:"-"`
	PasswordMinLength              *uint8 `json:"passwordMinLength,omitempty" toml:"passwordMinLength,omitempty"`
	IsSetPasswordMinLength         bool   `json:"-"`
}

func (o *ConfigAuthMethodEmailPasswordUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["hibpEnabled"]; ok {
		if v == nil {
			o.HibpEnabled = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x bool
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.HibpEnabled = &x
		}
		o.IsSetHibpEnabled = true
	}
	if v, ok := m["emailVerificationRequired"]; ok {
		if v == nil {
			o.EmailVerificationRequired = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x bool
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.EmailVerificationRequired = &x
		}
		o.IsSetEmailVerificationRequired = true
	}
	if v, ok := m["passwordMinLength"]; ok {
		if v == nil {
			o.PasswordMinLength = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x uint8
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.PasswordMinLength = &x
		}
		o.IsSetPasswordMinLength = true
	}

	return nil
}

func (o *ConfigAuthMethodEmailPasswordUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigAuthMethodEmailPasswordUpdateInput) GetHibpEnabled() *bool {
	if o == nil {
		o = &ConfigAuthMethodEmailPasswordUpdateInput{}
	}
	return o.HibpEnabled
}

func (o *ConfigAuthMethodEmailPasswordUpdateInput) GetEmailVerificationRequired() *bool {
	if o == nil {
		o = &ConfigAuthMethodEmailPasswordUpdateInput{}
	}
	return o.EmailVerificationRequired
}

func (o *ConfigAuthMethodEmailPasswordUpdateInput) GetPasswordMinLength() *uint8 {
	if o == nil {
		o = &ConfigAuthMethodEmailPasswordUpdateInput{}
	}
	return o.PasswordMinLength
}

func (s *ConfigAuthMethodEmailPassword) Update(v *ConfigAuthMethodEmailPasswordUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetHibpEnabled || v.HibpEnabled != nil {
		s.HibpEnabled = v.HibpEnabled
	}
	if v.IsSetEmailVerificationRequired || v.EmailVerificationRequired != nil {
		s.EmailVerificationRequired = v.EmailVerificationRequired
	}
	if v.IsSetPasswordMinLength || v.PasswordMinLength != nil {
		s.PasswordMinLength = v.PasswordMinLength
	}
}

type ConfigAuthMethodEmailPasswordInsertInput struct {
	HibpEnabled               *bool  `json:"hibpEnabled,omitempty" toml:"hibpEnabled,omitempty"`
	EmailVerificationRequired *bool  `json:"emailVerificationRequired,omitempty" toml:"emailVerificationRequired,omitempty"`
	PasswordMinLength         *uint8 `json:"passwordMinLength,omitempty" toml:"passwordMinLength,omitempty"`
}

func (o *ConfigAuthMethodEmailPasswordInsertInput) GetHibpEnabled() *bool {
	if o == nil {
		o = &ConfigAuthMethodEmailPasswordInsertInput{}
	}
	return o.HibpEnabled
}

func (o *ConfigAuthMethodEmailPasswordInsertInput) GetEmailVerificationRequired() *bool {
	if o == nil {
		o = &ConfigAuthMethodEmailPasswordInsertInput{}
	}
	return o.EmailVerificationRequired
}

func (o *ConfigAuthMethodEmailPasswordInsertInput) GetPasswordMinLength() *uint8 {
	if o == nil {
		o = &ConfigAuthMethodEmailPasswordInsertInput{}
	}
	return o.PasswordMinLength
}

func (s *ConfigAuthMethodEmailPassword) Insert(v *ConfigAuthMethodEmailPasswordInsertInput) {
	s.HibpEnabled = v.HibpEnabled
	s.EmailVerificationRequired = v.EmailVerificationRequired
	s.PasswordMinLength = v.PasswordMinLength
}

func (s *ConfigAuthMethodEmailPassword) Clone() *ConfigAuthMethodEmailPassword {
	if s == nil {
		return nil
	}

	v := &ConfigAuthMethodEmailPassword{}
	v.HibpEnabled = s.HibpEnabled
	v.EmailVerificationRequired = s.EmailVerificationRequired
	v.PasswordMinLength = s.PasswordMinLength
	return v
}

type ConfigAuthMethodEmailPasswordComparisonExp struct {
	And                       []*ConfigAuthMethodEmailPasswordComparisonExp `json:"_and,omitempty"`
	Not                       *ConfigAuthMethodEmailPasswordComparisonExp   `json:"_not,omitempty"`
	Or                        []*ConfigAuthMethodEmailPasswordComparisonExp `json:"_or,omitempty"`
	HibpEnabled               *ConfigBooleanComparisonExp                   `json:"hibpEnabled,omitempty"`
	EmailVerificationRequired *ConfigBooleanComparisonExp                   `json:"emailVerificationRequired,omitempty"`
	PasswordMinLength         *ConfigUint8ComparisonExp                     `json:"passwordMinLength,omitempty"`
}

func (exp *ConfigAuthMethodEmailPasswordComparisonExp) Matches(o *ConfigAuthMethodEmailPassword) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthMethodEmailPassword{}
	}
	if o.HibpEnabled != nil && !exp.HibpEnabled.Matches(*o.HibpEnabled) {
		return false
	}
	if o.EmailVerificationRequired != nil && !exp.EmailVerificationRequired.Matches(*o.EmailVerificationRequired) {
		return false
	}
	if o.PasswordMinLength != nil && !exp.PasswordMinLength.Matches(*o.PasswordMinLength) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAuthMethodEmailPasswordless struct {
	Enabled *bool `json:"enabled" toml:"enabled"`
}

func (o *ConfigAuthMethodEmailPasswordless) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Enabled != nil {
		m["enabled"] = o.Enabled
	}
	return json.Marshal(m)
}

func (o *ConfigAuthMethodEmailPasswordless) GetEnabled() *bool {
	if o == nil {
		o = &ConfigAuthMethodEmailPasswordless{}
	}
	return o.Enabled
}

type ConfigAuthMethodEmailPasswordlessUpdateInput struct {
	Enabled      *bool `json:"enabled,omitempty" toml:"enabled,omitempty"`
	IsSetEnabled bool  `json:"-"`
}

func (o *ConfigAuthMethodEmailPasswordlessUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["enabled"]; ok {
		if v == nil {
			o.Enabled = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x bool
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Enabled = &x
		}
		o.IsSetEnabled = true
	}

	return nil
}

func (o *ConfigAuthMethodEmailPasswordlessUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigAuthMethodEmailPasswordlessUpdateInput) GetEnabled() *bool {
	if o == nil {
		o = &ConfigAuthMethodEmailPasswordlessUpdateInput{}
	}
	return o.Enabled
}

func (s *ConfigAuthMethodEmailPasswordless) Update(v *ConfigAuthMethodEmailPasswordlessUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetEnabled || v.Enabled != nil {
		s.Enabled = v.Enabled
	}
}

type ConfigAuthMethodEmailPasswordlessInsertInput struct {
	Enabled *bool `json:"enabled,omitempty" toml:"enabled,omitempty"`
}

func (o *ConfigAuthMethodEmailPasswordlessInsertInput) GetEnabled() *bool {
	if o == nil {
		o = &ConfigAuthMethodEmailPasswordlessInsertInput{}
	}
	return o.Enabled
}

func (s *ConfigAuthMethodEmailPasswordless) Insert(v *ConfigAuthMethodEmailPasswordlessInsertInput) {
	s.Enabled = v.Enabled
}

func (s *ConfigAuthMethodEmailPasswordless) Clone() *ConfigAuthMethodEmailPasswordless {
	if s == nil {
		return nil
	}

	v := &ConfigAuthMethodEmailPasswordless{}
	v.Enabled = s.Enabled
	return v
}

type ConfigAuthMethodEmailPasswordlessComparisonExp struct {
	And     []*ConfigAuthMethodEmailPasswordlessComparisonExp `json:"_and,omitempty"`
	Not     *ConfigAuthMethodEmailPasswordlessComparisonExp   `json:"_not,omitempty"`
	Or      []*ConfigAuthMethodEmailPasswordlessComparisonExp `json:"_or,omitempty"`
	Enabled *ConfigBooleanComparisonExp                       `json:"enabled,omitempty"`
}

func (exp *ConfigAuthMethodEmailPasswordlessComparisonExp) Matches(o *ConfigAuthMethodEmailPasswordless) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthMethodEmailPasswordless{}
	}
	if o.Enabled != nil && !exp.Enabled.Matches(*o.Enabled) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAuthMethodOauth struct {
	Apple *ConfigAuthMethodOauthApple `json:"apple,omitempty" toml:"apple,omitempty"`

	Azuread *ConfigAuthMethodOauthAzuread `json:"azuread,omitempty" toml:"azuread,omitempty"`

	Bitbucket *ConfigStandardOauthProvider `json:"bitbucket,omitempty" toml:"bitbucket,omitempty"`

	Discord *ConfigStandardOauthProviderWithScope `json:"discord,omitempty" toml:"discord,omitempty"`

	Facebook *ConfigStandardOauthProviderWithScope `json:"facebook,omitempty" toml:"facebook,omitempty"`

	Github *ConfigStandardOauthProviderWithScope `json:"github,omitempty" toml:"github,omitempty"`

	Gitlab *ConfigStandardOauthProviderWithScope `json:"gitlab,omitempty" toml:"gitlab,omitempty"`

	Google *ConfigStandardOauthProviderWithScope `json:"google,omitempty" toml:"google,omitempty"`

	Linkedin *ConfigStandardOauthProviderWithScope `json:"linkedin,omitempty" toml:"linkedin,omitempty"`

	Spotify *ConfigStandardOauthProviderWithScope `json:"spotify,omitempty" toml:"spotify,omitempty"`

	Strava *ConfigStandardOauthProviderWithScope `json:"strava,omitempty" toml:"strava,omitempty"`

	Twitch *ConfigStandardOauthProviderWithScope `json:"twitch,omitempty" toml:"twitch,omitempty"`

	Twitter *ConfigAuthMethodOauthTwitter `json:"twitter,omitempty" toml:"twitter,omitempty"`

	Windowslive *ConfigStandardOauthProviderWithScope `json:"windowslive,omitempty" toml:"windowslive,omitempty"`

	Workos *ConfigAuthMethodOauthWorkos `json:"workos,omitempty" toml:"workos,omitempty"`
}

func (o *ConfigAuthMethodOauth) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Apple != nil {
		m["apple"] = o.Apple
	}
	if o.Azuread != nil {
		m["azuread"] = o.Azuread
	}
	if o.Bitbucket != nil {
		m["bitbucket"] = o.Bitbucket
	}
	if o.Discord != nil {
		m["discord"] = o.Discord
	}
	if o.Facebook != nil {
		m["facebook"] = o.Facebook
	}
	if o.Github != nil {
		m["github"] = o.Github
	}
	if o.Gitlab != nil {
		m["gitlab"] = o.Gitlab
	}
	if o.Google != nil {
		m["google"] = o.Google
	}
	if o.Linkedin != nil {
		m["linkedin"] = o.Linkedin
	}
	if o.Spotify != nil {
		m["spotify"] = o.Spotify
	}
	if o.Strava != nil {
		m["strava"] = o.Strava
	}
	if o.Twitch != nil {
		m["twitch"] = o.Twitch
	}
	if o.Twitter != nil {
		m["twitter"] = o.Twitter
	}
	if o.Windowslive != nil {
		m["windowslive"] = o.Windowslive
	}
	if o.Workos != nil {
		m["workos"] = o.Workos
	}
	return json.Marshal(m)
}

func (o *ConfigAuthMethodOauth) GetApple() *ConfigAuthMethodOauthApple {
	if o == nil {
		return nil
	}
	return o.Apple
}

func (o *ConfigAuthMethodOauth) GetAzuread() *ConfigAuthMethodOauthAzuread {
	if o == nil {
		return nil
	}
	return o.Azuread
}

func (o *ConfigAuthMethodOauth) GetBitbucket() *ConfigStandardOauthProvider {
	if o == nil {
		return nil
	}
	return o.Bitbucket
}

func (o *ConfigAuthMethodOauth) GetDiscord() *ConfigStandardOauthProviderWithScope {
	if o == nil {
		return nil
	}
	return o.Discord
}

func (o *ConfigAuthMethodOauth) GetFacebook() *ConfigStandardOauthProviderWithScope {
	if o == nil {
		return nil
	}
	return o.Facebook
}

func (o *ConfigAuthMethodOauth) GetGithub() *ConfigStandardOauthProviderWithScope {
	if o == nil {
		return nil
	}
	return o.Github
}

func (o *ConfigAuthMethodOauth) GetGitlab() *ConfigStandardOauthProviderWithScope {
	if o == nil {
		return nil
	}
	return o.Gitlab
}

func (o *ConfigAuthMethodOauth) GetGoogle() *ConfigStandardOauthProviderWithScope {
	if o == nil {
		return nil
	}
	return o.Google
}

func (o *ConfigAuthMethodOauth) GetLinkedin() *ConfigStandardOauthProviderWithScope {
	if o == nil {
		return nil
	}
	return o.Linkedin
}

func (o *ConfigAuthMethodOauth) GetSpotify() *ConfigStandardOauthProviderWithScope {
	if o == nil {
		return nil
	}
	return o.Spotify
}

func (o *ConfigAuthMethodOauth) GetStrava() *ConfigStandardOauthProviderWithScope {
	if o == nil {
		return nil
	}
	return o.Strava
}

func (o *ConfigAuthMethodOauth) GetTwitch() *ConfigStandardOauthProviderWithScope {
	if o == nil {
		return nil
	}
	return o.Twitch
}

func (o *ConfigAuthMethodOauth) GetTwitter() *ConfigAuthMethodOauthTwitter {
	if o == nil {
		return nil
	}
	return o.Twitter
}

func (o *ConfigAuthMethodOauth) GetWindowslive() *ConfigStandardOauthProviderWithScope {
	if o == nil {
		return nil
	}
	return o.Windowslive
}

func (o *ConfigAuthMethodOauth) GetWorkos() *ConfigAuthMethodOauthWorkos {
	if o == nil {
		return nil
	}
	return o.Workos
}

type ConfigAuthMethodOauthUpdateInput struct {
	Apple            *ConfigAuthMethodOauthAppleUpdateInput           `json:"apple,omitempty" toml:"apple,omitempty"`
	IsSetApple       bool                                             `json:"-"`
	Azuread          *ConfigAuthMethodOauthAzureadUpdateInput         `json:"azuread,omitempty" toml:"azuread,omitempty"`
	IsSetAzuread     bool                                             `json:"-"`
	Bitbucket        *ConfigStandardOauthProviderUpdateInput          `json:"bitbucket,omitempty" toml:"bitbucket,omitempty"`
	IsSetBitbucket   bool                                             `json:"-"`
	Discord          *ConfigStandardOauthProviderWithScopeUpdateInput `json:"discord,omitempty" toml:"discord,omitempty"`
	IsSetDiscord     bool                                             `json:"-"`
	Facebook         *ConfigStandardOauthProviderWithScopeUpdateInput `json:"facebook,omitempty" toml:"facebook,omitempty"`
	IsSetFacebook    bool                                             `json:"-"`
	Github           *ConfigStandardOauthProviderWithScopeUpdateInput `json:"github,omitempty" toml:"github,omitempty"`
	IsSetGithub      bool                                             `json:"-"`
	Gitlab           *ConfigStandardOauthProviderWithScopeUpdateInput `json:"gitlab,omitempty" toml:"gitlab,omitempty"`
	IsSetGitlab      bool                                             `json:"-"`
	Google           *ConfigStandardOauthProviderWithScopeUpdateInput `json:"google,omitempty" toml:"google,omitempty"`
	IsSetGoogle      bool                                             `json:"-"`
	Linkedin         *ConfigStandardOauthProviderWithScopeUpdateInput `json:"linkedin,omitempty" toml:"linkedin,omitempty"`
	IsSetLinkedin    bool                                             `json:"-"`
	Spotify          *ConfigStandardOauthProviderWithScopeUpdateInput `json:"spotify,omitempty" toml:"spotify,omitempty"`
	IsSetSpotify     bool                                             `json:"-"`
	Strava           *ConfigStandardOauthProviderWithScopeUpdateInput `json:"strava,omitempty" toml:"strava,omitempty"`
	IsSetStrava      bool                                             `json:"-"`
	Twitch           *ConfigStandardOauthProviderWithScopeUpdateInput `json:"twitch,omitempty" toml:"twitch,omitempty"`
	IsSetTwitch      bool                                             `json:"-"`
	Twitter          *ConfigAuthMethodOauthTwitterUpdateInput         `json:"twitter,omitempty" toml:"twitter,omitempty"`
	IsSetTwitter     bool                                             `json:"-"`
	Windowslive      *ConfigStandardOauthProviderWithScopeUpdateInput `json:"windowslive,omitempty" toml:"windowslive,omitempty"`
	IsSetWindowslive bool                                             `json:"-"`
	Workos           *ConfigAuthMethodOauthWorkosUpdateInput          `json:"workos,omitempty" toml:"workos,omitempty"`
	IsSetWorkos      bool                                             `json:"-"`
}

func (o *ConfigAuthMethodOauthUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if x, ok := m["apple"]; ok {
		if x != nil {
			t := &ConfigAuthMethodOauthAppleUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Apple = t
		}
		o.IsSetApple = true
	}
	if x, ok := m["azuread"]; ok {
		if x != nil {
			t := &ConfigAuthMethodOauthAzureadUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Azuread = t
		}
		o.IsSetAzuread = true
	}
	if x, ok := m["bitbucket"]; ok {
		if x != nil {
			t := &ConfigStandardOauthProviderUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Bitbucket = t
		}
		o.IsSetBitbucket = true
	}
	if x, ok := m["discord"]; ok {
		if x != nil {
			t := &ConfigStandardOauthProviderWithScopeUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Discord = t
		}
		o.IsSetDiscord = true
	}
	if x, ok := m["facebook"]; ok {
		if x != nil {
			t := &ConfigStandardOauthProviderWithScopeUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Facebook = t
		}
		o.IsSetFacebook = true
	}
	if x, ok := m["github"]; ok {
		if x != nil {
			t := &ConfigStandardOauthProviderWithScopeUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Github = t
		}
		o.IsSetGithub = true
	}
	if x, ok := m["gitlab"]; ok {
		if x != nil {
			t := &ConfigStandardOauthProviderWithScopeUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Gitlab = t
		}
		o.IsSetGitlab = true
	}
	if x, ok := m["google"]; ok {
		if x != nil {
			t := &ConfigStandardOauthProviderWithScopeUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Google = t
		}
		o.IsSetGoogle = true
	}
	if x, ok := m["linkedin"]; ok {
		if x != nil {
			t := &ConfigStandardOauthProviderWithScopeUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Linkedin = t
		}
		o.IsSetLinkedin = true
	}
	if x, ok := m["spotify"]; ok {
		if x != nil {
			t := &ConfigStandardOauthProviderWithScopeUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Spotify = t
		}
		o.IsSetSpotify = true
	}
	if x, ok := m["strava"]; ok {
		if x != nil {
			t := &ConfigStandardOauthProviderWithScopeUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Strava = t
		}
		o.IsSetStrava = true
	}
	if x, ok := m["twitch"]; ok {
		if x != nil {
			t := &ConfigStandardOauthProviderWithScopeUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Twitch = t
		}
		o.IsSetTwitch = true
	}
	if x, ok := m["twitter"]; ok {
		if x != nil {
			t := &ConfigAuthMethodOauthTwitterUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Twitter = t
		}
		o.IsSetTwitter = true
	}
	if x, ok := m["windowslive"]; ok {
		if x != nil {
			t := &ConfigStandardOauthProviderWithScopeUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Windowslive = t
		}
		o.IsSetWindowslive = true
	}
	if x, ok := m["workos"]; ok {
		if x != nil {
			t := &ConfigAuthMethodOauthWorkosUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Workos = t
		}
		o.IsSetWorkos = true
	}

	return nil
}

func (o *ConfigAuthMethodOauthUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigAuthMethodOauthUpdateInput) GetApple() *ConfigAuthMethodOauthAppleUpdateInput {
	if o == nil {
		return nil
	}
	return o.Apple
}

func (o *ConfigAuthMethodOauthUpdateInput) GetAzuread() *ConfigAuthMethodOauthAzureadUpdateInput {
	if o == nil {
		return nil
	}
	return o.Azuread
}

func (o *ConfigAuthMethodOauthUpdateInput) GetBitbucket() *ConfigStandardOauthProviderUpdateInput {
	if o == nil {
		return nil
	}
	return o.Bitbucket
}

func (o *ConfigAuthMethodOauthUpdateInput) GetDiscord() *ConfigStandardOauthProviderWithScopeUpdateInput {
	if o == nil {
		return nil
	}
	return o.Discord
}

func (o *ConfigAuthMethodOauthUpdateInput) GetFacebook() *ConfigStandardOauthProviderWithScopeUpdateInput {
	if o == nil {
		return nil
	}
	return o.Facebook
}

func (o *ConfigAuthMethodOauthUpdateInput) GetGithub() *ConfigStandardOauthProviderWithScopeUpdateInput {
	if o == nil {
		return nil
	}
	return o.Github
}

func (o *ConfigAuthMethodOauthUpdateInput) GetGitlab() *ConfigStandardOauthProviderWithScopeUpdateInput {
	if o == nil {
		return nil
	}
	return o.Gitlab
}

func (o *ConfigAuthMethodOauthUpdateInput) GetGoogle() *ConfigStandardOauthProviderWithScopeUpdateInput {
	if o == nil {
		return nil
	}
	return o.Google
}

func (o *ConfigAuthMethodOauthUpdateInput) GetLinkedin() *ConfigStandardOauthProviderWithScopeUpdateInput {
	if o == nil {
		return nil
	}
	return o.Linkedin
}

func (o *ConfigAuthMethodOauthUpdateInput) GetSpotify() *ConfigStandardOauthProviderWithScopeUpdateInput {
	if o == nil {
		return nil
	}
	return o.Spotify
}

func (o *ConfigAuthMethodOauthUpdateInput) GetStrava() *ConfigStandardOauthProviderWithScopeUpdateInput {
	if o == nil {
		return nil
	}
	return o.Strava
}

func (o *ConfigAuthMethodOauthUpdateInput) GetTwitch() *ConfigStandardOauthProviderWithScopeUpdateInput {
	if o == nil {
		return nil
	}
	return o.Twitch
}

func (o *ConfigAuthMethodOauthUpdateInput) GetTwitter() *ConfigAuthMethodOauthTwitterUpdateInput {
	if o == nil {
		return nil
	}
	return o.Twitter
}

func (o *ConfigAuthMethodOauthUpdateInput) GetWindowslive() *ConfigStandardOauthProviderWithScopeUpdateInput {
	if o == nil {
		return nil
	}
	return o.Windowslive
}

func (o *ConfigAuthMethodOauthUpdateInput) GetWorkos() *ConfigAuthMethodOauthWorkosUpdateInput {
	if o == nil {
		return nil
	}
	return o.Workos
}

func (s *ConfigAuthMethodOauth) Update(v *ConfigAuthMethodOauthUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetApple || v.Apple != nil {
		if v.Apple == nil {
			s.Apple = nil
		} else {
			if s.Apple == nil {
				s.Apple = &ConfigAuthMethodOauthApple{}
			}
			s.Apple.Update(v.Apple)
		}
	}
	if v.IsSetAzuread || v.Azuread != nil {
		if v.Azuread == nil {
			s.Azuread = nil
		} else {
			if s.Azuread == nil {
				s.Azuread = &ConfigAuthMethodOauthAzuread{}
			}
			s.Azuread.Update(v.Azuread)
		}
	}
	if v.IsSetBitbucket || v.Bitbucket != nil {
		if v.Bitbucket == nil {
			s.Bitbucket = nil
		} else {
			if s.Bitbucket == nil {
				s.Bitbucket = &ConfigStandardOauthProvider{}
			}
			s.Bitbucket.Update(v.Bitbucket)
		}
	}
	if v.IsSetDiscord || v.Discord != nil {
		if v.Discord == nil {
			s.Discord = nil
		} else {
			if s.Discord == nil {
				s.Discord = &ConfigStandardOauthProviderWithScope{}
			}
			s.Discord.Update(v.Discord)
		}
	}
	if v.IsSetFacebook || v.Facebook != nil {
		if v.Facebook == nil {
			s.Facebook = nil
		} else {
			if s.Facebook == nil {
				s.Facebook = &ConfigStandardOauthProviderWithScope{}
			}
			s.Facebook.Update(v.Facebook)
		}
	}
	if v.IsSetGithub || v.Github != nil {
		if v.Github == nil {
			s.Github = nil
		} else {
			if s.Github == nil {
				s.Github = &ConfigStandardOauthProviderWithScope{}
			}
			s.Github.Update(v.Github)
		}
	}
	if v.IsSetGitlab || v.Gitlab != nil {
		if v.Gitlab == nil {
			s.Gitlab = nil
		} else {
			if s.Gitlab == nil {
				s.Gitlab = &ConfigStandardOauthProviderWithScope{}
			}
			s.Gitlab.Update(v.Gitlab)
		}
	}
	if v.IsSetGoogle || v.Google != nil {
		if v.Google == nil {
			s.Google = nil
		} else {
			if s.Google == nil {
				s.Google = &ConfigStandardOauthProviderWithScope{}
			}
			s.Google.Update(v.Google)
		}
	}
	if v.IsSetLinkedin || v.Linkedin != nil {
		if v.Linkedin == nil {
			s.Linkedin = nil
		} else {
			if s.Linkedin == nil {
				s.Linkedin = &ConfigStandardOauthProviderWithScope{}
			}
			s.Linkedin.Update(v.Linkedin)
		}
	}
	if v.IsSetSpotify || v.Spotify != nil {
		if v.Spotify == nil {
			s.Spotify = nil
		} else {
			if s.Spotify == nil {
				s.Spotify = &ConfigStandardOauthProviderWithScope{}
			}
			s.Spotify.Update(v.Spotify)
		}
	}
	if v.IsSetStrava || v.Strava != nil {
		if v.Strava == nil {
			s.Strava = nil
		} else {
			if s.Strava == nil {
				s.Strava = &ConfigStandardOauthProviderWithScope{}
			}
			s.Strava.Update(v.Strava)
		}
	}
	if v.IsSetTwitch || v.Twitch != nil {
		if v.Twitch == nil {
			s.Twitch = nil
		} else {
			if s.Twitch == nil {
				s.Twitch = &ConfigStandardOauthProviderWithScope{}
			}
			s.Twitch.Update(v.Twitch)
		}
	}
	if v.IsSetTwitter || v.Twitter != nil {
		if v.Twitter == nil {
			s.Twitter = nil
		} else {
			if s.Twitter == nil {
				s.Twitter = &ConfigAuthMethodOauthTwitter{}
			}
			s.Twitter.Update(v.Twitter)
		}
	}
	if v.IsSetWindowslive || v.Windowslive != nil {
		if v.Windowslive == nil {
			s.Windowslive = nil
		} else {
			if s.Windowslive == nil {
				s.Windowslive = &ConfigStandardOauthProviderWithScope{}
			}
			s.Windowslive.Update(v.Windowslive)
		}
	}
	if v.IsSetWorkos || v.Workos != nil {
		if v.Workos == nil {
			s.Workos = nil
		} else {
			if s.Workos == nil {
				s.Workos = &ConfigAuthMethodOauthWorkos{}
			}
			s.Workos.Update(v.Workos)
		}
	}
}

type ConfigAuthMethodOauthInsertInput struct {
	Apple       *ConfigAuthMethodOauthAppleInsertInput           `json:"apple,omitempty" toml:"apple,omitempty"`
	Azuread     *ConfigAuthMethodOauthAzureadInsertInput         `json:"azuread,omitempty" toml:"azuread,omitempty"`
	Bitbucket   *ConfigStandardOauthProviderInsertInput          `json:"bitbucket,omitempty" toml:"bitbucket,omitempty"`
	Discord     *ConfigStandardOauthProviderWithScopeInsertInput `json:"discord,omitempty" toml:"discord,omitempty"`
	Facebook    *ConfigStandardOauthProviderWithScopeInsertInput `json:"facebook,omitempty" toml:"facebook,omitempty"`
	Github      *ConfigStandardOauthProviderWithScopeInsertInput `json:"github,omitempty" toml:"github,omitempty"`
	Gitlab      *ConfigStandardOauthProviderWithScopeInsertInput `json:"gitlab,omitempty" toml:"gitlab,omitempty"`
	Google      *ConfigStandardOauthProviderWithScopeInsertInput `json:"google,omitempty" toml:"google,omitempty"`
	Linkedin    *ConfigStandardOauthProviderWithScopeInsertInput `json:"linkedin,omitempty" toml:"linkedin,omitempty"`
	Spotify     *ConfigStandardOauthProviderWithScopeInsertInput `json:"spotify,omitempty" toml:"spotify,omitempty"`
	Strava      *ConfigStandardOauthProviderWithScopeInsertInput `json:"strava,omitempty" toml:"strava,omitempty"`
	Twitch      *ConfigStandardOauthProviderWithScopeInsertInput `json:"twitch,omitempty" toml:"twitch,omitempty"`
	Twitter     *ConfigAuthMethodOauthTwitterInsertInput         `json:"twitter,omitempty" toml:"twitter,omitempty"`
	Windowslive *ConfigStandardOauthProviderWithScopeInsertInput `json:"windowslive,omitempty" toml:"windowslive,omitempty"`
	Workos      *ConfigAuthMethodOauthWorkosInsertInput          `json:"workos,omitempty" toml:"workos,omitempty"`
}

func (o *ConfigAuthMethodOauthInsertInput) GetApple() *ConfigAuthMethodOauthAppleInsertInput {
	if o == nil {
		return nil
	}
	return o.Apple
}

func (o *ConfigAuthMethodOauthInsertInput) GetAzuread() *ConfigAuthMethodOauthAzureadInsertInput {
	if o == nil {
		return nil
	}
	return o.Azuread
}

func (o *ConfigAuthMethodOauthInsertInput) GetBitbucket() *ConfigStandardOauthProviderInsertInput {
	if o == nil {
		return nil
	}
	return o.Bitbucket
}

func (o *ConfigAuthMethodOauthInsertInput) GetDiscord() *ConfigStandardOauthProviderWithScopeInsertInput {
	if o == nil {
		return nil
	}
	return o.Discord
}

func (o *ConfigAuthMethodOauthInsertInput) GetFacebook() *ConfigStandardOauthProviderWithScopeInsertInput {
	if o == nil {
		return nil
	}
	return o.Facebook
}

func (o *ConfigAuthMethodOauthInsertInput) GetGithub() *ConfigStandardOauthProviderWithScopeInsertInput {
	if o == nil {
		return nil
	}
	return o.Github
}

func (o *ConfigAuthMethodOauthInsertInput) GetGitlab() *ConfigStandardOauthProviderWithScopeInsertInput {
	if o == nil {
		return nil
	}
	return o.Gitlab
}

func (o *ConfigAuthMethodOauthInsertInput) GetGoogle() *ConfigStandardOauthProviderWithScopeInsertInput {
	if o == nil {
		return nil
	}
	return o.Google
}

func (o *ConfigAuthMethodOauthInsertInput) GetLinkedin() *ConfigStandardOauthProviderWithScopeInsertInput {
	if o == nil {
		return nil
	}
	return o.Linkedin
}

func (o *ConfigAuthMethodOauthInsertInput) GetSpotify() *ConfigStandardOauthProviderWithScopeInsertInput {
	if o == nil {
		return nil
	}
	return o.Spotify
}

func (o *ConfigAuthMethodOauthInsertInput) GetStrava() *ConfigStandardOauthProviderWithScopeInsertInput {
	if o == nil {
		return nil
	}
	return o.Strava
}

func (o *ConfigAuthMethodOauthInsertInput) GetTwitch() *ConfigStandardOauthProviderWithScopeInsertInput {
	if o == nil {
		return nil
	}
	return o.Twitch
}

func (o *ConfigAuthMethodOauthInsertInput) GetTwitter() *ConfigAuthMethodOauthTwitterInsertInput {
	if o == nil {
		return nil
	}
	return o.Twitter
}

func (o *ConfigAuthMethodOauthInsertInput) GetWindowslive() *ConfigStandardOauthProviderWithScopeInsertInput {
	if o == nil {
		return nil
	}
	return o.Windowslive
}

func (o *ConfigAuthMethodOauthInsertInput) GetWorkos() *ConfigAuthMethodOauthWorkosInsertInput {
	if o == nil {
		return nil
	}
	return o.Workos
}

func (s *ConfigAuthMethodOauth) Insert(v *ConfigAuthMethodOauthInsertInput) {
	if v.Apple != nil {
		if s.Apple == nil {
			s.Apple = &ConfigAuthMethodOauthApple{}
		}
		s.Apple.Insert(v.Apple)
	}
	if v.Azuread != nil {
		if s.Azuread == nil {
			s.Azuread = &ConfigAuthMethodOauthAzuread{}
		}
		s.Azuread.Insert(v.Azuread)
	}
	if v.Bitbucket != nil {
		if s.Bitbucket == nil {
			s.Bitbucket = &ConfigStandardOauthProvider{}
		}
		s.Bitbucket.Insert(v.Bitbucket)
	}
	if v.Discord != nil {
		if s.Discord == nil {
			s.Discord = &ConfigStandardOauthProviderWithScope{}
		}
		s.Discord.Insert(v.Discord)
	}
	if v.Facebook != nil {
		if s.Facebook == nil {
			s.Facebook = &ConfigStandardOauthProviderWithScope{}
		}
		s.Facebook.Insert(v.Facebook)
	}
	if v.Github != nil {
		if s.Github == nil {
			s.Github = &ConfigStandardOauthProviderWithScope{}
		}
		s.Github.Insert(v.Github)
	}
	if v.Gitlab != nil {
		if s.Gitlab == nil {
			s.Gitlab = &ConfigStandardOauthProviderWithScope{}
		}
		s.Gitlab.Insert(v.Gitlab)
	}
	if v.Google != nil {
		if s.Google == nil {
			s.Google = &ConfigStandardOauthProviderWithScope{}
		}
		s.Google.Insert(v.Google)
	}
	if v.Linkedin != nil {
		if s.Linkedin == nil {
			s.Linkedin = &ConfigStandardOauthProviderWithScope{}
		}
		s.Linkedin.Insert(v.Linkedin)
	}
	if v.Spotify != nil {
		if s.Spotify == nil {
			s.Spotify = &ConfigStandardOauthProviderWithScope{}
		}
		s.Spotify.Insert(v.Spotify)
	}
	if v.Strava != nil {
		if s.Strava == nil {
			s.Strava = &ConfigStandardOauthProviderWithScope{}
		}
		s.Strava.Insert(v.Strava)
	}
	if v.Twitch != nil {
		if s.Twitch == nil {
			s.Twitch = &ConfigStandardOauthProviderWithScope{}
		}
		s.Twitch.Insert(v.Twitch)
	}
	if v.Twitter != nil {
		if s.Twitter == nil {
			s.Twitter = &ConfigAuthMethodOauthTwitter{}
		}
		s.Twitter.Insert(v.Twitter)
	}
	if v.Windowslive != nil {
		if s.Windowslive == nil {
			s.Windowslive = &ConfigStandardOauthProviderWithScope{}
		}
		s.Windowslive.Insert(v.Windowslive)
	}
	if v.Workos != nil {
		if s.Workos == nil {
			s.Workos = &ConfigAuthMethodOauthWorkos{}
		}
		s.Workos.Insert(v.Workos)
	}
}

func (s *ConfigAuthMethodOauth) Clone() *ConfigAuthMethodOauth {
	if s == nil {
		return nil
	}

	v := &ConfigAuthMethodOauth{}
	v.Apple = s.Apple.Clone()
	v.Azuread = s.Azuread.Clone()
	v.Bitbucket = s.Bitbucket.Clone()
	v.Discord = s.Discord.Clone()
	v.Facebook = s.Facebook.Clone()
	v.Github = s.Github.Clone()
	v.Gitlab = s.Gitlab.Clone()
	v.Google = s.Google.Clone()
	v.Linkedin = s.Linkedin.Clone()
	v.Spotify = s.Spotify.Clone()
	v.Strava = s.Strava.Clone()
	v.Twitch = s.Twitch.Clone()
	v.Twitter = s.Twitter.Clone()
	v.Windowslive = s.Windowslive.Clone()
	v.Workos = s.Workos.Clone()
	return v
}

type ConfigAuthMethodOauthComparisonExp struct {
	And         []*ConfigAuthMethodOauthComparisonExp              `json:"_and,omitempty"`
	Not         *ConfigAuthMethodOauthComparisonExp                `json:"_not,omitempty"`
	Or          []*ConfigAuthMethodOauthComparisonExp              `json:"_or,omitempty"`
	Apple       *ConfigAuthMethodOauthAppleComparisonExp           `json:"apple,omitempty"`
	Azuread     *ConfigAuthMethodOauthAzureadComparisonExp         `json:"azuread,omitempty"`
	Bitbucket   *ConfigStandardOauthProviderComparisonExp          `json:"bitbucket,omitempty"`
	Discord     *ConfigStandardOauthProviderWithScopeComparisonExp `json:"discord,omitempty"`
	Facebook    *ConfigStandardOauthProviderWithScopeComparisonExp `json:"facebook,omitempty"`
	Github      *ConfigStandardOauthProviderWithScopeComparisonExp `json:"github,omitempty"`
	Gitlab      *ConfigStandardOauthProviderWithScopeComparisonExp `json:"gitlab,omitempty"`
	Google      *ConfigStandardOauthProviderWithScopeComparisonExp `json:"google,omitempty"`
	Linkedin    *ConfigStandardOauthProviderWithScopeComparisonExp `json:"linkedin,omitempty"`
	Spotify     *ConfigStandardOauthProviderWithScopeComparisonExp `json:"spotify,omitempty"`
	Strava      *ConfigStandardOauthProviderWithScopeComparisonExp `json:"strava,omitempty"`
	Twitch      *ConfigStandardOauthProviderWithScopeComparisonExp `json:"twitch,omitempty"`
	Twitter     *ConfigAuthMethodOauthTwitterComparisonExp         `json:"twitter,omitempty"`
	Windowslive *ConfigStandardOauthProviderWithScopeComparisonExp `json:"windowslive,omitempty"`
	Workos      *ConfigAuthMethodOauthWorkosComparisonExp          `json:"workos,omitempty"`
}

func (exp *ConfigAuthMethodOauthComparisonExp) Matches(o *ConfigAuthMethodOauth) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthMethodOauth{
			Apple:       &ConfigAuthMethodOauthApple{},
			Azuread:     &ConfigAuthMethodOauthAzuread{},
			Bitbucket:   &ConfigStandardOauthProvider{},
			Discord:     &ConfigStandardOauthProviderWithScope{},
			Facebook:    &ConfigStandardOauthProviderWithScope{},
			Github:      &ConfigStandardOauthProviderWithScope{},
			Gitlab:      &ConfigStandardOauthProviderWithScope{},
			Google:      &ConfigStandardOauthProviderWithScope{},
			Linkedin:    &ConfigStandardOauthProviderWithScope{},
			Spotify:     &ConfigStandardOauthProviderWithScope{},
			Strava:      &ConfigStandardOauthProviderWithScope{},
			Twitch:      &ConfigStandardOauthProviderWithScope{},
			Twitter:     &ConfigAuthMethodOauthTwitter{},
			Windowslive: &ConfigStandardOauthProviderWithScope{},
			Workos:      &ConfigAuthMethodOauthWorkos{},
		}
	}
	if !exp.Apple.Matches(o.Apple) {
		return false
	}
	if !exp.Azuread.Matches(o.Azuread) {
		return false
	}
	if !exp.Bitbucket.Matches(o.Bitbucket) {
		return false
	}
	if !exp.Discord.Matches(o.Discord) {
		return false
	}
	if !exp.Facebook.Matches(o.Facebook) {
		return false
	}
	if !exp.Github.Matches(o.Github) {
		return false
	}
	if !exp.Gitlab.Matches(o.Gitlab) {
		return false
	}
	if !exp.Google.Matches(o.Google) {
		return false
	}
	if !exp.Linkedin.Matches(o.Linkedin) {
		return false
	}
	if !exp.Spotify.Matches(o.Spotify) {
		return false
	}
	if !exp.Strava.Matches(o.Strava) {
		return false
	}
	if !exp.Twitch.Matches(o.Twitch) {
		return false
	}
	if !exp.Twitter.Matches(o.Twitter) {
		return false
	}
	if !exp.Windowslive.Matches(o.Windowslive) {
		return false
	}
	if !exp.Workos.Matches(o.Workos) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAuthMethodOauthApple struct {
	Enabled *bool `json:"enabled" toml:"enabled"`

	ClientId *string `json:"clientId" toml:"clientId"`

	KeyId *string `json:"keyId" toml:"keyId"`

	TeamId *string `json:"teamId" toml:"teamId"`

	Scope []string `json:"scope,omitempty" toml:"scope,omitempty"`

	PrivateKey *string `json:"privateKey" toml:"privateKey"`
}

func (o *ConfigAuthMethodOauthApple) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Enabled != nil {
		m["enabled"] = o.Enabled
	}
	if o.ClientId != nil {
		m["clientId"] = o.ClientId
	}
	if o.KeyId != nil {
		m["keyId"] = o.KeyId
	}
	if o.TeamId != nil {
		m["teamId"] = o.TeamId
	}
	if o.Scope != nil {
		m["scope"] = o.Scope
	}
	if o.PrivateKey != nil {
		m["privateKey"] = o.PrivateKey
	}
	return json.Marshal(m)
}

func (o *ConfigAuthMethodOauthApple) GetEnabled() *bool {
	if o == nil {
		o = &ConfigAuthMethodOauthApple{}
	}
	return o.Enabled
}

func (o *ConfigAuthMethodOauthApple) GetClientId() *string {
	if o == nil {
		o = &ConfigAuthMethodOauthApple{}
	}
	return o.ClientId
}

func (o *ConfigAuthMethodOauthApple) GetKeyId() *string {
	if o == nil {
		o = &ConfigAuthMethodOauthApple{}
	}
	return o.KeyId
}

func (o *ConfigAuthMethodOauthApple) GetTeamId() *string {
	if o == nil {
		o = &ConfigAuthMethodOauthApple{}
	}
	return o.TeamId
}

func (o *ConfigAuthMethodOauthApple) GetScope() []string {
	if o == nil {
		o = &ConfigAuthMethodOauthApple{}
	}
	return o.Scope
}

func (o *ConfigAuthMethodOauthApple) GetPrivateKey() *string {
	if o == nil {
		o = &ConfigAuthMethodOauthApple{}
	}
	return o.PrivateKey
}

type ConfigAuthMethodOauthAppleUpdateInput struct {
	Enabled         *bool    `json:"enabled,omitempty" toml:"enabled,omitempty"`
	IsSetEnabled    bool     `json:"-"`
	ClientId        *string  `json:"clientId,omitempty" toml:"clientId,omitempty"`
	IsSetClientId   bool     `json:"-"`
	KeyId           *string  `json:"keyId,omitempty" toml:"keyId,omitempty"`
	IsSetKeyId      bool     `json:"-"`
	TeamId          *string  `json:"teamId,omitempty" toml:"teamId,omitempty"`
	IsSetTeamId     bool     `json:"-"`
	Scope           []string `json:"scope,omitempty" toml:"scope,omitempty"`
	IsSetScope      bool     `json:"-"`
	PrivateKey      *string  `json:"privateKey,omitempty" toml:"privateKey,omitempty"`
	IsSetPrivateKey bool     `json:"-"`
}

func (o *ConfigAuthMethodOauthAppleUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["enabled"]; ok {
		if v == nil {
			o.Enabled = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x bool
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Enabled = &x
		}
		o.IsSetEnabled = true
	}
	if v, ok := m["clientId"]; ok {
		if v == nil {
			o.ClientId = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.ClientId = &x
		}
		o.IsSetClientId = true
	}
	if v, ok := m["keyId"]; ok {
		if v == nil {
			o.KeyId = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.KeyId = &x
		}
		o.IsSetKeyId = true
	}
	if v, ok := m["teamId"]; ok {
		if v == nil {
			o.TeamId = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.TeamId = &x
		}
		o.IsSetTeamId = true
	}
	if v, ok := m["scope"]; ok {
		if v != nil {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var l []string
			if err := json.Unmarshal(b, &l); err != nil {
				return err
			}
			o.Scope = l
		}
		o.IsSetScope = true
	}
	if v, ok := m["privateKey"]; ok {
		if v == nil {
			o.PrivateKey = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.PrivateKey = &x
		}
		o.IsSetPrivateKey = true
	}

	return nil
}

func (o *ConfigAuthMethodOauthAppleUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigAuthMethodOauthAppleUpdateInput) GetEnabled() *bool {
	if o == nil {
		o = &ConfigAuthMethodOauthAppleUpdateInput{}
	}
	return o.Enabled
}

func (o *ConfigAuthMethodOauthAppleUpdateInput) GetClientId() *string {
	if o == nil {
		o = &ConfigAuthMethodOauthAppleUpdateInput{}
	}
	return o.ClientId
}

func (o *ConfigAuthMethodOauthAppleUpdateInput) GetKeyId() *string {
	if o == nil {
		o = &ConfigAuthMethodOauthAppleUpdateInput{}
	}
	return o.KeyId
}

func (o *ConfigAuthMethodOauthAppleUpdateInput) GetTeamId() *string {
	if o == nil {
		o = &ConfigAuthMethodOauthAppleUpdateInput{}
	}
	return o.TeamId
}

func (o *ConfigAuthMethodOauthAppleUpdateInput) GetScope() []string {
	if o == nil {
		o = &ConfigAuthMethodOauthAppleUpdateInput{}
	}
	return o.Scope
}

func (o *ConfigAuthMethodOauthAppleUpdateInput) GetPrivateKey() *string {
	if o == nil {
		o = &ConfigAuthMethodOauthAppleUpdateInput{}
	}
	return o.PrivateKey
}

func (s *ConfigAuthMethodOauthApple) Update(v *ConfigAuthMethodOauthAppleUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetEnabled || v.Enabled != nil {
		s.Enabled = v.Enabled
	}
	if v.IsSetClientId || v.ClientId != nil {
		s.ClientId = v.ClientId
	}
	if v.IsSetKeyId || v.KeyId != nil {
		s.KeyId = v.KeyId
	}
	if v.IsSetTeamId || v.TeamId != nil {
		s.TeamId = v.TeamId
	}
	if v.IsSetScope || v.Scope != nil {
		if v.Scope == nil {
			s.Scope = nil
		} else {
			s.Scope = make([]string, len(v.Scope))
			for i, e := range v.Scope {
				s.Scope[i] = e
			}
		}
	}
	if v.IsSetPrivateKey || v.PrivateKey != nil {
		s.PrivateKey = v.PrivateKey
	}
}

type ConfigAuthMethodOauthAppleInsertInput struct {
	Enabled    *bool    `json:"enabled,omitempty" toml:"enabled,omitempty"`
	ClientId   *string  `json:"clientId,omitempty" toml:"clientId,omitempty"`
	KeyId      *string  `json:"keyId,omitempty" toml:"keyId,omitempty"`
	TeamId     *string  `json:"teamId,omitempty" toml:"teamId,omitempty"`
	Scope      []string `json:"scope,omitempty" toml:"scope,omitempty"`
	PrivateKey *string  `json:"privateKey,omitempty" toml:"privateKey,omitempty"`
}

func (o *ConfigAuthMethodOauthAppleInsertInput) GetEnabled() *bool {
	if o == nil {
		o = &ConfigAuthMethodOauthAppleInsertInput{}
	}
	return o.Enabled
}

func (o *ConfigAuthMethodOauthAppleInsertInput) GetClientId() *string {
	if o == nil {
		o = &ConfigAuthMethodOauthAppleInsertInput{}
	}
	return o.ClientId
}

func (o *ConfigAuthMethodOauthAppleInsertInput) GetKeyId() *string {
	if o == nil {
		o = &ConfigAuthMethodOauthAppleInsertInput{}
	}
	return o.KeyId
}

func (o *ConfigAuthMethodOauthAppleInsertInput) GetTeamId() *string {
	if o == nil {
		o = &ConfigAuthMethodOauthAppleInsertInput{}
	}
	return o.TeamId
}

func (o *ConfigAuthMethodOauthAppleInsertInput) GetScope() []string {
	if o == nil {
		o = &ConfigAuthMethodOauthAppleInsertInput{}
	}
	return o.Scope
}

func (o *ConfigAuthMethodOauthAppleInsertInput) GetPrivateKey() *string {
	if o == nil {
		o = &ConfigAuthMethodOauthAppleInsertInput{}
	}
	return o.PrivateKey
}

func (s *ConfigAuthMethodOauthApple) Insert(v *ConfigAuthMethodOauthAppleInsertInput) {
	s.Enabled = v.Enabled
	s.ClientId = v.ClientId
	s.KeyId = v.KeyId
	s.TeamId = v.TeamId
	if v.Scope != nil {
		s.Scope = make([]string, len(v.Scope))
		for i, e := range v.Scope {
			s.Scope[i] = e
		}
	}
	s.PrivateKey = v.PrivateKey
}

func (s *ConfigAuthMethodOauthApple) Clone() *ConfigAuthMethodOauthApple {
	if s == nil {
		return nil
	}

	v := &ConfigAuthMethodOauthApple{}
	v.Enabled = s.Enabled
	v.ClientId = s.ClientId
	v.KeyId = s.KeyId
	v.TeamId = s.TeamId
	if s.Scope != nil {
		v.Scope = make([]string, len(s.Scope))
		copy(v.Scope, s.Scope)
	}
	v.PrivateKey = s.PrivateKey
	return v
}

type ConfigAuthMethodOauthAppleComparisonExp struct {
	And        []*ConfigAuthMethodOauthAppleComparisonExp `json:"_and,omitempty"`
	Not        *ConfigAuthMethodOauthAppleComparisonExp   `json:"_not,omitempty"`
	Or         []*ConfigAuthMethodOauthAppleComparisonExp `json:"_or,omitempty"`
	Enabled    *ConfigBooleanComparisonExp                `json:"enabled,omitempty"`
	ClientId   *ConfigStringComparisonExp                 `json:"clientId,omitempty"`
	KeyId      *ConfigStringComparisonExp                 `json:"keyId,omitempty"`
	TeamId     *ConfigStringComparisonExp                 `json:"teamId,omitempty"`
	Scope      *ConfigStringComparisonExp                 `json:"scope,omitempty"`
	PrivateKey *ConfigStringComparisonExp                 `json:"privateKey,omitempty"`
}

func (exp *ConfigAuthMethodOauthAppleComparisonExp) Matches(o *ConfigAuthMethodOauthApple) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthMethodOauthApple{
			Scope: []string{},
		}
	}
	if o.Enabled != nil && !exp.Enabled.Matches(*o.Enabled) {
		return false
	}
	if o.ClientId != nil && !exp.ClientId.Matches(*o.ClientId) {
		return false
	}
	if o.KeyId != nil && !exp.KeyId.Matches(*o.KeyId) {
		return false
	}
	if o.TeamId != nil && !exp.TeamId.Matches(*o.TeamId) {
		return false
	}
	{
		found := false
		for _, o := range o.Scope {
			if exp.Scope.Matches(o) {
				found = true
				break
			}
		}
		if !found && exp.Scope != nil {
			return false
		}
	}
	if o.PrivateKey != nil && !exp.PrivateKey.Matches(*o.PrivateKey) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAuthMethodOauthAzuread struct {
	Tenant *string `json:"tenant" toml:"tenant"`

	Enabled *bool `json:"enabled" toml:"enabled"`

	ClientId *string `json:"clientId" toml:"clientId"`

	ClientSecret *string `json:"clientSecret" toml:"clientSecret"`
}

func (o *ConfigAuthMethodOauthAzuread) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Tenant != nil {
		m["tenant"] = o.Tenant
	}
	if o.Enabled != nil {
		m["enabled"] = o.Enabled
	}
	if o.ClientId != nil {
		m["clientId"] = o.ClientId
	}
	if o.ClientSecret != nil {
		m["clientSecret"] = o.ClientSecret
	}
	return json.Marshal(m)
}

func (o *ConfigAuthMethodOauthAzuread) GetTenant() *string {
	if o == nil {
		o = &ConfigAuthMethodOauthAzuread{}
	}
	return o.Tenant
}

func (o *ConfigAuthMethodOauthAzuread) GetEnabled() *bool {
	if o == nil {
		o = &ConfigAuthMethodOauthAzuread{}
	}
	return o.Enabled
}

func (o *ConfigAuthMethodOauthAzuread) GetClientId() *string {
	if o == nil {
		o = &ConfigAuthMethodOauthAzuread{}
	}
	return o.ClientId
}

func (o *ConfigAuthMethodOauthAzuread) GetClientSecret() *string {
	if o == nil {
		o = &ConfigAuthMethodOauthAzuread{}
	}
	return o.ClientSecret
}

type ConfigAuthMethodOauthAzureadUpdateInput struct {
	Tenant            *string `json:"tenant,omitempty" toml:"tenant,omitempty"`
	IsSetTenant       bool    `json:"-"`
	Enabled           *bool   `json:"enabled,omitempty" toml:"enabled,omitempty"`
	IsSetEnabled      bool    `json:"-"`
	ClientId          *string `json:"clientId,omitempty" toml:"clientId,omitempty"`
	IsSetClientId     bool    `json:"-"`
	ClientSecret      *string `json:"clientSecret,omitempty" toml:"clientSecret,omitempty"`
	IsSetClientSecret bool    `json:"-"`
}

func (o *ConfigAuthMethodOauthAzureadUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["tenant"]; ok {
		if v == nil {
			o.Tenant = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Tenant = &x
		}
		o.IsSetTenant = true
	}
	if v, ok := m["enabled"]; ok {
		if v == nil {
			o.Enabled = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x bool
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Enabled = &x
		}
		o.IsSetEnabled = true
	}
	if v, ok := m["clientId"]; ok {
		if v == nil {
			o.ClientId = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.ClientId = &x
		}
		o.IsSetClientId = true
	}
	if v, ok := m["clientSecret"]; ok {
		if v == nil {
			o.ClientSecret = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.ClientSecret = &x
		}
		o.IsSetClientSecret = true
	}

	return nil
}

func (o *ConfigAuthMethodOauthAzureadUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigAuthMethodOauthAzureadUpdateInput) GetTenant() *string {
	if o == nil {
		o = &ConfigAuthMethodOauthAzureadUpdateInput{}
	}
	return o.Tenant
}

func (o *ConfigAuthMethodOauthAzureadUpdateInput) GetEnabled() *bool {
	if o == nil {
		o = &ConfigAuthMethodOauthAzureadUpdateInput{}
	}
	return o.Enabled
}

func (o *ConfigAuthMethodOauthAzureadUpdateInput) GetClientId() *string {
	if o == nil {
		o = &ConfigAuthMethodOauthAzureadUpdateInput{}
	}
	return o.ClientId
}

func (o *ConfigAuthMethodOauthAzureadUpdateInput) GetClientSecret() *string {
	if o == nil {
		o = &ConfigAuthMethodOauthAzureadUpdateInput{}
	}
	return o.ClientSecret
}

func (s *ConfigAuthMethodOauthAzuread) Update(v *ConfigAuthMethodOauthAzureadUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetTenant || v.Tenant != nil {
		s.Tenant = v.Tenant
	}
	if v.IsSetEnabled || v.Enabled != nil {
		s.Enabled = v.Enabled
	}
	if v.IsSetClientId || v.ClientId != nil {
		s.ClientId = v.ClientId
	}
	if v.IsSetClientSecret || v.ClientSecret != nil {
		s.ClientSecret = v.ClientSecret
	}
}

type ConfigAuthMethodOauthAzureadInsertInput struct {
	Tenant       *string `json:"tenant,omitempty" toml:"tenant,omitempty"`
	Enabled      *bool   `json:"enabled,omitempty" toml:"enabled,omitempty"`
	ClientId     *string `json:"clientId,omitempty" toml:"clientId,omitempty"`
	ClientSecret *string `json:"clientSecret,omitempty" toml:"clientSecret,omitempty"`
}

func (o *ConfigAuthMethodOauthAzureadInsertInput) GetTenant() *string {
	if o == nil {
		o = &ConfigAuthMethodOauthAzureadInsertInput{}
	}
	return o.Tenant
}

func (o *ConfigAuthMethodOauthAzureadInsertInput) GetEnabled() *bool {
	if o == nil {
		o = &ConfigAuthMethodOauthAzureadInsertInput{}
	}
	return o.Enabled
}

func (o *ConfigAuthMethodOauthAzureadInsertInput) GetClientId() *string {
	if o == nil {
		o = &ConfigAuthMethodOauthAzureadInsertInput{}
	}
	return o.ClientId
}

func (o *ConfigAuthMethodOauthAzureadInsertInput) GetClientSecret() *string {
	if o == nil {
		o = &ConfigAuthMethodOauthAzureadInsertInput{}
	}
	return o.ClientSecret
}

func (s *ConfigAuthMethodOauthAzuread) Insert(v *ConfigAuthMethodOauthAzureadInsertInput) {
	s.Tenant = v.Tenant
	s.Enabled = v.Enabled
	s.ClientId = v.ClientId
	s.ClientSecret = v.ClientSecret
}

func (s *ConfigAuthMethodOauthAzuread) Clone() *ConfigAuthMethodOauthAzuread {
	if s == nil {
		return nil
	}

	v := &ConfigAuthMethodOauthAzuread{}
	v.Tenant = s.Tenant
	v.Enabled = s.Enabled
	v.ClientId = s.ClientId
	v.ClientSecret = s.ClientSecret
	return v
}

type ConfigAuthMethodOauthAzureadComparisonExp struct {
	And          []*ConfigAuthMethodOauthAzureadComparisonExp `json:"_and,omitempty"`
	Not          *ConfigAuthMethodOauthAzureadComparisonExp   `json:"_not,omitempty"`
	Or           []*ConfigAuthMethodOauthAzureadComparisonExp `json:"_or,omitempty"`
	Tenant       *ConfigStringComparisonExp                   `json:"tenant,omitempty"`
	Enabled      *ConfigBooleanComparisonExp                  `json:"enabled,omitempty"`
	ClientId     *ConfigStringComparisonExp                   `json:"clientId,omitempty"`
	ClientSecret *ConfigStringComparisonExp                   `json:"clientSecret,omitempty"`
}

func (exp *ConfigAuthMethodOauthAzureadComparisonExp) Matches(o *ConfigAuthMethodOauthAzuread) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthMethodOauthAzuread{}
	}
	if o.Tenant != nil && !exp.Tenant.Matches(*o.Tenant) {
		return false
	}
	if o.Enabled != nil && !exp.Enabled.Matches(*o.Enabled) {
		return false
	}
	if o.ClientId != nil && !exp.ClientId.Matches(*o.ClientId) {
		return false
	}
	if o.ClientSecret != nil && !exp.ClientSecret.Matches(*o.ClientSecret) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAuthMethodOauthTwitter struct {
	Enabled *bool `json:"enabled" toml:"enabled"`

	ConsumerKey *string `json:"consumerKey" toml:"consumerKey"`

	ConsumerSecret *string `json:"consumerSecret" toml:"consumerSecret"`
}

func (o *ConfigAuthMethodOauthTwitter) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Enabled != nil {
		m["enabled"] = o.Enabled
	}
	if o.ConsumerKey != nil {
		m["consumerKey"] = o.ConsumerKey
	}
	if o.ConsumerSecret != nil {
		m["consumerSecret"] = o.ConsumerSecret
	}
	return json.Marshal(m)
}

func (o *ConfigAuthMethodOauthTwitter) GetEnabled() *bool {
	if o == nil {
		o = &ConfigAuthMethodOauthTwitter{}
	}
	return o.Enabled
}

func (o *ConfigAuthMethodOauthTwitter) GetConsumerKey() *string {
	if o == nil {
		o = &ConfigAuthMethodOauthTwitter{}
	}
	return o.ConsumerKey
}

func (o *ConfigAuthMethodOauthTwitter) GetConsumerSecret() *string {
	if o == nil {
		o = &ConfigAuthMethodOauthTwitter{}
	}
	return o.ConsumerSecret
}

type ConfigAuthMethodOauthTwitterUpdateInput struct {
	Enabled             *bool   `json:"enabled,omitempty" toml:"enabled,omitempty"`
	IsSetEnabled        bool    `json:"-"`
	ConsumerKey         *string `json:"consumerKey,omitempty" toml:"consumerKey,omitempty"`
	IsSetConsumerKey    bool    `json:"-"`
	ConsumerSecret      *string `json:"consumerSecret,omitempty" toml:"consumerSecret,omitempty"`
	IsSetConsumerSecret bool    `json:"-"`
}

func (o *ConfigAuthMethodOauthTwitterUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["enabled"]; ok {
		if v == nil {
			o.Enabled = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x bool
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Enabled = &x
		}
		o.IsSetEnabled = true
	}
	if v, ok := m["consumerKey"]; ok {
		if v == nil {
			o.ConsumerKey = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.ConsumerKey = &x
		}
		o.IsSetConsumerKey = true
	}
	if v, ok := m["consumerSecret"]; ok {
		if v == nil {
			o.ConsumerSecret = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.ConsumerSecret = &x
		}
		o.IsSetConsumerSecret = true
	}

	return nil
}

func (o *ConfigAuthMethodOauthTwitterUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigAuthMethodOauthTwitterUpdateInput) GetEnabled() *bool {
	if o == nil {
		o = &ConfigAuthMethodOauthTwitterUpdateInput{}
	}
	return o.Enabled
}

func (o *ConfigAuthMethodOauthTwitterUpdateInput) GetConsumerKey() *string {
	if o == nil {
		o = &ConfigAuthMethodOauthTwitterUpdateInput{}
	}
	return o.ConsumerKey
}

func (o *ConfigAuthMethodOauthTwitterUpdateInput) GetConsumerSecret() *string {
	if o == nil {
		o = &ConfigAuthMethodOauthTwitterUpdateInput{}
	}
	return o.ConsumerSecret
}

func (s *ConfigAuthMethodOauthTwitter) Update(v *ConfigAuthMethodOauthTwitterUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetEnabled || v.Enabled != nil {
		s.Enabled = v.Enabled
	}
	if v.IsSetConsumerKey || v.ConsumerKey != nil {
		s.ConsumerKey = v.ConsumerKey
	}
	if v.IsSetConsumerSecret || v.ConsumerSecret != nil {
		s.ConsumerSecret = v.ConsumerSecret
	}
}

type ConfigAuthMethodOauthTwitterInsertInput struct {
	Enabled        *bool   `json:"enabled,omitempty" toml:"enabled,omitempty"`
	ConsumerKey    *string `json:"consumerKey,omitempty" toml:"consumerKey,omitempty"`
	ConsumerSecret *string `json:"consumerSecret,omitempty" toml:"consumerSecret,omitempty"`
}

func (o *ConfigAuthMethodOauthTwitterInsertInput) GetEnabled() *bool {
	if o == nil {
		o = &ConfigAuthMethodOauthTwitterInsertInput{}
	}
	return o.Enabled
}

func (o *ConfigAuthMethodOauthTwitterInsertInput) GetConsumerKey() *string {
	if o == nil {
		o = &ConfigAuthMethodOauthTwitterInsertInput{}
	}
	return o.ConsumerKey
}

func (o *ConfigAuthMethodOauthTwitterInsertInput) GetConsumerSecret() *string {
	if o == nil {
		o = &ConfigAuthMethodOauthTwitterInsertInput{}
	}
	return o.ConsumerSecret
}

func (s *ConfigAuthMethodOauthTwitter) Insert(v *ConfigAuthMethodOauthTwitterInsertInput) {
	s.Enabled = v.Enabled
	s.ConsumerKey = v.ConsumerKey
	s.ConsumerSecret = v.ConsumerSecret
}

func (s *ConfigAuthMethodOauthTwitter) Clone() *ConfigAuthMethodOauthTwitter {
	if s == nil {
		return nil
	}

	v := &ConfigAuthMethodOauthTwitter{}
	v.Enabled = s.Enabled
	v.ConsumerKey = s.ConsumerKey
	v.ConsumerSecret = s.ConsumerSecret
	return v
}

type ConfigAuthMethodOauthTwitterComparisonExp struct {
	And            []*ConfigAuthMethodOauthTwitterComparisonExp `json:"_and,omitempty"`
	Not            *ConfigAuthMethodOauthTwitterComparisonExp   `json:"_not,omitempty"`
	Or             []*ConfigAuthMethodOauthTwitterComparisonExp `json:"_or,omitempty"`
	Enabled        *ConfigBooleanComparisonExp                  `json:"enabled,omitempty"`
	ConsumerKey    *ConfigStringComparisonExp                   `json:"consumerKey,omitempty"`
	ConsumerSecret *ConfigStringComparisonExp                   `json:"consumerSecret,omitempty"`
}

func (exp *ConfigAuthMethodOauthTwitterComparisonExp) Matches(o *ConfigAuthMethodOauthTwitter) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthMethodOauthTwitter{}
	}
	if o.Enabled != nil && !exp.Enabled.Matches(*o.Enabled) {
		return false
	}
	if o.ConsumerKey != nil && !exp.ConsumerKey.Matches(*o.ConsumerKey) {
		return false
	}
	if o.ConsumerSecret != nil && !exp.ConsumerSecret.Matches(*o.ConsumerSecret) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAuthMethodOauthWorkos struct {
	Connection *string `json:"connection" toml:"connection"`

	Enabled *bool `json:"enabled" toml:"enabled"`

	ClientId *string `json:"clientId" toml:"clientId"`

	Organization *string `json:"organization" toml:"organization"`

	ClientSecret *string `json:"clientSecret" toml:"clientSecret"`
}

func (o *ConfigAuthMethodOauthWorkos) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Connection != nil {
		m["connection"] = o.Connection
	}
	if o.Enabled != nil {
		m["enabled"] = o.Enabled
	}
	if o.ClientId != nil {
		m["clientId"] = o.ClientId
	}
	if o.Organization != nil {
		m["organization"] = o.Organization
	}
	if o.ClientSecret != nil {
		m["clientSecret"] = o.ClientSecret
	}
	return json.Marshal(m)
}

func (o *ConfigAuthMethodOauthWorkos) GetConnection() *string {
	if o == nil {
		o = &ConfigAuthMethodOauthWorkos{}
	}
	return o.Connection
}

func (o *ConfigAuthMethodOauthWorkos) GetEnabled() *bool {
	if o == nil {
		o = &ConfigAuthMethodOauthWorkos{}
	}
	return o.Enabled
}

func (o *ConfigAuthMethodOauthWorkos) GetClientId() *string {
	if o == nil {
		o = &ConfigAuthMethodOauthWorkos{}
	}
	return o.ClientId
}

func (o *ConfigAuthMethodOauthWorkos) GetOrganization() *string {
	if o == nil {
		o = &ConfigAuthMethodOauthWorkos{}
	}
	return o.Organization
}

func (o *ConfigAuthMethodOauthWorkos) GetClientSecret() *string {
	if o == nil {
		o = &ConfigAuthMethodOauthWorkos{}
	}
	return o.ClientSecret
}

type ConfigAuthMethodOauthWorkosUpdateInput struct {
	Connection        *string `json:"connection,omitempty" toml:"connection,omitempty"`
	IsSetConnection   bool    `json:"-"`
	Enabled           *bool   `json:"enabled,omitempty" toml:"enabled,omitempty"`
	IsSetEnabled      bool    `json:"-"`
	ClientId          *string `json:"clientId,omitempty" toml:"clientId,omitempty"`
	IsSetClientId     bool    `json:"-"`
	Organization      *string `json:"organization,omitempty" toml:"organization,omitempty"`
	IsSetOrganization bool    `json:"-"`
	ClientSecret      *string `json:"clientSecret,omitempty" toml:"clientSecret,omitempty"`
	IsSetClientSecret bool    `json:"-"`
}

func (o *ConfigAuthMethodOauthWorkosUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["connection"]; ok {
		if v == nil {
			o.Connection = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Connection = &x
		}
		o.IsSetConnection = true
	}
	if v, ok := m["enabled"]; ok {
		if v == nil {
			o.Enabled = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x bool
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Enabled = &x
		}
		o.IsSetEnabled = true
	}
	if v, ok := m["clientId"]; ok {
		if v == nil {
			o.ClientId = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.ClientId = &x
		}
		o.IsSetClientId = true
	}
	if v, ok := m["organization"]; ok {
		if v == nil {
			o.Organization = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Organization = &x
		}
		o.IsSetOrganization = true
	}
	if v, ok := m["clientSecret"]; ok {
		if v == nil {
			o.ClientSecret = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.ClientSecret = &x
		}
		o.IsSetClientSecret = true
	}

	return nil
}

func (o *ConfigAuthMethodOauthWorkosUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigAuthMethodOauthWorkosUpdateInput) GetConnection() *string {
	if o == nil {
		o = &ConfigAuthMethodOauthWorkosUpdateInput{}
	}
	return o.Connection
}

func (o *ConfigAuthMethodOauthWorkosUpdateInput) GetEnabled() *bool {
	if o == nil {
		o = &ConfigAuthMethodOauthWorkosUpdateInput{}
	}
	return o.Enabled
}

func (o *ConfigAuthMethodOauthWorkosUpdateInput) GetClientId() *string {
	if o == nil {
		o = &ConfigAuthMethodOauthWorkosUpdateInput{}
	}
	return o.ClientId
}

func (o *ConfigAuthMethodOauthWorkosUpdateInput) GetOrganization() *string {
	if o == nil {
		o = &ConfigAuthMethodOauthWorkosUpdateInput{}
	}
	return o.Organization
}

func (o *ConfigAuthMethodOauthWorkosUpdateInput) GetClientSecret() *string {
	if o == nil {
		o = &ConfigAuthMethodOauthWorkosUpdateInput{}
	}
	return o.ClientSecret
}

func (s *ConfigAuthMethodOauthWorkos) Update(v *ConfigAuthMethodOauthWorkosUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetConnection || v.Connection != nil {
		s.Connection = v.Connection
	}
	if v.IsSetEnabled || v.Enabled != nil {
		s.Enabled = v.Enabled
	}
	if v.IsSetClientId || v.ClientId != nil {
		s.ClientId = v.ClientId
	}
	if v.IsSetOrganization || v.Organization != nil {
		s.Organization = v.Organization
	}
	if v.IsSetClientSecret || v.ClientSecret != nil {
		s.ClientSecret = v.ClientSecret
	}
}

type ConfigAuthMethodOauthWorkosInsertInput struct {
	Connection   *string `json:"connection,omitempty" toml:"connection,omitempty"`
	Enabled      *bool   `json:"enabled,omitempty" toml:"enabled,omitempty"`
	ClientId     *string `json:"clientId,omitempty" toml:"clientId,omitempty"`
	Organization *string `json:"organization,omitempty" toml:"organization,omitempty"`
	ClientSecret *string `json:"clientSecret,omitempty" toml:"clientSecret,omitempty"`
}

func (o *ConfigAuthMethodOauthWorkosInsertInput) GetConnection() *string {
	if o == nil {
		o = &ConfigAuthMethodOauthWorkosInsertInput{}
	}
	return o.Connection
}

func (o *ConfigAuthMethodOauthWorkosInsertInput) GetEnabled() *bool {
	if o == nil {
		o = &ConfigAuthMethodOauthWorkosInsertInput{}
	}
	return o.Enabled
}

func (o *ConfigAuthMethodOauthWorkosInsertInput) GetClientId() *string {
	if o == nil {
		o = &ConfigAuthMethodOauthWorkosInsertInput{}
	}
	return o.ClientId
}

func (o *ConfigAuthMethodOauthWorkosInsertInput) GetOrganization() *string {
	if o == nil {
		o = &ConfigAuthMethodOauthWorkosInsertInput{}
	}
	return o.Organization
}

func (o *ConfigAuthMethodOauthWorkosInsertInput) GetClientSecret() *string {
	if o == nil {
		o = &ConfigAuthMethodOauthWorkosInsertInput{}
	}
	return o.ClientSecret
}

func (s *ConfigAuthMethodOauthWorkos) Insert(v *ConfigAuthMethodOauthWorkosInsertInput) {
	s.Connection = v.Connection
	s.Enabled = v.Enabled
	s.ClientId = v.ClientId
	s.Organization = v.Organization
	s.ClientSecret = v.ClientSecret
}

func (s *ConfigAuthMethodOauthWorkos) Clone() *ConfigAuthMethodOauthWorkos {
	if s == nil {
		return nil
	}

	v := &ConfigAuthMethodOauthWorkos{}
	v.Connection = s.Connection
	v.Enabled = s.Enabled
	v.ClientId = s.ClientId
	v.Organization = s.Organization
	v.ClientSecret = s.ClientSecret
	return v
}

type ConfigAuthMethodOauthWorkosComparisonExp struct {
	And          []*ConfigAuthMethodOauthWorkosComparisonExp `json:"_and,omitempty"`
	Not          *ConfigAuthMethodOauthWorkosComparisonExp   `json:"_not,omitempty"`
	Or           []*ConfigAuthMethodOauthWorkosComparisonExp `json:"_or,omitempty"`
	Connection   *ConfigStringComparisonExp                  `json:"connection,omitempty"`
	Enabled      *ConfigBooleanComparisonExp                 `json:"enabled,omitempty"`
	ClientId     *ConfigStringComparisonExp                  `json:"clientId,omitempty"`
	Organization *ConfigStringComparisonExp                  `json:"organization,omitempty"`
	ClientSecret *ConfigStringComparisonExp                  `json:"clientSecret,omitempty"`
}

func (exp *ConfigAuthMethodOauthWorkosComparisonExp) Matches(o *ConfigAuthMethodOauthWorkos) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthMethodOauthWorkos{}
	}
	if o.Connection != nil && !exp.Connection.Matches(*o.Connection) {
		return false
	}
	if o.Enabled != nil && !exp.Enabled.Matches(*o.Enabled) {
		return false
	}
	if o.ClientId != nil && !exp.ClientId.Matches(*o.ClientId) {
		return false
	}
	if o.Organization != nil && !exp.Organization.Matches(*o.Organization) {
		return false
	}
	if o.ClientSecret != nil && !exp.ClientSecret.Matches(*o.ClientSecret) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAuthMethodSmsPasswordless struct {
	Enabled *bool `json:"enabled" toml:"enabled"`
}

func (o *ConfigAuthMethodSmsPasswordless) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Enabled != nil {
		m["enabled"] = o.Enabled
	}
	return json.Marshal(m)
}

func (o *ConfigAuthMethodSmsPasswordless) GetEnabled() *bool {
	if o == nil {
		o = &ConfigAuthMethodSmsPasswordless{}
	}
	return o.Enabled
}

type ConfigAuthMethodSmsPasswordlessUpdateInput struct {
	Enabled      *bool `json:"enabled,omitempty" toml:"enabled,omitempty"`
	IsSetEnabled bool  `json:"-"`
}

func (o *ConfigAuthMethodSmsPasswordlessUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["enabled"]; ok {
		if v == nil {
			o.Enabled = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x bool
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Enabled = &x
		}
		o.IsSetEnabled = true
	}

	return nil
}

func (o *ConfigAuthMethodSmsPasswordlessUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigAuthMethodSmsPasswordlessUpdateInput) GetEnabled() *bool {
	if o == nil {
		o = &ConfigAuthMethodSmsPasswordlessUpdateInput{}
	}
	return o.Enabled
}

func (s *ConfigAuthMethodSmsPasswordless) Update(v *ConfigAuthMethodSmsPasswordlessUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetEnabled || v.Enabled != nil {
		s.Enabled = v.Enabled
	}
}

type ConfigAuthMethodSmsPasswordlessInsertInput struct {
	Enabled *bool `json:"enabled,omitempty" toml:"enabled,omitempty"`
}

func (o *ConfigAuthMethodSmsPasswordlessInsertInput) GetEnabled() *bool {
	if o == nil {
		o = &ConfigAuthMethodSmsPasswordlessInsertInput{}
	}
	return o.Enabled
}

func (s *ConfigAuthMethodSmsPasswordless) Insert(v *ConfigAuthMethodSmsPasswordlessInsertInput) {
	s.Enabled = v.Enabled
}

func (s *ConfigAuthMethodSmsPasswordless) Clone() *ConfigAuthMethodSmsPasswordless {
	if s == nil {
		return nil
	}

	v := &ConfigAuthMethodSmsPasswordless{}
	v.Enabled = s.Enabled
	return v
}

type ConfigAuthMethodSmsPasswordlessComparisonExp struct {
	And     []*ConfigAuthMethodSmsPasswordlessComparisonExp `json:"_and,omitempty"`
	Not     *ConfigAuthMethodSmsPasswordlessComparisonExp   `json:"_not,omitempty"`
	Or      []*ConfigAuthMethodSmsPasswordlessComparisonExp `json:"_or,omitempty"`
	Enabled *ConfigBooleanComparisonExp                     `json:"enabled,omitempty"`
}

func (exp *ConfigAuthMethodSmsPasswordlessComparisonExp) Matches(o *ConfigAuthMethodSmsPasswordless) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthMethodSmsPasswordless{}
	}
	if o.Enabled != nil && !exp.Enabled.Matches(*o.Enabled) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAuthMethodWebauthn struct {
	Enabled *bool `json:"enabled" toml:"enabled"`

	RelyingParty *ConfigAuthMethodWebauthnRelyingParty `json:"relyingParty,omitempty" toml:"relyingParty,omitempty"`

	Attestation *ConfigAuthMethodWebauthnAttestation `json:"attestation,omitempty" toml:"attestation,omitempty"`
}

func (o *ConfigAuthMethodWebauthn) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Enabled != nil {
		m["enabled"] = o.Enabled
	}
	if o.RelyingParty != nil {
		m["relyingParty"] = o.RelyingParty
	}
	if o.Attestation != nil {
		m["attestation"] = o.Attestation
	}
	return json.Marshal(m)
}

func (o *ConfigAuthMethodWebauthn) GetEnabled() *bool {
	if o == nil {
		o = &ConfigAuthMethodWebauthn{}
	}
	return o.Enabled
}

func (o *ConfigAuthMethodWebauthn) GetRelyingParty() *ConfigAuthMethodWebauthnRelyingParty {
	if o == nil {
		return nil
	}
	return o.RelyingParty
}

func (o *ConfigAuthMethodWebauthn) GetAttestation() *ConfigAuthMethodWebauthnAttestation {
	if o == nil {
		return nil
	}
	return o.Attestation
}

type ConfigAuthMethodWebauthnUpdateInput struct {
	Enabled           *bool                                            `json:"enabled,omitempty" toml:"enabled,omitempty"`
	IsSetEnabled      bool                                             `json:"-"`
	RelyingParty      *ConfigAuthMethodWebauthnRelyingPartyUpdateInput `json:"relyingParty,omitempty" toml:"relyingParty,omitempty"`
	IsSetRelyingParty bool                                             `json:"-"`
	Attestation       *ConfigAuthMethodWebauthnAttestationUpdateInput  `json:"attestation,omitempty" toml:"attestation,omitempty"`
	IsSetAttestation  bool                                             `json:"-"`
}

func (o *ConfigAuthMethodWebauthnUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["enabled"]; ok {
		if v == nil {
			o.Enabled = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x bool
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Enabled = &x
		}
		o.IsSetEnabled = true
	}
	if x, ok := m["relyingParty"]; ok {
		if x != nil {
			t := &ConfigAuthMethodWebauthnRelyingPartyUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.RelyingParty = t
		}
		o.IsSetRelyingParty = true
	}
	if x, ok := m["attestation"]; ok {
		if x != nil {
			t := &ConfigAuthMethodWebauthnAttestationUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Attestation = t
		}
		o.IsSetAttestation = true
	}

	return nil
}

func (o *ConfigAuthMethodWebauthnUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigAuthMethodWebauthnUpdateInput) GetEnabled() *bool {
	if o == nil {
		o = &ConfigAuthMethodWebauthnUpdateInput{}
	}
	return o.Enabled
}

func (o *ConfigAuthMethodWebauthnUpdateInput) GetRelyingParty() *ConfigAuthMethodWebauthnRelyingPartyUpdateInput {
	if o == nil {
		return nil
	}
	return o.RelyingParty
}

func (o *ConfigAuthMethodWebauthnUpdateInput) GetAttestation() *ConfigAuthMethodWebauthnAttestationUpdateInput {
	if o == nil {
		return nil
	}
	return o.Attestation
}

func (s *ConfigAuthMethodWebauthn) Update(v *ConfigAuthMethodWebauthnUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetEnabled || v.Enabled != nil {
		s.Enabled = v.Enabled
	}
	if v.IsSetRelyingParty || v.RelyingParty != nil {
		if v.RelyingParty == nil {
			s.RelyingParty = nil
		} else {
			if s.RelyingParty == nil {
				s.RelyingParty = &ConfigAuthMethodWebauthnRelyingParty{}
			}
			s.RelyingParty.Update(v.RelyingParty)
		}
	}
	if v.IsSetAttestation || v.Attestation != nil {
		if v.Attestation == nil {
			s.Attestation = nil
		} else {
			if s.Attestation == nil {
				s.Attestation = &ConfigAuthMethodWebauthnAttestation{}
			}
			s.Attestation.Update(v.Attestation)
		}
	}
}

type ConfigAuthMethodWebauthnInsertInput struct {
	Enabled      *bool                                            `json:"enabled,omitempty" toml:"enabled,omitempty"`
	RelyingParty *ConfigAuthMethodWebauthnRelyingPartyInsertInput `json:"relyingParty,omitempty" toml:"relyingParty,omitempty"`
	Attestation  *ConfigAuthMethodWebauthnAttestationInsertInput  `json:"attestation,omitempty" toml:"attestation,omitempty"`
}

func (o *ConfigAuthMethodWebauthnInsertInput) GetEnabled() *bool {
	if o == nil {
		o = &ConfigAuthMethodWebauthnInsertInput{}
	}
	return o.Enabled
}

func (o *ConfigAuthMethodWebauthnInsertInput) GetRelyingParty() *ConfigAuthMethodWebauthnRelyingPartyInsertInput {
	if o == nil {
		return nil
	}
	return o.RelyingParty
}

func (o *ConfigAuthMethodWebauthnInsertInput) GetAttestation() *ConfigAuthMethodWebauthnAttestationInsertInput {
	if o == nil {
		return nil
	}
	return o.Attestation
}

func (s *ConfigAuthMethodWebauthn) Insert(v *ConfigAuthMethodWebauthnInsertInput) {
	s.Enabled = v.Enabled
	if v.RelyingParty != nil {
		if s.RelyingParty == nil {
			s.RelyingParty = &ConfigAuthMethodWebauthnRelyingParty{}
		}
		s.RelyingParty.Insert(v.RelyingParty)
	}
	if v.Attestation != nil {
		if s.Attestation == nil {
			s.Attestation = &ConfigAuthMethodWebauthnAttestation{}
		}
		s.Attestation.Insert(v.Attestation)
	}
}

func (s *ConfigAuthMethodWebauthn) Clone() *ConfigAuthMethodWebauthn {
	if s == nil {
		return nil
	}

	v := &ConfigAuthMethodWebauthn{}
	v.Enabled = s.Enabled
	v.RelyingParty = s.RelyingParty.Clone()
	v.Attestation = s.Attestation.Clone()
	return v
}

type ConfigAuthMethodWebauthnComparisonExp struct {
	And          []*ConfigAuthMethodWebauthnComparisonExp           `json:"_and,omitempty"`
	Not          *ConfigAuthMethodWebauthnComparisonExp             `json:"_not,omitempty"`
	Or           []*ConfigAuthMethodWebauthnComparisonExp           `json:"_or,omitempty"`
	Enabled      *ConfigBooleanComparisonExp                        `json:"enabled,omitempty"`
	RelyingParty *ConfigAuthMethodWebauthnRelyingPartyComparisonExp `json:"relyingParty,omitempty"`
	Attestation  *ConfigAuthMethodWebauthnAttestationComparisonExp  `json:"attestation,omitempty"`
}

func (exp *ConfigAuthMethodWebauthnComparisonExp) Matches(o *ConfigAuthMethodWebauthn) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthMethodWebauthn{
			RelyingParty: &ConfigAuthMethodWebauthnRelyingParty{},
			Attestation:  &ConfigAuthMethodWebauthnAttestation{},
		}
	}
	if o.Enabled != nil && !exp.Enabled.Matches(*o.Enabled) {
		return false
	}
	if !exp.RelyingParty.Matches(o.RelyingParty) {
		return false
	}
	if !exp.Attestation.Matches(o.Attestation) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAuthMethodWebauthnAttestation struct {
	Timeout *uint32 `json:"timeout" toml:"timeout"`
}

func (o *ConfigAuthMethodWebauthnAttestation) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Timeout != nil {
		m["timeout"] = o.Timeout
	}
	return json.Marshal(m)
}

func (o *ConfigAuthMethodWebauthnAttestation) GetTimeout() *uint32 {
	if o == nil {
		o = &ConfigAuthMethodWebauthnAttestation{}
	}
	return o.Timeout
}

type ConfigAuthMethodWebauthnAttestationUpdateInput struct {
	Timeout      *uint32 `json:"timeout,omitempty" toml:"timeout,omitempty"`
	IsSetTimeout bool    `json:"-"`
}

func (o *ConfigAuthMethodWebauthnAttestationUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["timeout"]; ok {
		if v == nil {
			o.Timeout = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x uint32
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Timeout = &x
		}
		o.IsSetTimeout = true
	}

	return nil
}

func (o *ConfigAuthMethodWebauthnAttestationUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigAuthMethodWebauthnAttestationUpdateInput) GetTimeout() *uint32 {
	if o == nil {
		o = &ConfigAuthMethodWebauthnAttestationUpdateInput{}
	}
	return o.Timeout
}

func (s *ConfigAuthMethodWebauthnAttestation) Update(v *ConfigAuthMethodWebauthnAttestationUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetTimeout || v.Timeout != nil {
		s.Timeout = v.Timeout
	}
}

type ConfigAuthMethodWebauthnAttestationInsertInput struct {
	Timeout *uint32 `json:"timeout,omitempty" toml:"timeout,omitempty"`
}

func (o *ConfigAuthMethodWebauthnAttestationInsertInput) GetTimeout() *uint32 {
	if o == nil {
		o = &ConfigAuthMethodWebauthnAttestationInsertInput{}
	}
	return o.Timeout
}

func (s *ConfigAuthMethodWebauthnAttestation) Insert(v *ConfigAuthMethodWebauthnAttestationInsertInput) {
	s.Timeout = v.Timeout
}

func (s *ConfigAuthMethodWebauthnAttestation) Clone() *ConfigAuthMethodWebauthnAttestation {
	if s == nil {
		return nil
	}

	v := &ConfigAuthMethodWebauthnAttestation{}
	v.Timeout = s.Timeout
	return v
}

type ConfigAuthMethodWebauthnAttestationComparisonExp struct {
	And     []*ConfigAuthMethodWebauthnAttestationComparisonExp `json:"_and,omitempty"`
	Not     *ConfigAuthMethodWebauthnAttestationComparisonExp   `json:"_not,omitempty"`
	Or      []*ConfigAuthMethodWebauthnAttestationComparisonExp `json:"_or,omitempty"`
	Timeout *ConfigUint32ComparisonExp                          `json:"timeout,omitempty"`
}

func (exp *ConfigAuthMethodWebauthnAttestationComparisonExp) Matches(o *ConfigAuthMethodWebauthnAttestation) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthMethodWebauthnAttestation{}
	}
	if o.Timeout != nil && !exp.Timeout.Matches(*o.Timeout) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAuthMethodWebauthnRelyingParty struct {
	Name *string `json:"name" toml:"name"`

	Origins []string `json:"origins,omitempty" toml:"origins,omitempty"`
}

func (o *ConfigAuthMethodWebauthnRelyingParty) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Name != nil {
		m["name"] = o.Name
	}
	if o.Origins != nil {
		m["origins"] = o.Origins
	}
	return json.Marshal(m)
}

func (o *ConfigAuthMethodWebauthnRelyingParty) GetName() *string {
	if o == nil {
		o = &ConfigAuthMethodWebauthnRelyingParty{}
	}
	return o.Name
}

func (o *ConfigAuthMethodWebauthnRelyingParty) GetOrigins() []string {
	if o == nil {
		o = &ConfigAuthMethodWebauthnRelyingParty{}
	}
	return o.Origins
}

type ConfigAuthMethodWebauthnRelyingPartyUpdateInput struct {
	Name         *string  `json:"name,omitempty" toml:"name,omitempty"`
	IsSetName    bool     `json:"-"`
	Origins      []string `json:"origins,omitempty" toml:"origins,omitempty"`
	IsSetOrigins bool     `json:"-"`
}

func (o *ConfigAuthMethodWebauthnRelyingPartyUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["name"]; ok {
		if v == nil {
			o.Name = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Name = &x
		}
		o.IsSetName = true
	}
	if v, ok := m["origins"]; ok {
		if v != nil {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var l []string
			if err := json.Unmarshal(b, &l); err != nil {
				return err
			}
			o.Origins = l
		}
		o.IsSetOrigins = true
	}

	return nil
}

func (o *ConfigAuthMethodWebauthnRelyingPartyUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigAuthMethodWebauthnRelyingPartyUpdateInput) GetName() *string {
	if o == nil {
		o = &ConfigAuthMethodWebauthnRelyingPartyUpdateInput{}
	}
	return o.Name
}

func (o *ConfigAuthMethodWebauthnRelyingPartyUpdateInput) GetOrigins() []string {
	if o == nil {
		o = &ConfigAuthMethodWebauthnRelyingPartyUpdateInput{}
	}
	return o.Origins
}

func (s *ConfigAuthMethodWebauthnRelyingParty) Update(v *ConfigAuthMethodWebauthnRelyingPartyUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetName || v.Name != nil {
		s.Name = v.Name
	}
	if v.IsSetOrigins || v.Origins != nil {
		if v.Origins == nil {
			s.Origins = nil
		} else {
			s.Origins = make([]string, len(v.Origins))
			for i, e := range v.Origins {
				s.Origins[i] = e
			}
		}
	}
}

type ConfigAuthMethodWebauthnRelyingPartyInsertInput struct {
	Name    *string  `json:"name,omitempty" toml:"name,omitempty"`
	Origins []string `json:"origins,omitempty" toml:"origins,omitempty"`
}

func (o *ConfigAuthMethodWebauthnRelyingPartyInsertInput) GetName() *string {
	if o == nil {
		o = &ConfigAuthMethodWebauthnRelyingPartyInsertInput{}
	}
	return o.Name
}

func (o *ConfigAuthMethodWebauthnRelyingPartyInsertInput) GetOrigins() []string {
	if o == nil {
		o = &ConfigAuthMethodWebauthnRelyingPartyInsertInput{}
	}
	return o.Origins
}

func (s *ConfigAuthMethodWebauthnRelyingParty) Insert(v *ConfigAuthMethodWebauthnRelyingPartyInsertInput) {
	s.Name = v.Name
	if v.Origins != nil {
		s.Origins = make([]string, len(v.Origins))
		for i, e := range v.Origins {
			s.Origins[i] = e
		}
	}
}

func (s *ConfigAuthMethodWebauthnRelyingParty) Clone() *ConfigAuthMethodWebauthnRelyingParty {
	if s == nil {
		return nil
	}

	v := &ConfigAuthMethodWebauthnRelyingParty{}
	v.Name = s.Name
	if s.Origins != nil {
		v.Origins = make([]string, len(s.Origins))
		copy(v.Origins, s.Origins)
	}
	return v
}

type ConfigAuthMethodWebauthnRelyingPartyComparisonExp struct {
	And     []*ConfigAuthMethodWebauthnRelyingPartyComparisonExp `json:"_and,omitempty"`
	Not     *ConfigAuthMethodWebauthnRelyingPartyComparisonExp   `json:"_not,omitempty"`
	Or      []*ConfigAuthMethodWebauthnRelyingPartyComparisonExp `json:"_or,omitempty"`
	Name    *ConfigStringComparisonExp                           `json:"name,omitempty"`
	Origins *ConfigUrlComparisonExp                              `json:"origins,omitempty"`
}

func (exp *ConfigAuthMethodWebauthnRelyingPartyComparisonExp) Matches(o *ConfigAuthMethodWebauthnRelyingParty) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthMethodWebauthnRelyingParty{
			Origins: []string{},
		}
	}
	if o.Name != nil && !exp.Name.Matches(*o.Name) {
		return false
	}
	{
		found := false
		for _, o := range o.Origins {
			if exp.Origins.Matches(o) {
				found = true
				break
			}
		}
		if !found && exp.Origins != nil {
			return false
		}
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAuthRedirections struct {
	// AUTH_CLIENT_URL
	ClientUrl *string `json:"clientUrl" toml:"clientUrl"`
	// AUTH_ACCESS_CONTROL_ALLOWED_REDIRECT_URLS
	AllowedUrls []string `json:"allowedUrls,omitempty" toml:"allowedUrls,omitempty"`
}

func (o *ConfigAuthRedirections) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.ClientUrl != nil {
		m["clientUrl"] = o.ClientUrl
	}
	if o.AllowedUrls != nil {
		m["allowedUrls"] = o.AllowedUrls
	}
	return json.Marshal(m)
}

func (o *ConfigAuthRedirections) GetClientUrl() *string {
	if o == nil {
		o = &ConfigAuthRedirections{}
	}
	return o.ClientUrl
}

func (o *ConfigAuthRedirections) GetAllowedUrls() []string {
	if o == nil {
		o = &ConfigAuthRedirections{}
	}
	return o.AllowedUrls
}

type ConfigAuthRedirectionsUpdateInput struct {
	ClientUrl        *string  `json:"clientUrl,omitempty" toml:"clientUrl,omitempty"`
	IsSetClientUrl   bool     `json:"-"`
	AllowedUrls      []string `json:"allowedUrls,omitempty" toml:"allowedUrls,omitempty"`
	IsSetAllowedUrls bool     `json:"-"`
}

func (o *ConfigAuthRedirectionsUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["clientUrl"]; ok {
		if v == nil {
			o.ClientUrl = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.ClientUrl = &x
		}
		o.IsSetClientUrl = true
	}
	if v, ok := m["allowedUrls"]; ok {
		if v != nil {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var l []string
			if err := json.Unmarshal(b, &l); err != nil {
				return err
			}
			o.AllowedUrls = l
		}
		o.IsSetAllowedUrls = true
	}

	return nil
}

func (o *ConfigAuthRedirectionsUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigAuthRedirectionsUpdateInput) GetClientUrl() *string {
	if o == nil {
		o = &ConfigAuthRedirectionsUpdateInput{}
	}
	return o.ClientUrl
}

func (o *ConfigAuthRedirectionsUpdateInput) GetAllowedUrls() []string {
	if o == nil {
		o = &ConfigAuthRedirectionsUpdateInput{}
	}
	return o.AllowedUrls
}

func (s *ConfigAuthRedirections) Update(v *ConfigAuthRedirectionsUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetClientUrl || v.ClientUrl != nil {
		s.ClientUrl = v.ClientUrl
	}
	if v.IsSetAllowedUrls || v.AllowedUrls != nil {
		if v.AllowedUrls == nil {
			s.AllowedUrls = nil
		} else {
			s.AllowedUrls = make([]string, len(v.AllowedUrls))
			for i, e := range v.AllowedUrls {
				s.AllowedUrls[i] = e
			}
		}
	}
}

type ConfigAuthRedirectionsInsertInput struct {
	ClientUrl   *string  `json:"clientUrl,omitempty" toml:"clientUrl,omitempty"`
	AllowedUrls []string `json:"allowedUrls,omitempty" toml:"allowedUrls,omitempty"`
}

func (o *ConfigAuthRedirectionsInsertInput) GetClientUrl() *string {
	if o == nil {
		o = &ConfigAuthRedirectionsInsertInput{}
	}
	return o.ClientUrl
}

func (o *ConfigAuthRedirectionsInsertInput) GetAllowedUrls() []string {
	if o == nil {
		o = &ConfigAuthRedirectionsInsertInput{}
	}
	return o.AllowedUrls
}

func (s *ConfigAuthRedirections) Insert(v *ConfigAuthRedirectionsInsertInput) {
	s.ClientUrl = v.ClientUrl
	if v.AllowedUrls != nil {
		s.AllowedUrls = make([]string, len(v.AllowedUrls))
		for i, e := range v.AllowedUrls {
			s.AllowedUrls[i] = e
		}
	}
}

func (s *ConfigAuthRedirections) Clone() *ConfigAuthRedirections {
	if s == nil {
		return nil
	}

	v := &ConfigAuthRedirections{}
	v.ClientUrl = s.ClientUrl
	if s.AllowedUrls != nil {
		v.AllowedUrls = make([]string, len(s.AllowedUrls))
		copy(v.AllowedUrls, s.AllowedUrls)
	}
	return v
}

type ConfigAuthRedirectionsComparisonExp struct {
	And         []*ConfigAuthRedirectionsComparisonExp `json:"_and,omitempty"`
	Not         *ConfigAuthRedirectionsComparisonExp   `json:"_not,omitempty"`
	Or          []*ConfigAuthRedirectionsComparisonExp `json:"_or,omitempty"`
	ClientUrl   *ConfigUrlComparisonExp                `json:"clientUrl,omitempty"`
	AllowedUrls *ConfigStringComparisonExp             `json:"allowedUrls,omitempty"`
}

func (exp *ConfigAuthRedirectionsComparisonExp) Matches(o *ConfigAuthRedirections) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthRedirections{
			AllowedUrls: []string{},
		}
	}
	if o.ClientUrl != nil && !exp.ClientUrl.Matches(*o.ClientUrl) {
		return false
	}
	{
		found := false
		for _, o := range o.AllowedUrls {
			if exp.AllowedUrls.Matches(o) {
				found = true
				break
			}
		}
		if !found && exp.AllowedUrls != nil {
			return false
		}
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAuthSession struct {
	AccessToken *ConfigAuthSessionAccessToken `json:"accessToken,omitempty" toml:"accessToken,omitempty"`

	RefreshToken *ConfigAuthSessionRefreshToken `json:"refreshToken,omitempty" toml:"refreshToken,omitempty"`
}

func (o *ConfigAuthSession) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.AccessToken != nil {
		m["accessToken"] = o.AccessToken
	}
	if o.RefreshToken != nil {
		m["refreshToken"] = o.RefreshToken
	}
	return json.Marshal(m)
}

func (o *ConfigAuthSession) GetAccessToken() *ConfigAuthSessionAccessToken {
	if o == nil {
		return nil
	}
	return o.AccessToken
}

func (o *ConfigAuthSession) GetRefreshToken() *ConfigAuthSessionRefreshToken {
	if o == nil {
		return nil
	}
	return o.RefreshToken
}

type ConfigAuthSessionUpdateInput struct {
	AccessToken       *ConfigAuthSessionAccessTokenUpdateInput  `json:"accessToken,omitempty" toml:"accessToken,omitempty"`
	IsSetAccessToken  bool                                      `json:"-"`
	RefreshToken      *ConfigAuthSessionRefreshTokenUpdateInput `json:"refreshToken,omitempty" toml:"refreshToken,omitempty"`
	IsSetRefreshToken bool                                      `json:"-"`
}

func (o *ConfigAuthSessionUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if x, ok := m["accessToken"]; ok {
		if x != nil {
			t := &ConfigAuthSessionAccessTokenUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.AccessToken = t
		}
		o.IsSetAccessToken = true
	}
	if x, ok := m["refreshToken"]; ok {
		if x != nil {
			t := &ConfigAuthSessionRefreshTokenUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.RefreshToken = t
		}
		o.IsSetRefreshToken = true
	}

	return nil
}

func (o *ConfigAuthSessionUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigAuthSessionUpdateInput) GetAccessToken() *ConfigAuthSessionAccessTokenUpdateInput {
	if o == nil {
		return nil
	}
	return o.AccessToken
}

func (o *ConfigAuthSessionUpdateInput) GetRefreshToken() *ConfigAuthSessionRefreshTokenUpdateInput {
	if o == nil {
		return nil
	}
	return o.RefreshToken
}

func (s *ConfigAuthSession) Update(v *ConfigAuthSessionUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetAccessToken || v.AccessToken != nil {
		if v.AccessToken == nil {
			s.AccessToken = nil
		} else {
			if s.AccessToken == nil {
				s.AccessToken = &ConfigAuthSessionAccessToken{}
			}
			s.AccessToken.Update(v.AccessToken)
		}
	}
	if v.IsSetRefreshToken || v.RefreshToken != nil {
		if v.RefreshToken == nil {
			s.RefreshToken = nil
		} else {
			if s.RefreshToken == nil {
				s.RefreshToken = &ConfigAuthSessionRefreshToken{}
			}
			s.RefreshToken.Update(v.RefreshToken)
		}
	}
}

type ConfigAuthSessionInsertInput struct {
	AccessToken  *ConfigAuthSessionAccessTokenInsertInput  `json:"accessToken,omitempty" toml:"accessToken,omitempty"`
	RefreshToken *ConfigAuthSessionRefreshTokenInsertInput `json:"refreshToken,omitempty" toml:"refreshToken,omitempty"`
}

func (o *ConfigAuthSessionInsertInput) GetAccessToken() *ConfigAuthSessionAccessTokenInsertInput {
	if o == nil {
		return nil
	}
	return o.AccessToken
}

func (o *ConfigAuthSessionInsertInput) GetRefreshToken() *ConfigAuthSessionRefreshTokenInsertInput {
	if o == nil {
		return nil
	}
	return o.RefreshToken
}

func (s *ConfigAuthSession) Insert(v *ConfigAuthSessionInsertInput) {
	if v.AccessToken != nil {
		if s.AccessToken == nil {
			s.AccessToken = &ConfigAuthSessionAccessToken{}
		}
		s.AccessToken.Insert(v.AccessToken)
	}
	if v.RefreshToken != nil {
		if s.RefreshToken == nil {
			s.RefreshToken = &ConfigAuthSessionRefreshToken{}
		}
		s.RefreshToken.Insert(v.RefreshToken)
	}
}

func (s *ConfigAuthSession) Clone() *ConfigAuthSession {
	if s == nil {
		return nil
	}

	v := &ConfigAuthSession{}
	v.AccessToken = s.AccessToken.Clone()
	v.RefreshToken = s.RefreshToken.Clone()
	return v
}

type ConfigAuthSessionComparisonExp struct {
	And          []*ConfigAuthSessionComparisonExp           `json:"_and,omitempty"`
	Not          *ConfigAuthSessionComparisonExp             `json:"_not,omitempty"`
	Or           []*ConfigAuthSessionComparisonExp           `json:"_or,omitempty"`
	AccessToken  *ConfigAuthSessionAccessTokenComparisonExp  `json:"accessToken,omitempty"`
	RefreshToken *ConfigAuthSessionRefreshTokenComparisonExp `json:"refreshToken,omitempty"`
}

func (exp *ConfigAuthSessionComparisonExp) Matches(o *ConfigAuthSession) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthSession{
			AccessToken:  &ConfigAuthSessionAccessToken{},
			RefreshToken: &ConfigAuthSessionRefreshToken{},
		}
	}
	if !exp.AccessToken.Matches(o.AccessToken) {
		return false
	}
	if !exp.RefreshToken.Matches(o.RefreshToken) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAuthSessionAccessToken struct {
	// AUTH_ACCESS_TOKEN_EXPIRES_IN
	ExpiresIn *uint32 `json:"expiresIn" toml:"expiresIn"`
	// AUTH_JWT_CUSTOM_CLAIMS
	CustomClaims []*ConfigAuthsessionaccessTokenCustomClaims `json:"customClaims,omitempty" toml:"customClaims,omitempty"`
}

func (o *ConfigAuthSessionAccessToken) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.ExpiresIn != nil {
		m["expiresIn"] = o.ExpiresIn
	}
	if o.CustomClaims != nil {
		m["customClaims"] = o.CustomClaims
	}
	return json.Marshal(m)
}

func (o *ConfigAuthSessionAccessToken) GetExpiresIn() *uint32 {
	if o == nil {
		o = &ConfigAuthSessionAccessToken{}
	}
	return o.ExpiresIn
}

func (o *ConfigAuthSessionAccessToken) GetCustomClaims() []*ConfigAuthsessionaccessTokenCustomClaims {
	if o == nil {
		o = &ConfigAuthSessionAccessToken{}
	}
	return o.CustomClaims
}

type ConfigAuthSessionAccessTokenUpdateInput struct {
	ExpiresIn         *uint32                                                `json:"expiresIn,omitempty" toml:"expiresIn,omitempty"`
	IsSetExpiresIn    bool                                                   `json:"-"`
	CustomClaims      []*ConfigAuthsessionaccessTokenCustomClaimsUpdateInput `json:"customClaims,omitempty" toml:"customClaims,omitempty"`
	IsSetCustomClaims bool                                                   `json:"-"`
}

func (o *ConfigAuthSessionAccessTokenUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["expiresIn"]; ok {
		if v == nil {
			o.ExpiresIn = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x uint32
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.ExpiresIn = &x
		}
		o.IsSetExpiresIn = true
	}
	if v, ok := m["customClaims"]; ok {
		if v != nil {
			x, ok := v.([]interface{})
			if !ok {
				return fmt.Errorf("CustomClaims must be []interface{}, got %T", v)
			}

			l := make([]*ConfigAuthsessionaccessTokenCustomClaimsUpdateInput, len(x))
			for i, vv := range x {
				t := &ConfigAuthsessionaccessTokenCustomClaimsUpdateInput{}
				if err := t.UnmarshalGQL(vv); err != nil {
					return err
				}
				l[i] = t
			}
			o.CustomClaims = l
		}
		o.IsSetCustomClaims = true
	}

	return nil
}

func (o *ConfigAuthSessionAccessTokenUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigAuthSessionAccessTokenUpdateInput) GetExpiresIn() *uint32 {
	if o == nil {
		o = &ConfigAuthSessionAccessTokenUpdateInput{}
	}
	return o.ExpiresIn
}

func (o *ConfigAuthSessionAccessTokenUpdateInput) GetCustomClaims() []*ConfigAuthsessionaccessTokenCustomClaimsUpdateInput {
	if o == nil {
		o = &ConfigAuthSessionAccessTokenUpdateInput{}
	}
	return o.CustomClaims
}

func (s *ConfigAuthSessionAccessToken) Update(v *ConfigAuthSessionAccessTokenUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetExpiresIn || v.ExpiresIn != nil {
		s.ExpiresIn = v.ExpiresIn
	}
	if v.IsSetCustomClaims || v.CustomClaims != nil {
		if v.CustomClaims == nil {
			s.CustomClaims = nil
		} else {
			s.CustomClaims = make([]*ConfigAuthsessionaccessTokenCustomClaims, len(v.CustomClaims))
			for i, e := range v.CustomClaims {
				v := &ConfigAuthsessionaccessTokenCustomClaims{}
				v.Update(e)
				s.CustomClaims[i] = v
			}
		}
	}
}

type ConfigAuthSessionAccessTokenInsertInput struct {
	ExpiresIn    *uint32                                                `json:"expiresIn,omitempty" toml:"expiresIn,omitempty"`
	CustomClaims []*ConfigAuthsessionaccessTokenCustomClaimsInsertInput `json:"customClaims,omitempty" toml:"customClaims,omitempty"`
}

func (o *ConfigAuthSessionAccessTokenInsertInput) GetExpiresIn() *uint32 {
	if o == nil {
		o = &ConfigAuthSessionAccessTokenInsertInput{}
	}
	return o.ExpiresIn
}

func (o *ConfigAuthSessionAccessTokenInsertInput) GetCustomClaims() []*ConfigAuthsessionaccessTokenCustomClaimsInsertInput {
	if o == nil {
		o = &ConfigAuthSessionAccessTokenInsertInput{}
	}
	return o.CustomClaims
}

func (s *ConfigAuthSessionAccessToken) Insert(v *ConfigAuthSessionAccessTokenInsertInput) {
	s.ExpiresIn = v.ExpiresIn
	if v.CustomClaims != nil {
		s.CustomClaims = make([]*ConfigAuthsessionaccessTokenCustomClaims, len(v.CustomClaims))
		for i, e := range v.CustomClaims {
			v := &ConfigAuthsessionaccessTokenCustomClaims{}
			v.Insert(e)
			s.CustomClaims[i] = v
		}
	}
}

func (s *ConfigAuthSessionAccessToken) Clone() *ConfigAuthSessionAccessToken {
	if s == nil {
		return nil
	}

	v := &ConfigAuthSessionAccessToken{}
	v.ExpiresIn = s.ExpiresIn
	if s.CustomClaims != nil {
		v.CustomClaims = make([]*ConfigAuthsessionaccessTokenCustomClaims, len(s.CustomClaims))
		for i, e := range s.CustomClaims {
			v.CustomClaims[i] = e.Clone()
		}
	}
	return v
}

type ConfigAuthSessionAccessTokenComparisonExp struct {
	And          []*ConfigAuthSessionAccessTokenComparisonExp           `json:"_and,omitempty"`
	Not          *ConfigAuthSessionAccessTokenComparisonExp             `json:"_not,omitempty"`
	Or           []*ConfigAuthSessionAccessTokenComparisonExp           `json:"_or,omitempty"`
	ExpiresIn    *ConfigUint32ComparisonExp                             `json:"expiresIn,omitempty"`
	CustomClaims *ConfigAuthsessionaccessTokenCustomClaimsComparisonExp `json:"customClaims,omitempty"`
}

func (exp *ConfigAuthSessionAccessTokenComparisonExp) Matches(o *ConfigAuthSessionAccessToken) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthSessionAccessToken{
			CustomClaims: []*ConfigAuthsessionaccessTokenCustomClaims{},
		}
	}
	if o.ExpiresIn != nil && !exp.ExpiresIn.Matches(*o.ExpiresIn) {
		return false
	}
	{
		found := false
		for _, o := range o.CustomClaims {
			if exp.CustomClaims.Matches(o) {
				found = true
				break
			}
		}
		if !found && exp.CustomClaims != nil {
			return false
		}
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAuthSessionRefreshToken struct {
	// AUTH_REFRESH_TOKEN_EXPIRES_IN
	ExpiresIn *uint32 `json:"expiresIn" toml:"expiresIn"`
}

func (o *ConfigAuthSessionRefreshToken) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.ExpiresIn != nil {
		m["expiresIn"] = o.ExpiresIn
	}
	return json.Marshal(m)
}

func (o *ConfigAuthSessionRefreshToken) GetExpiresIn() *uint32 {
	if o == nil {
		o = &ConfigAuthSessionRefreshToken{}
	}
	return o.ExpiresIn
}

type ConfigAuthSessionRefreshTokenUpdateInput struct {
	ExpiresIn      *uint32 `json:"expiresIn,omitempty" toml:"expiresIn,omitempty"`
	IsSetExpiresIn bool    `json:"-"`
}

func (o *ConfigAuthSessionRefreshTokenUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["expiresIn"]; ok {
		if v == nil {
			o.ExpiresIn = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x uint32
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.ExpiresIn = &x
		}
		o.IsSetExpiresIn = true
	}

	return nil
}

func (o *ConfigAuthSessionRefreshTokenUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigAuthSessionRefreshTokenUpdateInput) GetExpiresIn() *uint32 {
	if o == nil {
		o = &ConfigAuthSessionRefreshTokenUpdateInput{}
	}
	return o.ExpiresIn
}

func (s *ConfigAuthSessionRefreshToken) Update(v *ConfigAuthSessionRefreshTokenUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetExpiresIn || v.ExpiresIn != nil {
		s.ExpiresIn = v.ExpiresIn
	}
}

type ConfigAuthSessionRefreshTokenInsertInput struct {
	ExpiresIn *uint32 `json:"expiresIn,omitempty" toml:"expiresIn,omitempty"`
}

func (o *ConfigAuthSessionRefreshTokenInsertInput) GetExpiresIn() *uint32 {
	if o == nil {
		o = &ConfigAuthSessionRefreshTokenInsertInput{}
	}
	return o.ExpiresIn
}

func (s *ConfigAuthSessionRefreshToken) Insert(v *ConfigAuthSessionRefreshTokenInsertInput) {
	s.ExpiresIn = v.ExpiresIn
}

func (s *ConfigAuthSessionRefreshToken) Clone() *ConfigAuthSessionRefreshToken {
	if s == nil {
		return nil
	}

	v := &ConfigAuthSessionRefreshToken{}
	v.ExpiresIn = s.ExpiresIn
	return v
}

type ConfigAuthSessionRefreshTokenComparisonExp struct {
	And       []*ConfigAuthSessionRefreshTokenComparisonExp `json:"_and,omitempty"`
	Not       *ConfigAuthSessionRefreshTokenComparisonExp   `json:"_not,omitempty"`
	Or        []*ConfigAuthSessionRefreshTokenComparisonExp `json:"_or,omitempty"`
	ExpiresIn *ConfigUint32ComparisonExp                    `json:"expiresIn,omitempty"`
}

func (exp *ConfigAuthSessionRefreshTokenComparisonExp) Matches(o *ConfigAuthSessionRefreshToken) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthSessionRefreshToken{}
	}
	if o.ExpiresIn != nil && !exp.ExpiresIn.Matches(*o.ExpiresIn) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAuthSignUp struct {
	// Inverse of AUTH_DISABLE_NEW_USERS
	Enabled *bool `json:"enabled" toml:"enabled"`
}

func (o *ConfigAuthSignUp) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Enabled != nil {
		m["enabled"] = o.Enabled
	}
	return json.Marshal(m)
}

func (o *ConfigAuthSignUp) GetEnabled() *bool {
	if o == nil {
		o = &ConfigAuthSignUp{}
	}
	return o.Enabled
}

type ConfigAuthSignUpUpdateInput struct {
	Enabled      *bool `json:"enabled,omitempty" toml:"enabled,omitempty"`
	IsSetEnabled bool  `json:"-"`
}

func (o *ConfigAuthSignUpUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["enabled"]; ok {
		if v == nil {
			o.Enabled = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x bool
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Enabled = &x
		}
		o.IsSetEnabled = true
	}

	return nil
}

func (o *ConfigAuthSignUpUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigAuthSignUpUpdateInput) GetEnabled() *bool {
	if o == nil {
		o = &ConfigAuthSignUpUpdateInput{}
	}
	return o.Enabled
}

func (s *ConfigAuthSignUp) Update(v *ConfigAuthSignUpUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetEnabled || v.Enabled != nil {
		s.Enabled = v.Enabled
	}
}

type ConfigAuthSignUpInsertInput struct {
	Enabled *bool `json:"enabled,omitempty" toml:"enabled,omitempty"`
}

func (o *ConfigAuthSignUpInsertInput) GetEnabled() *bool {
	if o == nil {
		o = &ConfigAuthSignUpInsertInput{}
	}
	return o.Enabled
}

func (s *ConfigAuthSignUp) Insert(v *ConfigAuthSignUpInsertInput) {
	s.Enabled = v.Enabled
}

func (s *ConfigAuthSignUp) Clone() *ConfigAuthSignUp {
	if s == nil {
		return nil
	}

	v := &ConfigAuthSignUp{}
	v.Enabled = s.Enabled
	return v
}

type ConfigAuthSignUpComparisonExp struct {
	And     []*ConfigAuthSignUpComparisonExp `json:"_and,omitempty"`
	Not     *ConfigAuthSignUpComparisonExp   `json:"_not,omitempty"`
	Or      []*ConfigAuthSignUpComparisonExp `json:"_or,omitempty"`
	Enabled *ConfigBooleanComparisonExp      `json:"enabled,omitempty"`
}

func (exp *ConfigAuthSignUpComparisonExp) Matches(o *ConfigAuthSignUp) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthSignUp{}
	}
	if o.Enabled != nil && !exp.Enabled.Matches(*o.Enabled) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAuthTotp struct {
	Enabled *bool `json:"enabled" toml:"enabled"`

	Issuer *string `json:"issuer" toml:"issuer"`
}

func (o *ConfigAuthTotp) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Enabled != nil {
		m["enabled"] = o.Enabled
	}
	if o.Issuer != nil {
		m["issuer"] = o.Issuer
	}
	return json.Marshal(m)
}

func (o *ConfigAuthTotp) GetEnabled() *bool {
	if o == nil {
		o = &ConfigAuthTotp{}
	}
	return o.Enabled
}

func (o *ConfigAuthTotp) GetIssuer() *string {
	if o == nil {
		o = &ConfigAuthTotp{}
	}
	return o.Issuer
}

type ConfigAuthTotpUpdateInput struct {
	Enabled      *bool   `json:"enabled,omitempty" toml:"enabled,omitempty"`
	IsSetEnabled bool    `json:"-"`
	Issuer       *string `json:"issuer,omitempty" toml:"issuer,omitempty"`
	IsSetIssuer  bool    `json:"-"`
}

func (o *ConfigAuthTotpUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["enabled"]; ok {
		if v == nil {
			o.Enabled = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x bool
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Enabled = &x
		}
		o.IsSetEnabled = true
	}
	if v, ok := m["issuer"]; ok {
		if v == nil {
			o.Issuer = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Issuer = &x
		}
		o.IsSetIssuer = true
	}

	return nil
}

func (o *ConfigAuthTotpUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigAuthTotpUpdateInput) GetEnabled() *bool {
	if o == nil {
		o = &ConfigAuthTotpUpdateInput{}
	}
	return o.Enabled
}

func (o *ConfigAuthTotpUpdateInput) GetIssuer() *string {
	if o == nil {
		o = &ConfigAuthTotpUpdateInput{}
	}
	return o.Issuer
}

func (s *ConfigAuthTotp) Update(v *ConfigAuthTotpUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetEnabled || v.Enabled != nil {
		s.Enabled = v.Enabled
	}
	if v.IsSetIssuer || v.Issuer != nil {
		s.Issuer = v.Issuer
	}
}

type ConfigAuthTotpInsertInput struct {
	Enabled *bool   `json:"enabled,omitempty" toml:"enabled,omitempty"`
	Issuer  *string `json:"issuer,omitempty" toml:"issuer,omitempty"`
}

func (o *ConfigAuthTotpInsertInput) GetEnabled() *bool {
	if o == nil {
		o = &ConfigAuthTotpInsertInput{}
	}
	return o.Enabled
}

func (o *ConfigAuthTotpInsertInput) GetIssuer() *string {
	if o == nil {
		o = &ConfigAuthTotpInsertInput{}
	}
	return o.Issuer
}

func (s *ConfigAuthTotp) Insert(v *ConfigAuthTotpInsertInput) {
	s.Enabled = v.Enabled
	s.Issuer = v.Issuer
}

func (s *ConfigAuthTotp) Clone() *ConfigAuthTotp {
	if s == nil {
		return nil
	}

	v := &ConfigAuthTotp{}
	v.Enabled = s.Enabled
	v.Issuer = s.Issuer
	return v
}

type ConfigAuthTotpComparisonExp struct {
	And     []*ConfigAuthTotpComparisonExp `json:"_and,omitempty"`
	Not     *ConfigAuthTotpComparisonExp   `json:"_not,omitempty"`
	Or      []*ConfigAuthTotpComparisonExp `json:"_or,omitempty"`
	Enabled *ConfigBooleanComparisonExp    `json:"enabled,omitempty"`
	Issuer  *ConfigStringComparisonExp     `json:"issuer,omitempty"`
}

func (exp *ConfigAuthTotpComparisonExp) Matches(o *ConfigAuthTotp) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthTotp{}
	}
	if o.Enabled != nil && !exp.Enabled.Matches(*o.Enabled) {
		return false
	}
	if o.Issuer != nil && !exp.Issuer.Matches(*o.Issuer) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAuthUser struct {
	Roles *ConfigAuthUserRoles `json:"roles,omitempty" toml:"roles,omitempty"`

	Locale *ConfigAuthUserLocale `json:"locale,omitempty" toml:"locale,omitempty"`

	Gravatar *ConfigAuthUserGravatar `json:"gravatar,omitempty" toml:"gravatar,omitempty"`

	Email *ConfigAuthUserEmail `json:"email,omitempty" toml:"email,omitempty"`

	EmailDomains *ConfigAuthUserEmailDomains `json:"emailDomains,omitempty" toml:"emailDomains,omitempty"`
}

func (o *ConfigAuthUser) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Roles != nil {
		m["roles"] = o.Roles
	}
	if o.Locale != nil {
		m["locale"] = o.Locale
	}
	if o.Gravatar != nil {
		m["gravatar"] = o.Gravatar
	}
	if o.Email != nil {
		m["email"] = o.Email
	}
	if o.EmailDomains != nil {
		m["emailDomains"] = o.EmailDomains
	}
	return json.Marshal(m)
}

func (o *ConfigAuthUser) GetRoles() *ConfigAuthUserRoles {
	if o == nil {
		return nil
	}
	return o.Roles
}

func (o *ConfigAuthUser) GetLocale() *ConfigAuthUserLocale {
	if o == nil {
		return nil
	}
	return o.Locale
}

func (o *ConfigAuthUser) GetGravatar() *ConfigAuthUserGravatar {
	if o == nil {
		return nil
	}
	return o.Gravatar
}

func (o *ConfigAuthUser) GetEmail() *ConfigAuthUserEmail {
	if o == nil {
		return nil
	}
	return o.Email
}

func (o *ConfigAuthUser) GetEmailDomains() *ConfigAuthUserEmailDomains {
	if o == nil {
		return nil
	}
	return o.EmailDomains
}

type ConfigAuthUserUpdateInput struct {
	Roles             *ConfigAuthUserRolesUpdateInput        `json:"roles,omitempty" toml:"roles,omitempty"`
	IsSetRoles        bool                                   `json:"-"`
	Locale            *ConfigAuthUserLocaleUpdateInput       `json:"locale,omitempty" toml:"locale,omitempty"`
	IsSetLocale       bool                                   `json:"-"`
	Gravatar          *ConfigAuthUserGravatarUpdateInput     `json:"gravatar,omitempty" toml:"gravatar,omitempty"`
	IsSetGravatar     bool                                   `json:"-"`
	Email             *ConfigAuthUserEmailUpdateInput        `json:"email,omitempty" toml:"email,omitempty"`
	IsSetEmail        bool                                   `json:"-"`
	EmailDomains      *ConfigAuthUserEmailDomainsUpdateInput `json:"emailDomains,omitempty" toml:"emailDomains,omitempty"`
	IsSetEmailDomains bool                                   `json:"-"`
}

func (o *ConfigAuthUserUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if x, ok := m["roles"]; ok {
		if x != nil {
			t := &ConfigAuthUserRolesUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Roles = t
		}
		o.IsSetRoles = true
	}
	if x, ok := m["locale"]; ok {
		if x != nil {
			t := &ConfigAuthUserLocaleUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Locale = t
		}
		o.IsSetLocale = true
	}
	if x, ok := m["gravatar"]; ok {
		if x != nil {
			t := &ConfigAuthUserGravatarUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Gravatar = t
		}
		o.IsSetGravatar = true
	}
	if x, ok := m["email"]; ok {
		if x != nil {
			t := &ConfigAuthUserEmailUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Email = t
		}
		o.IsSetEmail = true
	}
	if x, ok := m["emailDomains"]; ok {
		if x != nil {
			t := &ConfigAuthUserEmailDomainsUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.EmailDomains = t
		}
		o.IsSetEmailDomains = true
	}

	return nil
}

func (o *ConfigAuthUserUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigAuthUserUpdateInput) GetRoles() *ConfigAuthUserRolesUpdateInput {
	if o == nil {
		return nil
	}
	return o.Roles
}

func (o *ConfigAuthUserUpdateInput) GetLocale() *ConfigAuthUserLocaleUpdateInput {
	if o == nil {
		return nil
	}
	return o.Locale
}

func (o *ConfigAuthUserUpdateInput) GetGravatar() *ConfigAuthUserGravatarUpdateInput {
	if o == nil {
		return nil
	}
	return o.Gravatar
}

func (o *ConfigAuthUserUpdateInput) GetEmail() *ConfigAuthUserEmailUpdateInput {
	if o == nil {
		return nil
	}
	return o.Email
}

func (o *ConfigAuthUserUpdateInput) GetEmailDomains() *ConfigAuthUserEmailDomainsUpdateInput {
	if o == nil {
		return nil
	}
	return o.EmailDomains
}

func (s *ConfigAuthUser) Update(v *ConfigAuthUserUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetRoles || v.Roles != nil {
		if v.Roles == nil {
			s.Roles = nil
		} else {
			if s.Roles == nil {
				s.Roles = &ConfigAuthUserRoles{}
			}
			s.Roles.Update(v.Roles)
		}
	}
	if v.IsSetLocale || v.Locale != nil {
		if v.Locale == nil {
			s.Locale = nil
		} else {
			if s.Locale == nil {
				s.Locale = &ConfigAuthUserLocale{}
			}
			s.Locale.Update(v.Locale)
		}
	}
	if v.IsSetGravatar || v.Gravatar != nil {
		if v.Gravatar == nil {
			s.Gravatar = nil
		} else {
			if s.Gravatar == nil {
				s.Gravatar = &ConfigAuthUserGravatar{}
			}
			s.Gravatar.Update(v.Gravatar)
		}
	}
	if v.IsSetEmail || v.Email != nil {
		if v.Email == nil {
			s.Email = nil
		} else {
			if s.Email == nil {
				s.Email = &ConfigAuthUserEmail{}
			}
			s.Email.Update(v.Email)
		}
	}
	if v.IsSetEmailDomains || v.EmailDomains != nil {
		if v.EmailDomains == nil {
			s.EmailDomains = nil
		} else {
			if s.EmailDomains == nil {
				s.EmailDomains = &ConfigAuthUserEmailDomains{}
			}
			s.EmailDomains.Update(v.EmailDomains)
		}
	}
}

type ConfigAuthUserInsertInput struct {
	Roles        *ConfigAuthUserRolesInsertInput        `json:"roles,omitempty" toml:"roles,omitempty"`
	Locale       *ConfigAuthUserLocaleInsertInput       `json:"locale,omitempty" toml:"locale,omitempty"`
	Gravatar     *ConfigAuthUserGravatarInsertInput     `json:"gravatar,omitempty" toml:"gravatar,omitempty"`
	Email        *ConfigAuthUserEmailInsertInput        `json:"email,omitempty" toml:"email,omitempty"`
	EmailDomains *ConfigAuthUserEmailDomainsInsertInput `json:"emailDomains,omitempty" toml:"emailDomains,omitempty"`
}

func (o *ConfigAuthUserInsertInput) GetRoles() *ConfigAuthUserRolesInsertInput {
	if o == nil {
		return nil
	}
	return o.Roles
}

func (o *ConfigAuthUserInsertInput) GetLocale() *ConfigAuthUserLocaleInsertInput {
	if o == nil {
		return nil
	}
	return o.Locale
}

func (o *ConfigAuthUserInsertInput) GetGravatar() *ConfigAuthUserGravatarInsertInput {
	if o == nil {
		return nil
	}
	return o.Gravatar
}

func (o *ConfigAuthUserInsertInput) GetEmail() *ConfigAuthUserEmailInsertInput {
	if o == nil {
		return nil
	}
	return o.Email
}

func (o *ConfigAuthUserInsertInput) GetEmailDomains() *ConfigAuthUserEmailDomainsInsertInput {
	if o == nil {
		return nil
	}
	return o.EmailDomains
}

func (s *ConfigAuthUser) Insert(v *ConfigAuthUserInsertInput) {
	if v.Roles != nil {
		if s.Roles == nil {
			s.Roles = &ConfigAuthUserRoles{}
		}
		s.Roles.Insert(v.Roles)
	}
	if v.Locale != nil {
		if s.Locale == nil {
			s.Locale = &ConfigAuthUserLocale{}
		}
		s.Locale.Insert(v.Locale)
	}
	if v.Gravatar != nil {
		if s.Gravatar == nil {
			s.Gravatar = &ConfigAuthUserGravatar{}
		}
		s.Gravatar.Insert(v.Gravatar)
	}
	if v.Email != nil {
		if s.Email == nil {
			s.Email = &ConfigAuthUserEmail{}
		}
		s.Email.Insert(v.Email)
	}
	if v.EmailDomains != nil {
		if s.EmailDomains == nil {
			s.EmailDomains = &ConfigAuthUserEmailDomains{}
		}
		s.EmailDomains.Insert(v.EmailDomains)
	}
}

func (s *ConfigAuthUser) Clone() *ConfigAuthUser {
	if s == nil {
		return nil
	}

	v := &ConfigAuthUser{}
	v.Roles = s.Roles.Clone()
	v.Locale = s.Locale.Clone()
	v.Gravatar = s.Gravatar.Clone()
	v.Email = s.Email.Clone()
	v.EmailDomains = s.EmailDomains.Clone()
	return v
}

type ConfigAuthUserComparisonExp struct {
	And          []*ConfigAuthUserComparisonExp           `json:"_and,omitempty"`
	Not          *ConfigAuthUserComparisonExp             `json:"_not,omitempty"`
	Or           []*ConfigAuthUserComparisonExp           `json:"_or,omitempty"`
	Roles        *ConfigAuthUserRolesComparisonExp        `json:"roles,omitempty"`
	Locale       *ConfigAuthUserLocaleComparisonExp       `json:"locale,omitempty"`
	Gravatar     *ConfigAuthUserGravatarComparisonExp     `json:"gravatar,omitempty"`
	Email        *ConfigAuthUserEmailComparisonExp        `json:"email,omitempty"`
	EmailDomains *ConfigAuthUserEmailDomainsComparisonExp `json:"emailDomains,omitempty"`
}

func (exp *ConfigAuthUserComparisonExp) Matches(o *ConfigAuthUser) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthUser{
			Roles:        &ConfigAuthUserRoles{},
			Locale:       &ConfigAuthUserLocale{},
			Gravatar:     &ConfigAuthUserGravatar{},
			Email:        &ConfigAuthUserEmail{},
			EmailDomains: &ConfigAuthUserEmailDomains{},
		}
	}
	if !exp.Roles.Matches(o.Roles) {
		return false
	}
	if !exp.Locale.Matches(o.Locale) {
		return false
	}
	if !exp.Gravatar.Matches(o.Gravatar) {
		return false
	}
	if !exp.Email.Matches(o.Email) {
		return false
	}
	if !exp.EmailDomains.Matches(o.EmailDomains) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAuthUserEmail struct {
	// AUTH_ACCESS_CONTROL_ALLOWED_EMAILS
	Allowed []string `json:"allowed,omitempty" toml:"allowed,omitempty"`
	// AUTH_ACCESS_CONTROL_BLOCKED_EMAILS
	Blocked []string `json:"blocked,omitempty" toml:"blocked,omitempty"`
}

func (o *ConfigAuthUserEmail) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Allowed != nil {
		m["allowed"] = o.Allowed
	}
	if o.Blocked != nil {
		m["blocked"] = o.Blocked
	}
	return json.Marshal(m)
}

func (o *ConfigAuthUserEmail) GetAllowed() []string {
	if o == nil {
		o = &ConfigAuthUserEmail{}
	}
	return o.Allowed
}

func (o *ConfigAuthUserEmail) GetBlocked() []string {
	if o == nil {
		o = &ConfigAuthUserEmail{}
	}
	return o.Blocked
}

type ConfigAuthUserEmailUpdateInput struct {
	Allowed      []string `json:"allowed,omitempty" toml:"allowed,omitempty"`
	IsSetAllowed bool     `json:"-"`
	Blocked      []string `json:"blocked,omitempty" toml:"blocked,omitempty"`
	IsSetBlocked bool     `json:"-"`
}

func (o *ConfigAuthUserEmailUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["allowed"]; ok {
		if v != nil {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var l []string
			if err := json.Unmarshal(b, &l); err != nil {
				return err
			}
			o.Allowed = l
		}
		o.IsSetAllowed = true
	}
	if v, ok := m["blocked"]; ok {
		if v != nil {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var l []string
			if err := json.Unmarshal(b, &l); err != nil {
				return err
			}
			o.Blocked = l
		}
		o.IsSetBlocked = true
	}

	return nil
}

func (o *ConfigAuthUserEmailUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigAuthUserEmailUpdateInput) GetAllowed() []string {
	if o == nil {
		o = &ConfigAuthUserEmailUpdateInput{}
	}
	return o.Allowed
}

func (o *ConfigAuthUserEmailUpdateInput) GetBlocked() []string {
	if o == nil {
		o = &ConfigAuthUserEmailUpdateInput{}
	}
	return o.Blocked
}

func (s *ConfigAuthUserEmail) Update(v *ConfigAuthUserEmailUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetAllowed || v.Allowed != nil {
		if v.Allowed == nil {
			s.Allowed = nil
		} else {
			s.Allowed = make([]string, len(v.Allowed))
			for i, e := range v.Allowed {
				s.Allowed[i] = e
			}
		}
	}
	if v.IsSetBlocked || v.Blocked != nil {
		if v.Blocked == nil {
			s.Blocked = nil
		} else {
			s.Blocked = make([]string, len(v.Blocked))
			for i, e := range v.Blocked {
				s.Blocked[i] = e
			}
		}
	}
}

type ConfigAuthUserEmailInsertInput struct {
	Allowed []string `json:"allowed,omitempty" toml:"allowed,omitempty"`
	Blocked []string `json:"blocked,omitempty" toml:"blocked,omitempty"`
}

func (o *ConfigAuthUserEmailInsertInput) GetAllowed() []string {
	if o == nil {
		o = &ConfigAuthUserEmailInsertInput{}
	}
	return o.Allowed
}

func (o *ConfigAuthUserEmailInsertInput) GetBlocked() []string {
	if o == nil {
		o = &ConfigAuthUserEmailInsertInput{}
	}
	return o.Blocked
}

func (s *ConfigAuthUserEmail) Insert(v *ConfigAuthUserEmailInsertInput) {
	if v.Allowed != nil {
		s.Allowed = make([]string, len(v.Allowed))
		for i, e := range v.Allowed {
			s.Allowed[i] = e
		}
	}
	if v.Blocked != nil {
		s.Blocked = make([]string, len(v.Blocked))
		for i, e := range v.Blocked {
			s.Blocked[i] = e
		}
	}
}

func (s *ConfigAuthUserEmail) Clone() *ConfigAuthUserEmail {
	if s == nil {
		return nil
	}

	v := &ConfigAuthUserEmail{}
	if s.Allowed != nil {
		v.Allowed = make([]string, len(s.Allowed))
		copy(v.Allowed, s.Allowed)
	}
	if s.Blocked != nil {
		v.Blocked = make([]string, len(s.Blocked))
		copy(v.Blocked, s.Blocked)
	}
	return v
}

type ConfigAuthUserEmailComparisonExp struct {
	And     []*ConfigAuthUserEmailComparisonExp `json:"_and,omitempty"`
	Not     *ConfigAuthUserEmailComparisonExp   `json:"_not,omitempty"`
	Or      []*ConfigAuthUserEmailComparisonExp `json:"_or,omitempty"`
	Allowed *ConfigEmailComparisonExp           `json:"allowed,omitempty"`
	Blocked *ConfigEmailComparisonExp           `json:"blocked,omitempty"`
}

func (exp *ConfigAuthUserEmailComparisonExp) Matches(o *ConfigAuthUserEmail) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthUserEmail{
			Allowed: []string{},
			Blocked: []string{},
		}
	}
	{
		found := false
		for _, o := range o.Allowed {
			if exp.Allowed.Matches(o) {
				found = true
				break
			}
		}
		if !found && exp.Allowed != nil {
			return false
		}
	}
	{
		found := false
		for _, o := range o.Blocked {
			if exp.Blocked.Matches(o) {
				found = true
				break
			}
		}
		if !found && exp.Blocked != nil {
			return false
		}
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAuthUserEmailDomains struct {
	// AUTH_ACCESS_CONTROL_ALLOWED_EMAIL_DOMAINS
	Allowed []string `json:"allowed,omitempty" toml:"allowed,omitempty"`
	// AUTH_ACCESS_CONTROL_BLOCKED_EMAIL_DOMAINS
	Blocked []string `json:"blocked,omitempty" toml:"blocked,omitempty"`
}

func (o *ConfigAuthUserEmailDomains) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Allowed != nil {
		m["allowed"] = o.Allowed
	}
	if o.Blocked != nil {
		m["blocked"] = o.Blocked
	}
	return json.Marshal(m)
}

func (o *ConfigAuthUserEmailDomains) GetAllowed() []string {
	if o == nil {
		o = &ConfigAuthUserEmailDomains{}
	}
	return o.Allowed
}

func (o *ConfigAuthUserEmailDomains) GetBlocked() []string {
	if o == nil {
		o = &ConfigAuthUserEmailDomains{}
	}
	return o.Blocked
}

type ConfigAuthUserEmailDomainsUpdateInput struct {
	Allowed      []string `json:"allowed,omitempty" toml:"allowed,omitempty"`
	IsSetAllowed bool     `json:"-"`
	Blocked      []string `json:"blocked,omitempty" toml:"blocked,omitempty"`
	IsSetBlocked bool     `json:"-"`
}

func (o *ConfigAuthUserEmailDomainsUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["allowed"]; ok {
		if v != nil {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var l []string
			if err := json.Unmarshal(b, &l); err != nil {
				return err
			}
			o.Allowed = l
		}
		o.IsSetAllowed = true
	}
	if v, ok := m["blocked"]; ok {
		if v != nil {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var l []string
			if err := json.Unmarshal(b, &l); err != nil {
				return err
			}
			o.Blocked = l
		}
		o.IsSetBlocked = true
	}

	return nil
}

func (o *ConfigAuthUserEmailDomainsUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigAuthUserEmailDomainsUpdateInput) GetAllowed() []string {
	if o == nil {
		o = &ConfigAuthUserEmailDomainsUpdateInput{}
	}
	return o.Allowed
}

func (o *ConfigAuthUserEmailDomainsUpdateInput) GetBlocked() []string {
	if o == nil {
		o = &ConfigAuthUserEmailDomainsUpdateInput{}
	}
	return o.Blocked
}

func (s *ConfigAuthUserEmailDomains) Update(v *ConfigAuthUserEmailDomainsUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetAllowed || v.Allowed != nil {
		if v.Allowed == nil {
			s.Allowed = nil
		} else {
			s.Allowed = make([]string, len(v.Allowed))
			for i, e := range v.Allowed {
				s.Allowed[i] = e
			}
		}
	}
	if v.IsSetBlocked || v.Blocked != nil {
		if v.Blocked == nil {
			s.Blocked = nil
		} else {
			s.Blocked = make([]string, len(v.Blocked))
			for i, e := range v.Blocked {
				s.Blocked[i] = e
			}
		}
	}
}

type ConfigAuthUserEmailDomainsInsertInput struct {
	Allowed []string `json:"allowed,omitempty" toml:"allowed,omitempty"`
	Blocked []string `json:"blocked,omitempty" toml:"blocked,omitempty"`
}

func (o *ConfigAuthUserEmailDomainsInsertInput) GetAllowed() []string {
	if o == nil {
		o = &ConfigAuthUserEmailDomainsInsertInput{}
	}
	return o.Allowed
}

func (o *ConfigAuthUserEmailDomainsInsertInput) GetBlocked() []string {
	if o == nil {
		o = &ConfigAuthUserEmailDomainsInsertInput{}
	}
	return o.Blocked
}

func (s *ConfigAuthUserEmailDomains) Insert(v *ConfigAuthUserEmailDomainsInsertInput) {
	if v.Allowed != nil {
		s.Allowed = make([]string, len(v.Allowed))
		for i, e := range v.Allowed {
			s.Allowed[i] = e
		}
	}
	if v.Blocked != nil {
		s.Blocked = make([]string, len(v.Blocked))
		for i, e := range v.Blocked {
			s.Blocked[i] = e
		}
	}
}

func (s *ConfigAuthUserEmailDomains) Clone() *ConfigAuthUserEmailDomains {
	if s == nil {
		return nil
	}

	v := &ConfigAuthUserEmailDomains{}
	if s.Allowed != nil {
		v.Allowed = make([]string, len(s.Allowed))
		copy(v.Allowed, s.Allowed)
	}
	if s.Blocked != nil {
		v.Blocked = make([]string, len(s.Blocked))
		copy(v.Blocked, s.Blocked)
	}
	return v
}

type ConfigAuthUserEmailDomainsComparisonExp struct {
	And     []*ConfigAuthUserEmailDomainsComparisonExp `json:"_and,omitempty"`
	Not     *ConfigAuthUserEmailDomainsComparisonExp   `json:"_not,omitempty"`
	Or      []*ConfigAuthUserEmailDomainsComparisonExp `json:"_or,omitempty"`
	Allowed *ConfigStringComparisonExp                 `json:"allowed,omitempty"`
	Blocked *ConfigStringComparisonExp                 `json:"blocked,omitempty"`
}

func (exp *ConfigAuthUserEmailDomainsComparisonExp) Matches(o *ConfigAuthUserEmailDomains) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthUserEmailDomains{
			Allowed: []string{},
			Blocked: []string{},
		}
	}
	{
		found := false
		for _, o := range o.Allowed {
			if exp.Allowed.Matches(o) {
				found = true
				break
			}
		}
		if !found && exp.Allowed != nil {
			return false
		}
	}
	{
		found := false
		for _, o := range o.Blocked {
			if exp.Blocked.Matches(o) {
				found = true
				break
			}
		}
		if !found && exp.Blocked != nil {
			return false
		}
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAuthUserGravatar struct {
	// AUTH_GRAVATAR_ENABLED
	Enabled *bool `json:"enabled" toml:"enabled"`

	Default *string `json:"default" toml:"default"`

	Rating *string `json:"rating" toml:"rating"`
}

func (o *ConfigAuthUserGravatar) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Enabled != nil {
		m["enabled"] = o.Enabled
	}
	if o.Default != nil {
		m["default"] = o.Default
	}
	if o.Rating != nil {
		m["rating"] = o.Rating
	}
	return json.Marshal(m)
}

func (o *ConfigAuthUserGravatar) GetEnabled() *bool {
	if o == nil {
		o = &ConfigAuthUserGravatar{}
	}
	return o.Enabled
}

func (o *ConfigAuthUserGravatar) GetDefault() *string {
	if o == nil {
		o = &ConfigAuthUserGravatar{}
	}
	return o.Default
}

func (o *ConfigAuthUserGravatar) GetRating() *string {
	if o == nil {
		o = &ConfigAuthUserGravatar{}
	}
	return o.Rating
}

type ConfigAuthUserGravatarUpdateInput struct {
	Enabled      *bool   `json:"enabled,omitempty" toml:"enabled,omitempty"`
	IsSetEnabled bool    `json:"-"`
	Default      *string `json:"default,omitempty" toml:"default,omitempty"`
	IsSetDefault bool    `json:"-"`
	Rating       *string `json:"rating,omitempty" toml:"rating,omitempty"`
	IsSetRating  bool    `json:"-"`
}

func (o *ConfigAuthUserGravatarUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["enabled"]; ok {
		if v == nil {
			o.Enabled = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x bool
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Enabled = &x
		}
		o.IsSetEnabled = true
	}
	if v, ok := m["default"]; ok {
		if v == nil {
			o.Default = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Default = &x
		}
		o.IsSetDefault = true
	}
	if v, ok := m["rating"]; ok {
		if v == nil {
			o.Rating = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Rating = &x
		}
		o.IsSetRating = true
	}

	return nil
}

func (o *ConfigAuthUserGravatarUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigAuthUserGravatarUpdateInput) GetEnabled() *bool {
	if o == nil {
		o = &ConfigAuthUserGravatarUpdateInput{}
	}
	return o.Enabled
}

func (o *ConfigAuthUserGravatarUpdateInput) GetDefault() *string {
	if o == nil {
		o = &ConfigAuthUserGravatarUpdateInput{}
	}
	return o.Default
}

func (o *ConfigAuthUserGravatarUpdateInput) GetRating() *string {
	if o == nil {
		o = &ConfigAuthUserGravatarUpdateInput{}
	}
	return o.Rating
}

func (s *ConfigAuthUserGravatar) Update(v *ConfigAuthUserGravatarUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetEnabled || v.Enabled != nil {
		s.Enabled = v.Enabled
	}
	if v.IsSetDefault || v.Default != nil {
		s.Default = v.Default
	}
	if v.IsSetRating || v.Rating != nil {
		s.Rating = v.Rating
	}
}

type ConfigAuthUserGravatarInsertInput struct {
	Enabled *bool   `json:"enabled,omitempty" toml:"enabled,omitempty"`
	Default *string `json:"default,omitempty" toml:"default,omitempty"`
	Rating  *string `json:"rating,omitempty" toml:"rating,omitempty"`
}

func (o *ConfigAuthUserGravatarInsertInput) GetEnabled() *bool {
	if o == nil {
		o = &ConfigAuthUserGravatarInsertInput{}
	}
	return o.Enabled
}

func (o *ConfigAuthUserGravatarInsertInput) GetDefault() *string {
	if o == nil {
		o = &ConfigAuthUserGravatarInsertInput{}
	}
	return o.Default
}

func (o *ConfigAuthUserGravatarInsertInput) GetRating() *string {
	if o == nil {
		o = &ConfigAuthUserGravatarInsertInput{}
	}
	return o.Rating
}

func (s *ConfigAuthUserGravatar) Insert(v *ConfigAuthUserGravatarInsertInput) {
	s.Enabled = v.Enabled
	s.Default = v.Default
	s.Rating = v.Rating
}

func (s *ConfigAuthUserGravatar) Clone() *ConfigAuthUserGravatar {
	if s == nil {
		return nil
	}

	v := &ConfigAuthUserGravatar{}
	v.Enabled = s.Enabled
	v.Default = s.Default
	v.Rating = s.Rating
	return v
}

type ConfigAuthUserGravatarComparisonExp struct {
	And     []*ConfigAuthUserGravatarComparisonExp `json:"_and,omitempty"`
	Not     *ConfigAuthUserGravatarComparisonExp   `json:"_not,omitempty"`
	Or      []*ConfigAuthUserGravatarComparisonExp `json:"_or,omitempty"`
	Enabled *ConfigBooleanComparisonExp            `json:"enabled,omitempty"`
	Default *ConfigStringComparisonExp             `json:"default,omitempty"`
	Rating  *ConfigStringComparisonExp             `json:"rating,omitempty"`
}

func (exp *ConfigAuthUserGravatarComparisonExp) Matches(o *ConfigAuthUserGravatar) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthUserGravatar{}
	}
	if o.Enabled != nil && !exp.Enabled.Matches(*o.Enabled) {
		return false
	}
	if o.Default != nil && !exp.Default.Matches(*o.Default) {
		return false
	}
	if o.Rating != nil && !exp.Rating.Matches(*o.Rating) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAuthUserLocale struct {
	// AUTH_LOCALE_DEFAULT
	Default *string `json:"default" toml:"default"`
	// AUTH_LOCALE_ALLOWED_LOCALES
	Allowed []string `json:"allowed,omitempty" toml:"allowed,omitempty"`
}

func (o *ConfigAuthUserLocale) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Default != nil {
		m["default"] = o.Default
	}
	if o.Allowed != nil {
		m["allowed"] = o.Allowed
	}
	return json.Marshal(m)
}

func (o *ConfigAuthUserLocale) GetDefault() *string {
	if o == nil {
		o = &ConfigAuthUserLocale{}
	}
	return o.Default
}

func (o *ConfigAuthUserLocale) GetAllowed() []string {
	if o == nil {
		o = &ConfigAuthUserLocale{}
	}
	return o.Allowed
}

type ConfigAuthUserLocaleUpdateInput struct {
	Default      *string  `json:"default,omitempty" toml:"default,omitempty"`
	IsSetDefault bool     `json:"-"`
	Allowed      []string `json:"allowed,omitempty" toml:"allowed,omitempty"`
	IsSetAllowed bool     `json:"-"`
}

func (o *ConfigAuthUserLocaleUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["default"]; ok {
		if v == nil {
			o.Default = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Default = &x
		}
		o.IsSetDefault = true
	}
	if v, ok := m["allowed"]; ok {
		if v != nil {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var l []string
			if err := json.Unmarshal(b, &l); err != nil {
				return err
			}
			o.Allowed = l
		}
		o.IsSetAllowed = true
	}

	return nil
}

func (o *ConfigAuthUserLocaleUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigAuthUserLocaleUpdateInput) GetDefault() *string {
	if o == nil {
		o = &ConfigAuthUserLocaleUpdateInput{}
	}
	return o.Default
}

func (o *ConfigAuthUserLocaleUpdateInput) GetAllowed() []string {
	if o == nil {
		o = &ConfigAuthUserLocaleUpdateInput{}
	}
	return o.Allowed
}

func (s *ConfigAuthUserLocale) Update(v *ConfigAuthUserLocaleUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetDefault || v.Default != nil {
		s.Default = v.Default
	}
	if v.IsSetAllowed || v.Allowed != nil {
		if v.Allowed == nil {
			s.Allowed = nil
		} else {
			s.Allowed = make([]string, len(v.Allowed))
			for i, e := range v.Allowed {
				s.Allowed[i] = e
			}
		}
	}
}

type ConfigAuthUserLocaleInsertInput struct {
	Default *string  `json:"default,omitempty" toml:"default,omitempty"`
	Allowed []string `json:"allowed,omitempty" toml:"allowed,omitempty"`
}

func (o *ConfigAuthUserLocaleInsertInput) GetDefault() *string {
	if o == nil {
		o = &ConfigAuthUserLocaleInsertInput{}
	}
	return o.Default
}

func (o *ConfigAuthUserLocaleInsertInput) GetAllowed() []string {
	if o == nil {
		o = &ConfigAuthUserLocaleInsertInput{}
	}
	return o.Allowed
}

func (s *ConfigAuthUserLocale) Insert(v *ConfigAuthUserLocaleInsertInput) {
	s.Default = v.Default
	if v.Allowed != nil {
		s.Allowed = make([]string, len(v.Allowed))
		for i, e := range v.Allowed {
			s.Allowed[i] = e
		}
	}
}

func (s *ConfigAuthUserLocale) Clone() *ConfigAuthUserLocale {
	if s == nil {
		return nil
	}

	v := &ConfigAuthUserLocale{}
	v.Default = s.Default
	if s.Allowed != nil {
		v.Allowed = make([]string, len(s.Allowed))
		copy(v.Allowed, s.Allowed)
	}
	return v
}

type ConfigAuthUserLocaleComparisonExp struct {
	And     []*ConfigAuthUserLocaleComparisonExp `json:"_and,omitempty"`
	Not     *ConfigAuthUserLocaleComparisonExp   `json:"_not,omitempty"`
	Or      []*ConfigAuthUserLocaleComparisonExp `json:"_or,omitempty"`
	Default *ConfigLocaleComparisonExp           `json:"default,omitempty"`
	Allowed *ConfigLocaleComparisonExp           `json:"allowed,omitempty"`
}

func (exp *ConfigAuthUserLocaleComparisonExp) Matches(o *ConfigAuthUserLocale) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthUserLocale{
			Allowed: []string{},
		}
	}
	if o.Default != nil && !exp.Default.Matches(*o.Default) {
		return false
	}
	{
		found := false
		for _, o := range o.Allowed {
			if exp.Allowed.Matches(o) {
				found = true
				break
			}
		}
		if !found && exp.Allowed != nil {
			return false
		}
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAuthUserRoles struct {
	// AUTH_USER_DEFAULT_ROLE
	Default *string `json:"default" toml:"default"`
	// AUTH_USER_DEFAULT_ALLOWED_ROLES
	Allowed []string `json:"allowed,omitempty" toml:"allowed,omitempty"`
}

func (o *ConfigAuthUserRoles) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Default != nil {
		m["default"] = o.Default
	}
	if o.Allowed != nil {
		m["allowed"] = o.Allowed
	}
	return json.Marshal(m)
}

func (o *ConfigAuthUserRoles) GetDefault() *string {
	if o == nil {
		o = &ConfigAuthUserRoles{}
	}
	return o.Default
}

func (o *ConfigAuthUserRoles) GetAllowed() []string {
	if o == nil {
		o = &ConfigAuthUserRoles{}
	}
	return o.Allowed
}

type ConfigAuthUserRolesUpdateInput struct {
	Default      *string  `json:"default,omitempty" toml:"default,omitempty"`
	IsSetDefault bool     `json:"-"`
	Allowed      []string `json:"allowed,omitempty" toml:"allowed,omitempty"`
	IsSetAllowed bool     `json:"-"`
}

func (o *ConfigAuthUserRolesUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["default"]; ok {
		if v == nil {
			o.Default = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Default = &x
		}
		o.IsSetDefault = true
	}
	if v, ok := m["allowed"]; ok {
		if v != nil {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var l []string
			if err := json.Unmarshal(b, &l); err != nil {
				return err
			}
			o.Allowed = l
		}
		o.IsSetAllowed = true
	}

	return nil
}

func (o *ConfigAuthUserRolesUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigAuthUserRolesUpdateInput) GetDefault() *string {
	if o == nil {
		o = &ConfigAuthUserRolesUpdateInput{}
	}
	return o.Default
}

func (o *ConfigAuthUserRolesUpdateInput) GetAllowed() []string {
	if o == nil {
		o = &ConfigAuthUserRolesUpdateInput{}
	}
	return o.Allowed
}

func (s *ConfigAuthUserRoles) Update(v *ConfigAuthUserRolesUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetDefault || v.Default != nil {
		s.Default = v.Default
	}
	if v.IsSetAllowed || v.Allowed != nil {
		if v.Allowed == nil {
			s.Allowed = nil
		} else {
			s.Allowed = make([]string, len(v.Allowed))
			for i, e := range v.Allowed {
				s.Allowed[i] = e
			}
		}
	}
}

type ConfigAuthUserRolesInsertInput struct {
	Default *string  `json:"default,omitempty" toml:"default,omitempty"`
	Allowed []string `json:"allowed,omitempty" toml:"allowed,omitempty"`
}

func (o *ConfigAuthUserRolesInsertInput) GetDefault() *string {
	if o == nil {
		o = &ConfigAuthUserRolesInsertInput{}
	}
	return o.Default
}

func (o *ConfigAuthUserRolesInsertInput) GetAllowed() []string {
	if o == nil {
		o = &ConfigAuthUserRolesInsertInput{}
	}
	return o.Allowed
}

func (s *ConfigAuthUserRoles) Insert(v *ConfigAuthUserRolesInsertInput) {
	s.Default = v.Default
	if v.Allowed != nil {
		s.Allowed = make([]string, len(v.Allowed))
		for i, e := range v.Allowed {
			s.Allowed[i] = e
		}
	}
}

func (s *ConfigAuthUserRoles) Clone() *ConfigAuthUserRoles {
	if s == nil {
		return nil
	}

	v := &ConfigAuthUserRoles{}
	v.Default = s.Default
	if s.Allowed != nil {
		v.Allowed = make([]string, len(s.Allowed))
		copy(v.Allowed, s.Allowed)
	}
	return v
}

type ConfigAuthUserRolesComparisonExp struct {
	And     []*ConfigAuthUserRolesComparisonExp `json:"_and,omitempty"`
	Not     *ConfigAuthUserRolesComparisonExp   `json:"_not,omitempty"`
	Or      []*ConfigAuthUserRolesComparisonExp `json:"_or,omitempty"`
	Default *ConfigUserRoleComparisonExp        `json:"default,omitempty"`
	Allowed *ConfigUserRoleComparisonExp        `json:"allowed,omitempty"`
}

func (exp *ConfigAuthUserRolesComparisonExp) Matches(o *ConfigAuthUserRoles) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthUserRoles{
			Allowed: []string{},
		}
	}
	if o.Default != nil && !exp.Default.Matches(*o.Default) {
		return false
	}
	{
		found := false
		for _, o := range o.Allowed {
			if exp.Allowed.Matches(o) {
				found = true
				break
			}
		}
		if !found && exp.Allowed != nil {
			return false
		}
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

// AUTH_JWT_CUSTOM_CLAIMS
type ConfigAuthsessionaccessTokenCustomClaims struct {
	Key string `json:"key" toml:"key"`

	Value string `json:"value" toml:"value"`
}

func (o *ConfigAuthsessionaccessTokenCustomClaims) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	m["key"] = o.Key
	m["value"] = o.Value
	return json.Marshal(m)
}

func (o *ConfigAuthsessionaccessTokenCustomClaims) GetKey() string {
	if o == nil {
		o = &ConfigAuthsessionaccessTokenCustomClaims{}
	}
	return o.Key
}

func (o *ConfigAuthsessionaccessTokenCustomClaims) GetValue() string {
	if o == nil {
		o = &ConfigAuthsessionaccessTokenCustomClaims{}
	}
	return o.Value
}

type ConfigAuthsessionaccessTokenCustomClaimsUpdateInput struct {
	Key        *string `json:"key,omitempty" toml:"key,omitempty"`
	IsSetKey   bool    `json:"-"`
	Value      *string `json:"value,omitempty" toml:"value,omitempty"`
	IsSetValue bool    `json:"-"`
}

func (o *ConfigAuthsessionaccessTokenCustomClaimsUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["key"]; ok {
		if v == nil {
			o.Key = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Key = &x
		}
		o.IsSetKey = true
	}
	if v, ok := m["value"]; ok {
		if v == nil {
			o.Value = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Value = &x
		}
		o.IsSetValue = true
	}

	return nil
}

func (o *ConfigAuthsessionaccessTokenCustomClaimsUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigAuthsessionaccessTokenCustomClaimsUpdateInput) GetKey() *string {
	if o == nil {
		o = &ConfigAuthsessionaccessTokenCustomClaimsUpdateInput{}
	}
	return o.Key
}

func (o *ConfigAuthsessionaccessTokenCustomClaimsUpdateInput) GetValue() *string {
	if o == nil {
		o = &ConfigAuthsessionaccessTokenCustomClaimsUpdateInput{}
	}
	return o.Value
}

func (s *ConfigAuthsessionaccessTokenCustomClaims) Update(v *ConfigAuthsessionaccessTokenCustomClaimsUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetKey || v.Key != nil {
		if v.Key != nil {
			s.Key = *v.Key
		}
	}
	if v.IsSetValue || v.Value != nil {
		if v.Value != nil {
			s.Value = *v.Value
		}
	}
}

type ConfigAuthsessionaccessTokenCustomClaimsInsertInput struct {
	Key   string `json:"key,omitempty" toml:"key,omitempty"`
	Value string `json:"value,omitempty" toml:"value,omitempty"`
}

func (o *ConfigAuthsessionaccessTokenCustomClaimsInsertInput) GetKey() string {
	if o == nil {
		o = &ConfigAuthsessionaccessTokenCustomClaimsInsertInput{}
	}
	return o.Key
}

func (o *ConfigAuthsessionaccessTokenCustomClaimsInsertInput) GetValue() string {
	if o == nil {
		o = &ConfigAuthsessionaccessTokenCustomClaimsInsertInput{}
	}
	return o.Value
}

func (s *ConfigAuthsessionaccessTokenCustomClaims) Insert(v *ConfigAuthsessionaccessTokenCustomClaimsInsertInput) {
	s.Key = v.Key
	s.Value = v.Value
}

func (s *ConfigAuthsessionaccessTokenCustomClaims) Clone() *ConfigAuthsessionaccessTokenCustomClaims {
	if s == nil {
		return nil
	}

	v := &ConfigAuthsessionaccessTokenCustomClaims{}
	v.Key = s.Key
	v.Value = s.Value
	return v
}

type ConfigAuthsessionaccessTokenCustomClaimsComparisonExp struct {
	And   []*ConfigAuthsessionaccessTokenCustomClaimsComparisonExp `json:"_and,omitempty"`
	Not   *ConfigAuthsessionaccessTokenCustomClaimsComparisonExp   `json:"_not,omitempty"`
	Or    []*ConfigAuthsessionaccessTokenCustomClaimsComparisonExp `json:"_or,omitempty"`
	Key   *ConfigStringComparisonExp                               `json:"key,omitempty"`
	Value *ConfigStringComparisonExp                               `json:"value,omitempty"`
}

func (exp *ConfigAuthsessionaccessTokenCustomClaimsComparisonExp) Matches(o *ConfigAuthsessionaccessTokenCustomClaims) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthsessionaccessTokenCustomClaims{}
	}
	if !exp.Key.Matches(o.Key) {
		return false
	}
	if !exp.Value.Matches(o.Value) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigClaimMap struct {
	Claim string `json:"claim" toml:"claim"`

	Value *string `json:"value" toml:"value"`

	Path *string `json:"path" toml:"path"`

	Default *string `json:"default" toml:"default"`
}

func (o *ConfigClaimMap) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	m["claim"] = o.Claim
	if o.Value != nil {
		m["value"] = o.Value
	}
	if o.Path != nil {
		m["path"] = o.Path
	}
	if o.Default != nil {
		m["default"] = o.Default
	}
	return json.Marshal(m)
}

func (o *ConfigClaimMap) GetClaim() string {
	if o == nil {
		o = &ConfigClaimMap{}
	}
	return o.Claim
}

func (o *ConfigClaimMap) GetValue() *string {
	if o == nil {
		o = &ConfigClaimMap{}
	}
	return o.Value
}

func (o *ConfigClaimMap) GetPath() *string {
	if o == nil {
		o = &ConfigClaimMap{}
	}
	return o.Path
}

func (o *ConfigClaimMap) GetDefault() *string {
	if o == nil {
		o = &ConfigClaimMap{}
	}
	return o.Default
}

type ConfigClaimMapUpdateInput struct {
	Claim        *string `json:"claim,omitempty" toml:"claim,omitempty"`
	IsSetClaim   bool    `json:"-"`
	Value        *string `json:"value,omitempty" toml:"value,omitempty"`
	IsSetValue   bool    `json:"-"`
	Path         *string `json:"path,omitempty" toml:"path,omitempty"`
	IsSetPath    bool    `json:"-"`
	Default      *string `json:"default,omitempty" toml:"default,omitempty"`
	IsSetDefault bool    `json:"-"`
}

func (o *ConfigClaimMapUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["claim"]; ok {
		if v == nil {
			o.Claim = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Claim = &x
		}
		o.IsSetClaim = true
	}
	if v, ok := m["value"]; ok {
		if v == nil {
			o.Value = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Value = &x
		}
		o.IsSetValue = true
	}
	if v, ok := m["path"]; ok {
		if v == nil {
			o.Path = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Path = &x
		}
		o.IsSetPath = true
	}
	if v, ok := m["default"]; ok {
		if v == nil {
			o.Default = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Default = &x
		}
		o.IsSetDefault = true
	}

	return nil
}

func (o *ConfigClaimMapUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigClaimMapUpdateInput) GetClaim() *string {
	if o == nil {
		o = &ConfigClaimMapUpdateInput{}
	}
	return o.Claim
}

func (o *ConfigClaimMapUpdateInput) GetValue() *string {
	if o == nil {
		o = &ConfigClaimMapUpdateInput{}
	}
	return o.Value
}

func (o *ConfigClaimMapUpdateInput) GetPath() *string {
	if o == nil {
		o = &ConfigClaimMapUpdateInput{}
	}
	return o.Path
}

func (o *ConfigClaimMapUpdateInput) GetDefault() *string {
	if o == nil {
		o = &ConfigClaimMapUpdateInput{}
	}
	return o.Default
}

func (s *ConfigClaimMap) Update(v *ConfigClaimMapUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetClaim || v.Claim != nil {
		if v.Claim != nil {
			s.Claim = *v.Claim
		}
	}
	if v.IsSetValue || v.Value != nil {
		s.Value = v.Value
	}
	if v.IsSetPath || v.Path != nil {
		s.Path = v.Path
	}
	if v.IsSetDefault || v.Default != nil {
		s.Default = v.Default
	}
}

type ConfigClaimMapInsertInput struct {
	Claim   string  `json:"claim,omitempty" toml:"claim,omitempty"`
	Value   *string `json:"value,omitempty" toml:"value,omitempty"`
	Path    *string `json:"path,omitempty" toml:"path,omitempty"`
	Default *string `json:"default,omitempty" toml:"default,omitempty"`
}

func (o *ConfigClaimMapInsertInput) GetClaim() string {
	if o == nil {
		o = &ConfigClaimMapInsertInput{}
	}
	return o.Claim
}

func (o *ConfigClaimMapInsertInput) GetValue() *string {
	if o == nil {
		o = &ConfigClaimMapInsertInput{}
	}
	return o.Value
}

func (o *ConfigClaimMapInsertInput) GetPath() *string {
	if o == nil {
		o = &ConfigClaimMapInsertInput{}
	}
	return o.Path
}

func (o *ConfigClaimMapInsertInput) GetDefault() *string {
	if o == nil {
		o = &ConfigClaimMapInsertInput{}
	}
	return o.Default
}

func (s *ConfigClaimMap) Insert(v *ConfigClaimMapInsertInput) {
	s.Claim = v.Claim
	s.Value = v.Value
	s.Path = v.Path
	s.Default = v.Default
}

func (s *ConfigClaimMap) Clone() *ConfigClaimMap {
	if s == nil {
		return nil
	}

	v := &ConfigClaimMap{}
	v.Claim = s.Claim
	v.Value = s.Value
	v.Path = s.Path
	v.Default = s.Default
	return v
}

type ConfigClaimMapComparisonExp struct {
	And     []*ConfigClaimMapComparisonExp `json:"_and,omitempty"`
	Not     *ConfigClaimMapComparisonExp   `json:"_not,omitempty"`
	Or      []*ConfigClaimMapComparisonExp `json:"_or,omitempty"`
	Claim   *ConfigStringComparisonExp     `json:"claim,omitempty"`
	Value   *ConfigStringComparisonExp     `json:"value,omitempty"`
	Path    *ConfigStringComparisonExp     `json:"path,omitempty"`
	Default *ConfigStringComparisonExp     `json:"default,omitempty"`
}

func (exp *ConfigClaimMapComparisonExp) Matches(o *ConfigClaimMap) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigClaimMap{}
	}
	if !exp.Claim.Matches(o.Claim) {
		return false
	}
	if o.Value != nil && !exp.Value.Matches(*o.Value) {
		return false
	}
	if o.Path != nil && !exp.Path.Matches(*o.Path) {
		return false
	}
	if o.Default != nil && !exp.Default.Matches(*o.Default) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

// main entrypoint to the configuration
type ConfigConfig struct {
	// Global configuration that applies to all services
	Global *ConfigGlobal `json:"global,omitempty" toml:"global,omitempty"`
	// Configuration for hasura
	Hasura *ConfigHasura `json:"hasura,omitempty" toml:"hasura,omitempty"`
	// Configuration for functions service
	Functions *ConfigFunctions `json:"functions,omitempty" toml:"functions,omitempty"`
	// Configuration for auth service
	Auth *ConfigAuth `json:"auth,omitempty" toml:"auth,omitempty"`
	// Configuration for postgres service
	Postgres *ConfigPostgres `json:"postgres,omitempty" toml:"postgres,omitempty"`
	// Configuration for third party providers like SMTP, SMS, etc.
	Provider *ConfigProvider `json:"provider,omitempty" toml:"provider,omitempty"`
	// Configuration for storage service
	Storage *ConfigStorage `json:"storage,omitempty" toml:"storage,omitempty"`
	// Configuration for observability service
	Observability *ConfigObservability `json:"observability,omitempty" toml:"observability,omitempty"`
}

func (o *ConfigConfig) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Global != nil {
		m["global"] = o.Global
	}
	if o.Hasura != nil {
		m["hasura"] = o.Hasura
	}
	if o.Functions != nil {
		m["functions"] = o.Functions
	}
	if o.Auth != nil {
		m["auth"] = o.Auth
	}
	if o.Postgres != nil {
		m["postgres"] = o.Postgres
	}
	if o.Provider != nil {
		m["provider"] = o.Provider
	}
	if o.Storage != nil {
		m["storage"] = o.Storage
	}
	if o.Observability != nil {
		m["observability"] = o.Observability
	}
	return json.Marshal(m)
}

func (o *ConfigConfig) GetGlobal() *ConfigGlobal {
	if o == nil {
		return nil
	}
	return o.Global
}

func (o *ConfigConfig) GetHasura() *ConfigHasura {
	if o == nil {
		return nil
	}
	return o.Hasura
}

func (o *ConfigConfig) GetFunctions() *ConfigFunctions {
	if o == nil {
		return nil
	}
	return o.Functions
}

func (o *ConfigConfig) GetAuth() *ConfigAuth {
	if o == nil {
		return nil
	}
	return o.Auth
}

func (o *ConfigConfig) GetPostgres() *ConfigPostgres {
	if o == nil {
		return nil
	}
	return o.Postgres
}

func (o *ConfigConfig) GetProvider() *ConfigProvider {
	if o == nil {
		return nil
	}
	return o.Provider
}

func (o *ConfigConfig) GetStorage() *ConfigStorage {
	if o == nil {
		return nil
	}
	return o.Storage
}

func (o *ConfigConfig) GetObservability() *ConfigObservability {
	if o == nil {
		return nil
	}
	return o.Observability
}

type ConfigConfigUpdateInput struct {
	Global             *ConfigGlobalUpdateInput        `json:"global,omitempty" toml:"global,omitempty"`
	IsSetGlobal        bool                            `json:"-"`
	Hasura             *ConfigHasuraUpdateInput        `json:"hasura,omitempty" toml:"hasura,omitempty"`
	IsSetHasura        bool                            `json:"-"`
	Functions          *ConfigFunctionsUpdateInput     `json:"functions,omitempty" toml:"functions,omitempty"`
	IsSetFunctions     bool                            `json:"-"`
	Auth               *ConfigAuthUpdateInput          `json:"auth,omitempty" toml:"auth,omitempty"`
	IsSetAuth          bool                            `json:"-"`
	Postgres           *ConfigPostgresUpdateInput      `json:"postgres,omitempty" toml:"postgres,omitempty"`
	IsSetPostgres      bool                            `json:"-"`
	Provider           *ConfigProviderUpdateInput      `json:"provider,omitempty" toml:"provider,omitempty"`
	IsSetProvider      bool                            `json:"-"`
	Storage            *ConfigStorageUpdateInput       `json:"storage,omitempty" toml:"storage,omitempty"`
	IsSetStorage       bool                            `json:"-"`
	Observability      *ConfigObservabilityUpdateInput `json:"observability,omitempty" toml:"observability,omitempty"`
	IsSetObservability bool                            `json:"-"`
}

func (o *ConfigConfigUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if x, ok := m["global"]; ok {
		if x != nil {
			t := &ConfigGlobalUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Global = t
		}
		o.IsSetGlobal = true
	}
	if x, ok := m["hasura"]; ok {
		if x != nil {
			t := &ConfigHasuraUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Hasura = t
		}
		o.IsSetHasura = true
	}
	if x, ok := m["functions"]; ok {
		if x != nil {
			t := &ConfigFunctionsUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Functions = t
		}
		o.IsSetFunctions = true
	}
	if x, ok := m["auth"]; ok {
		if x != nil {
			t := &ConfigAuthUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Auth = t
		}
		o.IsSetAuth = true
	}
	if x, ok := m["postgres"]; ok {
		if x != nil {
			t := &ConfigPostgresUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Postgres = t
		}
		o.IsSetPostgres = true
	}
	if x, ok := m["provider"]; ok {
		if x != nil {
			t := &ConfigProviderUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Provider = t
		}
		o.IsSetProvider = true
	}
	if x, ok := m["storage"]; ok {
		if x != nil {
			t := &ConfigStorageUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Storage = t
		}
		o.IsSetStorage = true
	}
	if x, ok := m["observability"]; ok {
		if x != nil {
			t := &ConfigObservabilityUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Observability = t
		}
		o.IsSetObservability = true
	}

	return nil
}

func (o *ConfigConfigUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigConfigUpdateInput) GetGlobal() *ConfigGlobalUpdateInput {
	if o == nil {
		return nil
	}
	return o.Global
}

func (o *ConfigConfigUpdateInput) GetHasura() *ConfigHasuraUpdateInput {
	if o == nil {
		return nil
	}
	return o.Hasura
}

func (o *ConfigConfigUpdateInput) GetFunctions() *ConfigFunctionsUpdateInput {
	if o == nil {
		return nil
	}
	return o.Functions
}

func (o *ConfigConfigUpdateInput) GetAuth() *ConfigAuthUpdateInput {
	if o == nil {
		return nil
	}
	return o.Auth
}

func (o *ConfigConfigUpdateInput) GetPostgres() *ConfigPostgresUpdateInput {
	if o == nil {
		return nil
	}
	return o.Postgres
}

func (o *ConfigConfigUpdateInput) GetProvider() *ConfigProviderUpdateInput {
	if o == nil {
		return nil
	}
	return o.Provider
}

func (o *ConfigConfigUpdateInput) GetStorage() *ConfigStorageUpdateInput {
	if o == nil {
		return nil
	}
	return o.Storage
}

func (o *ConfigConfigUpdateInput) GetObservability() *ConfigObservabilityUpdateInput {
	if o == nil {
		return nil
	}
	return o.Observability
}

func (s *ConfigConfig) Update(v *ConfigConfigUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetGlobal || v.Global != nil {
		if v.Global == nil {
			s.Global = nil
		} else {
			if s.Global == nil {
				s.Global = &ConfigGlobal{}
			}
			s.Global.Update(v.Global)
		}
	}
	if v.IsSetHasura || v.Hasura != nil {
		if v.Hasura == nil {
			s.Hasura = nil
		} else {
			if s.Hasura == nil {
				s.Hasura = &ConfigHasura{}
			}
			s.Hasura.Update(v.Hasura)
		}
	}
	if v.IsSetFunctions || v.Functions != nil {
		if v.Functions == nil {
			s.Functions = nil
		} else {
			if s.Functions == nil {
				s.Functions = &ConfigFunctions{}
			}
			s.Functions.Update(v.Functions)
		}
	}
	if v.IsSetAuth || v.Auth != nil {
		if v.Auth == nil {
			s.Auth = nil
		} else {
			if s.Auth == nil {
				s.Auth = &ConfigAuth{}
			}
			s.Auth.Update(v.Auth)
		}
	}
	if v.IsSetPostgres || v.Postgres != nil {
		if v.Postgres == nil {
			s.Postgres = nil
		} else {
			if s.Postgres == nil {
				s.Postgres = &ConfigPostgres{}
			}
			s.Postgres.Update(v.Postgres)
		}
	}
	if v.IsSetProvider || v.Provider != nil {
		if v.Provider == nil {
			s.Provider = nil
		} else {
			if s.Provider == nil {
				s.Provider = &ConfigProvider{}
			}
			s.Provider.Update(v.Provider)
		}
	}
	if v.IsSetStorage || v.Storage != nil {
		if v.Storage == nil {
			s.Storage = nil
		} else {
			if s.Storage == nil {
				s.Storage = &ConfigStorage{}
			}
			s.Storage.Update(v.Storage)
		}
	}
	if v.IsSetObservability || v.Observability != nil {
		if v.Observability == nil {
			s.Observability = nil
		} else {
			if s.Observability == nil {
				s.Observability = &ConfigObservability{}
			}
			s.Observability.Update(v.Observability)
		}
	}
}

type ConfigConfigInsertInput struct {
	Global        *ConfigGlobalInsertInput        `json:"global,omitempty" toml:"global,omitempty"`
	Hasura        *ConfigHasuraInsertInput        `json:"hasura,omitempty" toml:"hasura,omitempty"`
	Functions     *ConfigFunctionsInsertInput     `json:"functions,omitempty" toml:"functions,omitempty"`
	Auth          *ConfigAuthInsertInput          `json:"auth,omitempty" toml:"auth,omitempty"`
	Postgres      *ConfigPostgresInsertInput      `json:"postgres,omitempty" toml:"postgres,omitempty"`
	Provider      *ConfigProviderInsertInput      `json:"provider,omitempty" toml:"provider,omitempty"`
	Storage       *ConfigStorageInsertInput       `json:"storage,omitempty" toml:"storage,omitempty"`
	Observability *ConfigObservabilityInsertInput `json:"observability,omitempty" toml:"observability,omitempty"`
}

func (o *ConfigConfigInsertInput) GetGlobal() *ConfigGlobalInsertInput {
	if o == nil {
		return nil
	}
	return o.Global
}

func (o *ConfigConfigInsertInput) GetHasura() *ConfigHasuraInsertInput {
	if o == nil {
		return nil
	}
	return o.Hasura
}

func (o *ConfigConfigInsertInput) GetFunctions() *ConfigFunctionsInsertInput {
	if o == nil {
		return nil
	}
	return o.Functions
}

func (o *ConfigConfigInsertInput) GetAuth() *ConfigAuthInsertInput {
	if o == nil {
		return nil
	}
	return o.Auth
}

func (o *ConfigConfigInsertInput) GetPostgres() *ConfigPostgresInsertInput {
	if o == nil {
		return nil
	}
	return o.Postgres
}

func (o *ConfigConfigInsertInput) GetProvider() *ConfigProviderInsertInput {
	if o == nil {
		return nil
	}
	return o.Provider
}

func (o *ConfigConfigInsertInput) GetStorage() *ConfigStorageInsertInput {
	if o == nil {
		return nil
	}
	return o.Storage
}

func (o *ConfigConfigInsertInput) GetObservability() *ConfigObservabilityInsertInput {
	if o == nil {
		return nil
	}
	return o.Observability
}

func (s *ConfigConfig) Insert(v *ConfigConfigInsertInput) {
	if v.Global != nil {
		if s.Global == nil {
			s.Global = &ConfigGlobal{}
		}
		s.Global.Insert(v.Global)
	}
	if v.Hasura != nil {
		if s.Hasura == nil {
			s.Hasura = &ConfigHasura{}
		}
		s.Hasura.Insert(v.Hasura)
	}
	if v.Functions != nil {
		if s.Functions == nil {
			s.Functions = &ConfigFunctions{}
		}
		s.Functions.Insert(v.Functions)
	}
	if v.Auth != nil {
		if s.Auth == nil {
			s.Auth = &ConfigAuth{}
		}
		s.Auth.Insert(v.Auth)
	}
	if v.Postgres != nil {
		if s.Postgres == nil {
			s.Postgres = &ConfigPostgres{}
		}
		s.Postgres.Insert(v.Postgres)
	}
	if v.Provider != nil {
		if s.Provider == nil {
			s.Provider = &ConfigProvider{}
		}
		s.Provider.Insert(v.Provider)
	}
	if v.Storage != nil {
		if s.Storage == nil {
			s.Storage = &ConfigStorage{}
		}
		s.Storage.Insert(v.Storage)
	}
	if v.Observability != nil {
		if s.Observability == nil {
			s.Observability = &ConfigObservability{}
		}
		s.Observability.Insert(v.Observability)
	}
}

func (s *ConfigConfig) Clone() *ConfigConfig {
	if s == nil {
		return nil
	}

	v := &ConfigConfig{}
	v.Global = s.Global.Clone()
	v.Hasura = s.Hasura.Clone()
	v.Functions = s.Functions.Clone()
	v.Auth = s.Auth.Clone()
	v.Postgres = s.Postgres.Clone()
	v.Provider = s.Provider.Clone()
	v.Storage = s.Storage.Clone()
	v.Observability = s.Observability.Clone()
	return v
}

type ConfigConfigComparisonExp struct {
	And           []*ConfigConfigComparisonExp      `json:"_and,omitempty"`
	Not           *ConfigConfigComparisonExp        `json:"_not,omitempty"`
	Or            []*ConfigConfigComparisonExp      `json:"_or,omitempty"`
	Global        *ConfigGlobalComparisonExp        `json:"global,omitempty"`
	Hasura        *ConfigHasuraComparisonExp        `json:"hasura,omitempty"`
	Functions     *ConfigFunctionsComparisonExp     `json:"functions,omitempty"`
	Auth          *ConfigAuthComparisonExp          `json:"auth,omitempty"`
	Postgres      *ConfigPostgresComparisonExp      `json:"postgres,omitempty"`
	Provider      *ConfigProviderComparisonExp      `json:"provider,omitempty"`
	Storage       *ConfigStorageComparisonExp       `json:"storage,omitempty"`
	Observability *ConfigObservabilityComparisonExp `json:"observability,omitempty"`
}

func (exp *ConfigConfigComparisonExp) Matches(o *ConfigConfig) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigConfig{
			Global:        &ConfigGlobal{},
			Hasura:        &ConfigHasura{},
			Functions:     &ConfigFunctions{},
			Auth:          &ConfigAuth{},
			Postgres:      &ConfigPostgres{},
			Provider:      &ConfigProvider{},
			Storage:       &ConfigStorage{},
			Observability: &ConfigObservability{},
		}
	}
	if !exp.Global.Matches(o.Global) {
		return false
	}
	if !exp.Hasura.Matches(o.Hasura) {
		return false
	}
	if !exp.Functions.Matches(o.Functions) {
		return false
	}
	if !exp.Auth.Matches(o.Auth) {
		return false
	}
	if !exp.Postgres.Matches(o.Postgres) {
		return false
	}
	if !exp.Provider.Matches(o.Provider) {
		return false
	}
	if !exp.Storage.Matches(o.Storage) {
		return false
	}
	if !exp.Observability.Matches(o.Observability) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigEmailComparisonExp struct {
	Eq  *string  `json:"_eq,omitempty"`
	Neq *string  `json:"_neq,omitempty"`
	In  []string `json:"_in,omitempty"`
	Nin []string `json:"_nin,omitempty"`
}

func (exp *ConfigEmailComparisonExp) Matches(o string) bool {
	if exp == nil {
		return true
	}

	if exp.Eq != nil && *exp.Eq != o {
		return false
	}

	if exp.Neq != nil && *exp.Neq == o {
		return false
	}

	if exp.In != nil && !contains(exp.In, o) {
		return false
	}

	if exp.Nin != nil && contains(exp.Nin, o) {
		return false
	}

	return true
}

type ConfigEnvironmentVariable struct {
	Name string `json:"name" toml:"name"`
	// Value of the environment variable
	Value string `json:"value" toml:"value"`
}

func (o *ConfigEnvironmentVariable) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	m["name"] = o.Name
	m["value"] = o.Value
	return json.Marshal(m)
}

func (o *ConfigEnvironmentVariable) GetName() string {
	if o == nil {
		o = &ConfigEnvironmentVariable{}
	}
	return o.Name
}

func (o *ConfigEnvironmentVariable) GetValue() string {
	if o == nil {
		o = &ConfigEnvironmentVariable{}
	}
	return o.Value
}

type ConfigEnvironmentVariableUpdateInput struct {
	Name       *string `json:"name,omitempty" toml:"name,omitempty"`
	IsSetName  bool    `json:"-"`
	Value      *string `json:"value,omitempty" toml:"value,omitempty"`
	IsSetValue bool    `json:"-"`
}

func (o *ConfigEnvironmentVariableUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["name"]; ok {
		if v == nil {
			o.Name = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Name = &x
		}
		o.IsSetName = true
	}
	if v, ok := m["value"]; ok {
		if v == nil {
			o.Value = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Value = &x
		}
		o.IsSetValue = true
	}

	return nil
}

func (o *ConfigEnvironmentVariableUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigEnvironmentVariableUpdateInput) GetName() *string {
	if o == nil {
		o = &ConfigEnvironmentVariableUpdateInput{}
	}
	return o.Name
}

func (o *ConfigEnvironmentVariableUpdateInput) GetValue() *string {
	if o == nil {
		o = &ConfigEnvironmentVariableUpdateInput{}
	}
	return o.Value
}

func (s *ConfigEnvironmentVariable) Update(v *ConfigEnvironmentVariableUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetName || v.Name != nil {
		if v.Name != nil {
			s.Name = *v.Name
		}
	}
	if v.IsSetValue || v.Value != nil {
		if v.Value != nil {
			s.Value = *v.Value
		}
	}
}

type ConfigEnvironmentVariableInsertInput struct {
	Name  string `json:"name,omitempty" toml:"name,omitempty"`
	Value string `json:"value,omitempty" toml:"value,omitempty"`
}

func (o *ConfigEnvironmentVariableInsertInput) GetName() string {
	if o == nil {
		o = &ConfigEnvironmentVariableInsertInput{}
	}
	return o.Name
}

func (o *ConfigEnvironmentVariableInsertInput) GetValue() string {
	if o == nil {
		o = &ConfigEnvironmentVariableInsertInput{}
	}
	return o.Value
}

func (s *ConfigEnvironmentVariable) Insert(v *ConfigEnvironmentVariableInsertInput) {
	s.Name = v.Name
	s.Value = v.Value
}

func (s *ConfigEnvironmentVariable) Clone() *ConfigEnvironmentVariable {
	if s == nil {
		return nil
	}

	v := &ConfigEnvironmentVariable{}
	v.Name = s.Name
	v.Value = s.Value
	return v
}

type ConfigEnvironmentVariableComparisonExp struct {
	And   []*ConfigEnvironmentVariableComparisonExp `json:"_and,omitempty"`
	Not   *ConfigEnvironmentVariableComparisonExp   `json:"_not,omitempty"`
	Or    []*ConfigEnvironmentVariableComparisonExp `json:"_or,omitempty"`
	Name  *ConfigStringComparisonExp                `json:"name,omitempty"`
	Value *ConfigStringComparisonExp                `json:"value,omitempty"`
}

func (exp *ConfigEnvironmentVariableComparisonExp) Matches(o *ConfigEnvironmentVariable) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigEnvironmentVariable{}
	}
	if !exp.Name.Matches(o.Name) {
		return false
	}
	if !exp.Value.Matches(o.Value) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

// Configuration for functions service
type ConfigFunctions struct {
	Node *ConfigFunctionsNode `json:"node,omitempty" toml:"node,omitempty"`
}

func (o *ConfigFunctions) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Node != nil {
		m["node"] = o.Node
	}
	return json.Marshal(m)
}

func (o *ConfigFunctions) GetNode() *ConfigFunctionsNode {
	if o == nil {
		return nil
	}
	return o.Node
}

type ConfigFunctionsUpdateInput struct {
	Node      *ConfigFunctionsNodeUpdateInput `json:"node,omitempty" toml:"node,omitempty"`
	IsSetNode bool                            `json:"-"`
}

func (o *ConfigFunctionsUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if x, ok := m["node"]; ok {
		if x != nil {
			t := &ConfigFunctionsNodeUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Node = t
		}
		o.IsSetNode = true
	}

	return nil
}

func (o *ConfigFunctionsUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigFunctionsUpdateInput) GetNode() *ConfigFunctionsNodeUpdateInput {
	if o == nil {
		return nil
	}
	return o.Node
}

func (s *ConfigFunctions) Update(v *ConfigFunctionsUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetNode || v.Node != nil {
		if v.Node == nil {
			s.Node = nil
		} else {
			if s.Node == nil {
				s.Node = &ConfigFunctionsNode{}
			}
			s.Node.Update(v.Node)
		}
	}
}

type ConfigFunctionsInsertInput struct {
	Node *ConfigFunctionsNodeInsertInput `json:"node,omitempty" toml:"node,omitempty"`
}

func (o *ConfigFunctionsInsertInput) GetNode() *ConfigFunctionsNodeInsertInput {
	if o == nil {
		return nil
	}
	return o.Node
}

func (s *ConfigFunctions) Insert(v *ConfigFunctionsInsertInput) {
	if v.Node != nil {
		if s.Node == nil {
			s.Node = &ConfigFunctionsNode{}
		}
		s.Node.Insert(v.Node)
	}
}

func (s *ConfigFunctions) Clone() *ConfigFunctions {
	if s == nil {
		return nil
	}

	v := &ConfigFunctions{}
	v.Node = s.Node.Clone()
	return v
}

type ConfigFunctionsComparisonExp struct {
	And  []*ConfigFunctionsComparisonExp   `json:"_and,omitempty"`
	Not  *ConfigFunctionsComparisonExp     `json:"_not,omitempty"`
	Or   []*ConfigFunctionsComparisonExp   `json:"_or,omitempty"`
	Node *ConfigFunctionsNodeComparisonExp `json:"node,omitempty"`
}

func (exp *ConfigFunctionsComparisonExp) Matches(o *ConfigFunctions) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigFunctions{
			Node: &ConfigFunctionsNode{},
		}
	}
	if !exp.Node.Matches(o.Node) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigFunctionsNode struct {
	Version *int `json:"version" toml:"version"`
}

func (o *ConfigFunctionsNode) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Version != nil {
		m["version"] = o.Version
	}
	return json.Marshal(m)
}

func (o *ConfigFunctionsNode) GetVersion() *int {
	if o == nil {
		o = &ConfigFunctionsNode{}
	}
	return o.Version
}

type ConfigFunctionsNodeUpdateInput struct {
	Version      *int `json:"version,omitempty" toml:"version,omitempty"`
	IsSetVersion bool `json:"-"`
}

func (o *ConfigFunctionsNodeUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["version"]; ok {
		if v == nil {
			o.Version = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x int
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Version = &x
		}
		o.IsSetVersion = true
	}

	return nil
}

func (o *ConfigFunctionsNodeUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigFunctionsNodeUpdateInput) GetVersion() *int {
	if o == nil {
		o = &ConfigFunctionsNodeUpdateInput{}
	}
	return o.Version
}

func (s *ConfigFunctionsNode) Update(v *ConfigFunctionsNodeUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetVersion || v.Version != nil {
		s.Version = v.Version
	}
}

type ConfigFunctionsNodeInsertInput struct {
	Version *int `json:"version,omitempty" toml:"version,omitempty"`
}

func (o *ConfigFunctionsNodeInsertInput) GetVersion() *int {
	if o == nil {
		o = &ConfigFunctionsNodeInsertInput{}
	}
	return o.Version
}

func (s *ConfigFunctionsNode) Insert(v *ConfigFunctionsNodeInsertInput) {
	s.Version = v.Version
}

func (s *ConfigFunctionsNode) Clone() *ConfigFunctionsNode {
	if s == nil {
		return nil
	}

	v := &ConfigFunctionsNode{}
	v.Version = s.Version
	return v
}

type ConfigFunctionsNodeComparisonExp struct {
	And     []*ConfigFunctionsNodeComparisonExp `json:"_and,omitempty"`
	Not     *ConfigFunctionsNodeComparisonExp   `json:"_not,omitempty"`
	Or      []*ConfigFunctionsNodeComparisonExp `json:"_or,omitempty"`
	Version *ConfigIntComparisonExp             `json:"version,omitempty"`
}

func (exp *ConfigFunctionsNodeComparisonExp) Matches(o *ConfigFunctionsNode) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigFunctionsNode{}
	}
	if o.Version != nil && !exp.Version.Matches(*o.Version) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

// Global configuration that applies to all services
type ConfigGlobal struct {
	// User-defined environment variables that are spread over all services
	Environment []*ConfigEnvironmentVariable `json:"environment,omitempty" toml:"environment,omitempty"`
}

func (o *ConfigGlobal) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Environment != nil {
		m["environment"] = o.Environment
	}
	return json.Marshal(m)
}

func (o *ConfigGlobal) GetEnvironment() []*ConfigEnvironmentVariable {
	if o == nil {
		o = &ConfigGlobal{}
	}
	return o.Environment
}

type ConfigGlobalUpdateInput struct {
	Environment      []*ConfigEnvironmentVariableUpdateInput `json:"environment,omitempty" toml:"environment,omitempty"`
	IsSetEnvironment bool                                    `json:"-"`
}

func (o *ConfigGlobalUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["environment"]; ok {
		if v != nil {
			x, ok := v.([]interface{})
			if !ok {
				return fmt.Errorf("Environment must be []interface{}, got %T", v)
			}

			l := make([]*ConfigEnvironmentVariableUpdateInput, len(x))
			for i, vv := range x {
				t := &ConfigEnvironmentVariableUpdateInput{}
				if err := t.UnmarshalGQL(vv); err != nil {
					return err
				}
				l[i] = t
			}
			o.Environment = l
		}
		o.IsSetEnvironment = true
	}

	return nil
}

func (o *ConfigGlobalUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigGlobalUpdateInput) GetEnvironment() []*ConfigEnvironmentVariableUpdateInput {
	if o == nil {
		o = &ConfigGlobalUpdateInput{}
	}
	return o.Environment
}

func (s *ConfigGlobal) Update(v *ConfigGlobalUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetEnvironment || v.Environment != nil {
		if v.Environment == nil {
			s.Environment = nil
		} else {
			s.Environment = make([]*ConfigEnvironmentVariable, len(v.Environment))
			for i, e := range v.Environment {
				v := &ConfigEnvironmentVariable{}
				v.Update(e)
				s.Environment[i] = v
			}
		}
	}
}

type ConfigGlobalInsertInput struct {
	Environment []*ConfigEnvironmentVariableInsertInput `json:"environment,omitempty" toml:"environment,omitempty"`
}

func (o *ConfigGlobalInsertInput) GetEnvironment() []*ConfigEnvironmentVariableInsertInput {
	if o == nil {
		o = &ConfigGlobalInsertInput{}
	}
	return o.Environment
}

func (s *ConfigGlobal) Insert(v *ConfigGlobalInsertInput) {
	if v.Environment != nil {
		s.Environment = make([]*ConfigEnvironmentVariable, len(v.Environment))
		for i, e := range v.Environment {
			v := &ConfigEnvironmentVariable{}
			v.Insert(e)
			s.Environment[i] = v
		}
	}
}

func (s *ConfigGlobal) Clone() *ConfigGlobal {
	if s == nil {
		return nil
	}

	v := &ConfigGlobal{}
	if s.Environment != nil {
		v.Environment = make([]*ConfigEnvironmentVariable, len(s.Environment))
		for i, e := range s.Environment {
			v.Environment[i] = e.Clone()
		}
	}
	return v
}

type ConfigGlobalComparisonExp struct {
	And         []*ConfigGlobalComparisonExp            `json:"_and,omitempty"`
	Not         *ConfigGlobalComparisonExp              `json:"_not,omitempty"`
	Or          []*ConfigGlobalComparisonExp            `json:"_or,omitempty"`
	Environment *ConfigEnvironmentVariableComparisonExp `json:"environment,omitempty"`
}

func (exp *ConfigGlobalComparisonExp) Matches(o *ConfigGlobal) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigGlobal{
			Environment: []*ConfigEnvironmentVariable{},
		}
	}
	{
		found := false
		for _, o := range o.Environment {
			if exp.Environment.Matches(o) {
				found = true
				break
			}
		}
		if !found && exp.Environment != nil {
			return false
		}
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigGrafana struct {
	AdminPassword string `json:"adminPassword" toml:"adminPassword"`
}

func (o *ConfigGrafana) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	m["adminPassword"] = o.AdminPassword
	return json.Marshal(m)
}

func (o *ConfigGrafana) GetAdminPassword() string {
	if o == nil {
		o = &ConfigGrafana{}
	}
	return o.AdminPassword
}

type ConfigGrafanaUpdateInput struct {
	AdminPassword      *string `json:"adminPassword,omitempty" toml:"adminPassword,omitempty"`
	IsSetAdminPassword bool    `json:"-"`
}

func (o *ConfigGrafanaUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["adminPassword"]; ok {
		if v == nil {
			o.AdminPassword = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.AdminPassword = &x
		}
		o.IsSetAdminPassword = true
	}

	return nil
}

func (o *ConfigGrafanaUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigGrafanaUpdateInput) GetAdminPassword() *string {
	if o == nil {
		o = &ConfigGrafanaUpdateInput{}
	}
	return o.AdminPassword
}

func (s *ConfigGrafana) Update(v *ConfigGrafanaUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetAdminPassword || v.AdminPassword != nil {
		if v.AdminPassword != nil {
			s.AdminPassword = *v.AdminPassword
		}
	}
}

type ConfigGrafanaInsertInput struct {
	AdminPassword string `json:"adminPassword,omitempty" toml:"adminPassword,omitempty"`
}

func (o *ConfigGrafanaInsertInput) GetAdminPassword() string {
	if o == nil {
		o = &ConfigGrafanaInsertInput{}
	}
	return o.AdminPassword
}

func (s *ConfigGrafana) Insert(v *ConfigGrafanaInsertInput) {
	s.AdminPassword = v.AdminPassword
}

func (s *ConfigGrafana) Clone() *ConfigGrafana {
	if s == nil {
		return nil
	}

	v := &ConfigGrafana{}
	v.AdminPassword = s.AdminPassword
	return v
}

type ConfigGrafanaComparisonExp struct {
	And           []*ConfigGrafanaComparisonExp `json:"_and,omitempty"`
	Not           *ConfigGrafanaComparisonExp   `json:"_not,omitempty"`
	Or            []*ConfigGrafanaComparisonExp `json:"_or,omitempty"`
	AdminPassword *ConfigStringComparisonExp    `json:"adminPassword,omitempty"`
}

func (exp *ConfigGrafanaComparisonExp) Matches(o *ConfigGrafana) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigGrafana{}
	}
	if !exp.AdminPassword.Matches(o.AdminPassword) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

// Configuration for hasura service
type ConfigHasura struct {
	// Version of hasura, you can see available versions in the URL below:
	// https://hub.docker.com/r/hasura/graphql-engine/tags
	Version *string `json:"version" toml:"version"`
	// JWT Secrets configuration
	JwtSecrets []*ConfigJWTSecret `json:"jwtSecrets,omitempty" toml:"jwtSecrets,omitempty"`
	// Admin secret
	AdminSecret string `json:"adminSecret" toml:"adminSecret"`
	// Webhook secret
	WebhookSecret string `json:"webhookSecret" toml:"webhookSecret"`
	// Configuration for hasura services
	// Reference: https://hasura.io/docs/latest/deployment/graphql-engine-flags/reference/
	Settings *ConfigHasuraSettings `json:"settings,omitempty" toml:"settings,omitempty"`

	Logs *ConfigHasuraLogs `json:"logs,omitempty" toml:"logs,omitempty"`

	Events *ConfigHasuraEvents `json:"events,omitempty" toml:"events,omitempty"`
	// Resources for the service
	Resources *ConfigResources `json:"resources,omitempty" toml:"resources,omitempty"`
}

func (o *ConfigHasura) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Version != nil {
		m["version"] = o.Version
	}
	if o.JwtSecrets != nil {
		m["jwtSecrets"] = o.JwtSecrets
	}
	m["adminSecret"] = o.AdminSecret
	m["webhookSecret"] = o.WebhookSecret
	if o.Settings != nil {
		m["settings"] = o.Settings
	}
	if o.Logs != nil {
		m["logs"] = o.Logs
	}
	if o.Events != nil {
		m["events"] = o.Events
	}
	if o.Resources != nil {
		m["resources"] = o.Resources
	}
	return json.Marshal(m)
}

func (o *ConfigHasura) GetVersion() *string {
	if o == nil {
		o = &ConfigHasura{}
	}
	return o.Version
}

func (o *ConfigHasura) GetJwtSecrets() []*ConfigJWTSecret {
	if o == nil {
		o = &ConfigHasura{}
	}
	return o.JwtSecrets
}

func (o *ConfigHasura) GetAdminSecret() string {
	if o == nil {
		o = &ConfigHasura{}
	}
	return o.AdminSecret
}

func (o *ConfigHasura) GetWebhookSecret() string {
	if o == nil {
		o = &ConfigHasura{}
	}
	return o.WebhookSecret
}

func (o *ConfigHasura) GetSettings() *ConfigHasuraSettings {
	if o == nil {
		return nil
	}
	return o.Settings
}

func (o *ConfigHasura) GetLogs() *ConfigHasuraLogs {
	if o == nil {
		return nil
	}
	return o.Logs
}

func (o *ConfigHasura) GetEvents() *ConfigHasuraEvents {
	if o == nil {
		return nil
	}
	return o.Events
}

func (o *ConfigHasura) GetResources() *ConfigResources {
	if o == nil {
		return nil
	}
	return o.Resources
}

type ConfigHasuraUpdateInput struct {
	Version            *string                          `json:"version,omitempty" toml:"version,omitempty"`
	IsSetVersion       bool                             `json:"-"`
	JwtSecrets         []*ConfigJWTSecretUpdateInput    `json:"jwtSecrets,omitempty" toml:"jwtSecrets,omitempty"`
	IsSetJwtSecrets    bool                             `json:"-"`
	AdminSecret        *string                          `json:"adminSecret,omitempty" toml:"adminSecret,omitempty"`
	IsSetAdminSecret   bool                             `json:"-"`
	WebhookSecret      *string                          `json:"webhookSecret,omitempty" toml:"webhookSecret,omitempty"`
	IsSetWebhookSecret bool                             `json:"-"`
	Settings           *ConfigHasuraSettingsUpdateInput `json:"settings,omitempty" toml:"settings,omitempty"`
	IsSetSettings      bool                             `json:"-"`
	Logs               *ConfigHasuraLogsUpdateInput     `json:"logs,omitempty" toml:"logs,omitempty"`
	IsSetLogs          bool                             `json:"-"`
	Events             *ConfigHasuraEventsUpdateInput   `json:"events,omitempty" toml:"events,omitempty"`
	IsSetEvents        bool                             `json:"-"`
	Resources          *ConfigResourcesUpdateInput      `json:"resources,omitempty" toml:"resources,omitempty"`
	IsSetResources     bool                             `json:"-"`
}

func (o *ConfigHasuraUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["version"]; ok {
		if v == nil {
			o.Version = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Version = &x
		}
		o.IsSetVersion = true
	}
	if v, ok := m["jwtSecrets"]; ok {
		if v != nil {
			x, ok := v.([]interface{})
			if !ok {
				return fmt.Errorf("JwtSecrets must be []interface{}, got %T", v)
			}

			l := make([]*ConfigJWTSecretUpdateInput, len(x))
			for i, vv := range x {
				t := &ConfigJWTSecretUpdateInput{}
				if err := t.UnmarshalGQL(vv); err != nil {
					return err
				}
				l[i] = t
			}
			o.JwtSecrets = l
		}
		o.IsSetJwtSecrets = true
	}
	if v, ok := m["adminSecret"]; ok {
		if v == nil {
			o.AdminSecret = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.AdminSecret = &x
		}
		o.IsSetAdminSecret = true
	}
	if v, ok := m["webhookSecret"]; ok {
		if v == nil {
			o.WebhookSecret = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.WebhookSecret = &x
		}
		o.IsSetWebhookSecret = true
	}
	if x, ok := m["settings"]; ok {
		if x != nil {
			t := &ConfigHasuraSettingsUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Settings = t
		}
		o.IsSetSettings = true
	}
	if x, ok := m["logs"]; ok {
		if x != nil {
			t := &ConfigHasuraLogsUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Logs = t
		}
		o.IsSetLogs = true
	}
	if x, ok := m["events"]; ok {
		if x != nil {
			t := &ConfigHasuraEventsUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Events = t
		}
		o.IsSetEvents = true
	}
	if x, ok := m["resources"]; ok {
		if x != nil {
			t := &ConfigResourcesUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Resources = t
		}
		o.IsSetResources = true
	}

	return nil
}

func (o *ConfigHasuraUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigHasuraUpdateInput) GetVersion() *string {
	if o == nil {
		o = &ConfigHasuraUpdateInput{}
	}
	return o.Version
}

func (o *ConfigHasuraUpdateInput) GetJwtSecrets() []*ConfigJWTSecretUpdateInput {
	if o == nil {
		o = &ConfigHasuraUpdateInput{}
	}
	return o.JwtSecrets
}

func (o *ConfigHasuraUpdateInput) GetAdminSecret() *string {
	if o == nil {
		o = &ConfigHasuraUpdateInput{}
	}
	return o.AdminSecret
}

func (o *ConfigHasuraUpdateInput) GetWebhookSecret() *string {
	if o == nil {
		o = &ConfigHasuraUpdateInput{}
	}
	return o.WebhookSecret
}

func (o *ConfigHasuraUpdateInput) GetSettings() *ConfigHasuraSettingsUpdateInput {
	if o == nil {
		return nil
	}
	return o.Settings
}

func (o *ConfigHasuraUpdateInput) GetLogs() *ConfigHasuraLogsUpdateInput {
	if o == nil {
		return nil
	}
	return o.Logs
}

func (o *ConfigHasuraUpdateInput) GetEvents() *ConfigHasuraEventsUpdateInput {
	if o == nil {
		return nil
	}
	return o.Events
}

func (o *ConfigHasuraUpdateInput) GetResources() *ConfigResourcesUpdateInput {
	if o == nil {
		return nil
	}
	return o.Resources
}

func (s *ConfigHasura) Update(v *ConfigHasuraUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetVersion || v.Version != nil {
		s.Version = v.Version
	}
	if v.IsSetJwtSecrets || v.JwtSecrets != nil {
		if v.JwtSecrets == nil {
			s.JwtSecrets = nil
		} else {
			s.JwtSecrets = make([]*ConfigJWTSecret, len(v.JwtSecrets))
			for i, e := range v.JwtSecrets {
				v := &ConfigJWTSecret{}
				v.Update(e)
				s.JwtSecrets[i] = v
			}
		}
	}
	if v.IsSetAdminSecret || v.AdminSecret != nil {
		if v.AdminSecret != nil {
			s.AdminSecret = *v.AdminSecret
		}
	}
	if v.IsSetWebhookSecret || v.WebhookSecret != nil {
		if v.WebhookSecret != nil {
			s.WebhookSecret = *v.WebhookSecret
		}
	}
	if v.IsSetSettings || v.Settings != nil {
		if v.Settings == nil {
			s.Settings = nil
		} else {
			if s.Settings == nil {
				s.Settings = &ConfigHasuraSettings{}
			}
			s.Settings.Update(v.Settings)
		}
	}
	if v.IsSetLogs || v.Logs != nil {
		if v.Logs == nil {
			s.Logs = nil
		} else {
			if s.Logs == nil {
				s.Logs = &ConfigHasuraLogs{}
			}
			s.Logs.Update(v.Logs)
		}
	}
	if v.IsSetEvents || v.Events != nil {
		if v.Events == nil {
			s.Events = nil
		} else {
			if s.Events == nil {
				s.Events = &ConfigHasuraEvents{}
			}
			s.Events.Update(v.Events)
		}
	}
	if v.IsSetResources || v.Resources != nil {
		if v.Resources == nil {
			s.Resources = nil
		} else {
			if s.Resources == nil {
				s.Resources = &ConfigResources{}
			}
			s.Resources.Update(v.Resources)
		}
	}
}

type ConfigHasuraInsertInput struct {
	Version       *string                          `json:"version,omitempty" toml:"version,omitempty"`
	JwtSecrets    []*ConfigJWTSecretInsertInput    `json:"jwtSecrets,omitempty" toml:"jwtSecrets,omitempty"`
	AdminSecret   string                           `json:"adminSecret,omitempty" toml:"adminSecret,omitempty"`
	WebhookSecret string                           `json:"webhookSecret,omitempty" toml:"webhookSecret,omitempty"`
	Settings      *ConfigHasuraSettingsInsertInput `json:"settings,omitempty" toml:"settings,omitempty"`
	Logs          *ConfigHasuraLogsInsertInput     `json:"logs,omitempty" toml:"logs,omitempty"`
	Events        *ConfigHasuraEventsInsertInput   `json:"events,omitempty" toml:"events,omitempty"`
	Resources     *ConfigResourcesInsertInput      `json:"resources,omitempty" toml:"resources,omitempty"`
}

func (o *ConfigHasuraInsertInput) GetVersion() *string {
	if o == nil {
		o = &ConfigHasuraInsertInput{}
	}
	return o.Version
}

func (o *ConfigHasuraInsertInput) GetJwtSecrets() []*ConfigJWTSecretInsertInput {
	if o == nil {
		o = &ConfigHasuraInsertInput{}
	}
	return o.JwtSecrets
}

func (o *ConfigHasuraInsertInput) GetAdminSecret() string {
	if o == nil {
		o = &ConfigHasuraInsertInput{}
	}
	return o.AdminSecret
}

func (o *ConfigHasuraInsertInput) GetWebhookSecret() string {
	if o == nil {
		o = &ConfigHasuraInsertInput{}
	}
	return o.WebhookSecret
}

func (o *ConfigHasuraInsertInput) GetSettings() *ConfigHasuraSettingsInsertInput {
	if o == nil {
		return nil
	}
	return o.Settings
}

func (o *ConfigHasuraInsertInput) GetLogs() *ConfigHasuraLogsInsertInput {
	if o == nil {
		return nil
	}
	return o.Logs
}

func (o *ConfigHasuraInsertInput) GetEvents() *ConfigHasuraEventsInsertInput {
	if o == nil {
		return nil
	}
	return o.Events
}

func (o *ConfigHasuraInsertInput) GetResources() *ConfigResourcesInsertInput {
	if o == nil {
		return nil
	}
	return o.Resources
}

func (s *ConfigHasura) Insert(v *ConfigHasuraInsertInput) {
	s.Version = v.Version
	if v.JwtSecrets != nil {
		s.JwtSecrets = make([]*ConfigJWTSecret, len(v.JwtSecrets))
		for i, e := range v.JwtSecrets {
			v := &ConfigJWTSecret{}
			v.Insert(e)
			s.JwtSecrets[i] = v
		}
	}
	s.AdminSecret = v.AdminSecret
	s.WebhookSecret = v.WebhookSecret
	if v.Settings != nil {
		if s.Settings == nil {
			s.Settings = &ConfigHasuraSettings{}
		}
		s.Settings.Insert(v.Settings)
	}
	if v.Logs != nil {
		if s.Logs == nil {
			s.Logs = &ConfigHasuraLogs{}
		}
		s.Logs.Insert(v.Logs)
	}
	if v.Events != nil {
		if s.Events == nil {
			s.Events = &ConfigHasuraEvents{}
		}
		s.Events.Insert(v.Events)
	}
	if v.Resources != nil {
		if s.Resources == nil {
			s.Resources = &ConfigResources{}
		}
		s.Resources.Insert(v.Resources)
	}
}

func (s *ConfigHasura) Clone() *ConfigHasura {
	if s == nil {
		return nil
	}

	v := &ConfigHasura{}
	v.Version = s.Version
	if s.JwtSecrets != nil {
		v.JwtSecrets = make([]*ConfigJWTSecret, len(s.JwtSecrets))
		for i, e := range s.JwtSecrets {
			v.JwtSecrets[i] = e.Clone()
		}
	}
	v.AdminSecret = s.AdminSecret
	v.WebhookSecret = s.WebhookSecret
	v.Settings = s.Settings.Clone()
	v.Logs = s.Logs.Clone()
	v.Events = s.Events.Clone()
	v.Resources = s.Resources.Clone()
	return v
}

type ConfigHasuraComparisonExp struct {
	And           []*ConfigHasuraComparisonExp       `json:"_and,omitempty"`
	Not           *ConfigHasuraComparisonExp         `json:"_not,omitempty"`
	Or            []*ConfigHasuraComparisonExp       `json:"_or,omitempty"`
	Version       *ConfigStringComparisonExp         `json:"version,omitempty"`
	JwtSecrets    *ConfigJWTSecretComparisonExp      `json:"jwtSecrets,omitempty"`
	AdminSecret   *ConfigStringComparisonExp         `json:"adminSecret,omitempty"`
	WebhookSecret *ConfigStringComparisonExp         `json:"webhookSecret,omitempty"`
	Settings      *ConfigHasuraSettingsComparisonExp `json:"settings,omitempty"`
	Logs          *ConfigHasuraLogsComparisonExp     `json:"logs,omitempty"`
	Events        *ConfigHasuraEventsComparisonExp   `json:"events,omitempty"`
	Resources     *ConfigResourcesComparisonExp      `json:"resources,omitempty"`
}

func (exp *ConfigHasuraComparisonExp) Matches(o *ConfigHasura) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigHasura{
			JwtSecrets: []*ConfigJWTSecret{},
			Settings:   &ConfigHasuraSettings{},
			Logs:       &ConfigHasuraLogs{},
			Events:     &ConfigHasuraEvents{},
			Resources:  &ConfigResources{},
		}
	}
	if o.Version != nil && !exp.Version.Matches(*o.Version) {
		return false
	}
	{
		found := false
		for _, o := range o.JwtSecrets {
			if exp.JwtSecrets.Matches(o) {
				found = true
				break
			}
		}
		if !found && exp.JwtSecrets != nil {
			return false
		}
	}
	if !exp.AdminSecret.Matches(o.AdminSecret) {
		return false
	}
	if !exp.WebhookSecret.Matches(o.WebhookSecret) {
		return false
	}
	if !exp.Settings.Matches(o.Settings) {
		return false
	}
	if !exp.Logs.Matches(o.Logs) {
		return false
	}
	if !exp.Events.Matches(o.Events) {
		return false
	}
	if !exp.Resources.Matches(o.Resources) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigHasuraAPIsComparisonExp struct {
	Eq  *string  `json:"_eq,omitempty"`
	Neq *string  `json:"_neq,omitempty"`
	In  []string `json:"_in,omitempty"`
	Nin []string `json:"_nin,omitempty"`
}

func (exp *ConfigHasuraAPIsComparisonExp) Matches(o string) bool {
	if exp == nil {
		return true
	}

	if exp.Eq != nil && *exp.Eq != o {
		return false
	}

	if exp.Neq != nil && *exp.Neq == o {
		return false
	}

	if exp.In != nil && !contains(exp.In, o) {
		return false
	}

	if exp.Nin != nil && contains(exp.Nin, o) {
		return false
	}

	return true
}

type ConfigHasuraEvents struct {
	// HASURA_GRAPHQL_EVENTS_HTTP_POOL_SIZE
	HttpPoolSize *uint32 `json:"httpPoolSize" toml:"httpPoolSize"`
}

func (o *ConfigHasuraEvents) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.HttpPoolSize != nil {
		m["httpPoolSize"] = o.HttpPoolSize
	}
	return json.Marshal(m)
}

func (o *ConfigHasuraEvents) GetHttpPoolSize() *uint32 {
	if o == nil {
		o = &ConfigHasuraEvents{}
	}
	return o.HttpPoolSize
}

type ConfigHasuraEventsUpdateInput struct {
	HttpPoolSize      *uint32 `json:"httpPoolSize,omitempty" toml:"httpPoolSize,omitempty"`
	IsSetHttpPoolSize bool    `json:"-"`
}

func (o *ConfigHasuraEventsUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["httpPoolSize"]; ok {
		if v == nil {
			o.HttpPoolSize = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x uint32
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.HttpPoolSize = &x
		}
		o.IsSetHttpPoolSize = true
	}

	return nil
}

func (o *ConfigHasuraEventsUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigHasuraEventsUpdateInput) GetHttpPoolSize() *uint32 {
	if o == nil {
		o = &ConfigHasuraEventsUpdateInput{}
	}
	return o.HttpPoolSize
}

func (s *ConfigHasuraEvents) Update(v *ConfigHasuraEventsUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetHttpPoolSize || v.HttpPoolSize != nil {
		s.HttpPoolSize = v.HttpPoolSize
	}
}

type ConfigHasuraEventsInsertInput struct {
	HttpPoolSize *uint32 `json:"httpPoolSize,omitempty" toml:"httpPoolSize,omitempty"`
}

func (o *ConfigHasuraEventsInsertInput) GetHttpPoolSize() *uint32 {
	if o == nil {
		o = &ConfigHasuraEventsInsertInput{}
	}
	return o.HttpPoolSize
}

func (s *ConfigHasuraEvents) Insert(v *ConfigHasuraEventsInsertInput) {
	s.HttpPoolSize = v.HttpPoolSize
}

func (s *ConfigHasuraEvents) Clone() *ConfigHasuraEvents {
	if s == nil {
		return nil
	}

	v := &ConfigHasuraEvents{}
	v.HttpPoolSize = s.HttpPoolSize
	return v
}

type ConfigHasuraEventsComparisonExp struct {
	And          []*ConfigHasuraEventsComparisonExp `json:"_and,omitempty"`
	Not          *ConfigHasuraEventsComparisonExp   `json:"_not,omitempty"`
	Or           []*ConfigHasuraEventsComparisonExp `json:"_or,omitempty"`
	HttpPoolSize *ConfigUint32ComparisonExp         `json:"httpPoolSize,omitempty"`
}

func (exp *ConfigHasuraEventsComparisonExp) Matches(o *ConfigHasuraEvents) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigHasuraEvents{}
	}
	if o.HttpPoolSize != nil && !exp.HttpPoolSize.Matches(*o.HttpPoolSize) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigHasuraLogs struct {
	Level *string `json:"level" toml:"level"`
}

func (o *ConfigHasuraLogs) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Level != nil {
		m["level"] = o.Level
	}
	return json.Marshal(m)
}

func (o *ConfigHasuraLogs) GetLevel() *string {
	if o == nil {
		o = &ConfigHasuraLogs{}
	}
	return o.Level
}

type ConfigHasuraLogsUpdateInput struct {
	Level      *string `json:"level,omitempty" toml:"level,omitempty"`
	IsSetLevel bool    `json:"-"`
}

func (o *ConfigHasuraLogsUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["level"]; ok {
		if v == nil {
			o.Level = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Level = &x
		}
		o.IsSetLevel = true
	}

	return nil
}

func (o *ConfigHasuraLogsUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigHasuraLogsUpdateInput) GetLevel() *string {
	if o == nil {
		o = &ConfigHasuraLogsUpdateInput{}
	}
	return o.Level
}

func (s *ConfigHasuraLogs) Update(v *ConfigHasuraLogsUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetLevel || v.Level != nil {
		s.Level = v.Level
	}
}

type ConfigHasuraLogsInsertInput struct {
	Level *string `json:"level,omitempty" toml:"level,omitempty"`
}

func (o *ConfigHasuraLogsInsertInput) GetLevel() *string {
	if o == nil {
		o = &ConfigHasuraLogsInsertInput{}
	}
	return o.Level
}

func (s *ConfigHasuraLogs) Insert(v *ConfigHasuraLogsInsertInput) {
	s.Level = v.Level
}

func (s *ConfigHasuraLogs) Clone() *ConfigHasuraLogs {
	if s == nil {
		return nil
	}

	v := &ConfigHasuraLogs{}
	v.Level = s.Level
	return v
}

type ConfigHasuraLogsComparisonExp struct {
	And   []*ConfigHasuraLogsComparisonExp `json:"_and,omitempty"`
	Not   *ConfigHasuraLogsComparisonExp   `json:"_not,omitempty"`
	Or    []*ConfigHasuraLogsComparisonExp `json:"_or,omitempty"`
	Level *ConfigStringComparisonExp       `json:"level,omitempty"`
}

func (exp *ConfigHasuraLogsComparisonExp) Matches(o *ConfigHasuraLogs) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigHasuraLogs{}
	}
	if o.Level != nil && !exp.Level.Matches(*o.Level) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

// Configuration for hasura services
// Reference: https://hasura.io/docs/latest/deployment/graphql-engine-flags/reference/
type ConfigHasuraSettings struct {
	// HASURA_GRAPHQL_CORS_DOMAIN
	CorsDomain []string `json:"corsDomain,omitempty" toml:"corsDomain,omitempty"`
	// HASURA_GRAPHQL_DEV_MODE
	DevMode *bool `json:"devMode" toml:"devMode"`
	// HASURA_GRAPHQL_ENABLE_ALLOWLIST
	EnableAllowList *bool `json:"enableAllowList" toml:"enableAllowList"`
	// HASURA_GRAPHQL_ENABLE_CONSOLE
	EnableConsole *bool `json:"enableConsole" toml:"enableConsole"`
	// HASURA_GRAPHQL_ENABLE_REMOTE_SCHEMA_PERMISSIONS
	EnableRemoteSchemaPermissions *bool `json:"enableRemoteSchemaPermissions" toml:"enableRemoteSchemaPermissions"`
	// HASURA_GRAPHQL_ENABLED_APIS
	EnabledAPIs []string `json:"enabledAPIs,omitempty" toml:"enabledAPIs,omitempty"`
}

func (o *ConfigHasuraSettings) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.CorsDomain != nil {
		m["corsDomain"] = o.CorsDomain
	}
	if o.DevMode != nil {
		m["devMode"] = o.DevMode
	}
	if o.EnableAllowList != nil {
		m["enableAllowList"] = o.EnableAllowList
	}
	if o.EnableConsole != nil {
		m["enableConsole"] = o.EnableConsole
	}
	if o.EnableRemoteSchemaPermissions != nil {
		m["enableRemoteSchemaPermissions"] = o.EnableRemoteSchemaPermissions
	}
	if o.EnabledAPIs != nil {
		m["enabledAPIs"] = o.EnabledAPIs
	}
	return json.Marshal(m)
}

func (o *ConfigHasuraSettings) GetCorsDomain() []string {
	if o == nil {
		o = &ConfigHasuraSettings{}
	}
	return o.CorsDomain
}

func (o *ConfigHasuraSettings) GetDevMode() *bool {
	if o == nil {
		o = &ConfigHasuraSettings{}
	}
	return o.DevMode
}

func (o *ConfigHasuraSettings) GetEnableAllowList() *bool {
	if o == nil {
		o = &ConfigHasuraSettings{}
	}
	return o.EnableAllowList
}

func (o *ConfigHasuraSettings) GetEnableConsole() *bool {
	if o == nil {
		o = &ConfigHasuraSettings{}
	}
	return o.EnableConsole
}

func (o *ConfigHasuraSettings) GetEnableRemoteSchemaPermissions() *bool {
	if o == nil {
		o = &ConfigHasuraSettings{}
	}
	return o.EnableRemoteSchemaPermissions
}

func (o *ConfigHasuraSettings) GetEnabledAPIs() []string {
	if o == nil {
		o = &ConfigHasuraSettings{}
	}
	return o.EnabledAPIs
}

type ConfigHasuraSettingsUpdateInput struct {
	CorsDomain                         []string `json:"corsDomain,omitempty" toml:"corsDomain,omitempty"`
	IsSetCorsDomain                    bool     `json:"-"`
	DevMode                            *bool    `json:"devMode,omitempty" toml:"devMode,omitempty"`
	IsSetDevMode                       bool     `json:"-"`
	EnableAllowList                    *bool    `json:"enableAllowList,omitempty" toml:"enableAllowList,omitempty"`
	IsSetEnableAllowList               bool     `json:"-"`
	EnableConsole                      *bool    `json:"enableConsole,omitempty" toml:"enableConsole,omitempty"`
	IsSetEnableConsole                 bool     `json:"-"`
	EnableRemoteSchemaPermissions      *bool    `json:"enableRemoteSchemaPermissions,omitempty" toml:"enableRemoteSchemaPermissions,omitempty"`
	IsSetEnableRemoteSchemaPermissions bool     `json:"-"`
	EnabledAPIs                        []string `json:"enabledAPIs,omitempty" toml:"enabledAPIs,omitempty"`
	IsSetEnabledAPIs                   bool     `json:"-"`
}

func (o *ConfigHasuraSettingsUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["corsDomain"]; ok {
		if v != nil {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var l []string
			if err := json.Unmarshal(b, &l); err != nil {
				return err
			}
			o.CorsDomain = l
		}
		o.IsSetCorsDomain = true
	}
	if v, ok := m["devMode"]; ok {
		if v == nil {
			o.DevMode = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x bool
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.DevMode = &x
		}
		o.IsSetDevMode = true
	}
	if v, ok := m["enableAllowList"]; ok {
		if v == nil {
			o.EnableAllowList = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x bool
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.EnableAllowList = &x
		}
		o.IsSetEnableAllowList = true
	}
	if v, ok := m["enableConsole"]; ok {
		if v == nil {
			o.EnableConsole = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x bool
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.EnableConsole = &x
		}
		o.IsSetEnableConsole = true
	}
	if v, ok := m["enableRemoteSchemaPermissions"]; ok {
		if v == nil {
			o.EnableRemoteSchemaPermissions = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x bool
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.EnableRemoteSchemaPermissions = &x
		}
		o.IsSetEnableRemoteSchemaPermissions = true
	}
	if v, ok := m["enabledAPIs"]; ok {
		if v != nil {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var l []string
			if err := json.Unmarshal(b, &l); err != nil {
				return err
			}
			o.EnabledAPIs = l
		}
		o.IsSetEnabledAPIs = true
	}

	return nil
}

func (o *ConfigHasuraSettingsUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigHasuraSettingsUpdateInput) GetCorsDomain() []string {
	if o == nil {
		o = &ConfigHasuraSettingsUpdateInput{}
	}
	return o.CorsDomain
}

func (o *ConfigHasuraSettingsUpdateInput) GetDevMode() *bool {
	if o == nil {
		o = &ConfigHasuraSettingsUpdateInput{}
	}
	return o.DevMode
}

func (o *ConfigHasuraSettingsUpdateInput) GetEnableAllowList() *bool {
	if o == nil {
		o = &ConfigHasuraSettingsUpdateInput{}
	}
	return o.EnableAllowList
}

func (o *ConfigHasuraSettingsUpdateInput) GetEnableConsole() *bool {
	if o == nil {
		o = &ConfigHasuraSettingsUpdateInput{}
	}
	return o.EnableConsole
}

func (o *ConfigHasuraSettingsUpdateInput) GetEnableRemoteSchemaPermissions() *bool {
	if o == nil {
		o = &ConfigHasuraSettingsUpdateInput{}
	}
	return o.EnableRemoteSchemaPermissions
}

func (o *ConfigHasuraSettingsUpdateInput) GetEnabledAPIs() []string {
	if o == nil {
		o = &ConfigHasuraSettingsUpdateInput{}
	}
	return o.EnabledAPIs
}

func (s *ConfigHasuraSettings) Update(v *ConfigHasuraSettingsUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetCorsDomain || v.CorsDomain != nil {
		if v.CorsDomain == nil {
			s.CorsDomain = nil
		} else {
			s.CorsDomain = make([]string, len(v.CorsDomain))
			for i, e := range v.CorsDomain {
				s.CorsDomain[i] = e
			}
		}
	}
	if v.IsSetDevMode || v.DevMode != nil {
		s.DevMode = v.DevMode
	}
	if v.IsSetEnableAllowList || v.EnableAllowList != nil {
		s.EnableAllowList = v.EnableAllowList
	}
	if v.IsSetEnableConsole || v.EnableConsole != nil {
		s.EnableConsole = v.EnableConsole
	}
	if v.IsSetEnableRemoteSchemaPermissions || v.EnableRemoteSchemaPermissions != nil {
		s.EnableRemoteSchemaPermissions = v.EnableRemoteSchemaPermissions
	}
	if v.IsSetEnabledAPIs || v.EnabledAPIs != nil {
		if v.EnabledAPIs == nil {
			s.EnabledAPIs = nil
		} else {
			s.EnabledAPIs = make([]string, len(v.EnabledAPIs))
			for i, e := range v.EnabledAPIs {
				s.EnabledAPIs[i] = e
			}
		}
	}
}

type ConfigHasuraSettingsInsertInput struct {
	CorsDomain                    []string `json:"corsDomain,omitempty" toml:"corsDomain,omitempty"`
	DevMode                       *bool    `json:"devMode,omitempty" toml:"devMode,omitempty"`
	EnableAllowList               *bool    `json:"enableAllowList,omitempty" toml:"enableAllowList,omitempty"`
	EnableConsole                 *bool    `json:"enableConsole,omitempty" toml:"enableConsole,omitempty"`
	EnableRemoteSchemaPermissions *bool    `json:"enableRemoteSchemaPermissions,omitempty" toml:"enableRemoteSchemaPermissions,omitempty"`
	EnabledAPIs                   []string `json:"enabledAPIs,omitempty" toml:"enabledAPIs,omitempty"`
}

func (o *ConfigHasuraSettingsInsertInput) GetCorsDomain() []string {
	if o == nil {
		o = &ConfigHasuraSettingsInsertInput{}
	}
	return o.CorsDomain
}

func (o *ConfigHasuraSettingsInsertInput) GetDevMode() *bool {
	if o == nil {
		o = &ConfigHasuraSettingsInsertInput{}
	}
	return o.DevMode
}

func (o *ConfigHasuraSettingsInsertInput) GetEnableAllowList() *bool {
	if o == nil {
		o = &ConfigHasuraSettingsInsertInput{}
	}
	return o.EnableAllowList
}

func (o *ConfigHasuraSettingsInsertInput) GetEnableConsole() *bool {
	if o == nil {
		o = &ConfigHasuraSettingsInsertInput{}
	}
	return o.EnableConsole
}

func (o *ConfigHasuraSettingsInsertInput) GetEnableRemoteSchemaPermissions() *bool {
	if o == nil {
		o = &ConfigHasuraSettingsInsertInput{}
	}
	return o.EnableRemoteSchemaPermissions
}

func (o *ConfigHasuraSettingsInsertInput) GetEnabledAPIs() []string {
	if o == nil {
		o = &ConfigHasuraSettingsInsertInput{}
	}
	return o.EnabledAPIs
}

func (s *ConfigHasuraSettings) Insert(v *ConfigHasuraSettingsInsertInput) {
	if v.CorsDomain != nil {
		s.CorsDomain = make([]string, len(v.CorsDomain))
		for i, e := range v.CorsDomain {
			s.CorsDomain[i] = e
		}
	}
	s.DevMode = v.DevMode
	s.EnableAllowList = v.EnableAllowList
	s.EnableConsole = v.EnableConsole
	s.EnableRemoteSchemaPermissions = v.EnableRemoteSchemaPermissions
	if v.EnabledAPIs != nil {
		s.EnabledAPIs = make([]string, len(v.EnabledAPIs))
		for i, e := range v.EnabledAPIs {
			s.EnabledAPIs[i] = e
		}
	}
}

func (s *ConfigHasuraSettings) Clone() *ConfigHasuraSettings {
	if s == nil {
		return nil
	}

	v := &ConfigHasuraSettings{}
	if s.CorsDomain != nil {
		v.CorsDomain = make([]string, len(s.CorsDomain))
		copy(v.CorsDomain, s.CorsDomain)
	}
	v.DevMode = s.DevMode
	v.EnableAllowList = s.EnableAllowList
	v.EnableConsole = s.EnableConsole
	v.EnableRemoteSchemaPermissions = s.EnableRemoteSchemaPermissions
	if s.EnabledAPIs != nil {
		v.EnabledAPIs = make([]string, len(s.EnabledAPIs))
		copy(v.EnabledAPIs, s.EnabledAPIs)
	}
	return v
}

type ConfigHasuraSettingsComparisonExp struct {
	And                           []*ConfigHasuraSettingsComparisonExp `json:"_and,omitempty"`
	Not                           *ConfigHasuraSettingsComparisonExp   `json:"_not,omitempty"`
	Or                            []*ConfigHasuraSettingsComparisonExp `json:"_or,omitempty"`
	CorsDomain                    *ConfigUrlComparisonExp              `json:"corsDomain,omitempty"`
	DevMode                       *ConfigBooleanComparisonExp          `json:"devMode,omitempty"`
	EnableAllowList               *ConfigBooleanComparisonExp          `json:"enableAllowList,omitempty"`
	EnableConsole                 *ConfigBooleanComparisonExp          `json:"enableConsole,omitempty"`
	EnableRemoteSchemaPermissions *ConfigBooleanComparisonExp          `json:"enableRemoteSchemaPermissions,omitempty"`
	EnabledAPIs                   *ConfigHasuraAPIsComparisonExp       `json:"enabledAPIs,omitempty"`
}

func (exp *ConfigHasuraSettingsComparisonExp) Matches(o *ConfigHasuraSettings) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigHasuraSettings{
			CorsDomain:  []string{},
			EnabledAPIs: []string{},
		}
	}
	{
		found := false
		for _, o := range o.CorsDomain {
			if exp.CorsDomain.Matches(o) {
				found = true
				break
			}
		}
		if !found && exp.CorsDomain != nil {
			return false
		}
	}
	if o.DevMode != nil && !exp.DevMode.Matches(*o.DevMode) {
		return false
	}
	if o.EnableAllowList != nil && !exp.EnableAllowList.Matches(*o.EnableAllowList) {
		return false
	}
	if o.EnableConsole != nil && !exp.EnableConsole.Matches(*o.EnableConsole) {
		return false
	}
	if o.EnableRemoteSchemaPermissions != nil && !exp.EnableRemoteSchemaPermissions.Matches(*o.EnableRemoteSchemaPermissions) {
		return false
	}
	{
		found := false
		for _, o := range o.EnabledAPIs {
			if exp.EnabledAPIs.Matches(o) {
				found = true
				break
			}
		}
		if !found && exp.EnabledAPIs != nil {
			return false
		}
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

// See https://hasura.io/docs/latest/auth/authentication/jwt/
type ConfigJWTSecret struct {
	Type *string `json:"type" toml:"type"`

	Key *string `json:"key" toml:"key"`

	JwkUrl *string `json:"jwk_url" toml:"jwk_url"`

	ClaimsFormat *string `json:"claims_format" toml:"claims_format"`

	Audience *string `json:"audience" toml:"audience"`

	Issuer *string `json:"issuer" toml:"issuer"`

	AllowedSkew *uint32 `json:"allowed_skew" toml:"allowed_skew"`

	Header *string `json:"header" toml:"header"`

	ClaimsMap []*ConfigClaimMap `json:"claims_map,omitempty" toml:"claims_map,omitempty"`

	ClaimsNamespace *string `json:"claims_namespace" toml:"claims_namespace"`

	ClaimsNamespacePath *string `json:"claims_namespace_path" toml:"claims_namespace_path"`
}

func (o *ConfigJWTSecret) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Type != nil {
		m["type"] = o.Type
	}
	if o.Key != nil {
		m["key"] = o.Key
	}
	if o.JwkUrl != nil {
		m["jwk_url"] = o.JwkUrl
	}
	if o.ClaimsFormat != nil {
		m["claims_format"] = o.ClaimsFormat
	}
	if o.Audience != nil {
		m["audience"] = o.Audience
	}
	if o.Issuer != nil {
		m["issuer"] = o.Issuer
	}
	if o.AllowedSkew != nil {
		m["allowed_skew"] = o.AllowedSkew
	}
	if o.Header != nil {
		m["header"] = o.Header
	}
	if o.ClaimsMap != nil {
		m["claims_map"] = o.ClaimsMap
	}
	if o.ClaimsNamespace != nil {
		m["claims_namespace"] = o.ClaimsNamespace
	}
	if o.ClaimsNamespacePath != nil {
		m["claims_namespace_path"] = o.ClaimsNamespacePath
	}
	return json.Marshal(m)
}

func (o *ConfigJWTSecret) GetType() *string {
	if o == nil {
		o = &ConfigJWTSecret{}
	}
	return o.Type
}

func (o *ConfigJWTSecret) GetKey() *string {
	if o == nil {
		o = &ConfigJWTSecret{}
	}
	return o.Key
}

func (o *ConfigJWTSecret) GetJwkUrl() *string {
	if o == nil {
		o = &ConfigJWTSecret{}
	}
	return o.JwkUrl
}

func (o *ConfigJWTSecret) GetClaimsFormat() *string {
	if o == nil {
		o = &ConfigJWTSecret{}
	}
	return o.ClaimsFormat
}

func (o *ConfigJWTSecret) GetAudience() *string {
	if o == nil {
		o = &ConfigJWTSecret{}
	}
	return o.Audience
}

func (o *ConfigJWTSecret) GetIssuer() *string {
	if o == nil {
		o = &ConfigJWTSecret{}
	}
	return o.Issuer
}

func (o *ConfigJWTSecret) GetAllowedSkew() *uint32 {
	if o == nil {
		o = &ConfigJWTSecret{}
	}
	return o.AllowedSkew
}

func (o *ConfigJWTSecret) GetHeader() *string {
	if o == nil {
		o = &ConfigJWTSecret{}
	}
	return o.Header
}

func (o *ConfigJWTSecret) GetClaimsMap() []*ConfigClaimMap {
	if o == nil {
		o = &ConfigJWTSecret{}
	}
	return o.ClaimsMap
}

func (o *ConfigJWTSecret) GetClaimsNamespace() *string {
	if o == nil {
		o = &ConfigJWTSecret{}
	}
	return o.ClaimsNamespace
}

func (o *ConfigJWTSecret) GetClaimsNamespacePath() *string {
	if o == nil {
		o = &ConfigJWTSecret{}
	}
	return o.ClaimsNamespacePath
}

type ConfigJWTSecretUpdateInput struct {
	Type                     *string                      `json:"type,omitempty" toml:"type,omitempty"`
	IsSetType                bool                         `json:"-"`
	Key                      *string                      `json:"key,omitempty" toml:"key,omitempty"`
	IsSetKey                 bool                         `json:"-"`
	JwkUrl                   *string                      `json:"jwk_url,omitempty" toml:"jwk_url,omitempty"`
	IsSetJwkUrl              bool                         `json:"-"`
	ClaimsFormat             *string                      `json:"claims_format,omitempty" toml:"claims_format,omitempty"`
	IsSetClaimsFormat        bool                         `json:"-"`
	Audience                 *string                      `json:"audience,omitempty" toml:"audience,omitempty"`
	IsSetAudience            bool                         `json:"-"`
	Issuer                   *string                      `json:"issuer,omitempty" toml:"issuer,omitempty"`
	IsSetIssuer              bool                         `json:"-"`
	AllowedSkew              *uint32                      `json:"allowed_skew,omitempty" toml:"allowed_skew,omitempty"`
	IsSetAllowedSkew         bool                         `json:"-"`
	Header                   *string                      `json:"header,omitempty" toml:"header,omitempty"`
	IsSetHeader              bool                         `json:"-"`
	ClaimsMap                []*ConfigClaimMapUpdateInput `json:"claims_map,omitempty" toml:"claims_map,omitempty"`
	IsSetClaimsMap           bool                         `json:"-"`
	ClaimsNamespace          *string                      `json:"claims_namespace,omitempty" toml:"claims_namespace,omitempty"`
	IsSetClaimsNamespace     bool                         `json:"-"`
	ClaimsNamespacePath      *string                      `json:"claims_namespace_path,omitempty" toml:"claims_namespace_path,omitempty"`
	IsSetClaimsNamespacePath bool                         `json:"-"`
}

func (o *ConfigJWTSecretUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["type"]; ok {
		if v == nil {
			o.Type = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Type = &x
		}
		o.IsSetType = true
	}
	if v, ok := m["key"]; ok {
		if v == nil {
			o.Key = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Key = &x
		}
		o.IsSetKey = true
	}
	if v, ok := m["jwk_url"]; ok {
		if v == nil {
			o.JwkUrl = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.JwkUrl = &x
		}
		o.IsSetJwkUrl = true
	}
	if v, ok := m["claims_format"]; ok {
		if v == nil {
			o.ClaimsFormat = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.ClaimsFormat = &x
		}
		o.IsSetClaimsFormat = true
	}
	if v, ok := m["audience"]; ok {
		if v == nil {
			o.Audience = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Audience = &x
		}
		o.IsSetAudience = true
	}
	if v, ok := m["issuer"]; ok {
		if v == nil {
			o.Issuer = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Issuer = &x
		}
		o.IsSetIssuer = true
	}
	if v, ok := m["allowed_skew"]; ok {
		if v == nil {
			o.AllowedSkew = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x uint32
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.AllowedSkew = &x
		}
		o.IsSetAllowedSkew = true
	}
	if v, ok := m["header"]; ok {
		if v == nil {
			o.Header = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Header = &x
		}
		o.IsSetHeader = true
	}
	if v, ok := m["claims_map"]; ok {
		if v != nil {
			x, ok := v.([]interface{})
			if !ok {
				return fmt.Errorf("ClaimsMap must be []interface{}, got %T", v)
			}

			l := make([]*ConfigClaimMapUpdateInput, len(x))
			for i, vv := range x {
				t := &ConfigClaimMapUpdateInput{}
				if err := t.UnmarshalGQL(vv); err != nil {
					return err
				}
				l[i] = t
			}
			o.ClaimsMap = l
		}
		o.IsSetClaimsMap = true
	}
	if v, ok := m["claims_namespace"]; ok {
		if v == nil {
			o.ClaimsNamespace = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.ClaimsNamespace = &x
		}
		o.IsSetClaimsNamespace = true
	}
	if v, ok := m["claims_namespace_path"]; ok {
		if v == nil {
			o.ClaimsNamespacePath = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.ClaimsNamespacePath = &x
		}
		o.IsSetClaimsNamespacePath = true
	}

	return nil
}

func (o *ConfigJWTSecretUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigJWTSecretUpdateInput) GetType() *string {
	if o == nil {
		o = &ConfigJWTSecretUpdateInput{}
	}
	return o.Type
}

func (o *ConfigJWTSecretUpdateInput) GetKey() *string {
	if o == nil {
		o = &ConfigJWTSecretUpdateInput{}
	}
	return o.Key
}

func (o *ConfigJWTSecretUpdateInput) GetJwkUrl() *string {
	if o == nil {
		o = &ConfigJWTSecretUpdateInput{}
	}
	return o.JwkUrl
}

func (o *ConfigJWTSecretUpdateInput) GetClaimsFormat() *string {
	if o == nil {
		o = &ConfigJWTSecretUpdateInput{}
	}
	return o.ClaimsFormat
}

func (o *ConfigJWTSecretUpdateInput) GetAudience() *string {
	if o == nil {
		o = &ConfigJWTSecretUpdateInput{}
	}
	return o.Audience
}

func (o *ConfigJWTSecretUpdateInput) GetIssuer() *string {
	if o == nil {
		o = &ConfigJWTSecretUpdateInput{}
	}
	return o.Issuer
}

func (o *ConfigJWTSecretUpdateInput) GetAllowedSkew() *uint32 {
	if o == nil {
		o = &ConfigJWTSecretUpdateInput{}
	}
	return o.AllowedSkew
}

func (o *ConfigJWTSecretUpdateInput) GetHeader() *string {
	if o == nil {
		o = &ConfigJWTSecretUpdateInput{}
	}
	return o.Header
}

func (o *ConfigJWTSecretUpdateInput) GetClaimsMap() []*ConfigClaimMapUpdateInput {
	if o == nil {
		o = &ConfigJWTSecretUpdateInput{}
	}
	return o.ClaimsMap
}

func (o *ConfigJWTSecretUpdateInput) GetClaimsNamespace() *string {
	if o == nil {
		o = &ConfigJWTSecretUpdateInput{}
	}
	return o.ClaimsNamespace
}

func (o *ConfigJWTSecretUpdateInput) GetClaimsNamespacePath() *string {
	if o == nil {
		o = &ConfigJWTSecretUpdateInput{}
	}
	return o.ClaimsNamespacePath
}

func (s *ConfigJWTSecret) Update(v *ConfigJWTSecretUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetType || v.Type != nil {
		s.Type = v.Type
	}
	if v.IsSetKey || v.Key != nil {
		s.Key = v.Key
	}
	if v.IsSetJwkUrl || v.JwkUrl != nil {
		s.JwkUrl = v.JwkUrl
	}
	if v.IsSetClaimsFormat || v.ClaimsFormat != nil {
		s.ClaimsFormat = v.ClaimsFormat
	}
	if v.IsSetAudience || v.Audience != nil {
		s.Audience = v.Audience
	}
	if v.IsSetIssuer || v.Issuer != nil {
		s.Issuer = v.Issuer
	}
	if v.IsSetAllowedSkew || v.AllowedSkew != nil {
		s.AllowedSkew = v.AllowedSkew
	}
	if v.IsSetHeader || v.Header != nil {
		s.Header = v.Header
	}
	if v.IsSetClaimsMap || v.ClaimsMap != nil {
		if v.ClaimsMap == nil {
			s.ClaimsMap = nil
		} else {
			s.ClaimsMap = make([]*ConfigClaimMap, len(v.ClaimsMap))
			for i, e := range v.ClaimsMap {
				v := &ConfigClaimMap{}
				v.Update(e)
				s.ClaimsMap[i] = v
			}
		}
	}
	if v.IsSetClaimsNamespace || v.ClaimsNamespace != nil {
		s.ClaimsNamespace = v.ClaimsNamespace
	}
	if v.IsSetClaimsNamespacePath || v.ClaimsNamespacePath != nil {
		s.ClaimsNamespacePath = v.ClaimsNamespacePath
	}
}

type ConfigJWTSecretInsertInput struct {
	Type                *string                      `json:"type,omitempty" toml:"type,omitempty"`
	Key                 *string                      `json:"key,omitempty" toml:"key,omitempty"`
	JwkUrl              *string                      `json:"jwk_url,omitempty" toml:"jwk_url,omitempty"`
	ClaimsFormat        *string                      `json:"claims_format,omitempty" toml:"claims_format,omitempty"`
	Audience            *string                      `json:"audience,omitempty" toml:"audience,omitempty"`
	Issuer              *string                      `json:"issuer,omitempty" toml:"issuer,omitempty"`
	AllowedSkew         *uint32                      `json:"allowed_skew,omitempty" toml:"allowed_skew,omitempty"`
	Header              *string                      `json:"header,omitempty" toml:"header,omitempty"`
	ClaimsMap           []*ConfigClaimMapInsertInput `json:"claims_map,omitempty" toml:"claims_map,omitempty"`
	ClaimsNamespace     *string                      `json:"claims_namespace,omitempty" toml:"claims_namespace,omitempty"`
	ClaimsNamespacePath *string                      `json:"claims_namespace_path,omitempty" toml:"claims_namespace_path,omitempty"`
}

func (o *ConfigJWTSecretInsertInput) GetType() *string {
	if o == nil {
		o = &ConfigJWTSecretInsertInput{}
	}
	return o.Type
}

func (o *ConfigJWTSecretInsertInput) GetKey() *string {
	if o == nil {
		o = &ConfigJWTSecretInsertInput{}
	}
	return o.Key
}

func (o *ConfigJWTSecretInsertInput) GetJwkUrl() *string {
	if o == nil {
		o = &ConfigJWTSecretInsertInput{}
	}
	return o.JwkUrl
}

func (o *ConfigJWTSecretInsertInput) GetClaimsFormat() *string {
	if o == nil {
		o = &ConfigJWTSecretInsertInput{}
	}
	return o.ClaimsFormat
}

func (o *ConfigJWTSecretInsertInput) GetAudience() *string {
	if o == nil {
		o = &ConfigJWTSecretInsertInput{}
	}
	return o.Audience
}

func (o *ConfigJWTSecretInsertInput) GetIssuer() *string {
	if o == nil {
		o = &ConfigJWTSecretInsertInput{}
	}
	return o.Issuer
}

func (o *ConfigJWTSecretInsertInput) GetAllowedSkew() *uint32 {
	if o == nil {
		o = &ConfigJWTSecretInsertInput{}
	}
	return o.AllowedSkew
}

func (o *ConfigJWTSecretInsertInput) GetHeader() *string {
	if o == nil {
		o = &ConfigJWTSecretInsertInput{}
	}
	return o.Header
}

func (o *ConfigJWTSecretInsertInput) GetClaimsMap() []*ConfigClaimMapInsertInput {
	if o == nil {
		o = &ConfigJWTSecretInsertInput{}
	}
	return o.ClaimsMap
}

func (o *ConfigJWTSecretInsertInput) GetClaimsNamespace() *string {
	if o == nil {
		o = &ConfigJWTSecretInsertInput{}
	}
	return o.ClaimsNamespace
}

func (o *ConfigJWTSecretInsertInput) GetClaimsNamespacePath() *string {
	if o == nil {
		o = &ConfigJWTSecretInsertInput{}
	}
	return o.ClaimsNamespacePath
}

func (s *ConfigJWTSecret) Insert(v *ConfigJWTSecretInsertInput) {
	s.Type = v.Type
	s.Key = v.Key
	s.JwkUrl = v.JwkUrl
	s.ClaimsFormat = v.ClaimsFormat
	s.Audience = v.Audience
	s.Issuer = v.Issuer
	s.AllowedSkew = v.AllowedSkew
	s.Header = v.Header
	if v.ClaimsMap != nil {
		s.ClaimsMap = make([]*ConfigClaimMap, len(v.ClaimsMap))
		for i, e := range v.ClaimsMap {
			v := &ConfigClaimMap{}
			v.Insert(e)
			s.ClaimsMap[i] = v
		}
	}
	s.ClaimsNamespace = v.ClaimsNamespace
	s.ClaimsNamespacePath = v.ClaimsNamespacePath
}

func (s *ConfigJWTSecret) Clone() *ConfigJWTSecret {
	if s == nil {
		return nil
	}

	v := &ConfigJWTSecret{}
	v.Type = s.Type
	v.Key = s.Key
	v.JwkUrl = s.JwkUrl
	v.ClaimsFormat = s.ClaimsFormat
	v.Audience = s.Audience
	v.Issuer = s.Issuer
	v.AllowedSkew = s.AllowedSkew
	v.Header = s.Header
	if s.ClaimsMap != nil {
		v.ClaimsMap = make([]*ConfigClaimMap, len(s.ClaimsMap))
		for i, e := range s.ClaimsMap {
			v.ClaimsMap[i] = e.Clone()
		}
	}
	v.ClaimsNamespace = s.ClaimsNamespace
	v.ClaimsNamespacePath = s.ClaimsNamespacePath
	return v
}

type ConfigJWTSecretComparisonExp struct {
	And                 []*ConfigJWTSecretComparisonExp `json:"_and,omitempty"`
	Not                 *ConfigJWTSecretComparisonExp   `json:"_not,omitempty"`
	Or                  []*ConfigJWTSecretComparisonExp `json:"_or,omitempty"`
	Type                *ConfigStringComparisonExp      `json:"type,omitempty"`
	Key                 *ConfigStringComparisonExp      `json:"key,omitempty"`
	JwkUrl              *ConfigUrlComparisonExp         `json:"jwk_url,omitempty"`
	ClaimsFormat        *ConfigStringComparisonExp      `json:"claims_format,omitempty"`
	Audience            *ConfigStringComparisonExp      `json:"audience,omitempty"`
	Issuer              *ConfigStringComparisonExp      `json:"issuer,omitempty"`
	AllowedSkew         *ConfigUint32ComparisonExp      `json:"allowed_skew,omitempty"`
	Header              *ConfigStringComparisonExp      `json:"header,omitempty"`
	ClaimsMap           *ConfigClaimMapComparisonExp    `json:"claims_map,omitempty"`
	ClaimsNamespace     *ConfigStringComparisonExp      `json:"claims_namespace,omitempty"`
	ClaimsNamespacePath *ConfigStringComparisonExp      `json:"claims_namespace_path,omitempty"`
}

func (exp *ConfigJWTSecretComparisonExp) Matches(o *ConfigJWTSecret) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigJWTSecret{
			ClaimsMap: []*ConfigClaimMap{},
		}
	}
	if o.Type != nil && !exp.Type.Matches(*o.Type) {
		return false
	}
	if o.Key != nil && !exp.Key.Matches(*o.Key) {
		return false
	}
	if o.JwkUrl != nil && !exp.JwkUrl.Matches(*o.JwkUrl) {
		return false
	}
	if o.ClaimsFormat != nil && !exp.ClaimsFormat.Matches(*o.ClaimsFormat) {
		return false
	}
	if o.Audience != nil && !exp.Audience.Matches(*o.Audience) {
		return false
	}
	if o.Issuer != nil && !exp.Issuer.Matches(*o.Issuer) {
		return false
	}
	if o.AllowedSkew != nil && !exp.AllowedSkew.Matches(*o.AllowedSkew) {
		return false
	}
	if o.Header != nil && !exp.Header.Matches(*o.Header) {
		return false
	}
	{
		found := false
		for _, o := range o.ClaimsMap {
			if exp.ClaimsMap.Matches(o) {
				found = true
				break
			}
		}
		if !found && exp.ClaimsMap != nil {
			return false
		}
	}
	if o.ClaimsNamespace != nil && !exp.ClaimsNamespace.Matches(*o.ClaimsNamespace) {
		return false
	}
	if o.ClaimsNamespacePath != nil && !exp.ClaimsNamespacePath.Matches(*o.ClaimsNamespacePath) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigLocaleComparisonExp struct {
	Eq  *string  `json:"_eq,omitempty"`
	Neq *string  `json:"_neq,omitempty"`
	In  []string `json:"_in,omitempty"`
	Nin []string `json:"_nin,omitempty"`
}

func (exp *ConfigLocaleComparisonExp) Matches(o string) bool {
	if exp == nil {
		return true
	}

	if exp.Eq != nil && *exp.Eq != o {
		return false
	}

	if exp.Neq != nil && *exp.Neq == o {
		return false
	}

	if exp.In != nil && !contains(exp.In, o) {
		return false
	}

	if exp.Nin != nil && contains(exp.Nin, o) {
		return false
	}

	return true
}

type ConfigObservability struct {
	Grafana *ConfigGrafana `json:"grafana,omitempty" toml:"grafana,omitempty"`
}

func (o *ConfigObservability) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Grafana != nil {
		m["grafana"] = o.Grafana
	}
	return json.Marshal(m)
}

func (o *ConfigObservability) GetGrafana() *ConfigGrafana {
	if o == nil {
		return nil
	}
	return o.Grafana
}

type ConfigObservabilityUpdateInput struct {
	Grafana      *ConfigGrafanaUpdateInput `json:"grafana,omitempty" toml:"grafana,omitempty"`
	IsSetGrafana bool                      `json:"-"`
}

func (o *ConfigObservabilityUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if x, ok := m["grafana"]; ok {
		if x != nil {
			t := &ConfigGrafanaUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Grafana = t
		}
		o.IsSetGrafana = true
	}

	return nil
}

func (o *ConfigObservabilityUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigObservabilityUpdateInput) GetGrafana() *ConfigGrafanaUpdateInput {
	if o == nil {
		return nil
	}
	return o.Grafana
}

func (s *ConfigObservability) Update(v *ConfigObservabilityUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetGrafana || v.Grafana != nil {
		if v.Grafana == nil {
			s.Grafana = nil
		} else {
			if s.Grafana == nil {
				s.Grafana = &ConfigGrafana{}
			}
			s.Grafana.Update(v.Grafana)
		}
	}
}

type ConfigObservabilityInsertInput struct {
	Grafana *ConfigGrafanaInsertInput `json:"grafana,omitempty" toml:"grafana,omitempty"`
}

func (o *ConfigObservabilityInsertInput) GetGrafana() *ConfigGrafanaInsertInput {
	if o == nil {
		return nil
	}
	return o.Grafana
}

func (s *ConfigObservability) Insert(v *ConfigObservabilityInsertInput) {
	if v.Grafana != nil {
		if s.Grafana == nil {
			s.Grafana = &ConfigGrafana{}
		}
		s.Grafana.Insert(v.Grafana)
	}
}

func (s *ConfigObservability) Clone() *ConfigObservability {
	if s == nil {
		return nil
	}

	v := &ConfigObservability{}
	v.Grafana = s.Grafana.Clone()
	return v
}

type ConfigObservabilityComparisonExp struct {
	And     []*ConfigObservabilityComparisonExp `json:"_and,omitempty"`
	Not     *ConfigObservabilityComparisonExp   `json:"_not,omitempty"`
	Or      []*ConfigObservabilityComparisonExp `json:"_or,omitempty"`
	Grafana *ConfigGrafanaComparisonExp         `json:"grafana,omitempty"`
}

func (exp *ConfigObservabilityComparisonExp) Matches(o *ConfigObservability) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigObservability{
			Grafana: &ConfigGrafana{},
		}
	}
	if !exp.Grafana.Matches(o.Grafana) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigPortComparisonExp struct {
	Eq  *uint16  `json:"_eq,omitempty"`
	Neq *uint16  `json:"_neq,omitempty"`
	In  []uint16 `json:"_in,omitempty"`
	Nin []uint16 `json:"_nin,omitempty"`
}

func (exp *ConfigPortComparisonExp) Matches(o uint16) bool {
	if exp == nil {
		return true
	}

	if exp.Eq != nil && *exp.Eq != o {
		return false
	}

	if exp.Neq != nil && *exp.Neq == o {
		return false
	}

	if exp.In != nil && !contains(exp.In, o) {
		return false
	}

	if exp.Nin != nil && contains(exp.Nin, o) {
		return false
	}

	return true
}

// Configuration for postgres service
type ConfigPostgres struct {
	// Version of postgres, you can see available versions in the URL below:
	// https://hub.docker.com/r/nhost/postgres/tags
	Version *string `json:"version" toml:"version"`
	// Resources for the service
	Resources *ConfigResources `json:"resources,omitempty" toml:"resources,omitempty"`
}

func (o *ConfigPostgres) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Version != nil {
		m["version"] = o.Version
	}
	if o.Resources != nil {
		m["resources"] = o.Resources
	}
	return json.Marshal(m)
}

func (o *ConfigPostgres) GetVersion() *string {
	if o == nil {
		o = &ConfigPostgres{}
	}
	return o.Version
}

func (o *ConfigPostgres) GetResources() *ConfigResources {
	if o == nil {
		return nil
	}
	return o.Resources
}

type ConfigPostgresUpdateInput struct {
	Version        *string                     `json:"version,omitempty" toml:"version,omitempty"`
	IsSetVersion   bool                        `json:"-"`
	Resources      *ConfigResourcesUpdateInput `json:"resources,omitempty" toml:"resources,omitempty"`
	IsSetResources bool                        `json:"-"`
}

func (o *ConfigPostgresUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["version"]; ok {
		if v == nil {
			o.Version = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Version = &x
		}
		o.IsSetVersion = true
	}
	if x, ok := m["resources"]; ok {
		if x != nil {
			t := &ConfigResourcesUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Resources = t
		}
		o.IsSetResources = true
	}

	return nil
}

func (o *ConfigPostgresUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigPostgresUpdateInput) GetVersion() *string {
	if o == nil {
		o = &ConfigPostgresUpdateInput{}
	}
	return o.Version
}

func (o *ConfigPostgresUpdateInput) GetResources() *ConfigResourcesUpdateInput {
	if o == nil {
		return nil
	}
	return o.Resources
}

func (s *ConfigPostgres) Update(v *ConfigPostgresUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetVersion || v.Version != nil {
		s.Version = v.Version
	}
	if v.IsSetResources || v.Resources != nil {
		if v.Resources == nil {
			s.Resources = nil
		} else {
			if s.Resources == nil {
				s.Resources = &ConfigResources{}
			}
			s.Resources.Update(v.Resources)
		}
	}
}

type ConfigPostgresInsertInput struct {
	Version   *string                     `json:"version,omitempty" toml:"version,omitempty"`
	Resources *ConfigResourcesInsertInput `json:"resources,omitempty" toml:"resources,omitempty"`
}

func (o *ConfigPostgresInsertInput) GetVersion() *string {
	if o == nil {
		o = &ConfigPostgresInsertInput{}
	}
	return o.Version
}

func (o *ConfigPostgresInsertInput) GetResources() *ConfigResourcesInsertInput {
	if o == nil {
		return nil
	}
	return o.Resources
}

func (s *ConfigPostgres) Insert(v *ConfigPostgresInsertInput) {
	s.Version = v.Version
	if v.Resources != nil {
		if s.Resources == nil {
			s.Resources = &ConfigResources{}
		}
		s.Resources.Insert(v.Resources)
	}
}

func (s *ConfigPostgres) Clone() *ConfigPostgres {
	if s == nil {
		return nil
	}

	v := &ConfigPostgres{}
	v.Version = s.Version
	v.Resources = s.Resources.Clone()
	return v
}

type ConfigPostgresComparisonExp struct {
	And       []*ConfigPostgresComparisonExp `json:"_and,omitempty"`
	Not       *ConfigPostgresComparisonExp   `json:"_not,omitempty"`
	Or        []*ConfigPostgresComparisonExp `json:"_or,omitempty"`
	Version   *ConfigStringComparisonExp     `json:"version,omitempty"`
	Resources *ConfigResourcesComparisonExp  `json:"resources,omitempty"`
}

func (exp *ConfigPostgresComparisonExp) Matches(o *ConfigPostgres) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigPostgres{
			Resources: &ConfigResources{},
		}
	}
	if o.Version != nil && !exp.Version.Matches(*o.Version) {
		return false
	}
	if !exp.Resources.Matches(o.Resources) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigProvider struct {
	Smtp *ConfigSmtp `json:"smtp,omitempty" toml:"smtp,omitempty"`

	Sms *ConfigSms `json:"sms,omitempty" toml:"sms,omitempty"`
}

func (o *ConfigProvider) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Smtp != nil {
		m["smtp"] = o.Smtp
	}
	if o.Sms != nil {
		m["sms"] = o.Sms
	}
	return json.Marshal(m)
}

func (o *ConfigProvider) GetSmtp() *ConfigSmtp {
	if o == nil {
		return nil
	}
	return o.Smtp
}

func (o *ConfigProvider) GetSms() *ConfigSms {
	if o == nil {
		return nil
	}
	return o.Sms
}

type ConfigProviderUpdateInput struct {
	Smtp      *ConfigSmtpUpdateInput `json:"smtp,omitempty" toml:"smtp,omitempty"`
	IsSetSmtp bool                   `json:"-"`
	Sms       *ConfigSmsUpdateInput  `json:"sms,omitempty" toml:"sms,omitempty"`
	IsSetSms  bool                   `json:"-"`
}

func (o *ConfigProviderUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if x, ok := m["smtp"]; ok {
		if x != nil {
			t := &ConfigSmtpUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Smtp = t
		}
		o.IsSetSmtp = true
	}
	if x, ok := m["sms"]; ok {
		if x != nil {
			t := &ConfigSmsUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Sms = t
		}
		o.IsSetSms = true
	}

	return nil
}

func (o *ConfigProviderUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigProviderUpdateInput) GetSmtp() *ConfigSmtpUpdateInput {
	if o == nil {
		return nil
	}
	return o.Smtp
}

func (o *ConfigProviderUpdateInput) GetSms() *ConfigSmsUpdateInput {
	if o == nil {
		return nil
	}
	return o.Sms
}

func (s *ConfigProvider) Update(v *ConfigProviderUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetSmtp || v.Smtp != nil {
		if v.Smtp == nil {
			s.Smtp = nil
		} else {
			if s.Smtp == nil {
				s.Smtp = &ConfigSmtp{}
			}
			s.Smtp.Update(v.Smtp)
		}
	}
	if v.IsSetSms || v.Sms != nil {
		if v.Sms == nil {
			s.Sms = nil
		} else {
			if s.Sms == nil {
				s.Sms = &ConfigSms{}
			}
			s.Sms.Update(v.Sms)
		}
	}
}

type ConfigProviderInsertInput struct {
	Smtp *ConfigSmtpInsertInput `json:"smtp,omitempty" toml:"smtp,omitempty"`
	Sms  *ConfigSmsInsertInput  `json:"sms,omitempty" toml:"sms,omitempty"`
}

func (o *ConfigProviderInsertInput) GetSmtp() *ConfigSmtpInsertInput {
	if o == nil {
		return nil
	}
	return o.Smtp
}

func (o *ConfigProviderInsertInput) GetSms() *ConfigSmsInsertInput {
	if o == nil {
		return nil
	}
	return o.Sms
}

func (s *ConfigProvider) Insert(v *ConfigProviderInsertInput) {
	if v.Smtp != nil {
		if s.Smtp == nil {
			s.Smtp = &ConfigSmtp{}
		}
		s.Smtp.Insert(v.Smtp)
	}
	if v.Sms != nil {
		if s.Sms == nil {
			s.Sms = &ConfigSms{}
		}
		s.Sms.Insert(v.Sms)
	}
}

func (s *ConfigProvider) Clone() *ConfigProvider {
	if s == nil {
		return nil
	}

	v := &ConfigProvider{}
	v.Smtp = s.Smtp.Clone()
	v.Sms = s.Sms.Clone()
	return v
}

type ConfigProviderComparisonExp struct {
	And  []*ConfigProviderComparisonExp `json:"_and,omitempty"`
	Not  *ConfigProviderComparisonExp   `json:"_not,omitempty"`
	Or   []*ConfigProviderComparisonExp `json:"_or,omitempty"`
	Smtp *ConfigSmtpComparisonExp       `json:"smtp,omitempty"`
	Sms  *ConfigSmsComparisonExp        `json:"sms,omitempty"`
}

func (exp *ConfigProviderComparisonExp) Matches(o *ConfigProvider) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigProvider{
			Smtp: &ConfigSmtp{},
			Sms:  &ConfigSms{},
		}
	}
	if !exp.Smtp.Matches(o.Smtp) {
		return false
	}
	if !exp.Sms.Matches(o.Sms) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

// Resource configuration for a service
type ConfigResources struct {
	Compute *ConfigResourcesCompute `json:"compute,omitempty" toml:"compute,omitempty"`
	// Number of replicas for a service
	Replicas uint8 `json:"replicas" toml:"replicas"`
}

func (o *ConfigResources) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Compute != nil {
		m["compute"] = o.Compute
	}
	m["replicas"] = o.Replicas
	return json.Marshal(m)
}

func (o *ConfigResources) GetCompute() *ConfigResourcesCompute {
	if o == nil {
		return nil
	}
	return o.Compute
}

func (o *ConfigResources) GetReplicas() uint8 {
	if o == nil {
		o = &ConfigResources{}
	}
	return o.Replicas
}

type ConfigResourcesUpdateInput struct {
	Compute       *ConfigResourcesComputeUpdateInput `json:"compute,omitempty" toml:"compute,omitempty"`
	IsSetCompute  bool                               `json:"-"`
	Replicas      *uint8                             `json:"replicas,omitempty" toml:"replicas,omitempty"`
	IsSetReplicas bool                               `json:"-"`
}

func (o *ConfigResourcesUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if x, ok := m["compute"]; ok {
		if x != nil {
			t := &ConfigResourcesComputeUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Compute = t
		}
		o.IsSetCompute = true
	}
	if v, ok := m["replicas"]; ok {
		if v == nil {
			o.Replicas = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x uint8
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Replicas = &x
		}
		o.IsSetReplicas = true
	}

	return nil
}

func (o *ConfigResourcesUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigResourcesUpdateInput) GetCompute() *ConfigResourcesComputeUpdateInput {
	if o == nil {
		return nil
	}
	return o.Compute
}

func (o *ConfigResourcesUpdateInput) GetReplicas() *uint8 {
	if o == nil {
		o = &ConfigResourcesUpdateInput{}
	}
	return o.Replicas
}

func (s *ConfigResources) Update(v *ConfigResourcesUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetCompute || v.Compute != nil {
		if v.Compute == nil {
			s.Compute = nil
		} else {
			if s.Compute == nil {
				s.Compute = &ConfigResourcesCompute{}
			}
			s.Compute.Update(v.Compute)
		}
	}
	if v.IsSetReplicas || v.Replicas != nil {
		if v.Replicas != nil {
			s.Replicas = *v.Replicas
		}
	}
}

type ConfigResourcesInsertInput struct {
	Compute  *ConfigResourcesComputeInsertInput `json:"compute,omitempty" toml:"compute,omitempty"`
	Replicas uint8                              `json:"replicas,omitempty" toml:"replicas,omitempty"`
}

func (o *ConfigResourcesInsertInput) GetCompute() *ConfigResourcesComputeInsertInput {
	if o == nil {
		return nil
	}
	return o.Compute
}

func (o *ConfigResourcesInsertInput) GetReplicas() uint8 {
	if o == nil {
		o = &ConfigResourcesInsertInput{}
	}
	return o.Replicas
}

func (s *ConfigResources) Insert(v *ConfigResourcesInsertInput) {
	if v.Compute != nil {
		if s.Compute == nil {
			s.Compute = &ConfigResourcesCompute{}
		}
		s.Compute.Insert(v.Compute)
	}
	s.Replicas = v.Replicas
}

func (s *ConfigResources) Clone() *ConfigResources {
	if s == nil {
		return nil
	}

	v := &ConfigResources{}
	v.Compute = s.Compute.Clone()
	v.Replicas = s.Replicas
	return v
}

type ConfigResourcesComparisonExp struct {
	And      []*ConfigResourcesComparisonExp      `json:"_and,omitempty"`
	Not      *ConfigResourcesComparisonExp        `json:"_not,omitempty"`
	Or       []*ConfigResourcesComparisonExp      `json:"_or,omitempty"`
	Compute  *ConfigResourcesComputeComparisonExp `json:"compute,omitempty"`
	Replicas *ConfigUint8ComparisonExp            `json:"replicas,omitempty"`
}

func (exp *ConfigResourcesComparisonExp) Matches(o *ConfigResources) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigResources{
			Compute: &ConfigResourcesCompute{},
		}
	}
	if !exp.Compute.Matches(o.Compute) {
		return false
	}
	if !exp.Replicas.Matches(o.Replicas) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigResourcesCompute struct {
	// milicpus, 1000 milicpus = 1 cpu
	Cpu uint32 `json:"cpu" toml:"cpu"`
	// MiB: 128MiB to 30GiB
	Memory uint32 `json:"memory" toml:"memory"`
}

func (o *ConfigResourcesCompute) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	m["cpu"] = o.Cpu
	m["memory"] = o.Memory
	return json.Marshal(m)
}

func (o *ConfigResourcesCompute) GetCpu() uint32 {
	if o == nil {
		o = &ConfigResourcesCompute{}
	}
	return o.Cpu
}

func (o *ConfigResourcesCompute) GetMemory() uint32 {
	if o == nil {
		o = &ConfigResourcesCompute{}
	}
	return o.Memory
}

type ConfigResourcesComputeUpdateInput struct {
	Cpu         *uint32 `json:"cpu,omitempty" toml:"cpu,omitempty"`
	IsSetCpu    bool    `json:"-"`
	Memory      *uint32 `json:"memory,omitempty" toml:"memory,omitempty"`
	IsSetMemory bool    `json:"-"`
}

func (o *ConfigResourcesComputeUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["cpu"]; ok {
		if v == nil {
			o.Cpu = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x uint32
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Cpu = &x
		}
		o.IsSetCpu = true
	}
	if v, ok := m["memory"]; ok {
		if v == nil {
			o.Memory = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x uint32
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Memory = &x
		}
		o.IsSetMemory = true
	}

	return nil
}

func (o *ConfigResourcesComputeUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigResourcesComputeUpdateInput) GetCpu() *uint32 {
	if o == nil {
		o = &ConfigResourcesComputeUpdateInput{}
	}
	return o.Cpu
}

func (o *ConfigResourcesComputeUpdateInput) GetMemory() *uint32 {
	if o == nil {
		o = &ConfigResourcesComputeUpdateInput{}
	}
	return o.Memory
}

func (s *ConfigResourcesCompute) Update(v *ConfigResourcesComputeUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetCpu || v.Cpu != nil {
		if v.Cpu != nil {
			s.Cpu = *v.Cpu
		}
	}
	if v.IsSetMemory || v.Memory != nil {
		if v.Memory != nil {
			s.Memory = *v.Memory
		}
	}
}

type ConfigResourcesComputeInsertInput struct {
	Cpu    uint32 `json:"cpu,omitempty" toml:"cpu,omitempty"`
	Memory uint32 `json:"memory,omitempty" toml:"memory,omitempty"`
}

func (o *ConfigResourcesComputeInsertInput) GetCpu() uint32 {
	if o == nil {
		o = &ConfigResourcesComputeInsertInput{}
	}
	return o.Cpu
}

func (o *ConfigResourcesComputeInsertInput) GetMemory() uint32 {
	if o == nil {
		o = &ConfigResourcesComputeInsertInput{}
	}
	return o.Memory
}

func (s *ConfigResourcesCompute) Insert(v *ConfigResourcesComputeInsertInput) {
	s.Cpu = v.Cpu
	s.Memory = v.Memory
}

func (s *ConfigResourcesCompute) Clone() *ConfigResourcesCompute {
	if s == nil {
		return nil
	}

	v := &ConfigResourcesCompute{}
	v.Cpu = s.Cpu
	v.Memory = s.Memory
	return v
}

type ConfigResourcesComputeComparisonExp struct {
	And    []*ConfigResourcesComputeComparisonExp `json:"_and,omitempty"`
	Not    *ConfigResourcesComputeComparisonExp   `json:"_not,omitempty"`
	Or     []*ConfigResourcesComputeComparisonExp `json:"_or,omitempty"`
	Cpu    *ConfigUint32ComparisonExp             `json:"cpu,omitempty"`
	Memory *ConfigUint32ComparisonExp             `json:"memory,omitempty"`
}

func (exp *ConfigResourcesComputeComparisonExp) Matches(o *ConfigResourcesCompute) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigResourcesCompute{}
	}
	if !exp.Cpu.Matches(o.Cpu) {
		return false
	}
	if !exp.Memory.Matches(o.Memory) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigRunServiceConfig struct {
	Name string `json:"name" toml:"name"`

	Image *ConfigRunServiceImage `json:"image,omitempty" toml:"image,omitempty"`

	Command []string `json:"command,omitempty" toml:"command,omitempty"`

	Environment []*ConfigEnvironmentVariable `json:"environment,omitempty" toml:"environment,omitempty"`

	Ports []*ConfigRunServicePort `json:"ports,omitempty" toml:"ports,omitempty"`

	Resources *ConfigRunServiceResources `json:"resources,omitempty" toml:"resources,omitempty"`
}

func (o *ConfigRunServiceConfig) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	m["name"] = o.Name
	if o.Image != nil {
		m["image"] = o.Image
	}
	if o.Command != nil {
		m["command"] = o.Command
	}
	if o.Environment != nil {
		m["environment"] = o.Environment
	}
	if o.Ports != nil {
		m["ports"] = o.Ports
	}
	if o.Resources != nil {
		m["resources"] = o.Resources
	}
	return json.Marshal(m)
}

func (o *ConfigRunServiceConfig) GetName() string {
	if o == nil {
		o = &ConfigRunServiceConfig{}
	}
	return o.Name
}

func (o *ConfigRunServiceConfig) GetImage() *ConfigRunServiceImage {
	if o == nil {
		return nil
	}
	return o.Image
}

func (o *ConfigRunServiceConfig) GetCommand() []string {
	if o == nil {
		o = &ConfigRunServiceConfig{}
	}
	return o.Command
}

func (o *ConfigRunServiceConfig) GetEnvironment() []*ConfigEnvironmentVariable {
	if o == nil {
		o = &ConfigRunServiceConfig{}
	}
	return o.Environment
}

func (o *ConfigRunServiceConfig) GetPorts() []*ConfigRunServicePort {
	if o == nil {
		o = &ConfigRunServiceConfig{}
	}
	return o.Ports
}

func (o *ConfigRunServiceConfig) GetResources() *ConfigRunServiceResources {
	if o == nil {
		return nil
	}
	return o.Resources
}

type ConfigRunServiceConfigUpdateInput struct {
	Name             *string                                 `json:"name,omitempty" toml:"name,omitempty"`
	IsSetName        bool                                    `json:"-"`
	Image            *ConfigRunServiceImageUpdateInput       `json:"image,omitempty" toml:"image,omitempty"`
	IsSetImage       bool                                    `json:"-"`
	Command          []string                                `json:"command,omitempty" toml:"command,omitempty"`
	IsSetCommand     bool                                    `json:"-"`
	Environment      []*ConfigEnvironmentVariableUpdateInput `json:"environment,omitempty" toml:"environment,omitempty"`
	IsSetEnvironment bool                                    `json:"-"`
	Ports            []*ConfigRunServicePortUpdateInput      `json:"ports,omitempty" toml:"ports,omitempty"`
	IsSetPorts       bool                                    `json:"-"`
	Resources        *ConfigRunServiceResourcesUpdateInput   `json:"resources,omitempty" toml:"resources,omitempty"`
	IsSetResources   bool                                    `json:"-"`
}

func (o *ConfigRunServiceConfigUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["name"]; ok {
		if v == nil {
			o.Name = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Name = &x
		}
		o.IsSetName = true
	}
	if x, ok := m["image"]; ok {
		if x != nil {
			t := &ConfigRunServiceImageUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Image = t
		}
		o.IsSetImage = true
	}
	if v, ok := m["command"]; ok {
		if v != nil {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var l []string
			if err := json.Unmarshal(b, &l); err != nil {
				return err
			}
			o.Command = l
		}
		o.IsSetCommand = true
	}
	if v, ok := m["environment"]; ok {
		if v != nil {
			x, ok := v.([]interface{})
			if !ok {
				return fmt.Errorf("Environment must be []interface{}, got %T", v)
			}

			l := make([]*ConfigEnvironmentVariableUpdateInput, len(x))
			for i, vv := range x {
				t := &ConfigEnvironmentVariableUpdateInput{}
				if err := t.UnmarshalGQL(vv); err != nil {
					return err
				}
				l[i] = t
			}
			o.Environment = l
		}
		o.IsSetEnvironment = true
	}
	if v, ok := m["ports"]; ok {
		if v != nil {
			x, ok := v.([]interface{})
			if !ok {
				return fmt.Errorf("Ports must be []interface{}, got %T", v)
			}

			l := make([]*ConfigRunServicePortUpdateInput, len(x))
			for i, vv := range x {
				t := &ConfigRunServicePortUpdateInput{}
				if err := t.UnmarshalGQL(vv); err != nil {
					return err
				}
				l[i] = t
			}
			o.Ports = l
		}
		o.IsSetPorts = true
	}
	if x, ok := m["resources"]; ok {
		if x != nil {
			t := &ConfigRunServiceResourcesUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Resources = t
		}
		o.IsSetResources = true
	}

	return nil
}

func (o *ConfigRunServiceConfigUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigRunServiceConfigUpdateInput) GetName() *string {
	if o == nil {
		o = &ConfigRunServiceConfigUpdateInput{}
	}
	return o.Name
}

func (o *ConfigRunServiceConfigUpdateInput) GetImage() *ConfigRunServiceImageUpdateInput {
	if o == nil {
		return nil
	}
	return o.Image
}

func (o *ConfigRunServiceConfigUpdateInput) GetCommand() []string {
	if o == nil {
		o = &ConfigRunServiceConfigUpdateInput{}
	}
	return o.Command
}

func (o *ConfigRunServiceConfigUpdateInput) GetEnvironment() []*ConfigEnvironmentVariableUpdateInput {
	if o == nil {
		o = &ConfigRunServiceConfigUpdateInput{}
	}
	return o.Environment
}

func (o *ConfigRunServiceConfigUpdateInput) GetPorts() []*ConfigRunServicePortUpdateInput {
	if o == nil {
		o = &ConfigRunServiceConfigUpdateInput{}
	}
	return o.Ports
}

func (o *ConfigRunServiceConfigUpdateInput) GetResources() *ConfigRunServiceResourcesUpdateInput {
	if o == nil {
		return nil
	}
	return o.Resources
}

func (s *ConfigRunServiceConfig) Update(v *ConfigRunServiceConfigUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetName || v.Name != nil {
		if v.Name != nil {
			s.Name = *v.Name
		}
	}
	if v.IsSetImage || v.Image != nil {
		if v.Image == nil {
			s.Image = nil
		} else {
			if s.Image == nil {
				s.Image = &ConfigRunServiceImage{}
			}
			s.Image.Update(v.Image)
		}
	}
	if v.IsSetCommand || v.Command != nil {
		if v.Command == nil {
			s.Command = nil
		} else {
			s.Command = make([]string, len(v.Command))
			for i, e := range v.Command {
				s.Command[i] = e
			}
		}
	}
	if v.IsSetEnvironment || v.Environment != nil {
		if v.Environment == nil {
			s.Environment = nil
		} else {
			s.Environment = make([]*ConfigEnvironmentVariable, len(v.Environment))
			for i, e := range v.Environment {
				v := &ConfigEnvironmentVariable{}
				v.Update(e)
				s.Environment[i] = v
			}
		}
	}
	if v.IsSetPorts || v.Ports != nil {
		if v.Ports == nil {
			s.Ports = nil
		} else {
			s.Ports = make([]*ConfigRunServicePort, len(v.Ports))
			for i, e := range v.Ports {
				v := &ConfigRunServicePort{}
				v.Update(e)
				s.Ports[i] = v
			}
		}
	}
	if v.IsSetResources || v.Resources != nil {
		if v.Resources == nil {
			s.Resources = nil
		} else {
			if s.Resources == nil {
				s.Resources = &ConfigRunServiceResources{}
			}
			s.Resources.Update(v.Resources)
		}
	}
}

type ConfigRunServiceConfigInsertInput struct {
	Name        string                                  `json:"name,omitempty" toml:"name,omitempty"`
	Image       *ConfigRunServiceImageInsertInput       `json:"image,omitempty" toml:"image,omitempty"`
	Command     []string                                `json:"command,omitempty" toml:"command,omitempty"`
	Environment []*ConfigEnvironmentVariableInsertInput `json:"environment,omitempty" toml:"environment,omitempty"`
	Ports       []*ConfigRunServicePortInsertInput      `json:"ports,omitempty" toml:"ports,omitempty"`
	Resources   *ConfigRunServiceResourcesInsertInput   `json:"resources,omitempty" toml:"resources,omitempty"`
}

func (o *ConfigRunServiceConfigInsertInput) GetName() string {
	if o == nil {
		o = &ConfigRunServiceConfigInsertInput{}
	}
	return o.Name
}

func (o *ConfigRunServiceConfigInsertInput) GetImage() *ConfigRunServiceImageInsertInput {
	if o == nil {
		return nil
	}
	return o.Image
}

func (o *ConfigRunServiceConfigInsertInput) GetCommand() []string {
	if o == nil {
		o = &ConfigRunServiceConfigInsertInput{}
	}
	return o.Command
}

func (o *ConfigRunServiceConfigInsertInput) GetEnvironment() []*ConfigEnvironmentVariableInsertInput {
	if o == nil {
		o = &ConfigRunServiceConfigInsertInput{}
	}
	return o.Environment
}

func (o *ConfigRunServiceConfigInsertInput) GetPorts() []*ConfigRunServicePortInsertInput {
	if o == nil {
		o = &ConfigRunServiceConfigInsertInput{}
	}
	return o.Ports
}

func (o *ConfigRunServiceConfigInsertInput) GetResources() *ConfigRunServiceResourcesInsertInput {
	if o == nil {
		return nil
	}
	return o.Resources
}

func (s *ConfigRunServiceConfig) Insert(v *ConfigRunServiceConfigInsertInput) {
	s.Name = v.Name
	if v.Image != nil {
		if s.Image == nil {
			s.Image = &ConfigRunServiceImage{}
		}
		s.Image.Insert(v.Image)
	}
	if v.Command != nil {
		s.Command = make([]string, len(v.Command))
		for i, e := range v.Command {
			s.Command[i] = e
		}
	}
	if v.Environment != nil {
		s.Environment = make([]*ConfigEnvironmentVariable, len(v.Environment))
		for i, e := range v.Environment {
			v := &ConfigEnvironmentVariable{}
			v.Insert(e)
			s.Environment[i] = v
		}
	}
	if v.Ports != nil {
		s.Ports = make([]*ConfigRunServicePort, len(v.Ports))
		for i, e := range v.Ports {
			v := &ConfigRunServicePort{}
			v.Insert(e)
			s.Ports[i] = v
		}
	}
	if v.Resources != nil {
		if s.Resources == nil {
			s.Resources = &ConfigRunServiceResources{}
		}
		s.Resources.Insert(v.Resources)
	}
}

func (s *ConfigRunServiceConfig) Clone() *ConfigRunServiceConfig {
	if s == nil {
		return nil
	}

	v := &ConfigRunServiceConfig{}
	v.Name = s.Name
	v.Image = s.Image.Clone()
	if s.Command != nil {
		v.Command = make([]string, len(s.Command))
		copy(v.Command, s.Command)
	}
	if s.Environment != nil {
		v.Environment = make([]*ConfigEnvironmentVariable, len(s.Environment))
		for i, e := range s.Environment {
			v.Environment[i] = e.Clone()
		}
	}
	if s.Ports != nil {
		v.Ports = make([]*ConfigRunServicePort, len(s.Ports))
		for i, e := range s.Ports {
			v.Ports[i] = e.Clone()
		}
	}
	v.Resources = s.Resources.Clone()
	return v
}

type ConfigRunServiceConfigComparisonExp struct {
	And         []*ConfigRunServiceConfigComparisonExp  `json:"_and,omitempty"`
	Not         *ConfigRunServiceConfigComparisonExp    `json:"_not,omitempty"`
	Or          []*ConfigRunServiceConfigComparisonExp  `json:"_or,omitempty"`
	Name        *ConfigStringComparisonExp              `json:"name,omitempty"`
	Image       *ConfigRunServiceImageComparisonExp     `json:"image,omitempty"`
	Command     *ConfigStringComparisonExp              `json:"command,omitempty"`
	Environment *ConfigEnvironmentVariableComparisonExp `json:"environment,omitempty"`
	Ports       *ConfigRunServicePortComparisonExp      `json:"ports,omitempty"`
	Resources   *ConfigRunServiceResourcesComparisonExp `json:"resources,omitempty"`
}

func (exp *ConfigRunServiceConfigComparisonExp) Matches(o *ConfigRunServiceConfig) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigRunServiceConfig{
			Image:       &ConfigRunServiceImage{},
			Command:     []string{},
			Environment: []*ConfigEnvironmentVariable{},
			Ports:       []*ConfigRunServicePort{},
			Resources:   &ConfigRunServiceResources{},
		}
	}
	if !exp.Name.Matches(o.Name) {
		return false
	}
	if !exp.Image.Matches(o.Image) {
		return false
	}
	{
		found := false
		for _, o := range o.Command {
			if exp.Command.Matches(o) {
				found = true
				break
			}
		}
		if !found && exp.Command != nil {
			return false
		}
	}
	{
		found := false
		for _, o := range o.Environment {
			if exp.Environment.Matches(o) {
				found = true
				break
			}
		}
		if !found && exp.Environment != nil {
			return false
		}
	}
	{
		found := false
		for _, o := range o.Ports {
			if exp.Ports.Matches(o) {
				found = true
				break
			}
		}
		if !found && exp.Ports != nil {
			return false
		}
	}
	if !exp.Resources.Matches(o.Resources) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigRunServiceImage struct {
	Image string `json:"image" toml:"image"`
}

func (o *ConfigRunServiceImage) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	m["image"] = o.Image
	return json.Marshal(m)
}

func (o *ConfigRunServiceImage) GetImage() string {
	if o == nil {
		o = &ConfigRunServiceImage{}
	}
	return o.Image
}

type ConfigRunServiceImageUpdateInput struct {
	Image      *string `json:"image,omitempty" toml:"image,omitempty"`
	IsSetImage bool    `json:"-"`
}

func (o *ConfigRunServiceImageUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["image"]; ok {
		if v == nil {
			o.Image = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Image = &x
		}
		o.IsSetImage = true
	}

	return nil
}

func (o *ConfigRunServiceImageUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigRunServiceImageUpdateInput) GetImage() *string {
	if o == nil {
		o = &ConfigRunServiceImageUpdateInput{}
	}
	return o.Image
}

func (s *ConfigRunServiceImage) Update(v *ConfigRunServiceImageUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetImage || v.Image != nil {
		if v.Image != nil {
			s.Image = *v.Image
		}
	}
}

type ConfigRunServiceImageInsertInput struct {
	Image string `json:"image,omitempty" toml:"image,omitempty"`
}

func (o *ConfigRunServiceImageInsertInput) GetImage() string {
	if o == nil {
		o = &ConfigRunServiceImageInsertInput{}
	}
	return o.Image
}

func (s *ConfigRunServiceImage) Insert(v *ConfigRunServiceImageInsertInput) {
	s.Image = v.Image
}

func (s *ConfigRunServiceImage) Clone() *ConfigRunServiceImage {
	if s == nil {
		return nil
	}

	v := &ConfigRunServiceImage{}
	v.Image = s.Image
	return v
}

type ConfigRunServiceImageComparisonExp struct {
	And   []*ConfigRunServiceImageComparisonExp `json:"_and,omitempty"`
	Not   *ConfigRunServiceImageComparisonExp   `json:"_not,omitempty"`
	Or    []*ConfigRunServiceImageComparisonExp `json:"_or,omitempty"`
	Image *ConfigStringComparisonExp            `json:"image,omitempty"`
}

func (exp *ConfigRunServiceImageComparisonExp) Matches(o *ConfigRunServiceImage) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigRunServiceImage{}
	}
	if !exp.Image.Matches(o.Image) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigRunServicePort struct {
	Port uint16 `json:"port" toml:"port"`

	Type string `json:"type" toml:"type"`

	Publish *bool `json:"publish" toml:"publish"`
}

func (o *ConfigRunServicePort) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	m["port"] = o.Port
	m["type"] = o.Type
	if o.Publish != nil {
		m["publish"] = o.Publish
	}
	return json.Marshal(m)
}

func (o *ConfigRunServicePort) GetPort() uint16 {
	if o == nil {
		o = &ConfigRunServicePort{}
	}
	return o.Port
}

func (o *ConfigRunServicePort) GetType() string {
	if o == nil {
		o = &ConfigRunServicePort{}
	}
	return o.Type
}

func (o *ConfigRunServicePort) GetPublish() *bool {
	if o == nil {
		o = &ConfigRunServicePort{}
	}
	return o.Publish
}

type ConfigRunServicePortUpdateInput struct {
	Port         *uint16 `json:"port,omitempty" toml:"port,omitempty"`
	IsSetPort    bool    `json:"-"`
	Type         *string `json:"type,omitempty" toml:"type,omitempty"`
	IsSetType    bool    `json:"-"`
	Publish      *bool   `json:"publish,omitempty" toml:"publish,omitempty"`
	IsSetPublish bool    `json:"-"`
}

func (o *ConfigRunServicePortUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["port"]; ok {
		if v == nil {
			o.Port = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x uint16
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Port = &x
		}
		o.IsSetPort = true
	}
	if v, ok := m["type"]; ok {
		if v == nil {
			o.Type = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Type = &x
		}
		o.IsSetType = true
	}
	if v, ok := m["publish"]; ok {
		if v == nil {
			o.Publish = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x bool
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Publish = &x
		}
		o.IsSetPublish = true
	}

	return nil
}

func (o *ConfigRunServicePortUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigRunServicePortUpdateInput) GetPort() *uint16 {
	if o == nil {
		o = &ConfigRunServicePortUpdateInput{}
	}
	return o.Port
}

func (o *ConfigRunServicePortUpdateInput) GetType() *string {
	if o == nil {
		o = &ConfigRunServicePortUpdateInput{}
	}
	return o.Type
}

func (o *ConfigRunServicePortUpdateInput) GetPublish() *bool {
	if o == nil {
		o = &ConfigRunServicePortUpdateInput{}
	}
	return o.Publish
}

func (s *ConfigRunServicePort) Update(v *ConfigRunServicePortUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetPort || v.Port != nil {
		if v.Port != nil {
			s.Port = *v.Port
		}
	}
	if v.IsSetType || v.Type != nil {
		if v.Type != nil {
			s.Type = *v.Type
		}
	}
	if v.IsSetPublish || v.Publish != nil {
		s.Publish = v.Publish
	}
}

type ConfigRunServicePortInsertInput struct {
	Port    uint16 `json:"port,omitempty" toml:"port,omitempty"`
	Type    string `json:"type,omitempty" toml:"type,omitempty"`
	Publish *bool  `json:"publish,omitempty" toml:"publish,omitempty"`
}

func (o *ConfigRunServicePortInsertInput) GetPort() uint16 {
	if o == nil {
		o = &ConfigRunServicePortInsertInput{}
	}
	return o.Port
}

func (o *ConfigRunServicePortInsertInput) GetType() string {
	if o == nil {
		o = &ConfigRunServicePortInsertInput{}
	}
	return o.Type
}

func (o *ConfigRunServicePortInsertInput) GetPublish() *bool {
	if o == nil {
		o = &ConfigRunServicePortInsertInput{}
	}
	return o.Publish
}

func (s *ConfigRunServicePort) Insert(v *ConfigRunServicePortInsertInput) {
	s.Port = v.Port
	s.Type = v.Type
	s.Publish = v.Publish
}

func (s *ConfigRunServicePort) Clone() *ConfigRunServicePort {
	if s == nil {
		return nil
	}

	v := &ConfigRunServicePort{}
	v.Port = s.Port
	v.Type = s.Type
	v.Publish = s.Publish
	return v
}

type ConfigRunServicePortComparisonExp struct {
	And     []*ConfigRunServicePortComparisonExp `json:"_and,omitempty"`
	Not     *ConfigRunServicePortComparisonExp   `json:"_not,omitempty"`
	Or      []*ConfigRunServicePortComparisonExp `json:"_or,omitempty"`
	Port    *ConfigPortComparisonExp             `json:"port,omitempty"`
	Type    *ConfigStringComparisonExp           `json:"type,omitempty"`
	Publish *ConfigBooleanComparisonExp          `json:"publish,omitempty"`
}

func (exp *ConfigRunServicePortComparisonExp) Matches(o *ConfigRunServicePort) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigRunServicePort{}
	}
	if !exp.Port.Matches(o.Port) {
		return false
	}
	if !exp.Type.Matches(o.Type) {
		return false
	}
	if o.Publish != nil && !exp.Publish.Matches(*o.Publish) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

// Resource configuration for a service
type ConfigRunServiceResources struct {
	Compute *ConfigRunServiceResourcesCompute `json:"compute,omitempty" toml:"compute,omitempty"`

	Storage []*ConfigRunServiceResourcesStorage `json:"storage,omitempty" toml:"storage,omitempty"`
	// Number of replicas for a service
	Replicas uint8 `json:"replicas" toml:"replicas"`
}

func (o *ConfigRunServiceResources) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Compute != nil {
		m["compute"] = o.Compute
	}
	if o.Storage != nil {
		m["storage"] = o.Storage
	}
	m["replicas"] = o.Replicas
	return json.Marshal(m)
}

func (o *ConfigRunServiceResources) GetCompute() *ConfigRunServiceResourcesCompute {
	if o == nil {
		return nil
	}
	return o.Compute
}

func (o *ConfigRunServiceResources) GetStorage() []*ConfigRunServiceResourcesStorage {
	if o == nil {
		o = &ConfigRunServiceResources{}
	}
	return o.Storage
}

func (o *ConfigRunServiceResources) GetReplicas() uint8 {
	if o == nil {
		o = &ConfigRunServiceResources{}
	}
	return o.Replicas
}

type ConfigRunServiceResourcesUpdateInput struct {
	Compute       *ConfigRunServiceResourcesComputeUpdateInput   `json:"compute,omitempty" toml:"compute,omitempty"`
	IsSetCompute  bool                                           `json:"-"`
	Storage       []*ConfigRunServiceResourcesStorageUpdateInput `json:"storage,omitempty" toml:"storage,omitempty"`
	IsSetStorage  bool                                           `json:"-"`
	Replicas      *uint8                                         `json:"replicas,omitempty" toml:"replicas,omitempty"`
	IsSetReplicas bool                                           `json:"-"`
}

func (o *ConfigRunServiceResourcesUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if x, ok := m["compute"]; ok {
		if x != nil {
			t := &ConfigRunServiceResourcesComputeUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Compute = t
		}
		o.IsSetCompute = true
	}
	if v, ok := m["storage"]; ok {
		if v != nil {
			x, ok := v.([]interface{})
			if !ok {
				return fmt.Errorf("Storage must be []interface{}, got %T", v)
			}

			l := make([]*ConfigRunServiceResourcesStorageUpdateInput, len(x))
			for i, vv := range x {
				t := &ConfigRunServiceResourcesStorageUpdateInput{}
				if err := t.UnmarshalGQL(vv); err != nil {
					return err
				}
				l[i] = t
			}
			o.Storage = l
		}
		o.IsSetStorage = true
	}
	if v, ok := m["replicas"]; ok {
		if v == nil {
			o.Replicas = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x uint8
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Replicas = &x
		}
		o.IsSetReplicas = true
	}

	return nil
}

func (o *ConfigRunServiceResourcesUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigRunServiceResourcesUpdateInput) GetCompute() *ConfigRunServiceResourcesComputeUpdateInput {
	if o == nil {
		return nil
	}
	return o.Compute
}

func (o *ConfigRunServiceResourcesUpdateInput) GetStorage() []*ConfigRunServiceResourcesStorageUpdateInput {
	if o == nil {
		o = &ConfigRunServiceResourcesUpdateInput{}
	}
	return o.Storage
}

func (o *ConfigRunServiceResourcesUpdateInput) GetReplicas() *uint8 {
	if o == nil {
		o = &ConfigRunServiceResourcesUpdateInput{}
	}
	return o.Replicas
}

func (s *ConfigRunServiceResources) Update(v *ConfigRunServiceResourcesUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetCompute || v.Compute != nil {
		if v.Compute == nil {
			s.Compute = nil
		} else {
			if s.Compute == nil {
				s.Compute = &ConfigRunServiceResourcesCompute{}
			}
			s.Compute.Update(v.Compute)
		}
	}
	if v.IsSetStorage || v.Storage != nil {
		if v.Storage == nil {
			s.Storage = nil
		} else {
			s.Storage = make([]*ConfigRunServiceResourcesStorage, len(v.Storage))
			for i, e := range v.Storage {
				v := &ConfigRunServiceResourcesStorage{}
				v.Update(e)
				s.Storage[i] = v
			}
		}
	}
	if v.IsSetReplicas || v.Replicas != nil {
		if v.Replicas != nil {
			s.Replicas = *v.Replicas
		}
	}
}

type ConfigRunServiceResourcesInsertInput struct {
	Compute  *ConfigRunServiceResourcesComputeInsertInput   `json:"compute,omitempty" toml:"compute,omitempty"`
	Storage  []*ConfigRunServiceResourcesStorageInsertInput `json:"storage,omitempty" toml:"storage,omitempty"`
	Replicas uint8                                          `json:"replicas,omitempty" toml:"replicas,omitempty"`
}

func (o *ConfigRunServiceResourcesInsertInput) GetCompute() *ConfigRunServiceResourcesComputeInsertInput {
	if o == nil {
		return nil
	}
	return o.Compute
}

func (o *ConfigRunServiceResourcesInsertInput) GetStorage() []*ConfigRunServiceResourcesStorageInsertInput {
	if o == nil {
		o = &ConfigRunServiceResourcesInsertInput{}
	}
	return o.Storage
}

func (o *ConfigRunServiceResourcesInsertInput) GetReplicas() uint8 {
	if o == nil {
		o = &ConfigRunServiceResourcesInsertInput{}
	}
	return o.Replicas
}

func (s *ConfigRunServiceResources) Insert(v *ConfigRunServiceResourcesInsertInput) {
	if v.Compute != nil {
		if s.Compute == nil {
			s.Compute = &ConfigRunServiceResourcesCompute{}
		}
		s.Compute.Insert(v.Compute)
	}
	if v.Storage != nil {
		s.Storage = make([]*ConfigRunServiceResourcesStorage, len(v.Storage))
		for i, e := range v.Storage {
			v := &ConfigRunServiceResourcesStorage{}
			v.Insert(e)
			s.Storage[i] = v
		}
	}
	s.Replicas = v.Replicas
}

func (s *ConfigRunServiceResources) Clone() *ConfigRunServiceResources {
	if s == nil {
		return nil
	}

	v := &ConfigRunServiceResources{}
	v.Compute = s.Compute.Clone()
	if s.Storage != nil {
		v.Storage = make([]*ConfigRunServiceResourcesStorage, len(s.Storage))
		for i, e := range s.Storage {
			v.Storage[i] = e.Clone()
		}
	}
	v.Replicas = s.Replicas
	return v
}

type ConfigRunServiceResourcesComparisonExp struct {
	And      []*ConfigRunServiceResourcesComparisonExp      `json:"_and,omitempty"`
	Not      *ConfigRunServiceResourcesComparisonExp        `json:"_not,omitempty"`
	Or       []*ConfigRunServiceResourcesComparisonExp      `json:"_or,omitempty"`
	Compute  *ConfigRunServiceResourcesComputeComparisonExp `json:"compute,omitempty"`
	Storage  *ConfigRunServiceResourcesStorageComparisonExp `json:"storage,omitempty"`
	Replicas *ConfigUint8ComparisonExp                      `json:"replicas,omitempty"`
}

func (exp *ConfigRunServiceResourcesComparisonExp) Matches(o *ConfigRunServiceResources) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigRunServiceResources{
			Compute: &ConfigRunServiceResourcesCompute{},
			Storage: []*ConfigRunServiceResourcesStorage{},
		}
	}
	if !exp.Compute.Matches(o.Compute) {
		return false
	}
	{
		found := false
		for _, o := range o.Storage {
			if exp.Storage.Matches(o) {
				found = true
				break
			}
		}
		if !found && exp.Storage != nil {
			return false
		}
	}
	if !exp.Replicas.Matches(o.Replicas) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigRunServiceResourcesCompute struct {
	// milicpus, 1000 milicpus = 1 cpu
	Cpu uint32 `json:"cpu" toml:"cpu"`
	// MiB: 128MiB to 30GiB
	Memory uint32 `json:"memory" toml:"memory"`
}

func (o *ConfigRunServiceResourcesCompute) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	m["cpu"] = o.Cpu
	m["memory"] = o.Memory
	return json.Marshal(m)
}

func (o *ConfigRunServiceResourcesCompute) GetCpu() uint32 {
	if o == nil {
		o = &ConfigRunServiceResourcesCompute{}
	}
	return o.Cpu
}

func (o *ConfigRunServiceResourcesCompute) GetMemory() uint32 {
	if o == nil {
		o = &ConfigRunServiceResourcesCompute{}
	}
	return o.Memory
}

type ConfigRunServiceResourcesComputeUpdateInput struct {
	Cpu         *uint32 `json:"cpu,omitempty" toml:"cpu,omitempty"`
	IsSetCpu    bool    `json:"-"`
	Memory      *uint32 `json:"memory,omitempty" toml:"memory,omitempty"`
	IsSetMemory bool    `json:"-"`
}

func (o *ConfigRunServiceResourcesComputeUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["cpu"]; ok {
		if v == nil {
			o.Cpu = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x uint32
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Cpu = &x
		}
		o.IsSetCpu = true
	}
	if v, ok := m["memory"]; ok {
		if v == nil {
			o.Memory = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x uint32
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Memory = &x
		}
		o.IsSetMemory = true
	}

	return nil
}

func (o *ConfigRunServiceResourcesComputeUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigRunServiceResourcesComputeUpdateInput) GetCpu() *uint32 {
	if o == nil {
		o = &ConfigRunServiceResourcesComputeUpdateInput{}
	}
	return o.Cpu
}

func (o *ConfigRunServiceResourcesComputeUpdateInput) GetMemory() *uint32 {
	if o == nil {
		o = &ConfigRunServiceResourcesComputeUpdateInput{}
	}
	return o.Memory
}

func (s *ConfigRunServiceResourcesCompute) Update(v *ConfigRunServiceResourcesComputeUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetCpu || v.Cpu != nil {
		if v.Cpu != nil {
			s.Cpu = *v.Cpu
		}
	}
	if v.IsSetMemory || v.Memory != nil {
		if v.Memory != nil {
			s.Memory = *v.Memory
		}
	}
}

type ConfigRunServiceResourcesComputeInsertInput struct {
	Cpu    uint32 `json:"cpu,omitempty" toml:"cpu,omitempty"`
	Memory uint32 `json:"memory,omitempty" toml:"memory,omitempty"`
}

func (o *ConfigRunServiceResourcesComputeInsertInput) GetCpu() uint32 {
	if o == nil {
		o = &ConfigRunServiceResourcesComputeInsertInput{}
	}
	return o.Cpu
}

func (o *ConfigRunServiceResourcesComputeInsertInput) GetMemory() uint32 {
	if o == nil {
		o = &ConfigRunServiceResourcesComputeInsertInput{}
	}
	return o.Memory
}

func (s *ConfigRunServiceResourcesCompute) Insert(v *ConfigRunServiceResourcesComputeInsertInput) {
	s.Cpu = v.Cpu
	s.Memory = v.Memory
}

func (s *ConfigRunServiceResourcesCompute) Clone() *ConfigRunServiceResourcesCompute {
	if s == nil {
		return nil
	}

	v := &ConfigRunServiceResourcesCompute{}
	v.Cpu = s.Cpu
	v.Memory = s.Memory
	return v
}

type ConfigRunServiceResourcesComputeComparisonExp struct {
	And    []*ConfigRunServiceResourcesComputeComparisonExp `json:"_and,omitempty"`
	Not    *ConfigRunServiceResourcesComputeComparisonExp   `json:"_not,omitempty"`
	Or     []*ConfigRunServiceResourcesComputeComparisonExp `json:"_or,omitempty"`
	Cpu    *ConfigUint32ComparisonExp                       `json:"cpu,omitempty"`
	Memory *ConfigUint32ComparisonExp                       `json:"memory,omitempty"`
}

func (exp *ConfigRunServiceResourcesComputeComparisonExp) Matches(o *ConfigRunServiceResourcesCompute) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigRunServiceResourcesCompute{}
	}
	if !exp.Cpu.Matches(o.Cpu) {
		return false
	}
	if !exp.Memory.Matches(o.Memory) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigRunServiceResourcesStorage struct {
	// name of the volume, changing it will cause data loss
	Name string `json:"name" toml:"name"`
	// GiB
	Capacity uint32 `json:"capacity" toml:"capacity"`

	Path string `json:"path" toml:"path"`
}

func (o *ConfigRunServiceResourcesStorage) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	m["name"] = o.Name
	m["capacity"] = o.Capacity
	m["path"] = o.Path
	return json.Marshal(m)
}

func (o *ConfigRunServiceResourcesStorage) GetName() string {
	if o == nil {
		o = &ConfigRunServiceResourcesStorage{}
	}
	return o.Name
}

func (o *ConfigRunServiceResourcesStorage) GetCapacity() uint32 {
	if o == nil {
		o = &ConfigRunServiceResourcesStorage{}
	}
	return o.Capacity
}

func (o *ConfigRunServiceResourcesStorage) GetPath() string {
	if o == nil {
		o = &ConfigRunServiceResourcesStorage{}
	}
	return o.Path
}

type ConfigRunServiceResourcesStorageUpdateInput struct {
	Name          *string `json:"name,omitempty" toml:"name,omitempty"`
	IsSetName     bool    `json:"-"`
	Capacity      *uint32 `json:"capacity,omitempty" toml:"capacity,omitempty"`
	IsSetCapacity bool    `json:"-"`
	Path          *string `json:"path,omitempty" toml:"path,omitempty"`
	IsSetPath     bool    `json:"-"`
}

func (o *ConfigRunServiceResourcesStorageUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["name"]; ok {
		if v == nil {
			o.Name = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Name = &x
		}
		o.IsSetName = true
	}
	if v, ok := m["capacity"]; ok {
		if v == nil {
			o.Capacity = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x uint32
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Capacity = &x
		}
		o.IsSetCapacity = true
	}
	if v, ok := m["path"]; ok {
		if v == nil {
			o.Path = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Path = &x
		}
		o.IsSetPath = true
	}

	return nil
}

func (o *ConfigRunServiceResourcesStorageUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigRunServiceResourcesStorageUpdateInput) GetName() *string {
	if o == nil {
		o = &ConfigRunServiceResourcesStorageUpdateInput{}
	}
	return o.Name
}

func (o *ConfigRunServiceResourcesStorageUpdateInput) GetCapacity() *uint32 {
	if o == nil {
		o = &ConfigRunServiceResourcesStorageUpdateInput{}
	}
	return o.Capacity
}

func (o *ConfigRunServiceResourcesStorageUpdateInput) GetPath() *string {
	if o == nil {
		o = &ConfigRunServiceResourcesStorageUpdateInput{}
	}
	return o.Path
}

func (s *ConfigRunServiceResourcesStorage) Update(v *ConfigRunServiceResourcesStorageUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetName || v.Name != nil {
		if v.Name != nil {
			s.Name = *v.Name
		}
	}
	if v.IsSetCapacity || v.Capacity != nil {
		if v.Capacity != nil {
			s.Capacity = *v.Capacity
		}
	}
	if v.IsSetPath || v.Path != nil {
		if v.Path != nil {
			s.Path = *v.Path
		}
	}
}

type ConfigRunServiceResourcesStorageInsertInput struct {
	Name     string `json:"name,omitempty" toml:"name,omitempty"`
	Capacity uint32 `json:"capacity,omitempty" toml:"capacity,omitempty"`
	Path     string `json:"path,omitempty" toml:"path,omitempty"`
}

func (o *ConfigRunServiceResourcesStorageInsertInput) GetName() string {
	if o == nil {
		o = &ConfigRunServiceResourcesStorageInsertInput{}
	}
	return o.Name
}

func (o *ConfigRunServiceResourcesStorageInsertInput) GetCapacity() uint32 {
	if o == nil {
		o = &ConfigRunServiceResourcesStorageInsertInput{}
	}
	return o.Capacity
}

func (o *ConfigRunServiceResourcesStorageInsertInput) GetPath() string {
	if o == nil {
		o = &ConfigRunServiceResourcesStorageInsertInput{}
	}
	return o.Path
}

func (s *ConfigRunServiceResourcesStorage) Insert(v *ConfigRunServiceResourcesStorageInsertInput) {
	s.Name = v.Name
	s.Capacity = v.Capacity
	s.Path = v.Path
}

func (s *ConfigRunServiceResourcesStorage) Clone() *ConfigRunServiceResourcesStorage {
	if s == nil {
		return nil
	}

	v := &ConfigRunServiceResourcesStorage{}
	v.Name = s.Name
	v.Capacity = s.Capacity
	v.Path = s.Path
	return v
}

type ConfigRunServiceResourcesStorageComparisonExp struct {
	And      []*ConfigRunServiceResourcesStorageComparisonExp `json:"_and,omitempty"`
	Not      *ConfigRunServiceResourcesStorageComparisonExp   `json:"_not,omitempty"`
	Or       []*ConfigRunServiceResourcesStorageComparisonExp `json:"_or,omitempty"`
	Name     *ConfigStringComparisonExp                       `json:"name,omitempty"`
	Capacity *ConfigUint32ComparisonExp                       `json:"capacity,omitempty"`
	Path     *ConfigStringComparisonExp                       `json:"path,omitempty"`
}

func (exp *ConfigRunServiceResourcesStorageComparisonExp) Matches(o *ConfigRunServiceResourcesStorage) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigRunServiceResourcesStorage{}
	}
	if !exp.Name.Matches(o.Name) {
		return false
	}
	if !exp.Capacity.Matches(o.Capacity) {
		return false
	}
	if !exp.Path.Matches(o.Path) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigSms struct {
	Provider *string `json:"provider" toml:"provider"`

	AccountSid string `json:"accountSid" toml:"accountSid"`

	AuthToken string `json:"authToken" toml:"authToken"`

	MessagingServiceId string `json:"messagingServiceId" toml:"messagingServiceId"`
}

func (o *ConfigSms) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Provider != nil {
		m["provider"] = o.Provider
	}
	m["accountSid"] = o.AccountSid
	m["authToken"] = o.AuthToken
	m["messagingServiceId"] = o.MessagingServiceId
	return json.Marshal(m)
}

func (o *ConfigSms) GetProvider() *string {
	if o == nil {
		o = &ConfigSms{}
	}
	return o.Provider
}

func (o *ConfigSms) GetAccountSid() string {
	if o == nil {
		o = &ConfigSms{}
	}
	return o.AccountSid
}

func (o *ConfigSms) GetAuthToken() string {
	if o == nil {
		o = &ConfigSms{}
	}
	return o.AuthToken
}

func (o *ConfigSms) GetMessagingServiceId() string {
	if o == nil {
		o = &ConfigSms{}
	}
	return o.MessagingServiceId
}

type ConfigSmsUpdateInput struct {
	Provider                *string `json:"provider,omitempty" toml:"provider,omitempty"`
	IsSetProvider           bool    `json:"-"`
	AccountSid              *string `json:"accountSid,omitempty" toml:"accountSid,omitempty"`
	IsSetAccountSid         bool    `json:"-"`
	AuthToken               *string `json:"authToken,omitempty" toml:"authToken,omitempty"`
	IsSetAuthToken          bool    `json:"-"`
	MessagingServiceId      *string `json:"messagingServiceId,omitempty" toml:"messagingServiceId,omitempty"`
	IsSetMessagingServiceId bool    `json:"-"`
}

func (o *ConfigSmsUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["provider"]; ok {
		if v == nil {
			o.Provider = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Provider = &x
		}
		o.IsSetProvider = true
	}
	if v, ok := m["accountSid"]; ok {
		if v == nil {
			o.AccountSid = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.AccountSid = &x
		}
		o.IsSetAccountSid = true
	}
	if v, ok := m["authToken"]; ok {
		if v == nil {
			o.AuthToken = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.AuthToken = &x
		}
		o.IsSetAuthToken = true
	}
	if v, ok := m["messagingServiceId"]; ok {
		if v == nil {
			o.MessagingServiceId = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.MessagingServiceId = &x
		}
		o.IsSetMessagingServiceId = true
	}

	return nil
}

func (o *ConfigSmsUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigSmsUpdateInput) GetProvider() *string {
	if o == nil {
		o = &ConfigSmsUpdateInput{}
	}
	return o.Provider
}

func (o *ConfigSmsUpdateInput) GetAccountSid() *string {
	if o == nil {
		o = &ConfigSmsUpdateInput{}
	}
	return o.AccountSid
}

func (o *ConfigSmsUpdateInput) GetAuthToken() *string {
	if o == nil {
		o = &ConfigSmsUpdateInput{}
	}
	return o.AuthToken
}

func (o *ConfigSmsUpdateInput) GetMessagingServiceId() *string {
	if o == nil {
		o = &ConfigSmsUpdateInput{}
	}
	return o.MessagingServiceId
}

func (s *ConfigSms) Update(v *ConfigSmsUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetProvider || v.Provider != nil {
		s.Provider = v.Provider
	}
	if v.IsSetAccountSid || v.AccountSid != nil {
		if v.AccountSid != nil {
			s.AccountSid = *v.AccountSid
		}
	}
	if v.IsSetAuthToken || v.AuthToken != nil {
		if v.AuthToken != nil {
			s.AuthToken = *v.AuthToken
		}
	}
	if v.IsSetMessagingServiceId || v.MessagingServiceId != nil {
		if v.MessagingServiceId != nil {
			s.MessagingServiceId = *v.MessagingServiceId
		}
	}
}

type ConfigSmsInsertInput struct {
	Provider           *string `json:"provider,omitempty" toml:"provider,omitempty"`
	AccountSid         string  `json:"accountSid,omitempty" toml:"accountSid,omitempty"`
	AuthToken          string  `json:"authToken,omitempty" toml:"authToken,omitempty"`
	MessagingServiceId string  `json:"messagingServiceId,omitempty" toml:"messagingServiceId,omitempty"`
}

func (o *ConfigSmsInsertInput) GetProvider() *string {
	if o == nil {
		o = &ConfigSmsInsertInput{}
	}
	return o.Provider
}

func (o *ConfigSmsInsertInput) GetAccountSid() string {
	if o == nil {
		o = &ConfigSmsInsertInput{}
	}
	return o.AccountSid
}

func (o *ConfigSmsInsertInput) GetAuthToken() string {
	if o == nil {
		o = &ConfigSmsInsertInput{}
	}
	return o.AuthToken
}

func (o *ConfigSmsInsertInput) GetMessagingServiceId() string {
	if o == nil {
		o = &ConfigSmsInsertInput{}
	}
	return o.MessagingServiceId
}

func (s *ConfigSms) Insert(v *ConfigSmsInsertInput) {
	s.Provider = v.Provider
	s.AccountSid = v.AccountSid
	s.AuthToken = v.AuthToken
	s.MessagingServiceId = v.MessagingServiceId
}

func (s *ConfigSms) Clone() *ConfigSms {
	if s == nil {
		return nil
	}

	v := &ConfigSms{}
	v.Provider = s.Provider
	v.AccountSid = s.AccountSid
	v.AuthToken = s.AuthToken
	v.MessagingServiceId = s.MessagingServiceId
	return v
}

type ConfigSmsComparisonExp struct {
	And                []*ConfigSmsComparisonExp  `json:"_and,omitempty"`
	Not                *ConfigSmsComparisonExp    `json:"_not,omitempty"`
	Or                 []*ConfigSmsComparisonExp  `json:"_or,omitempty"`
	Provider           *ConfigStringComparisonExp `json:"provider,omitempty"`
	AccountSid         *ConfigStringComparisonExp `json:"accountSid,omitempty"`
	AuthToken          *ConfigStringComparisonExp `json:"authToken,omitempty"`
	MessagingServiceId *ConfigStringComparisonExp `json:"messagingServiceId,omitempty"`
}

func (exp *ConfigSmsComparisonExp) Matches(o *ConfigSms) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigSms{}
	}
	if o.Provider != nil && !exp.Provider.Matches(*o.Provider) {
		return false
	}
	if !exp.AccountSid.Matches(o.AccountSid) {
		return false
	}
	if !exp.AuthToken.Matches(o.AuthToken) {
		return false
	}
	if !exp.MessagingServiceId.Matches(o.MessagingServiceId) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigSmtp struct {
	User string `json:"user" toml:"user"`

	Password string `json:"password" toml:"password"`

	Sender string `json:"sender" toml:"sender"`

	Host string `json:"host" toml:"host"`

	Port uint16 `json:"port" toml:"port"`

	Secure bool `json:"secure" toml:"secure"`

	Method string `json:"method" toml:"method"`
}

func (o *ConfigSmtp) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	m["user"] = o.User
	m["password"] = o.Password
	m["sender"] = o.Sender
	m["host"] = o.Host
	m["port"] = o.Port
	m["secure"] = o.Secure
	m["method"] = o.Method
	return json.Marshal(m)
}

func (o *ConfigSmtp) GetUser() string {
	if o == nil {
		o = &ConfigSmtp{}
	}
	return o.User
}

func (o *ConfigSmtp) GetPassword() string {
	if o == nil {
		o = &ConfigSmtp{}
	}
	return o.Password
}

func (o *ConfigSmtp) GetSender() string {
	if o == nil {
		o = &ConfigSmtp{}
	}
	return o.Sender
}

func (o *ConfigSmtp) GetHost() string {
	if o == nil {
		o = &ConfigSmtp{}
	}
	return o.Host
}

func (o *ConfigSmtp) GetPort() uint16 {
	if o == nil {
		o = &ConfigSmtp{}
	}
	return o.Port
}

func (o *ConfigSmtp) GetSecure() bool {
	if o == nil {
		o = &ConfigSmtp{}
	}
	return o.Secure
}

func (o *ConfigSmtp) GetMethod() string {
	if o == nil {
		o = &ConfigSmtp{}
	}
	return o.Method
}

type ConfigSmtpUpdateInput struct {
	User          *string `json:"user,omitempty" toml:"user,omitempty"`
	IsSetUser     bool    `json:"-"`
	Password      *string `json:"password,omitempty" toml:"password,omitempty"`
	IsSetPassword bool    `json:"-"`
	Sender        *string `json:"sender,omitempty" toml:"sender,omitempty"`
	IsSetSender   bool    `json:"-"`
	Host          *string `json:"host,omitempty" toml:"host,omitempty"`
	IsSetHost     bool    `json:"-"`
	Port          *uint16 `json:"port,omitempty" toml:"port,omitempty"`
	IsSetPort     bool    `json:"-"`
	Secure        *bool   `json:"secure,omitempty" toml:"secure,omitempty"`
	IsSetSecure   bool    `json:"-"`
	Method        *string `json:"method,omitempty" toml:"method,omitempty"`
	IsSetMethod   bool    `json:"-"`
}

func (o *ConfigSmtpUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["user"]; ok {
		if v == nil {
			o.User = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.User = &x
		}
		o.IsSetUser = true
	}
	if v, ok := m["password"]; ok {
		if v == nil {
			o.Password = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Password = &x
		}
		o.IsSetPassword = true
	}
	if v, ok := m["sender"]; ok {
		if v == nil {
			o.Sender = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Sender = &x
		}
		o.IsSetSender = true
	}
	if v, ok := m["host"]; ok {
		if v == nil {
			o.Host = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Host = &x
		}
		o.IsSetHost = true
	}
	if v, ok := m["port"]; ok {
		if v == nil {
			o.Port = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x uint16
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Port = &x
		}
		o.IsSetPort = true
	}
	if v, ok := m["secure"]; ok {
		if v == nil {
			o.Secure = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x bool
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Secure = &x
		}
		o.IsSetSecure = true
	}
	if v, ok := m["method"]; ok {
		if v == nil {
			o.Method = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Method = &x
		}
		o.IsSetMethod = true
	}

	return nil
}

func (o *ConfigSmtpUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigSmtpUpdateInput) GetUser() *string {
	if o == nil {
		o = &ConfigSmtpUpdateInput{}
	}
	return o.User
}

func (o *ConfigSmtpUpdateInput) GetPassword() *string {
	if o == nil {
		o = &ConfigSmtpUpdateInput{}
	}
	return o.Password
}

func (o *ConfigSmtpUpdateInput) GetSender() *string {
	if o == nil {
		o = &ConfigSmtpUpdateInput{}
	}
	return o.Sender
}

func (o *ConfigSmtpUpdateInput) GetHost() *string {
	if o == nil {
		o = &ConfigSmtpUpdateInput{}
	}
	return o.Host
}

func (o *ConfigSmtpUpdateInput) GetPort() *uint16 {
	if o == nil {
		o = &ConfigSmtpUpdateInput{}
	}
	return o.Port
}

func (o *ConfigSmtpUpdateInput) GetSecure() *bool {
	if o == nil {
		o = &ConfigSmtpUpdateInput{}
	}
	return o.Secure
}

func (o *ConfigSmtpUpdateInput) GetMethod() *string {
	if o == nil {
		o = &ConfigSmtpUpdateInput{}
	}
	return o.Method
}

func (s *ConfigSmtp) Update(v *ConfigSmtpUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetUser || v.User != nil {
		if v.User != nil {
			s.User = *v.User
		}
	}
	if v.IsSetPassword || v.Password != nil {
		if v.Password != nil {
			s.Password = *v.Password
		}
	}
	if v.IsSetSender || v.Sender != nil {
		if v.Sender != nil {
			s.Sender = *v.Sender
		}
	}
	if v.IsSetHost || v.Host != nil {
		if v.Host != nil {
			s.Host = *v.Host
		}
	}
	if v.IsSetPort || v.Port != nil {
		if v.Port != nil {
			s.Port = *v.Port
		}
	}
	if v.IsSetSecure || v.Secure != nil {
		if v.Secure != nil {
			s.Secure = *v.Secure
		}
	}
	if v.IsSetMethod || v.Method != nil {
		if v.Method != nil {
			s.Method = *v.Method
		}
	}
}

type ConfigSmtpInsertInput struct {
	User     string `json:"user,omitempty" toml:"user,omitempty"`
	Password string `json:"password,omitempty" toml:"password,omitempty"`
	Sender   string `json:"sender,omitempty" toml:"sender,omitempty"`
	Host     string `json:"host,omitempty" toml:"host,omitempty"`
	Port     uint16 `json:"port,omitempty" toml:"port,omitempty"`
	Secure   bool   `json:"secure,omitempty" toml:"secure,omitempty"`
	Method   string `json:"method,omitempty" toml:"method,omitempty"`
}

func (o *ConfigSmtpInsertInput) GetUser() string {
	if o == nil {
		o = &ConfigSmtpInsertInput{}
	}
	return o.User
}

func (o *ConfigSmtpInsertInput) GetPassword() string {
	if o == nil {
		o = &ConfigSmtpInsertInput{}
	}
	return o.Password
}

func (o *ConfigSmtpInsertInput) GetSender() string {
	if o == nil {
		o = &ConfigSmtpInsertInput{}
	}
	return o.Sender
}

func (o *ConfigSmtpInsertInput) GetHost() string {
	if o == nil {
		o = &ConfigSmtpInsertInput{}
	}
	return o.Host
}

func (o *ConfigSmtpInsertInput) GetPort() uint16 {
	if o == nil {
		o = &ConfigSmtpInsertInput{}
	}
	return o.Port
}

func (o *ConfigSmtpInsertInput) GetSecure() bool {
	if o == nil {
		o = &ConfigSmtpInsertInput{}
	}
	return o.Secure
}

func (o *ConfigSmtpInsertInput) GetMethod() string {
	if o == nil {
		o = &ConfigSmtpInsertInput{}
	}
	return o.Method
}

func (s *ConfigSmtp) Insert(v *ConfigSmtpInsertInput) {
	s.User = v.User
	s.Password = v.Password
	s.Sender = v.Sender
	s.Host = v.Host
	s.Port = v.Port
	s.Secure = v.Secure
	s.Method = v.Method
}

func (s *ConfigSmtp) Clone() *ConfigSmtp {
	if s == nil {
		return nil
	}

	v := &ConfigSmtp{}
	v.User = s.User
	v.Password = s.Password
	v.Sender = s.Sender
	v.Host = s.Host
	v.Port = s.Port
	v.Secure = s.Secure
	v.Method = s.Method
	return v
}

type ConfigSmtpComparisonExp struct {
	And      []*ConfigSmtpComparisonExp  `json:"_and,omitempty"`
	Not      *ConfigSmtpComparisonExp    `json:"_not,omitempty"`
	Or       []*ConfigSmtpComparisonExp  `json:"_or,omitempty"`
	User     *ConfigStringComparisonExp  `json:"user,omitempty"`
	Password *ConfigStringComparisonExp  `json:"password,omitempty"`
	Sender   *ConfigStringComparisonExp  `json:"sender,omitempty"`
	Host     *ConfigStringComparisonExp  `json:"host,omitempty"`
	Port     *ConfigPortComparisonExp    `json:"port,omitempty"`
	Secure   *ConfigBooleanComparisonExp `json:"secure,omitempty"`
	Method   *ConfigStringComparisonExp  `json:"method,omitempty"`
}

func (exp *ConfigSmtpComparisonExp) Matches(o *ConfigSmtp) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigSmtp{}
	}
	if !exp.User.Matches(o.User) {
		return false
	}
	if !exp.Password.Matches(o.Password) {
		return false
	}
	if !exp.Sender.Matches(o.Sender) {
		return false
	}
	if !exp.Host.Matches(o.Host) {
		return false
	}
	if !exp.Port.Matches(o.Port) {
		return false
	}
	if !exp.Secure.Matches(o.Secure) {
		return false
	}
	if !exp.Method.Matches(o.Method) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigStandardOauthProvider struct {
	Enabled *bool `json:"enabled" toml:"enabled"`

	ClientId *string `json:"clientId" toml:"clientId"`

	ClientSecret *string `json:"clientSecret" toml:"clientSecret"`
}

func (o *ConfigStandardOauthProvider) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Enabled != nil {
		m["enabled"] = o.Enabled
	}
	if o.ClientId != nil {
		m["clientId"] = o.ClientId
	}
	if o.ClientSecret != nil {
		m["clientSecret"] = o.ClientSecret
	}
	return json.Marshal(m)
}

func (o *ConfigStandardOauthProvider) GetEnabled() *bool {
	if o == nil {
		o = &ConfigStandardOauthProvider{}
	}
	return o.Enabled
}

func (o *ConfigStandardOauthProvider) GetClientId() *string {
	if o == nil {
		o = &ConfigStandardOauthProvider{}
	}
	return o.ClientId
}

func (o *ConfigStandardOauthProvider) GetClientSecret() *string {
	if o == nil {
		o = &ConfigStandardOauthProvider{}
	}
	return o.ClientSecret
}

type ConfigStandardOauthProviderUpdateInput struct {
	Enabled           *bool   `json:"enabled,omitempty" toml:"enabled,omitempty"`
	IsSetEnabled      bool    `json:"-"`
	ClientId          *string `json:"clientId,omitempty" toml:"clientId,omitempty"`
	IsSetClientId     bool    `json:"-"`
	ClientSecret      *string `json:"clientSecret,omitempty" toml:"clientSecret,omitempty"`
	IsSetClientSecret bool    `json:"-"`
}

func (o *ConfigStandardOauthProviderUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["enabled"]; ok {
		if v == nil {
			o.Enabled = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x bool
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Enabled = &x
		}
		o.IsSetEnabled = true
	}
	if v, ok := m["clientId"]; ok {
		if v == nil {
			o.ClientId = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.ClientId = &x
		}
		o.IsSetClientId = true
	}
	if v, ok := m["clientSecret"]; ok {
		if v == nil {
			o.ClientSecret = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.ClientSecret = &x
		}
		o.IsSetClientSecret = true
	}

	return nil
}

func (o *ConfigStandardOauthProviderUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigStandardOauthProviderUpdateInput) GetEnabled() *bool {
	if o == nil {
		o = &ConfigStandardOauthProviderUpdateInput{}
	}
	return o.Enabled
}

func (o *ConfigStandardOauthProviderUpdateInput) GetClientId() *string {
	if o == nil {
		o = &ConfigStandardOauthProviderUpdateInput{}
	}
	return o.ClientId
}

func (o *ConfigStandardOauthProviderUpdateInput) GetClientSecret() *string {
	if o == nil {
		o = &ConfigStandardOauthProviderUpdateInput{}
	}
	return o.ClientSecret
}

func (s *ConfigStandardOauthProvider) Update(v *ConfigStandardOauthProviderUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetEnabled || v.Enabled != nil {
		s.Enabled = v.Enabled
	}
	if v.IsSetClientId || v.ClientId != nil {
		s.ClientId = v.ClientId
	}
	if v.IsSetClientSecret || v.ClientSecret != nil {
		s.ClientSecret = v.ClientSecret
	}
}

type ConfigStandardOauthProviderInsertInput struct {
	Enabled      *bool   `json:"enabled,omitempty" toml:"enabled,omitempty"`
	ClientId     *string `json:"clientId,omitempty" toml:"clientId,omitempty"`
	ClientSecret *string `json:"clientSecret,omitempty" toml:"clientSecret,omitempty"`
}

func (o *ConfigStandardOauthProviderInsertInput) GetEnabled() *bool {
	if o == nil {
		o = &ConfigStandardOauthProviderInsertInput{}
	}
	return o.Enabled
}

func (o *ConfigStandardOauthProviderInsertInput) GetClientId() *string {
	if o == nil {
		o = &ConfigStandardOauthProviderInsertInput{}
	}
	return o.ClientId
}

func (o *ConfigStandardOauthProviderInsertInput) GetClientSecret() *string {
	if o == nil {
		o = &ConfigStandardOauthProviderInsertInput{}
	}
	return o.ClientSecret
}

func (s *ConfigStandardOauthProvider) Insert(v *ConfigStandardOauthProviderInsertInput) {
	s.Enabled = v.Enabled
	s.ClientId = v.ClientId
	s.ClientSecret = v.ClientSecret
}

func (s *ConfigStandardOauthProvider) Clone() *ConfigStandardOauthProvider {
	if s == nil {
		return nil
	}

	v := &ConfigStandardOauthProvider{}
	v.Enabled = s.Enabled
	v.ClientId = s.ClientId
	v.ClientSecret = s.ClientSecret
	return v
}

type ConfigStandardOauthProviderComparisonExp struct {
	And          []*ConfigStandardOauthProviderComparisonExp `json:"_and,omitempty"`
	Not          *ConfigStandardOauthProviderComparisonExp   `json:"_not,omitempty"`
	Or           []*ConfigStandardOauthProviderComparisonExp `json:"_or,omitempty"`
	Enabled      *ConfigBooleanComparisonExp                 `json:"enabled,omitempty"`
	ClientId     *ConfigStringComparisonExp                  `json:"clientId,omitempty"`
	ClientSecret *ConfigStringComparisonExp                  `json:"clientSecret,omitempty"`
}

func (exp *ConfigStandardOauthProviderComparisonExp) Matches(o *ConfigStandardOauthProvider) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigStandardOauthProvider{}
	}
	if o.Enabled != nil && !exp.Enabled.Matches(*o.Enabled) {
		return false
	}
	if o.ClientId != nil && !exp.ClientId.Matches(*o.ClientId) {
		return false
	}
	if o.ClientSecret != nil && !exp.ClientSecret.Matches(*o.ClientSecret) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigStandardOauthProviderWithScope struct {
	Enabled *bool `json:"enabled" toml:"enabled"`

	ClientId *string `json:"clientId" toml:"clientId"`

	Scope []string `json:"scope,omitempty" toml:"scope,omitempty"`

	ClientSecret *string `json:"clientSecret" toml:"clientSecret"`
}

func (o *ConfigStandardOauthProviderWithScope) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Enabled != nil {
		m["enabled"] = o.Enabled
	}
	if o.ClientId != nil {
		m["clientId"] = o.ClientId
	}
	if o.Scope != nil {
		m["scope"] = o.Scope
	}
	if o.ClientSecret != nil {
		m["clientSecret"] = o.ClientSecret
	}
	return json.Marshal(m)
}

func (o *ConfigStandardOauthProviderWithScope) GetEnabled() *bool {
	if o == nil {
		o = &ConfigStandardOauthProviderWithScope{}
	}
	return o.Enabled
}

func (o *ConfigStandardOauthProviderWithScope) GetClientId() *string {
	if o == nil {
		o = &ConfigStandardOauthProviderWithScope{}
	}
	return o.ClientId
}

func (o *ConfigStandardOauthProviderWithScope) GetScope() []string {
	if o == nil {
		o = &ConfigStandardOauthProviderWithScope{}
	}
	return o.Scope
}

func (o *ConfigStandardOauthProviderWithScope) GetClientSecret() *string {
	if o == nil {
		o = &ConfigStandardOauthProviderWithScope{}
	}
	return o.ClientSecret
}

type ConfigStandardOauthProviderWithScopeUpdateInput struct {
	Enabled           *bool    `json:"enabled,omitempty" toml:"enabled,omitempty"`
	IsSetEnabled      bool     `json:"-"`
	ClientId          *string  `json:"clientId,omitempty" toml:"clientId,omitempty"`
	IsSetClientId     bool     `json:"-"`
	Scope             []string `json:"scope,omitempty" toml:"scope,omitempty"`
	IsSetScope        bool     `json:"-"`
	ClientSecret      *string  `json:"clientSecret,omitempty" toml:"clientSecret,omitempty"`
	IsSetClientSecret bool     `json:"-"`
}

func (o *ConfigStandardOauthProviderWithScopeUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["enabled"]; ok {
		if v == nil {
			o.Enabled = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x bool
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Enabled = &x
		}
		o.IsSetEnabled = true
	}
	if v, ok := m["clientId"]; ok {
		if v == nil {
			o.ClientId = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.ClientId = &x
		}
		o.IsSetClientId = true
	}
	if v, ok := m["scope"]; ok {
		if v != nil {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var l []string
			if err := json.Unmarshal(b, &l); err != nil {
				return err
			}
			o.Scope = l
		}
		o.IsSetScope = true
	}
	if v, ok := m["clientSecret"]; ok {
		if v == nil {
			o.ClientSecret = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.ClientSecret = &x
		}
		o.IsSetClientSecret = true
	}

	return nil
}

func (o *ConfigStandardOauthProviderWithScopeUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigStandardOauthProviderWithScopeUpdateInput) GetEnabled() *bool {
	if o == nil {
		o = &ConfigStandardOauthProviderWithScopeUpdateInput{}
	}
	return o.Enabled
}

func (o *ConfigStandardOauthProviderWithScopeUpdateInput) GetClientId() *string {
	if o == nil {
		o = &ConfigStandardOauthProviderWithScopeUpdateInput{}
	}
	return o.ClientId
}

func (o *ConfigStandardOauthProviderWithScopeUpdateInput) GetScope() []string {
	if o == nil {
		o = &ConfigStandardOauthProviderWithScopeUpdateInput{}
	}
	return o.Scope
}

func (o *ConfigStandardOauthProviderWithScopeUpdateInput) GetClientSecret() *string {
	if o == nil {
		o = &ConfigStandardOauthProviderWithScopeUpdateInput{}
	}
	return o.ClientSecret
}

func (s *ConfigStandardOauthProviderWithScope) Update(v *ConfigStandardOauthProviderWithScopeUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetEnabled || v.Enabled != nil {
		s.Enabled = v.Enabled
	}
	if v.IsSetClientId || v.ClientId != nil {
		s.ClientId = v.ClientId
	}
	if v.IsSetScope || v.Scope != nil {
		if v.Scope == nil {
			s.Scope = nil
		} else {
			s.Scope = make([]string, len(v.Scope))
			for i, e := range v.Scope {
				s.Scope[i] = e
			}
		}
	}
	if v.IsSetClientSecret || v.ClientSecret != nil {
		s.ClientSecret = v.ClientSecret
	}
}

type ConfigStandardOauthProviderWithScopeInsertInput struct {
	Enabled      *bool    `json:"enabled,omitempty" toml:"enabled,omitempty"`
	ClientId     *string  `json:"clientId,omitempty" toml:"clientId,omitempty"`
	Scope        []string `json:"scope,omitempty" toml:"scope,omitempty"`
	ClientSecret *string  `json:"clientSecret,omitempty" toml:"clientSecret,omitempty"`
}

func (o *ConfigStandardOauthProviderWithScopeInsertInput) GetEnabled() *bool {
	if o == nil {
		o = &ConfigStandardOauthProviderWithScopeInsertInput{}
	}
	return o.Enabled
}

func (o *ConfigStandardOauthProviderWithScopeInsertInput) GetClientId() *string {
	if o == nil {
		o = &ConfigStandardOauthProviderWithScopeInsertInput{}
	}
	return o.ClientId
}

func (o *ConfigStandardOauthProviderWithScopeInsertInput) GetScope() []string {
	if o == nil {
		o = &ConfigStandardOauthProviderWithScopeInsertInput{}
	}
	return o.Scope
}

func (o *ConfigStandardOauthProviderWithScopeInsertInput) GetClientSecret() *string {
	if o == nil {
		o = &ConfigStandardOauthProviderWithScopeInsertInput{}
	}
	return o.ClientSecret
}

func (s *ConfigStandardOauthProviderWithScope) Insert(v *ConfigStandardOauthProviderWithScopeInsertInput) {
	s.Enabled = v.Enabled
	s.ClientId = v.ClientId
	if v.Scope != nil {
		s.Scope = make([]string, len(v.Scope))
		for i, e := range v.Scope {
			s.Scope[i] = e
		}
	}
	s.ClientSecret = v.ClientSecret
}

func (s *ConfigStandardOauthProviderWithScope) Clone() *ConfigStandardOauthProviderWithScope {
	if s == nil {
		return nil
	}

	v := &ConfigStandardOauthProviderWithScope{}
	v.Enabled = s.Enabled
	v.ClientId = s.ClientId
	if s.Scope != nil {
		v.Scope = make([]string, len(s.Scope))
		copy(v.Scope, s.Scope)
	}
	v.ClientSecret = s.ClientSecret
	return v
}

type ConfigStandardOauthProviderWithScopeComparisonExp struct {
	And          []*ConfigStandardOauthProviderWithScopeComparisonExp `json:"_and,omitempty"`
	Not          *ConfigStandardOauthProviderWithScopeComparisonExp   `json:"_not,omitempty"`
	Or           []*ConfigStandardOauthProviderWithScopeComparisonExp `json:"_or,omitempty"`
	Enabled      *ConfigBooleanComparisonExp                          `json:"enabled,omitempty"`
	ClientId     *ConfigStringComparisonExp                           `json:"clientId,omitempty"`
	Scope        *ConfigStringComparisonExp                           `json:"scope,omitempty"`
	ClientSecret *ConfigStringComparisonExp                           `json:"clientSecret,omitempty"`
}

func (exp *ConfigStandardOauthProviderWithScopeComparisonExp) Matches(o *ConfigStandardOauthProviderWithScope) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigStandardOauthProviderWithScope{
			Scope: []string{},
		}
	}
	if o.Enabled != nil && !exp.Enabled.Matches(*o.Enabled) {
		return false
	}
	if o.ClientId != nil && !exp.ClientId.Matches(*o.ClientId) {
		return false
	}
	{
		found := false
		for _, o := range o.Scope {
			if exp.Scope.Matches(o) {
				found = true
				break
			}
		}
		if !found && exp.Scope != nil {
			return false
		}
	}
	if o.ClientSecret != nil && !exp.ClientSecret.Matches(*o.ClientSecret) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

// Configuration for storage service
type ConfigStorage struct {
	// Version of storage service, you can see available versions in the URL below:
	// https://hub.docker.com/r/nhost/hasura-storage/tags
	//
	// Releases:
	//
	// https://github.com/nhost/hasura-storage/releases
	Version *string `json:"version" toml:"version"`
	// Resources for the service
	Resources *ConfigResources `json:"resources,omitempty" toml:"resources,omitempty"`
}

func (o *ConfigStorage) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Version != nil {
		m["version"] = o.Version
	}
	if o.Resources != nil {
		m["resources"] = o.Resources
	}
	return json.Marshal(m)
}

func (o *ConfigStorage) GetVersion() *string {
	if o == nil {
		o = &ConfigStorage{}
	}
	return o.Version
}

func (o *ConfigStorage) GetResources() *ConfigResources {
	if o == nil {
		return nil
	}
	return o.Resources
}

type ConfigStorageUpdateInput struct {
	Version        *string                     `json:"version,omitempty" toml:"version,omitempty"`
	IsSetVersion   bool                        `json:"-"`
	Resources      *ConfigResourcesUpdateInput `json:"resources,omitempty" toml:"resources,omitempty"`
	IsSetResources bool                        `json:"-"`
}

func (o *ConfigStorageUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["version"]; ok {
		if v == nil {
			o.Version = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Version = &x
		}
		o.IsSetVersion = true
	}
	if x, ok := m["resources"]; ok {
		if x != nil {
			t := &ConfigResourcesUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Resources = t
		}
		o.IsSetResources = true
	}

	return nil
}

func (o *ConfigStorageUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigStorageUpdateInput) GetVersion() *string {
	if o == nil {
		o = &ConfigStorageUpdateInput{}
	}
	return o.Version
}

func (o *ConfigStorageUpdateInput) GetResources() *ConfigResourcesUpdateInput {
	if o == nil {
		return nil
	}
	return o.Resources
}

func (s *ConfigStorage) Update(v *ConfigStorageUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetVersion || v.Version != nil {
		s.Version = v.Version
	}
	if v.IsSetResources || v.Resources != nil {
		if v.Resources == nil {
			s.Resources = nil
		} else {
			if s.Resources == nil {
				s.Resources = &ConfigResources{}
			}
			s.Resources.Update(v.Resources)
		}
	}
}

type ConfigStorageInsertInput struct {
	Version   *string                     `json:"version,omitempty" toml:"version,omitempty"`
	Resources *ConfigResourcesInsertInput `json:"resources,omitempty" toml:"resources,omitempty"`
}

func (o *ConfigStorageInsertInput) GetVersion() *string {
	if o == nil {
		o = &ConfigStorageInsertInput{}
	}
	return o.Version
}

func (o *ConfigStorageInsertInput) GetResources() *ConfigResourcesInsertInput {
	if o == nil {
		return nil
	}
	return o.Resources
}

func (s *ConfigStorage) Insert(v *ConfigStorageInsertInput) {
	s.Version = v.Version
	if v.Resources != nil {
		if s.Resources == nil {
			s.Resources = &ConfigResources{}
		}
		s.Resources.Insert(v.Resources)
	}
}

func (s *ConfigStorage) Clone() *ConfigStorage {
	if s == nil {
		return nil
	}

	v := &ConfigStorage{}
	v.Version = s.Version
	v.Resources = s.Resources.Clone()
	return v
}

type ConfigStorageComparisonExp struct {
	And       []*ConfigStorageComparisonExp `json:"_and,omitempty"`
	Not       *ConfigStorageComparisonExp   `json:"_not,omitempty"`
	Or        []*ConfigStorageComparisonExp `json:"_or,omitempty"`
	Version   *ConfigStringComparisonExp    `json:"version,omitempty"`
	Resources *ConfigResourcesComparisonExp `json:"resources,omitempty"`
}

func (exp *ConfigStorageComparisonExp) Matches(o *ConfigStorage) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigStorage{
			Resources: &ConfigResources{},
		}
	}
	if o.Version != nil && !exp.Version.Matches(*o.Version) {
		return false
	}
	if !exp.Resources.Matches(o.Resources) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigSystemConfig struct {
	Auth *ConfigSystemConfigAuth `json:"auth,omitempty" toml:"auth,omitempty"`

	Postgres *ConfigSystemConfigPostgres `json:"postgres,omitempty" toml:"postgres,omitempty"`
}

func (o *ConfigSystemConfig) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Auth != nil {
		m["auth"] = o.Auth
	}
	if o.Postgres != nil {
		m["postgres"] = o.Postgres
	}
	return json.Marshal(m)
}

func (o *ConfigSystemConfig) GetAuth() *ConfigSystemConfigAuth {
	if o == nil {
		return nil
	}
	return o.Auth
}

func (o *ConfigSystemConfig) GetPostgres() *ConfigSystemConfigPostgres {
	if o == nil {
		return nil
	}
	return o.Postgres
}

type ConfigSystemConfigUpdateInput struct {
	Auth          *ConfigSystemConfigAuthUpdateInput     `json:"auth,omitempty" toml:"auth,omitempty"`
	IsSetAuth     bool                                   `json:"-"`
	Postgres      *ConfigSystemConfigPostgresUpdateInput `json:"postgres,omitempty" toml:"postgres,omitempty"`
	IsSetPostgres bool                                   `json:"-"`
}

func (o *ConfigSystemConfigUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if x, ok := m["auth"]; ok {
		if x != nil {
			t := &ConfigSystemConfigAuthUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Auth = t
		}
		o.IsSetAuth = true
	}
	if x, ok := m["postgres"]; ok {
		if x != nil {
			t := &ConfigSystemConfigPostgresUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Postgres = t
		}
		o.IsSetPostgres = true
	}

	return nil
}

func (o *ConfigSystemConfigUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigSystemConfigUpdateInput) GetAuth() *ConfigSystemConfigAuthUpdateInput {
	if o == nil {
		return nil
	}
	return o.Auth
}

func (o *ConfigSystemConfigUpdateInput) GetPostgres() *ConfigSystemConfigPostgresUpdateInput {
	if o == nil {
		return nil
	}
	return o.Postgres
}

func (s *ConfigSystemConfig) Update(v *ConfigSystemConfigUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetAuth || v.Auth != nil {
		if v.Auth == nil {
			s.Auth = nil
		} else {
			if s.Auth == nil {
				s.Auth = &ConfigSystemConfigAuth{}
			}
			s.Auth.Update(v.Auth)
		}
	}
	if v.IsSetPostgres || v.Postgres != nil {
		if v.Postgres == nil {
			s.Postgres = nil
		} else {
			if s.Postgres == nil {
				s.Postgres = &ConfigSystemConfigPostgres{}
			}
			s.Postgres.Update(v.Postgres)
		}
	}
}

type ConfigSystemConfigInsertInput struct {
	Auth     *ConfigSystemConfigAuthInsertInput     `json:"auth,omitempty" toml:"auth,omitempty"`
	Postgres *ConfigSystemConfigPostgresInsertInput `json:"postgres,omitempty" toml:"postgres,omitempty"`
}

func (o *ConfigSystemConfigInsertInput) GetAuth() *ConfigSystemConfigAuthInsertInput {
	if o == nil {
		return nil
	}
	return o.Auth
}

func (o *ConfigSystemConfigInsertInput) GetPostgres() *ConfigSystemConfigPostgresInsertInput {
	if o == nil {
		return nil
	}
	return o.Postgres
}

func (s *ConfigSystemConfig) Insert(v *ConfigSystemConfigInsertInput) {
	if v.Auth != nil {
		if s.Auth == nil {
			s.Auth = &ConfigSystemConfigAuth{}
		}
		s.Auth.Insert(v.Auth)
	}
	if v.Postgres != nil {
		if s.Postgres == nil {
			s.Postgres = &ConfigSystemConfigPostgres{}
		}
		s.Postgres.Insert(v.Postgres)
	}
}

func (s *ConfigSystemConfig) Clone() *ConfigSystemConfig {
	if s == nil {
		return nil
	}

	v := &ConfigSystemConfig{}
	v.Auth = s.Auth.Clone()
	v.Postgres = s.Postgres.Clone()
	return v
}

type ConfigSystemConfigComparisonExp struct {
	And      []*ConfigSystemConfigComparisonExp       `json:"_and,omitempty"`
	Not      *ConfigSystemConfigComparisonExp         `json:"_not,omitempty"`
	Or       []*ConfigSystemConfigComparisonExp       `json:"_or,omitempty"`
	Auth     *ConfigSystemConfigAuthComparisonExp     `json:"auth,omitempty"`
	Postgres *ConfigSystemConfigPostgresComparisonExp `json:"postgres,omitempty"`
}

func (exp *ConfigSystemConfigComparisonExp) Matches(o *ConfigSystemConfig) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigSystemConfig{
			Auth:     &ConfigSystemConfigAuth{},
			Postgres: &ConfigSystemConfigPostgres{},
		}
	}
	if !exp.Auth.Matches(o.Auth) {
		return false
	}
	if !exp.Postgres.Matches(o.Postgres) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigSystemConfigAuth struct {
	Email *ConfigSystemConfigAuthEmail `json:"email,omitempty" toml:"email,omitempty"`
}

func (o *ConfigSystemConfigAuth) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Email != nil {
		m["email"] = o.Email
	}
	return json.Marshal(m)
}

func (o *ConfigSystemConfigAuth) GetEmail() *ConfigSystemConfigAuthEmail {
	if o == nil {
		return nil
	}
	return o.Email
}

type ConfigSystemConfigAuthUpdateInput struct {
	Email      *ConfigSystemConfigAuthEmailUpdateInput `json:"email,omitempty" toml:"email,omitempty"`
	IsSetEmail bool                                    `json:"-"`
}

func (o *ConfigSystemConfigAuthUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if x, ok := m["email"]; ok {
		if x != nil {
			t := &ConfigSystemConfigAuthEmailUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Email = t
		}
		o.IsSetEmail = true
	}

	return nil
}

func (o *ConfigSystemConfigAuthUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigSystemConfigAuthUpdateInput) GetEmail() *ConfigSystemConfigAuthEmailUpdateInput {
	if o == nil {
		return nil
	}
	return o.Email
}

func (s *ConfigSystemConfigAuth) Update(v *ConfigSystemConfigAuthUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetEmail || v.Email != nil {
		if v.Email == nil {
			s.Email = nil
		} else {
			if s.Email == nil {
				s.Email = &ConfigSystemConfigAuthEmail{}
			}
			s.Email.Update(v.Email)
		}
	}
}

type ConfigSystemConfigAuthInsertInput struct {
	Email *ConfigSystemConfigAuthEmailInsertInput `json:"email,omitempty" toml:"email,omitempty"`
}

func (o *ConfigSystemConfigAuthInsertInput) GetEmail() *ConfigSystemConfigAuthEmailInsertInput {
	if o == nil {
		return nil
	}
	return o.Email
}

func (s *ConfigSystemConfigAuth) Insert(v *ConfigSystemConfigAuthInsertInput) {
	if v.Email != nil {
		if s.Email == nil {
			s.Email = &ConfigSystemConfigAuthEmail{}
		}
		s.Email.Insert(v.Email)
	}
}

func (s *ConfigSystemConfigAuth) Clone() *ConfigSystemConfigAuth {
	if s == nil {
		return nil
	}

	v := &ConfigSystemConfigAuth{}
	v.Email = s.Email.Clone()
	return v
}

type ConfigSystemConfigAuthComparisonExp struct {
	And   []*ConfigSystemConfigAuthComparisonExp    `json:"_and,omitempty"`
	Not   *ConfigSystemConfigAuthComparisonExp      `json:"_not,omitempty"`
	Or    []*ConfigSystemConfigAuthComparisonExp    `json:"_or,omitempty"`
	Email *ConfigSystemConfigAuthEmailComparisonExp `json:"email,omitempty"`
}

func (exp *ConfigSystemConfigAuthComparisonExp) Matches(o *ConfigSystemConfigAuth) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigSystemConfigAuth{
			Email: &ConfigSystemConfigAuthEmail{},
		}
	}
	if !exp.Email.Matches(o.Email) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigSystemConfigAuthEmail struct {
	Templates *ConfigSystemConfigAuthEmailTemplates `json:"templates,omitempty" toml:"templates,omitempty"`
}

func (o *ConfigSystemConfigAuthEmail) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Templates != nil {
		m["templates"] = o.Templates
	}
	return json.Marshal(m)
}

func (o *ConfigSystemConfigAuthEmail) GetTemplates() *ConfigSystemConfigAuthEmailTemplates {
	if o == nil {
		return nil
	}
	return o.Templates
}

type ConfigSystemConfigAuthEmailUpdateInput struct {
	Templates      *ConfigSystemConfigAuthEmailTemplatesUpdateInput `json:"templates,omitempty" toml:"templates,omitempty"`
	IsSetTemplates bool                                             `json:"-"`
}

func (o *ConfigSystemConfigAuthEmailUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if x, ok := m["templates"]; ok {
		if x != nil {
			t := &ConfigSystemConfigAuthEmailTemplatesUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Templates = t
		}
		o.IsSetTemplates = true
	}

	return nil
}

func (o *ConfigSystemConfigAuthEmailUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigSystemConfigAuthEmailUpdateInput) GetTemplates() *ConfigSystemConfigAuthEmailTemplatesUpdateInput {
	if o == nil {
		return nil
	}
	return o.Templates
}

func (s *ConfigSystemConfigAuthEmail) Update(v *ConfigSystemConfigAuthEmailUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetTemplates || v.Templates != nil {
		if v.Templates == nil {
			s.Templates = nil
		} else {
			if s.Templates == nil {
				s.Templates = &ConfigSystemConfigAuthEmailTemplates{}
			}
			s.Templates.Update(v.Templates)
		}
	}
}

type ConfigSystemConfigAuthEmailInsertInput struct {
	Templates *ConfigSystemConfigAuthEmailTemplatesInsertInput `json:"templates,omitempty" toml:"templates,omitempty"`
}

func (o *ConfigSystemConfigAuthEmailInsertInput) GetTemplates() *ConfigSystemConfigAuthEmailTemplatesInsertInput {
	if o == nil {
		return nil
	}
	return o.Templates
}

func (s *ConfigSystemConfigAuthEmail) Insert(v *ConfigSystemConfigAuthEmailInsertInput) {
	if v.Templates != nil {
		if s.Templates == nil {
			s.Templates = &ConfigSystemConfigAuthEmailTemplates{}
		}
		s.Templates.Insert(v.Templates)
	}
}

func (s *ConfigSystemConfigAuthEmail) Clone() *ConfigSystemConfigAuthEmail {
	if s == nil {
		return nil
	}

	v := &ConfigSystemConfigAuthEmail{}
	v.Templates = s.Templates.Clone()
	return v
}

type ConfigSystemConfigAuthEmailComparisonExp struct {
	And       []*ConfigSystemConfigAuthEmailComparisonExp        `json:"_and,omitempty"`
	Not       *ConfigSystemConfigAuthEmailComparisonExp          `json:"_not,omitempty"`
	Or        []*ConfigSystemConfigAuthEmailComparisonExp        `json:"_or,omitempty"`
	Templates *ConfigSystemConfigAuthEmailTemplatesComparisonExp `json:"templates,omitempty"`
}

func (exp *ConfigSystemConfigAuthEmailComparisonExp) Matches(o *ConfigSystemConfigAuthEmail) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigSystemConfigAuthEmail{
			Templates: &ConfigSystemConfigAuthEmailTemplates{},
		}
	}
	if !exp.Templates.Matches(o.Templates) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigSystemConfigAuthEmailTemplates struct {
	S3Key *string `json:"s3Key" toml:"s3Key"`
}

func (o *ConfigSystemConfigAuthEmailTemplates) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.S3Key != nil {
		m["s3Key"] = o.S3Key
	}
	return json.Marshal(m)
}

func (o *ConfigSystemConfigAuthEmailTemplates) GetS3Key() *string {
	if o == nil {
		o = &ConfigSystemConfigAuthEmailTemplates{}
	}
	return o.S3Key
}

type ConfigSystemConfigAuthEmailTemplatesUpdateInput struct {
	S3Key      *string `json:"s3Key,omitempty" toml:"s3Key,omitempty"`
	IsSetS3Key bool    `json:"-"`
}

func (o *ConfigSystemConfigAuthEmailTemplatesUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["s3Key"]; ok {
		if v == nil {
			o.S3Key = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.S3Key = &x
		}
		o.IsSetS3Key = true
	}

	return nil
}

func (o *ConfigSystemConfigAuthEmailTemplatesUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigSystemConfigAuthEmailTemplatesUpdateInput) GetS3Key() *string {
	if o == nil {
		o = &ConfigSystemConfigAuthEmailTemplatesUpdateInput{}
	}
	return o.S3Key
}

func (s *ConfigSystemConfigAuthEmailTemplates) Update(v *ConfigSystemConfigAuthEmailTemplatesUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetS3Key || v.S3Key != nil {
		s.S3Key = v.S3Key
	}
}

type ConfigSystemConfigAuthEmailTemplatesInsertInput struct {
	S3Key *string `json:"s3Key,omitempty" toml:"s3Key,omitempty"`
}

func (o *ConfigSystemConfigAuthEmailTemplatesInsertInput) GetS3Key() *string {
	if o == nil {
		o = &ConfigSystemConfigAuthEmailTemplatesInsertInput{}
	}
	return o.S3Key
}

func (s *ConfigSystemConfigAuthEmailTemplates) Insert(v *ConfigSystemConfigAuthEmailTemplatesInsertInput) {
	s.S3Key = v.S3Key
}

func (s *ConfigSystemConfigAuthEmailTemplates) Clone() *ConfigSystemConfigAuthEmailTemplates {
	if s == nil {
		return nil
	}

	v := &ConfigSystemConfigAuthEmailTemplates{}
	v.S3Key = s.S3Key
	return v
}

type ConfigSystemConfigAuthEmailTemplatesComparisonExp struct {
	And   []*ConfigSystemConfigAuthEmailTemplatesComparisonExp `json:"_and,omitempty"`
	Not   *ConfigSystemConfigAuthEmailTemplatesComparisonExp   `json:"_not,omitempty"`
	Or    []*ConfigSystemConfigAuthEmailTemplatesComparisonExp `json:"_or,omitempty"`
	S3Key *ConfigStringComparisonExp                           `json:"s3Key,omitempty"`
}

func (exp *ConfigSystemConfigAuthEmailTemplatesComparisonExp) Matches(o *ConfigSystemConfigAuthEmailTemplates) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigSystemConfigAuthEmailTemplates{}
	}
	if o.S3Key != nil && !exp.S3Key.Matches(*o.S3Key) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigSystemConfigPostgres struct {
	Enabled *bool `json:"enabled" toml:"enabled"`

	Database string `json:"database" toml:"database"`

	ConnectionString *ConfigSystemConfigPostgresConnectionString `json:"connectionString,omitempty" toml:"connectionString,omitempty"`
}

func (o *ConfigSystemConfigPostgres) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Enabled != nil {
		m["enabled"] = o.Enabled
	}
	m["database"] = o.Database
	if o.ConnectionString != nil {
		m["connectionString"] = o.ConnectionString
	}
	return json.Marshal(m)
}

func (o *ConfigSystemConfigPostgres) GetEnabled() *bool {
	if o == nil {
		o = &ConfigSystemConfigPostgres{}
	}
	return o.Enabled
}

func (o *ConfigSystemConfigPostgres) GetDatabase() string {
	if o == nil {
		o = &ConfigSystemConfigPostgres{}
	}
	return o.Database
}

func (o *ConfigSystemConfigPostgres) GetConnectionString() *ConfigSystemConfigPostgresConnectionString {
	if o == nil {
		return nil
	}
	return o.ConnectionString
}

type ConfigSystemConfigPostgresUpdateInput struct {
	Enabled               *bool                                                  `json:"enabled,omitempty" toml:"enabled,omitempty"`
	IsSetEnabled          bool                                                   `json:"-"`
	Database              *string                                                `json:"database,omitempty" toml:"database,omitempty"`
	IsSetDatabase         bool                                                   `json:"-"`
	ConnectionString      *ConfigSystemConfigPostgresConnectionStringUpdateInput `json:"connectionString,omitempty" toml:"connectionString,omitempty"`
	IsSetConnectionString bool                                                   `json:"-"`
}

func (o *ConfigSystemConfigPostgresUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["enabled"]; ok {
		if v == nil {
			o.Enabled = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x bool
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Enabled = &x
		}
		o.IsSetEnabled = true
	}
	if v, ok := m["database"]; ok {
		if v == nil {
			o.Database = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Database = &x
		}
		o.IsSetDatabase = true
	}
	if x, ok := m["connectionString"]; ok {
		if x != nil {
			t := &ConfigSystemConfigPostgresConnectionStringUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.ConnectionString = t
		}
		o.IsSetConnectionString = true
	}

	return nil
}

func (o *ConfigSystemConfigPostgresUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigSystemConfigPostgresUpdateInput) GetEnabled() *bool {
	if o == nil {
		o = &ConfigSystemConfigPostgresUpdateInput{}
	}
	return o.Enabled
}

func (o *ConfigSystemConfigPostgresUpdateInput) GetDatabase() *string {
	if o == nil {
		o = &ConfigSystemConfigPostgresUpdateInput{}
	}
	return o.Database
}

func (o *ConfigSystemConfigPostgresUpdateInput) GetConnectionString() *ConfigSystemConfigPostgresConnectionStringUpdateInput {
	if o == nil {
		return nil
	}
	return o.ConnectionString
}

func (s *ConfigSystemConfigPostgres) Update(v *ConfigSystemConfigPostgresUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetEnabled || v.Enabled != nil {
		s.Enabled = v.Enabled
	}
	if v.IsSetDatabase || v.Database != nil {
		if v.Database != nil {
			s.Database = *v.Database
		}
	}
	if v.IsSetConnectionString || v.ConnectionString != nil {
		if v.ConnectionString == nil {
			s.ConnectionString = nil
		} else {
			if s.ConnectionString == nil {
				s.ConnectionString = &ConfigSystemConfigPostgresConnectionString{}
			}
			s.ConnectionString.Update(v.ConnectionString)
		}
	}
}

type ConfigSystemConfigPostgresInsertInput struct {
	Enabled          *bool                                                  `json:"enabled,omitempty" toml:"enabled,omitempty"`
	Database         string                                                 `json:"database,omitempty" toml:"database,omitempty"`
	ConnectionString *ConfigSystemConfigPostgresConnectionStringInsertInput `json:"connectionString,omitempty" toml:"connectionString,omitempty"`
}

func (o *ConfigSystemConfigPostgresInsertInput) GetEnabled() *bool {
	if o == nil {
		o = &ConfigSystemConfigPostgresInsertInput{}
	}
	return o.Enabled
}

func (o *ConfigSystemConfigPostgresInsertInput) GetDatabase() string {
	if o == nil {
		o = &ConfigSystemConfigPostgresInsertInput{}
	}
	return o.Database
}

func (o *ConfigSystemConfigPostgresInsertInput) GetConnectionString() *ConfigSystemConfigPostgresConnectionStringInsertInput {
	if o == nil {
		return nil
	}
	return o.ConnectionString
}

func (s *ConfigSystemConfigPostgres) Insert(v *ConfigSystemConfigPostgresInsertInput) {
	s.Enabled = v.Enabled
	s.Database = v.Database
	if v.ConnectionString != nil {
		if s.ConnectionString == nil {
			s.ConnectionString = &ConfigSystemConfigPostgresConnectionString{}
		}
		s.ConnectionString.Insert(v.ConnectionString)
	}
}

func (s *ConfigSystemConfigPostgres) Clone() *ConfigSystemConfigPostgres {
	if s == nil {
		return nil
	}

	v := &ConfigSystemConfigPostgres{}
	v.Enabled = s.Enabled
	v.Database = s.Database
	v.ConnectionString = s.ConnectionString.Clone()
	return v
}

type ConfigSystemConfigPostgresComparisonExp struct {
	And              []*ConfigSystemConfigPostgresComparisonExp               `json:"_and,omitempty"`
	Not              *ConfigSystemConfigPostgresComparisonExp                 `json:"_not,omitempty"`
	Or               []*ConfigSystemConfigPostgresComparisonExp               `json:"_or,omitempty"`
	Enabled          *ConfigBooleanComparisonExp                              `json:"enabled,omitempty"`
	Database         *ConfigStringComparisonExp                               `json:"database,omitempty"`
	ConnectionString *ConfigSystemConfigPostgresConnectionStringComparisonExp `json:"connectionString,omitempty"`
}

func (exp *ConfigSystemConfigPostgresComparisonExp) Matches(o *ConfigSystemConfigPostgres) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigSystemConfigPostgres{
			ConnectionString: &ConfigSystemConfigPostgresConnectionString{},
		}
	}
	if o.Enabled != nil && !exp.Enabled.Matches(*o.Enabled) {
		return false
	}
	if !exp.Database.Matches(o.Database) {
		return false
	}
	if !exp.ConnectionString.Matches(o.ConnectionString) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigSystemConfigPostgresConnectionString struct {
	Backup string `json:"backup" toml:"backup"`

	Hasura string `json:"hasura" toml:"hasura"`

	Auth string `json:"auth" toml:"auth"`

	Storage string `json:"storage" toml:"storage"`
}

func (o *ConfigSystemConfigPostgresConnectionString) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	m["backup"] = o.Backup
	m["hasura"] = o.Hasura
	m["auth"] = o.Auth
	m["storage"] = o.Storage
	return json.Marshal(m)
}

func (o *ConfigSystemConfigPostgresConnectionString) GetBackup() string {
	if o == nil {
		o = &ConfigSystemConfigPostgresConnectionString{}
	}
	return o.Backup
}

func (o *ConfigSystemConfigPostgresConnectionString) GetHasura() string {
	if o == nil {
		o = &ConfigSystemConfigPostgresConnectionString{}
	}
	return o.Hasura
}

func (o *ConfigSystemConfigPostgresConnectionString) GetAuth() string {
	if o == nil {
		o = &ConfigSystemConfigPostgresConnectionString{}
	}
	return o.Auth
}

func (o *ConfigSystemConfigPostgresConnectionString) GetStorage() string {
	if o == nil {
		o = &ConfigSystemConfigPostgresConnectionString{}
	}
	return o.Storage
}

type ConfigSystemConfigPostgresConnectionStringUpdateInput struct {
	Backup       *string `json:"backup,omitempty" toml:"backup,omitempty"`
	IsSetBackup  bool    `json:"-"`
	Hasura       *string `json:"hasura,omitempty" toml:"hasura,omitempty"`
	IsSetHasura  bool    `json:"-"`
	Auth         *string `json:"auth,omitempty" toml:"auth,omitempty"`
	IsSetAuth    bool    `json:"-"`
	Storage      *string `json:"storage,omitempty" toml:"storage,omitempty"`
	IsSetStorage bool    `json:"-"`
}

func (o *ConfigSystemConfigPostgresConnectionStringUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["backup"]; ok {
		if v == nil {
			o.Backup = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Backup = &x
		}
		o.IsSetBackup = true
	}
	if v, ok := m["hasura"]; ok {
		if v == nil {
			o.Hasura = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Hasura = &x
		}
		o.IsSetHasura = true
	}
	if v, ok := m["auth"]; ok {
		if v == nil {
			o.Auth = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Auth = &x
		}
		o.IsSetAuth = true
	}
	if v, ok := m["storage"]; ok {
		if v == nil {
			o.Storage = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Storage = &x
		}
		o.IsSetStorage = true
	}

	return nil
}

func (o *ConfigSystemConfigPostgresConnectionStringUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigSystemConfigPostgresConnectionStringUpdateInput) GetBackup() *string {
	if o == nil {
		o = &ConfigSystemConfigPostgresConnectionStringUpdateInput{}
	}
	return o.Backup
}

func (o *ConfigSystemConfigPostgresConnectionStringUpdateInput) GetHasura() *string {
	if o == nil {
		o = &ConfigSystemConfigPostgresConnectionStringUpdateInput{}
	}
	return o.Hasura
}

func (o *ConfigSystemConfigPostgresConnectionStringUpdateInput) GetAuth() *string {
	if o == nil {
		o = &ConfigSystemConfigPostgresConnectionStringUpdateInput{}
	}
	return o.Auth
}

func (o *ConfigSystemConfigPostgresConnectionStringUpdateInput) GetStorage() *string {
	if o == nil {
		o = &ConfigSystemConfigPostgresConnectionStringUpdateInput{}
	}
	return o.Storage
}

func (s *ConfigSystemConfigPostgresConnectionString) Update(v *ConfigSystemConfigPostgresConnectionStringUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetBackup || v.Backup != nil {
		if v.Backup != nil {
			s.Backup = *v.Backup
		}
	}
	if v.IsSetHasura || v.Hasura != nil {
		if v.Hasura != nil {
			s.Hasura = *v.Hasura
		}
	}
	if v.IsSetAuth || v.Auth != nil {
		if v.Auth != nil {
			s.Auth = *v.Auth
		}
	}
	if v.IsSetStorage || v.Storage != nil {
		if v.Storage != nil {
			s.Storage = *v.Storage
		}
	}
}

type ConfigSystemConfigPostgresConnectionStringInsertInput struct {
	Backup  string `json:"backup,omitempty" toml:"backup,omitempty"`
	Hasura  string `json:"hasura,omitempty" toml:"hasura,omitempty"`
	Auth    string `json:"auth,omitempty" toml:"auth,omitempty"`
	Storage string `json:"storage,omitempty" toml:"storage,omitempty"`
}

func (o *ConfigSystemConfigPostgresConnectionStringInsertInput) GetBackup() string {
	if o == nil {
		o = &ConfigSystemConfigPostgresConnectionStringInsertInput{}
	}
	return o.Backup
}

func (o *ConfigSystemConfigPostgresConnectionStringInsertInput) GetHasura() string {
	if o == nil {
		o = &ConfigSystemConfigPostgresConnectionStringInsertInput{}
	}
	return o.Hasura
}

func (o *ConfigSystemConfigPostgresConnectionStringInsertInput) GetAuth() string {
	if o == nil {
		o = &ConfigSystemConfigPostgresConnectionStringInsertInput{}
	}
	return o.Auth
}

func (o *ConfigSystemConfigPostgresConnectionStringInsertInput) GetStorage() string {
	if o == nil {
		o = &ConfigSystemConfigPostgresConnectionStringInsertInput{}
	}
	return o.Storage
}

func (s *ConfigSystemConfigPostgresConnectionString) Insert(v *ConfigSystemConfigPostgresConnectionStringInsertInput) {
	s.Backup = v.Backup
	s.Hasura = v.Hasura
	s.Auth = v.Auth
	s.Storage = v.Storage
}

func (s *ConfigSystemConfigPostgresConnectionString) Clone() *ConfigSystemConfigPostgresConnectionString {
	if s == nil {
		return nil
	}

	v := &ConfigSystemConfigPostgresConnectionString{}
	v.Backup = s.Backup
	v.Hasura = s.Hasura
	v.Auth = s.Auth
	v.Storage = s.Storage
	return v
}

type ConfigSystemConfigPostgresConnectionStringComparisonExp struct {
	And     []*ConfigSystemConfigPostgresConnectionStringComparisonExp `json:"_and,omitempty"`
	Not     *ConfigSystemConfigPostgresConnectionStringComparisonExp   `json:"_not,omitempty"`
	Or      []*ConfigSystemConfigPostgresConnectionStringComparisonExp `json:"_or,omitempty"`
	Backup  *ConfigStringComparisonExp                                 `json:"backup,omitempty"`
	Hasura  *ConfigStringComparisonExp                                 `json:"hasura,omitempty"`
	Auth    *ConfigStringComparisonExp                                 `json:"auth,omitempty"`
	Storage *ConfigStringComparisonExp                                 `json:"storage,omitempty"`
}

func (exp *ConfigSystemConfigPostgresConnectionStringComparisonExp) Matches(o *ConfigSystemConfigPostgresConnectionString) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigSystemConfigPostgresConnectionString{}
	}
	if !exp.Backup.Matches(o.Backup) {
		return false
	}
	if !exp.Hasura.Matches(o.Hasura) {
		return false
	}
	if !exp.Auth.Matches(o.Auth) {
		return false
	}
	if !exp.Storage.Matches(o.Storage) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigUrlComparisonExp struct {
	Eq  *string  `json:"_eq,omitempty"`
	Neq *string  `json:"_neq,omitempty"`
	In  []string `json:"_in,omitempty"`
	Nin []string `json:"_nin,omitempty"`
}

func (exp *ConfigUrlComparisonExp) Matches(o string) bool {
	if exp == nil {
		return true
	}

	if exp.Eq != nil && *exp.Eq != o {
		return false
	}

	if exp.Neq != nil && *exp.Neq == o {
		return false
	}

	if exp.In != nil && !contains(exp.In, o) {
		return false
	}

	if exp.Nin != nil && contains(exp.Nin, o) {
		return false
	}

	return true
}

type ConfigUserRoleComparisonExp struct {
	Eq  *string  `json:"_eq,omitempty"`
	Neq *string  `json:"_neq,omitempty"`
	In  []string `json:"_in,omitempty"`
	Nin []string `json:"_nin,omitempty"`
}

func (exp *ConfigUserRoleComparisonExp) Matches(o string) bool {
	if exp == nil {
		return true
	}

	if exp.Eq != nil && *exp.Eq != o {
		return false
	}

	if exp.Neq != nil && *exp.Neq == o {
		return false
	}

	if exp.In != nil && !contains(exp.In, o) {
		return false
	}

	if exp.Nin != nil && contains(exp.Nin, o) {
		return false
	}

	return true
}
