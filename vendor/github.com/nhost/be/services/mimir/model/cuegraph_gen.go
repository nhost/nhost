// Code generated by github.com/nhost/be/tools/cuegraph, DO NOT EDIT.

package model

import (
	"encoding/json"
	"fmt"
	"io"
)

type Matcher[T any] interface {
	Matches(T) bool
}

func all[T any, U Matcher[T]](list []U, element T) bool {
	for _, e := range list {
		if !e.Matches(element) {
			return false
		}
	}
	return true
}

func or[T any, U Matcher[T]](list []U, element T) bool {
	for _, e := range list {
		if e.Matches(element) {
			return true
		}
	}
	return false
}

func contains[T comparable](slice []T, item T) bool {
	for _, s := range slice {
		if s == item {
			return true
		}
	}
	return false
}

type GenericComparisonExp[T comparable] struct {
	Eq  *T  `json:"_eq,omitempty"`
	Neq *T  `json:"_neq,omitempty"`
	In  []T `json:"_in,omitempty"`
	Nin []T `json:"_nin,omitempty"`
}

func (exp *GenericComparisonExp[T]) Matches(o T) bool {
	if exp == nil {
		return true
	}

	if exp.Eq != nil && *exp.Eq != o {
		return false
	}

	if exp.Neq != nil && *exp.Neq == o {
		return false
	}

	if exp.In != nil && !contains(exp.In, o) {
		return false
	}

	if exp.Nin != nil && contains(exp.Nin, o) {
		return false
	}

	return true
}

type (
	ConfigIntComparisonExp   = GenericComparisonExp[int]
	ConfigInt8ComparisonExp  = GenericComparisonExp[int8]
	ConfigInt16ComparisonExp = GenericComparisonExp[int16]
	ConfigInt32ComparisonExp = GenericComparisonExp[int32]
	ConfigInt64ComparisonExp = GenericComparisonExp[int64]
)

type (
	ConfigUintComparisonExp   = GenericComparisonExp[uint]
	ConfigUint8ComparisonExp  = GenericComparisonExp[uint8]
	ConfigUint16ComparisonExp = GenericComparisonExp[uint16]
	ConfigUint32ComparisonExp = GenericComparisonExp[uint32]
	ConfigUint64ComparisonExp = GenericComparisonExp[uint64]
)

type ConfigStringComparisonExp = GenericComparisonExp[string]

type ConfigBooleanComparisonExp = GenericComparisonExp[bool]

type ConfigFloatComparisonExp = GenericComparisonExp[float64]

type ConfigAI struct {
	Version *string `json:"version" toml:"version"`

	Resources *ConfigAIResources `json:"resources,omitempty" toml:"resources,omitempty"`

	Openai *ConfigAIOpenai `json:"openai,omitempty" toml:"openai,omitempty"`

	AutoEmbeddings *ConfigAIAutoEmbeddings `json:"autoEmbeddings,omitempty" toml:"autoEmbeddings,omitempty"`

	WebhookSecret string `json:"webhookSecret" toml:"webhookSecret"`
}

func (o *ConfigAI) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Version != nil {
		m["version"] = o.Version
	}
	if o.Resources != nil {
		m["resources"] = o.Resources
	}
	if o.Openai != nil {
		m["openai"] = o.Openai
	}
	if o.AutoEmbeddings != nil {
		m["autoEmbeddings"] = o.AutoEmbeddings
	}
	m["webhookSecret"] = o.WebhookSecret
	return json.Marshal(m)
}

func (o *ConfigAI) GetVersion() *string {
	if o == nil {
		o = &ConfigAI{}
	}
	return o.Version
}

func (o *ConfigAI) GetResources() *ConfigAIResources {
	if o == nil {
		return nil
	}
	return o.Resources
}

func (o *ConfigAI) GetOpenai() *ConfigAIOpenai {
	if o == nil {
		return nil
	}
	return o.Openai
}

func (o *ConfigAI) GetAutoEmbeddings() *ConfigAIAutoEmbeddings {
	if o == nil {
		return nil
	}
	return o.AutoEmbeddings
}

func (o *ConfigAI) GetWebhookSecret() string {
	if o == nil {
		o = &ConfigAI{}
	}
	return o.WebhookSecret
}

type ConfigAIUpdateInput struct {
	Version             *string                            `json:"version,omitempty" toml:"version,omitempty"`
	IsSetVersion        bool                               `json:"-"`
	Resources           *ConfigAIResourcesUpdateInput      `json:"resources,omitempty" toml:"resources,omitempty"`
	IsSetResources      bool                               `json:"-"`
	Openai              *ConfigAIOpenaiUpdateInput         `json:"openai,omitempty" toml:"openai,omitempty"`
	IsSetOpenai         bool                               `json:"-"`
	AutoEmbeddings      *ConfigAIAutoEmbeddingsUpdateInput `json:"autoEmbeddings,omitempty" toml:"autoEmbeddings,omitempty"`
	IsSetAutoEmbeddings bool                               `json:"-"`
	WebhookSecret       *string                            `json:"webhookSecret,omitempty" toml:"webhookSecret,omitempty"`
	IsSetWebhookSecret  bool                               `json:"-"`
}

func (o *ConfigAIUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["version"]; ok {
		if v == nil {
			o.Version = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Version = &x
		}
		o.IsSetVersion = true
	}
	if x, ok := m["resources"]; ok {
		if x != nil {
			t := &ConfigAIResourcesUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Resources = t
		}
		o.IsSetResources = true
	}
	if x, ok := m["openai"]; ok {
		if x != nil {
			t := &ConfigAIOpenaiUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Openai = t
		}
		o.IsSetOpenai = true
	}
	if x, ok := m["autoEmbeddings"]; ok {
		if x != nil {
			t := &ConfigAIAutoEmbeddingsUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.AutoEmbeddings = t
		}
		o.IsSetAutoEmbeddings = true
	}
	if v, ok := m["webhookSecret"]; ok {
		if v == nil {
			o.WebhookSecret = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.WebhookSecret = &x
		}
		o.IsSetWebhookSecret = true
	}

	return nil
}

func (o *ConfigAIUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigAIUpdateInput) GetVersion() *string {
	if o == nil {
		o = &ConfigAIUpdateInput{}
	}
	return o.Version
}

func (o *ConfigAIUpdateInput) GetResources() *ConfigAIResourcesUpdateInput {
	if o == nil {
		return nil
	}
	return o.Resources
}

func (o *ConfigAIUpdateInput) GetOpenai() *ConfigAIOpenaiUpdateInput {
	if o == nil {
		return nil
	}
	return o.Openai
}

func (o *ConfigAIUpdateInput) GetAutoEmbeddings() *ConfigAIAutoEmbeddingsUpdateInput {
	if o == nil {
		return nil
	}
	return o.AutoEmbeddings
}

func (o *ConfigAIUpdateInput) GetWebhookSecret() *string {
	if o == nil {
		o = &ConfigAIUpdateInput{}
	}
	return o.WebhookSecret
}

func (s *ConfigAI) Update(v *ConfigAIUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetVersion || v.Version != nil {
		s.Version = v.Version
	}
	if v.IsSetResources || v.Resources != nil {
		if v.Resources == nil {
			s.Resources = nil
		} else {
			if s.Resources == nil {
				s.Resources = &ConfigAIResources{}
			}
			s.Resources.Update(v.Resources)
		}
	}
	if v.IsSetOpenai || v.Openai != nil {
		if v.Openai == nil {
			s.Openai = nil
		} else {
			if s.Openai == nil {
				s.Openai = &ConfigAIOpenai{}
			}
			s.Openai.Update(v.Openai)
		}
	}
	if v.IsSetAutoEmbeddings || v.AutoEmbeddings != nil {
		if v.AutoEmbeddings == nil {
			s.AutoEmbeddings = nil
		} else {
			if s.AutoEmbeddings == nil {
				s.AutoEmbeddings = &ConfigAIAutoEmbeddings{}
			}
			s.AutoEmbeddings.Update(v.AutoEmbeddings)
		}
	}
	if v.IsSetWebhookSecret || v.WebhookSecret != nil {
		if v.WebhookSecret != nil {
			s.WebhookSecret = *v.WebhookSecret
		}
	}
}

type ConfigAIInsertInput struct {
	Version        *string                            `json:"version,omitempty" toml:"version,omitempty"`
	Resources      *ConfigAIResourcesInsertInput      `json:"resources,omitempty" toml:"resources,omitempty"`
	Openai         *ConfigAIOpenaiInsertInput         `json:"openai,omitempty" toml:"openai,omitempty"`
	AutoEmbeddings *ConfigAIAutoEmbeddingsInsertInput `json:"autoEmbeddings,omitempty" toml:"autoEmbeddings,omitempty"`
	WebhookSecret  string                             `json:"webhookSecret,omitempty" toml:"webhookSecret,omitempty"`
}

func (o *ConfigAIInsertInput) GetVersion() *string {
	if o == nil {
		o = &ConfigAIInsertInput{}
	}
	return o.Version
}

func (o *ConfigAIInsertInput) GetResources() *ConfigAIResourcesInsertInput {
	if o == nil {
		return nil
	}
	return o.Resources
}

func (o *ConfigAIInsertInput) GetOpenai() *ConfigAIOpenaiInsertInput {
	if o == nil {
		return nil
	}
	return o.Openai
}

func (o *ConfigAIInsertInput) GetAutoEmbeddings() *ConfigAIAutoEmbeddingsInsertInput {
	if o == nil {
		return nil
	}
	return o.AutoEmbeddings
}

func (o *ConfigAIInsertInput) GetWebhookSecret() string {
	if o == nil {
		o = &ConfigAIInsertInput{}
	}
	return o.WebhookSecret
}

func (s *ConfigAI) Insert(v *ConfigAIInsertInput) {
	s.Version = v.Version
	if v.Resources != nil {
		if s.Resources == nil {
			s.Resources = &ConfigAIResources{}
		}
		s.Resources.Insert(v.Resources)
	}
	if v.Openai != nil {
		if s.Openai == nil {
			s.Openai = &ConfigAIOpenai{}
		}
		s.Openai.Insert(v.Openai)
	}
	if v.AutoEmbeddings != nil {
		if s.AutoEmbeddings == nil {
			s.AutoEmbeddings = &ConfigAIAutoEmbeddings{}
		}
		s.AutoEmbeddings.Insert(v.AutoEmbeddings)
	}
	s.WebhookSecret = v.WebhookSecret
}

func (s *ConfigAI) Clone() *ConfigAI {
	if s == nil {
		return nil
	}

	v := &ConfigAI{}
	v.Version = s.Version
	v.Resources = s.Resources.Clone()
	v.Openai = s.Openai.Clone()
	v.AutoEmbeddings = s.AutoEmbeddings.Clone()
	v.WebhookSecret = s.WebhookSecret
	return v
}

type ConfigAIComparisonExp struct {
	And            []*ConfigAIComparisonExp             `json:"_and,omitempty"`
	Not            *ConfigAIComparisonExp               `json:"_not,omitempty"`
	Or             []*ConfigAIComparisonExp             `json:"_or,omitempty"`
	Version        *ConfigStringComparisonExp           `json:"version,omitempty"`
	Resources      *ConfigAIResourcesComparisonExp      `json:"resources,omitempty"`
	Openai         *ConfigAIOpenaiComparisonExp         `json:"openai,omitempty"`
	AutoEmbeddings *ConfigAIAutoEmbeddingsComparisonExp `json:"autoEmbeddings,omitempty"`
	WebhookSecret  *ConfigStringComparisonExp           `json:"webhookSecret,omitempty"`
}

func (exp *ConfigAIComparisonExp) Matches(o *ConfigAI) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAI{
			Resources:      &ConfigAIResources{},
			Openai:         &ConfigAIOpenai{},
			AutoEmbeddings: &ConfigAIAutoEmbeddings{},
		}
	}
	if o.Version != nil && !exp.Version.Matches(*o.Version) {
		return false
	}
	if !exp.Resources.Matches(o.Resources) {
		return false
	}
	if !exp.Openai.Matches(o.Openai) {
		return false
	}
	if !exp.AutoEmbeddings.Matches(o.AutoEmbeddings) {
		return false
	}
	if !exp.WebhookSecret.Matches(o.WebhookSecret) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAIAutoEmbeddings struct {
	SynchPeriodMinutes *uint32 `json:"synchPeriodMinutes" toml:"synchPeriodMinutes"`
}

func (o *ConfigAIAutoEmbeddings) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.SynchPeriodMinutes != nil {
		m["synchPeriodMinutes"] = o.SynchPeriodMinutes
	}
	return json.Marshal(m)
}

func (o *ConfigAIAutoEmbeddings) GetSynchPeriodMinutes() *uint32 {
	if o == nil {
		o = &ConfigAIAutoEmbeddings{}
	}
	return o.SynchPeriodMinutes
}

type ConfigAIAutoEmbeddingsUpdateInput struct {
	SynchPeriodMinutes      *uint32 `json:"synchPeriodMinutes,omitempty" toml:"synchPeriodMinutes,omitempty"`
	IsSetSynchPeriodMinutes bool    `json:"-"`
}

func (o *ConfigAIAutoEmbeddingsUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["synchPeriodMinutes"]; ok {
		if v == nil {
			o.SynchPeriodMinutes = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x uint32
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.SynchPeriodMinutes = &x
		}
		o.IsSetSynchPeriodMinutes = true
	}

	return nil
}

func (o *ConfigAIAutoEmbeddingsUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigAIAutoEmbeddingsUpdateInput) GetSynchPeriodMinutes() *uint32 {
	if o == nil {
		o = &ConfigAIAutoEmbeddingsUpdateInput{}
	}
	return o.SynchPeriodMinutes
}

func (s *ConfigAIAutoEmbeddings) Update(v *ConfigAIAutoEmbeddingsUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetSynchPeriodMinutes || v.SynchPeriodMinutes != nil {
		s.SynchPeriodMinutes = v.SynchPeriodMinutes
	}
}

type ConfigAIAutoEmbeddingsInsertInput struct {
	SynchPeriodMinutes *uint32 `json:"synchPeriodMinutes,omitempty" toml:"synchPeriodMinutes,omitempty"`
}

func (o *ConfigAIAutoEmbeddingsInsertInput) GetSynchPeriodMinutes() *uint32 {
	if o == nil {
		o = &ConfigAIAutoEmbeddingsInsertInput{}
	}
	return o.SynchPeriodMinutes
}

func (s *ConfigAIAutoEmbeddings) Insert(v *ConfigAIAutoEmbeddingsInsertInput) {
	s.SynchPeriodMinutes = v.SynchPeriodMinutes
}

func (s *ConfigAIAutoEmbeddings) Clone() *ConfigAIAutoEmbeddings {
	if s == nil {
		return nil
	}

	v := &ConfigAIAutoEmbeddings{}
	v.SynchPeriodMinutes = s.SynchPeriodMinutes
	return v
}

type ConfigAIAutoEmbeddingsComparisonExp struct {
	And                []*ConfigAIAutoEmbeddingsComparisonExp `json:"_and,omitempty"`
	Not                *ConfigAIAutoEmbeddingsComparisonExp   `json:"_not,omitempty"`
	Or                 []*ConfigAIAutoEmbeddingsComparisonExp `json:"_or,omitempty"`
	SynchPeriodMinutes *ConfigUint32ComparisonExp             `json:"synchPeriodMinutes,omitempty"`
}

func (exp *ConfigAIAutoEmbeddingsComparisonExp) Matches(o *ConfigAIAutoEmbeddings) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAIAutoEmbeddings{}
	}
	if o.SynchPeriodMinutes != nil && !exp.SynchPeriodMinutes.Matches(*o.SynchPeriodMinutes) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAIOpenai struct {
	Organization *string `json:"organization" toml:"organization"`

	ApiKey string `json:"apiKey" toml:"apiKey"`
}

func (o *ConfigAIOpenai) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Organization != nil {
		m["organization"] = o.Organization
	}
	m["apiKey"] = o.ApiKey
	return json.Marshal(m)
}

func (o *ConfigAIOpenai) GetOrganization() *string {
	if o == nil {
		o = &ConfigAIOpenai{}
	}
	return o.Organization
}

func (o *ConfigAIOpenai) GetApiKey() string {
	if o == nil {
		o = &ConfigAIOpenai{}
	}
	return o.ApiKey
}

type ConfigAIOpenaiUpdateInput struct {
	Organization      *string `json:"organization,omitempty" toml:"organization,omitempty"`
	IsSetOrganization bool    `json:"-"`
	ApiKey            *string `json:"apiKey,omitempty" toml:"apiKey,omitempty"`
	IsSetApiKey       bool    `json:"-"`
}

func (o *ConfigAIOpenaiUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["organization"]; ok {
		if v == nil {
			o.Organization = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Organization = &x
		}
		o.IsSetOrganization = true
	}
	if v, ok := m["apiKey"]; ok {
		if v == nil {
			o.ApiKey = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.ApiKey = &x
		}
		o.IsSetApiKey = true
	}

	return nil
}

func (o *ConfigAIOpenaiUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigAIOpenaiUpdateInput) GetOrganization() *string {
	if o == nil {
		o = &ConfigAIOpenaiUpdateInput{}
	}
	return o.Organization
}

func (o *ConfigAIOpenaiUpdateInput) GetApiKey() *string {
	if o == nil {
		o = &ConfigAIOpenaiUpdateInput{}
	}
	return o.ApiKey
}

func (s *ConfigAIOpenai) Update(v *ConfigAIOpenaiUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetOrganization || v.Organization != nil {
		s.Organization = v.Organization
	}
	if v.IsSetApiKey || v.ApiKey != nil {
		if v.ApiKey != nil {
			s.ApiKey = *v.ApiKey
		}
	}
}

type ConfigAIOpenaiInsertInput struct {
	Organization *string `json:"organization,omitempty" toml:"organization,omitempty"`
	ApiKey       string  `json:"apiKey,omitempty" toml:"apiKey,omitempty"`
}

func (o *ConfigAIOpenaiInsertInput) GetOrganization() *string {
	if o == nil {
		o = &ConfigAIOpenaiInsertInput{}
	}
	return o.Organization
}

func (o *ConfigAIOpenaiInsertInput) GetApiKey() string {
	if o == nil {
		o = &ConfigAIOpenaiInsertInput{}
	}
	return o.ApiKey
}

func (s *ConfigAIOpenai) Insert(v *ConfigAIOpenaiInsertInput) {
	s.Organization = v.Organization
	s.ApiKey = v.ApiKey
}

func (s *ConfigAIOpenai) Clone() *ConfigAIOpenai {
	if s == nil {
		return nil
	}

	v := &ConfigAIOpenai{}
	v.Organization = s.Organization
	v.ApiKey = s.ApiKey
	return v
}

type ConfigAIOpenaiComparisonExp struct {
	And          []*ConfigAIOpenaiComparisonExp `json:"_and,omitempty"`
	Not          *ConfigAIOpenaiComparisonExp   `json:"_not,omitempty"`
	Or           []*ConfigAIOpenaiComparisonExp `json:"_or,omitempty"`
	Organization *ConfigStringComparisonExp     `json:"organization,omitempty"`
	ApiKey       *ConfigStringComparisonExp     `json:"apiKey,omitempty"`
}

func (exp *ConfigAIOpenaiComparisonExp) Matches(o *ConfigAIOpenai) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAIOpenai{}
	}
	if o.Organization != nil && !exp.Organization.Matches(*o.Organization) {
		return false
	}
	if !exp.ApiKey.Matches(o.ApiKey) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAIResources struct {
	Compute *ConfigComputeResources `json:"compute,omitempty" toml:"compute,omitempty"`
}

func (o *ConfigAIResources) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Compute != nil {
		m["compute"] = o.Compute
	}
	return json.Marshal(m)
}

func (o *ConfigAIResources) GetCompute() *ConfigComputeResources {
	if o == nil {
		return nil
	}
	return o.Compute
}

type ConfigAIResourcesUpdateInput struct {
	Compute      *ConfigComputeResourcesUpdateInput `json:"compute,omitempty" toml:"compute,omitempty"`
	IsSetCompute bool                               `json:"-"`
}

func (o *ConfigAIResourcesUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if x, ok := m["compute"]; ok {
		if x != nil {
			t := &ConfigComputeResourcesUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Compute = t
		}
		o.IsSetCompute = true
	}

	return nil
}

func (o *ConfigAIResourcesUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigAIResourcesUpdateInput) GetCompute() *ConfigComputeResourcesUpdateInput {
	if o == nil {
		return nil
	}
	return o.Compute
}

func (s *ConfigAIResources) Update(v *ConfigAIResourcesUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetCompute || v.Compute != nil {
		if v.Compute == nil {
			s.Compute = nil
		} else {
			if s.Compute == nil {
				s.Compute = &ConfigComputeResources{}
			}
			s.Compute.Update(v.Compute)
		}
	}
}

type ConfigAIResourcesInsertInput struct {
	Compute *ConfigComputeResourcesInsertInput `json:"compute,omitempty" toml:"compute,omitempty"`
}

func (o *ConfigAIResourcesInsertInput) GetCompute() *ConfigComputeResourcesInsertInput {
	if o == nil {
		return nil
	}
	return o.Compute
}

func (s *ConfigAIResources) Insert(v *ConfigAIResourcesInsertInput) {
	if v.Compute != nil {
		if s.Compute == nil {
			s.Compute = &ConfigComputeResources{}
		}
		s.Compute.Insert(v.Compute)
	}
}

func (s *ConfigAIResources) Clone() *ConfigAIResources {
	if s == nil {
		return nil
	}

	v := &ConfigAIResources{}
	v.Compute = s.Compute.Clone()
	return v
}

type ConfigAIResourcesComparisonExp struct {
	And     []*ConfigAIResourcesComparisonExp    `json:"_and,omitempty"`
	Not     *ConfigAIResourcesComparisonExp      `json:"_not,omitempty"`
	Or      []*ConfigAIResourcesComparisonExp    `json:"_or,omitempty"`
	Compute *ConfigComputeResourcesComparisonExp `json:"compute,omitempty"`
}

func (exp *ConfigAIResourcesComparisonExp) Matches(o *ConfigAIResources) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAIResources{
			Compute: &ConfigComputeResources{},
		}
	}
	if !exp.Compute.Matches(o.Compute) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

// Configuration for auth service
// You can find more information about the configuration here:
// https://github.com/nhost/hasura-auth/blob/main/docs/environment-variables.md
type ConfigAuth struct {
	// Version of auth, you can see available versions in the URL below:
	// https://hub.docker.com/r/nhost/hasura-auth/tags
	//
	// Releases:
	//
	// https://github.com/nhost/hasura-auth/releases
	Version *string `json:"version" toml:"version"`
	// Resources for the service
	Resources *ConfigResources `json:"resources,omitempty" toml:"resources,omitempty"`

	ElevatedPrivileges *ConfigAuthElevatedPrivileges `json:"elevatedPrivileges,omitempty" toml:"elevatedPrivileges,omitempty"`

	Redirections *ConfigAuthRedirections `json:"redirections,omitempty" toml:"redirections,omitempty"`

	SignUp *ConfigAuthSignUp `json:"signUp,omitempty" toml:"signUp,omitempty"`

	User *ConfigAuthUser `json:"user,omitempty" toml:"user,omitempty"`

	Session *ConfigAuthSession `json:"session,omitempty" toml:"session,omitempty"`

	Method *ConfigAuthMethod `json:"method,omitempty" toml:"method,omitempty"`

	Totp *ConfigAuthTotp `json:"totp,omitempty" toml:"totp,omitempty"`

	Misc *ConfigAuthMisc `json:"misc,omitempty" toml:"misc,omitempty"`

	RateLimit *ConfigAuthRateLimit `json:"rateLimit,omitempty" toml:"rateLimit,omitempty"`
}

func (o *ConfigAuth) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Version != nil {
		m["version"] = o.Version
	}
	if o.Resources != nil {
		m["resources"] = o.Resources
	}
	if o.ElevatedPrivileges != nil {
		m["elevatedPrivileges"] = o.ElevatedPrivileges
	}
	if o.Redirections != nil {
		m["redirections"] = o.Redirections
	}
	if o.SignUp != nil {
		m["signUp"] = o.SignUp
	}
	if o.User != nil {
		m["user"] = o.User
	}
	if o.Session != nil {
		m["session"] = o.Session
	}
	if o.Method != nil {
		m["method"] = o.Method
	}
	if o.Totp != nil {
		m["totp"] = o.Totp
	}
	if o.Misc != nil {
		m["misc"] = o.Misc
	}
	if o.RateLimit != nil {
		m["rateLimit"] = o.RateLimit
	}
	return json.Marshal(m)
}

func (o *ConfigAuth) GetVersion() *string {
	if o == nil {
		o = &ConfigAuth{}
	}
	return o.Version
}

func (o *ConfigAuth) GetResources() *ConfigResources {
	if o == nil {
		return nil
	}
	return o.Resources
}

func (o *ConfigAuth) GetElevatedPrivileges() *ConfigAuthElevatedPrivileges {
	if o == nil {
		return nil
	}
	return o.ElevatedPrivileges
}

func (o *ConfigAuth) GetRedirections() *ConfigAuthRedirections {
	if o == nil {
		return nil
	}
	return o.Redirections
}

func (o *ConfigAuth) GetSignUp() *ConfigAuthSignUp {
	if o == nil {
		return nil
	}
	return o.SignUp
}

func (o *ConfigAuth) GetUser() *ConfigAuthUser {
	if o == nil {
		return nil
	}
	return o.User
}

func (o *ConfigAuth) GetSession() *ConfigAuthSession {
	if o == nil {
		return nil
	}
	return o.Session
}

func (o *ConfigAuth) GetMethod() *ConfigAuthMethod {
	if o == nil {
		return nil
	}
	return o.Method
}

func (o *ConfigAuth) GetTotp() *ConfigAuthTotp {
	if o == nil {
		return nil
	}
	return o.Totp
}

func (o *ConfigAuth) GetMisc() *ConfigAuthMisc {
	if o == nil {
		return nil
	}
	return o.Misc
}

func (o *ConfigAuth) GetRateLimit() *ConfigAuthRateLimit {
	if o == nil {
		return nil
	}
	return o.RateLimit
}

type ConfigAuthUpdateInput struct {
	Version                 *string                                  `json:"version,omitempty" toml:"version,omitempty"`
	IsSetVersion            bool                                     `json:"-"`
	Resources               *ConfigResourcesUpdateInput              `json:"resources,omitempty" toml:"resources,omitempty"`
	IsSetResources          bool                                     `json:"-"`
	ElevatedPrivileges      *ConfigAuthElevatedPrivilegesUpdateInput `json:"elevatedPrivileges,omitempty" toml:"elevatedPrivileges,omitempty"`
	IsSetElevatedPrivileges bool                                     `json:"-"`
	Redirections            *ConfigAuthRedirectionsUpdateInput       `json:"redirections,omitempty" toml:"redirections,omitempty"`
	IsSetRedirections       bool                                     `json:"-"`
	SignUp                  *ConfigAuthSignUpUpdateInput             `json:"signUp,omitempty" toml:"signUp,omitempty"`
	IsSetSignUp             bool                                     `json:"-"`
	User                    *ConfigAuthUserUpdateInput               `json:"user,omitempty" toml:"user,omitempty"`
	IsSetUser               bool                                     `json:"-"`
	Session                 *ConfigAuthSessionUpdateInput            `json:"session,omitempty" toml:"session,omitempty"`
	IsSetSession            bool                                     `json:"-"`
	Method                  *ConfigAuthMethodUpdateInput             `json:"method,omitempty" toml:"method,omitempty"`
	IsSetMethod             bool                                     `json:"-"`
	Totp                    *ConfigAuthTotpUpdateInput               `json:"totp,omitempty" toml:"totp,omitempty"`
	IsSetTotp               bool                                     `json:"-"`
	Misc                    *ConfigAuthMiscUpdateInput               `json:"misc,omitempty" toml:"misc,omitempty"`
	IsSetMisc               bool                                     `json:"-"`
	RateLimit               *ConfigAuthRateLimitUpdateInput          `json:"rateLimit,omitempty" toml:"rateLimit,omitempty"`
	IsSetRateLimit          bool                                     `json:"-"`
}

func (o *ConfigAuthUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["version"]; ok {
		if v == nil {
			o.Version = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Version = &x
		}
		o.IsSetVersion = true
	}
	if x, ok := m["resources"]; ok {
		if x != nil {
			t := &ConfigResourcesUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Resources = t
		}
		o.IsSetResources = true
	}
	if x, ok := m["elevatedPrivileges"]; ok {
		if x != nil {
			t := &ConfigAuthElevatedPrivilegesUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.ElevatedPrivileges = t
		}
		o.IsSetElevatedPrivileges = true
	}
	if x, ok := m["redirections"]; ok {
		if x != nil {
			t := &ConfigAuthRedirectionsUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Redirections = t
		}
		o.IsSetRedirections = true
	}
	if x, ok := m["signUp"]; ok {
		if x != nil {
			t := &ConfigAuthSignUpUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.SignUp = t
		}
		o.IsSetSignUp = true
	}
	if x, ok := m["user"]; ok {
		if x != nil {
			t := &ConfigAuthUserUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.User = t
		}
		o.IsSetUser = true
	}
	if x, ok := m["session"]; ok {
		if x != nil {
			t := &ConfigAuthSessionUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Session = t
		}
		o.IsSetSession = true
	}
	if x, ok := m["method"]; ok {
		if x != nil {
			t := &ConfigAuthMethodUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Method = t
		}
		o.IsSetMethod = true
	}
	if x, ok := m["totp"]; ok {
		if x != nil {
			t := &ConfigAuthTotpUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Totp = t
		}
		o.IsSetTotp = true
	}
	if x, ok := m["misc"]; ok {
		if x != nil {
			t := &ConfigAuthMiscUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Misc = t
		}
		o.IsSetMisc = true
	}
	if x, ok := m["rateLimit"]; ok {
		if x != nil {
			t := &ConfigAuthRateLimitUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.RateLimit = t
		}
		o.IsSetRateLimit = true
	}

	return nil
}

func (o *ConfigAuthUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigAuthUpdateInput) GetVersion() *string {
	if o == nil {
		o = &ConfigAuthUpdateInput{}
	}
	return o.Version
}

func (o *ConfigAuthUpdateInput) GetResources() *ConfigResourcesUpdateInput {
	if o == nil {
		return nil
	}
	return o.Resources
}

func (o *ConfigAuthUpdateInput) GetElevatedPrivileges() *ConfigAuthElevatedPrivilegesUpdateInput {
	if o == nil {
		return nil
	}
	return o.ElevatedPrivileges
}

func (o *ConfigAuthUpdateInput) GetRedirections() *ConfigAuthRedirectionsUpdateInput {
	if o == nil {
		return nil
	}
	return o.Redirections
}

func (o *ConfigAuthUpdateInput) GetSignUp() *ConfigAuthSignUpUpdateInput {
	if o == nil {
		return nil
	}
	return o.SignUp
}

func (o *ConfigAuthUpdateInput) GetUser() *ConfigAuthUserUpdateInput {
	if o == nil {
		return nil
	}
	return o.User
}

func (o *ConfigAuthUpdateInput) GetSession() *ConfigAuthSessionUpdateInput {
	if o == nil {
		return nil
	}
	return o.Session
}

func (o *ConfigAuthUpdateInput) GetMethod() *ConfigAuthMethodUpdateInput {
	if o == nil {
		return nil
	}
	return o.Method
}

func (o *ConfigAuthUpdateInput) GetTotp() *ConfigAuthTotpUpdateInput {
	if o == nil {
		return nil
	}
	return o.Totp
}

func (o *ConfigAuthUpdateInput) GetMisc() *ConfigAuthMiscUpdateInput {
	if o == nil {
		return nil
	}
	return o.Misc
}

func (o *ConfigAuthUpdateInput) GetRateLimit() *ConfigAuthRateLimitUpdateInput {
	if o == nil {
		return nil
	}
	return o.RateLimit
}

func (s *ConfigAuth) Update(v *ConfigAuthUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetVersion || v.Version != nil {
		s.Version = v.Version
	}
	if v.IsSetResources || v.Resources != nil {
		if v.Resources == nil {
			s.Resources = nil
		} else {
			if s.Resources == nil {
				s.Resources = &ConfigResources{}
			}
			s.Resources.Update(v.Resources)
		}
	}
	if v.IsSetElevatedPrivileges || v.ElevatedPrivileges != nil {
		if v.ElevatedPrivileges == nil {
			s.ElevatedPrivileges = nil
		} else {
			if s.ElevatedPrivileges == nil {
				s.ElevatedPrivileges = &ConfigAuthElevatedPrivileges{}
			}
			s.ElevatedPrivileges.Update(v.ElevatedPrivileges)
		}
	}
	if v.IsSetRedirections || v.Redirections != nil {
		if v.Redirections == nil {
			s.Redirections = nil
		} else {
			if s.Redirections == nil {
				s.Redirections = &ConfigAuthRedirections{}
			}
			s.Redirections.Update(v.Redirections)
		}
	}
	if v.IsSetSignUp || v.SignUp != nil {
		if v.SignUp == nil {
			s.SignUp = nil
		} else {
			if s.SignUp == nil {
				s.SignUp = &ConfigAuthSignUp{}
			}
			s.SignUp.Update(v.SignUp)
		}
	}
	if v.IsSetUser || v.User != nil {
		if v.User == nil {
			s.User = nil
		} else {
			if s.User == nil {
				s.User = &ConfigAuthUser{}
			}
			s.User.Update(v.User)
		}
	}
	if v.IsSetSession || v.Session != nil {
		if v.Session == nil {
			s.Session = nil
		} else {
			if s.Session == nil {
				s.Session = &ConfigAuthSession{}
			}
			s.Session.Update(v.Session)
		}
	}
	if v.IsSetMethod || v.Method != nil {
		if v.Method == nil {
			s.Method = nil
		} else {
			if s.Method == nil {
				s.Method = &ConfigAuthMethod{}
			}
			s.Method.Update(v.Method)
		}
	}
	if v.IsSetTotp || v.Totp != nil {
		if v.Totp == nil {
			s.Totp = nil
		} else {
			if s.Totp == nil {
				s.Totp = &ConfigAuthTotp{}
			}
			s.Totp.Update(v.Totp)
		}
	}
	if v.IsSetMisc || v.Misc != nil {
		if v.Misc == nil {
			s.Misc = nil
		} else {
			if s.Misc == nil {
				s.Misc = &ConfigAuthMisc{}
			}
			s.Misc.Update(v.Misc)
		}
	}
	if v.IsSetRateLimit || v.RateLimit != nil {
		if v.RateLimit == nil {
			s.RateLimit = nil
		} else {
			if s.RateLimit == nil {
				s.RateLimit = &ConfigAuthRateLimit{}
			}
			s.RateLimit.Update(v.RateLimit)
		}
	}
}

type ConfigAuthInsertInput struct {
	Version            *string                                  `json:"version,omitempty" toml:"version,omitempty"`
	Resources          *ConfigResourcesInsertInput              `json:"resources,omitempty" toml:"resources,omitempty"`
	ElevatedPrivileges *ConfigAuthElevatedPrivilegesInsertInput `json:"elevatedPrivileges,omitempty" toml:"elevatedPrivileges,omitempty"`
	Redirections       *ConfigAuthRedirectionsInsertInput       `json:"redirections,omitempty" toml:"redirections,omitempty"`
	SignUp             *ConfigAuthSignUpInsertInput             `json:"signUp,omitempty" toml:"signUp,omitempty"`
	User               *ConfigAuthUserInsertInput               `json:"user,omitempty" toml:"user,omitempty"`
	Session            *ConfigAuthSessionInsertInput            `json:"session,omitempty" toml:"session,omitempty"`
	Method             *ConfigAuthMethodInsertInput             `json:"method,omitempty" toml:"method,omitempty"`
	Totp               *ConfigAuthTotpInsertInput               `json:"totp,omitempty" toml:"totp,omitempty"`
	Misc               *ConfigAuthMiscInsertInput               `json:"misc,omitempty" toml:"misc,omitempty"`
	RateLimit          *ConfigAuthRateLimitInsertInput          `json:"rateLimit,omitempty" toml:"rateLimit,omitempty"`
}

func (o *ConfigAuthInsertInput) GetVersion() *string {
	if o == nil {
		o = &ConfigAuthInsertInput{}
	}
	return o.Version
}

func (o *ConfigAuthInsertInput) GetResources() *ConfigResourcesInsertInput {
	if o == nil {
		return nil
	}
	return o.Resources
}

func (o *ConfigAuthInsertInput) GetElevatedPrivileges() *ConfigAuthElevatedPrivilegesInsertInput {
	if o == nil {
		return nil
	}
	return o.ElevatedPrivileges
}

func (o *ConfigAuthInsertInput) GetRedirections() *ConfigAuthRedirectionsInsertInput {
	if o == nil {
		return nil
	}
	return o.Redirections
}

func (o *ConfigAuthInsertInput) GetSignUp() *ConfigAuthSignUpInsertInput {
	if o == nil {
		return nil
	}
	return o.SignUp
}

func (o *ConfigAuthInsertInput) GetUser() *ConfigAuthUserInsertInput {
	if o == nil {
		return nil
	}
	return o.User
}

func (o *ConfigAuthInsertInput) GetSession() *ConfigAuthSessionInsertInput {
	if o == nil {
		return nil
	}
	return o.Session
}

func (o *ConfigAuthInsertInput) GetMethod() *ConfigAuthMethodInsertInput {
	if o == nil {
		return nil
	}
	return o.Method
}

func (o *ConfigAuthInsertInput) GetTotp() *ConfigAuthTotpInsertInput {
	if o == nil {
		return nil
	}
	return o.Totp
}

func (o *ConfigAuthInsertInput) GetMisc() *ConfigAuthMiscInsertInput {
	if o == nil {
		return nil
	}
	return o.Misc
}

func (o *ConfigAuthInsertInput) GetRateLimit() *ConfigAuthRateLimitInsertInput {
	if o == nil {
		return nil
	}
	return o.RateLimit
}

func (s *ConfigAuth) Insert(v *ConfigAuthInsertInput) {
	s.Version = v.Version
	if v.Resources != nil {
		if s.Resources == nil {
			s.Resources = &ConfigResources{}
		}
		s.Resources.Insert(v.Resources)
	}
	if v.ElevatedPrivileges != nil {
		if s.ElevatedPrivileges == nil {
			s.ElevatedPrivileges = &ConfigAuthElevatedPrivileges{}
		}
		s.ElevatedPrivileges.Insert(v.ElevatedPrivileges)
	}
	if v.Redirections != nil {
		if s.Redirections == nil {
			s.Redirections = &ConfigAuthRedirections{}
		}
		s.Redirections.Insert(v.Redirections)
	}
	if v.SignUp != nil {
		if s.SignUp == nil {
			s.SignUp = &ConfigAuthSignUp{}
		}
		s.SignUp.Insert(v.SignUp)
	}
	if v.User != nil {
		if s.User == nil {
			s.User = &ConfigAuthUser{}
		}
		s.User.Insert(v.User)
	}
	if v.Session != nil {
		if s.Session == nil {
			s.Session = &ConfigAuthSession{}
		}
		s.Session.Insert(v.Session)
	}
	if v.Method != nil {
		if s.Method == nil {
			s.Method = &ConfigAuthMethod{}
		}
		s.Method.Insert(v.Method)
	}
	if v.Totp != nil {
		if s.Totp == nil {
			s.Totp = &ConfigAuthTotp{}
		}
		s.Totp.Insert(v.Totp)
	}
	if v.Misc != nil {
		if s.Misc == nil {
			s.Misc = &ConfigAuthMisc{}
		}
		s.Misc.Insert(v.Misc)
	}
	if v.RateLimit != nil {
		if s.RateLimit == nil {
			s.RateLimit = &ConfigAuthRateLimit{}
		}
		s.RateLimit.Insert(v.RateLimit)
	}
}

func (s *ConfigAuth) Clone() *ConfigAuth {
	if s == nil {
		return nil
	}

	v := &ConfigAuth{}
	v.Version = s.Version
	v.Resources = s.Resources.Clone()
	v.ElevatedPrivileges = s.ElevatedPrivileges.Clone()
	v.Redirections = s.Redirections.Clone()
	v.SignUp = s.SignUp.Clone()
	v.User = s.User.Clone()
	v.Session = s.Session.Clone()
	v.Method = s.Method.Clone()
	v.Totp = s.Totp.Clone()
	v.Misc = s.Misc.Clone()
	v.RateLimit = s.RateLimit.Clone()
	return v
}

type ConfigAuthComparisonExp struct {
	And                []*ConfigAuthComparisonExp                 `json:"_and,omitempty"`
	Not                *ConfigAuthComparisonExp                   `json:"_not,omitempty"`
	Or                 []*ConfigAuthComparisonExp                 `json:"_or,omitempty"`
	Version            *ConfigStringComparisonExp                 `json:"version,omitempty"`
	Resources          *ConfigResourcesComparisonExp              `json:"resources,omitempty"`
	ElevatedPrivileges *ConfigAuthElevatedPrivilegesComparisonExp `json:"elevatedPrivileges,omitempty"`
	Redirections       *ConfigAuthRedirectionsComparisonExp       `json:"redirections,omitempty"`
	SignUp             *ConfigAuthSignUpComparisonExp             `json:"signUp,omitempty"`
	User               *ConfigAuthUserComparisonExp               `json:"user,omitempty"`
	Session            *ConfigAuthSessionComparisonExp            `json:"session,omitempty"`
	Method             *ConfigAuthMethodComparisonExp             `json:"method,omitempty"`
	Totp               *ConfigAuthTotpComparisonExp               `json:"totp,omitempty"`
	Misc               *ConfigAuthMiscComparisonExp               `json:"misc,omitempty"`
	RateLimit          *ConfigAuthRateLimitComparisonExp          `json:"rateLimit,omitempty"`
}

func (exp *ConfigAuthComparisonExp) Matches(o *ConfigAuth) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuth{
			Resources:          &ConfigResources{},
			ElevatedPrivileges: &ConfigAuthElevatedPrivileges{},
			Redirections:       &ConfigAuthRedirections{},
			SignUp:             &ConfigAuthSignUp{},
			User:               &ConfigAuthUser{},
			Session:            &ConfigAuthSession{},
			Method:             &ConfigAuthMethod{},
			Totp:               &ConfigAuthTotp{},
			Misc:               &ConfigAuthMisc{},
			RateLimit:          &ConfigAuthRateLimit{},
		}
	}
	if o.Version != nil && !exp.Version.Matches(*o.Version) {
		return false
	}
	if !exp.Resources.Matches(o.Resources) {
		return false
	}
	if !exp.ElevatedPrivileges.Matches(o.ElevatedPrivileges) {
		return false
	}
	if !exp.Redirections.Matches(o.Redirections) {
		return false
	}
	if !exp.SignUp.Matches(o.SignUp) {
		return false
	}
	if !exp.User.Matches(o.User) {
		return false
	}
	if !exp.Session.Matches(o.Session) {
		return false
	}
	if !exp.Method.Matches(o.Method) {
		return false
	}
	if !exp.Totp.Matches(o.Totp) {
		return false
	}
	if !exp.Misc.Matches(o.Misc) {
		return false
	}
	if !exp.RateLimit.Matches(o.RateLimit) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAuthElevatedPrivileges struct {
	Mode *string `json:"mode" toml:"mode"`
}

func (o *ConfigAuthElevatedPrivileges) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Mode != nil {
		m["mode"] = o.Mode
	}
	return json.Marshal(m)
}

func (o *ConfigAuthElevatedPrivileges) GetMode() *string {
	if o == nil {
		o = &ConfigAuthElevatedPrivileges{}
	}
	return o.Mode
}

type ConfigAuthElevatedPrivilegesUpdateInput struct {
	Mode      *string `json:"mode,omitempty" toml:"mode,omitempty"`
	IsSetMode bool    `json:"-"`
}

func (o *ConfigAuthElevatedPrivilegesUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["mode"]; ok {
		if v == nil {
			o.Mode = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Mode = &x
		}
		o.IsSetMode = true
	}

	return nil
}

func (o *ConfigAuthElevatedPrivilegesUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigAuthElevatedPrivilegesUpdateInput) GetMode() *string {
	if o == nil {
		o = &ConfigAuthElevatedPrivilegesUpdateInput{}
	}
	return o.Mode
}

func (s *ConfigAuthElevatedPrivileges) Update(v *ConfigAuthElevatedPrivilegesUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetMode || v.Mode != nil {
		s.Mode = v.Mode
	}
}

type ConfigAuthElevatedPrivilegesInsertInput struct {
	Mode *string `json:"mode,omitempty" toml:"mode,omitempty"`
}

func (o *ConfigAuthElevatedPrivilegesInsertInput) GetMode() *string {
	if o == nil {
		o = &ConfigAuthElevatedPrivilegesInsertInput{}
	}
	return o.Mode
}

func (s *ConfigAuthElevatedPrivileges) Insert(v *ConfigAuthElevatedPrivilegesInsertInput) {
	s.Mode = v.Mode
}

func (s *ConfigAuthElevatedPrivileges) Clone() *ConfigAuthElevatedPrivileges {
	if s == nil {
		return nil
	}

	v := &ConfigAuthElevatedPrivileges{}
	v.Mode = s.Mode
	return v
}

type ConfigAuthElevatedPrivilegesComparisonExp struct {
	And  []*ConfigAuthElevatedPrivilegesComparisonExp `json:"_and,omitempty"`
	Not  *ConfigAuthElevatedPrivilegesComparisonExp   `json:"_not,omitempty"`
	Or   []*ConfigAuthElevatedPrivilegesComparisonExp `json:"_or,omitempty"`
	Mode *ConfigStringComparisonExp                   `json:"mode,omitempty"`
}

func (exp *ConfigAuthElevatedPrivilegesComparisonExp) Matches(o *ConfigAuthElevatedPrivileges) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthElevatedPrivileges{}
	}
	if o.Mode != nil && !exp.Mode.Matches(*o.Mode) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAuthMethod struct {
	Anonymous *ConfigAuthMethodAnonymous `json:"anonymous,omitempty" toml:"anonymous,omitempty"`

	EmailPasswordless *ConfigAuthMethodEmailPasswordless `json:"emailPasswordless,omitempty" toml:"emailPasswordless,omitempty"`

	Otp *ConfigAuthMethodOtp `json:"otp,omitempty" toml:"otp,omitempty"`

	EmailPassword *ConfigAuthMethodEmailPassword `json:"emailPassword,omitempty" toml:"emailPassword,omitempty"`

	SmsPasswordless *ConfigAuthMethodSmsPasswordless `json:"smsPasswordless,omitempty" toml:"smsPasswordless,omitempty"`

	Oauth *ConfigAuthMethodOauth `json:"oauth,omitempty" toml:"oauth,omitempty"`

	Webauthn *ConfigAuthMethodWebauthn `json:"webauthn,omitempty" toml:"webauthn,omitempty"`
}

func (o *ConfigAuthMethod) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Anonymous != nil {
		m["anonymous"] = o.Anonymous
	}
	if o.EmailPasswordless != nil {
		m["emailPasswordless"] = o.EmailPasswordless
	}
	if o.Otp != nil {
		m["otp"] = o.Otp
	}
	if o.EmailPassword != nil {
		m["emailPassword"] = o.EmailPassword
	}
	if o.SmsPasswordless != nil {
		m["smsPasswordless"] = o.SmsPasswordless
	}
	if o.Oauth != nil {
		m["oauth"] = o.Oauth
	}
	if o.Webauthn != nil {
		m["webauthn"] = o.Webauthn
	}
	return json.Marshal(m)
}

func (o *ConfigAuthMethod) GetAnonymous() *ConfigAuthMethodAnonymous {
	if o == nil {
		return nil
	}
	return o.Anonymous
}

func (o *ConfigAuthMethod) GetEmailPasswordless() *ConfigAuthMethodEmailPasswordless {
	if o == nil {
		return nil
	}
	return o.EmailPasswordless
}

func (o *ConfigAuthMethod) GetOtp() *ConfigAuthMethodOtp {
	if o == nil {
		return nil
	}
	return o.Otp
}

func (o *ConfigAuthMethod) GetEmailPassword() *ConfigAuthMethodEmailPassword {
	if o == nil {
		return nil
	}
	return o.EmailPassword
}

func (o *ConfigAuthMethod) GetSmsPasswordless() *ConfigAuthMethodSmsPasswordless {
	if o == nil {
		return nil
	}
	return o.SmsPasswordless
}

func (o *ConfigAuthMethod) GetOauth() *ConfigAuthMethodOauth {
	if o == nil {
		return nil
	}
	return o.Oauth
}

func (o *ConfigAuthMethod) GetWebauthn() *ConfigAuthMethodWebauthn {
	if o == nil {
		return nil
	}
	return o.Webauthn
}

type ConfigAuthMethodUpdateInput struct {
	Anonymous              *ConfigAuthMethodAnonymousUpdateInput         `json:"anonymous,omitempty" toml:"anonymous,omitempty"`
	IsSetAnonymous         bool                                          `json:"-"`
	EmailPasswordless      *ConfigAuthMethodEmailPasswordlessUpdateInput `json:"emailPasswordless,omitempty" toml:"emailPasswordless,omitempty"`
	IsSetEmailPasswordless bool                                          `json:"-"`
	Otp                    *ConfigAuthMethodOtpUpdateInput               `json:"otp,omitempty" toml:"otp,omitempty"`
	IsSetOtp               bool                                          `json:"-"`
	EmailPassword          *ConfigAuthMethodEmailPasswordUpdateInput     `json:"emailPassword,omitempty" toml:"emailPassword,omitempty"`
	IsSetEmailPassword     bool                                          `json:"-"`
	SmsPasswordless        *ConfigAuthMethodSmsPasswordlessUpdateInput   `json:"smsPasswordless,omitempty" toml:"smsPasswordless,omitempty"`
	IsSetSmsPasswordless   bool                                          `json:"-"`
	Oauth                  *ConfigAuthMethodOauthUpdateInput             `json:"oauth,omitempty" toml:"oauth,omitempty"`
	IsSetOauth             bool                                          `json:"-"`
	Webauthn               *ConfigAuthMethodWebauthnUpdateInput          `json:"webauthn,omitempty" toml:"webauthn,omitempty"`
	IsSetWebauthn          bool                                          `json:"-"`
}

func (o *ConfigAuthMethodUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if x, ok := m["anonymous"]; ok {
		if x != nil {
			t := &ConfigAuthMethodAnonymousUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Anonymous = t
		}
		o.IsSetAnonymous = true
	}
	if x, ok := m["emailPasswordless"]; ok {
		if x != nil {
			t := &ConfigAuthMethodEmailPasswordlessUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.EmailPasswordless = t
		}
		o.IsSetEmailPasswordless = true
	}
	if x, ok := m["otp"]; ok {
		if x != nil {
			t := &ConfigAuthMethodOtpUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Otp = t
		}
		o.IsSetOtp = true
	}
	if x, ok := m["emailPassword"]; ok {
		if x != nil {
			t := &ConfigAuthMethodEmailPasswordUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.EmailPassword = t
		}
		o.IsSetEmailPassword = true
	}
	if x, ok := m["smsPasswordless"]; ok {
		if x != nil {
			t := &ConfigAuthMethodSmsPasswordlessUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.SmsPasswordless = t
		}
		o.IsSetSmsPasswordless = true
	}
	if x, ok := m["oauth"]; ok {
		if x != nil {
			t := &ConfigAuthMethodOauthUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Oauth = t
		}
		o.IsSetOauth = true
	}
	if x, ok := m["webauthn"]; ok {
		if x != nil {
			t := &ConfigAuthMethodWebauthnUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Webauthn = t
		}
		o.IsSetWebauthn = true
	}

	return nil
}

func (o *ConfigAuthMethodUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigAuthMethodUpdateInput) GetAnonymous() *ConfigAuthMethodAnonymousUpdateInput {
	if o == nil {
		return nil
	}
	return o.Anonymous
}

func (o *ConfigAuthMethodUpdateInput) GetEmailPasswordless() *ConfigAuthMethodEmailPasswordlessUpdateInput {
	if o == nil {
		return nil
	}
	return o.EmailPasswordless
}

func (o *ConfigAuthMethodUpdateInput) GetOtp() *ConfigAuthMethodOtpUpdateInput {
	if o == nil {
		return nil
	}
	return o.Otp
}

func (o *ConfigAuthMethodUpdateInput) GetEmailPassword() *ConfigAuthMethodEmailPasswordUpdateInput {
	if o == nil {
		return nil
	}
	return o.EmailPassword
}

func (o *ConfigAuthMethodUpdateInput) GetSmsPasswordless() *ConfigAuthMethodSmsPasswordlessUpdateInput {
	if o == nil {
		return nil
	}
	return o.SmsPasswordless
}

func (o *ConfigAuthMethodUpdateInput) GetOauth() *ConfigAuthMethodOauthUpdateInput {
	if o == nil {
		return nil
	}
	return o.Oauth
}

func (o *ConfigAuthMethodUpdateInput) GetWebauthn() *ConfigAuthMethodWebauthnUpdateInput {
	if o == nil {
		return nil
	}
	return o.Webauthn
}

func (s *ConfigAuthMethod) Update(v *ConfigAuthMethodUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetAnonymous || v.Anonymous != nil {
		if v.Anonymous == nil {
			s.Anonymous = nil
		} else {
			if s.Anonymous == nil {
				s.Anonymous = &ConfigAuthMethodAnonymous{}
			}
			s.Anonymous.Update(v.Anonymous)
		}
	}
	if v.IsSetEmailPasswordless || v.EmailPasswordless != nil {
		if v.EmailPasswordless == nil {
			s.EmailPasswordless = nil
		} else {
			if s.EmailPasswordless == nil {
				s.EmailPasswordless = &ConfigAuthMethodEmailPasswordless{}
			}
			s.EmailPasswordless.Update(v.EmailPasswordless)
		}
	}
	if v.IsSetOtp || v.Otp != nil {
		if v.Otp == nil {
			s.Otp = nil
		} else {
			if s.Otp == nil {
				s.Otp = &ConfigAuthMethodOtp{}
			}
			s.Otp.Update(v.Otp)
		}
	}
	if v.IsSetEmailPassword || v.EmailPassword != nil {
		if v.EmailPassword == nil {
			s.EmailPassword = nil
		} else {
			if s.EmailPassword == nil {
				s.EmailPassword = &ConfigAuthMethodEmailPassword{}
			}
			s.EmailPassword.Update(v.EmailPassword)
		}
	}
	if v.IsSetSmsPasswordless || v.SmsPasswordless != nil {
		if v.SmsPasswordless == nil {
			s.SmsPasswordless = nil
		} else {
			if s.SmsPasswordless == nil {
				s.SmsPasswordless = &ConfigAuthMethodSmsPasswordless{}
			}
			s.SmsPasswordless.Update(v.SmsPasswordless)
		}
	}
	if v.IsSetOauth || v.Oauth != nil {
		if v.Oauth == nil {
			s.Oauth = nil
		} else {
			if s.Oauth == nil {
				s.Oauth = &ConfigAuthMethodOauth{}
			}
			s.Oauth.Update(v.Oauth)
		}
	}
	if v.IsSetWebauthn || v.Webauthn != nil {
		if v.Webauthn == nil {
			s.Webauthn = nil
		} else {
			if s.Webauthn == nil {
				s.Webauthn = &ConfigAuthMethodWebauthn{}
			}
			s.Webauthn.Update(v.Webauthn)
		}
	}
}

type ConfigAuthMethodInsertInput struct {
	Anonymous         *ConfigAuthMethodAnonymousInsertInput         `json:"anonymous,omitempty" toml:"anonymous,omitempty"`
	EmailPasswordless *ConfigAuthMethodEmailPasswordlessInsertInput `json:"emailPasswordless,omitempty" toml:"emailPasswordless,omitempty"`
	Otp               *ConfigAuthMethodOtpInsertInput               `json:"otp,omitempty" toml:"otp,omitempty"`
	EmailPassword     *ConfigAuthMethodEmailPasswordInsertInput     `json:"emailPassword,omitempty" toml:"emailPassword,omitempty"`
	SmsPasswordless   *ConfigAuthMethodSmsPasswordlessInsertInput   `json:"smsPasswordless,omitempty" toml:"smsPasswordless,omitempty"`
	Oauth             *ConfigAuthMethodOauthInsertInput             `json:"oauth,omitempty" toml:"oauth,omitempty"`
	Webauthn          *ConfigAuthMethodWebauthnInsertInput          `json:"webauthn,omitempty" toml:"webauthn,omitempty"`
}

func (o *ConfigAuthMethodInsertInput) GetAnonymous() *ConfigAuthMethodAnonymousInsertInput {
	if o == nil {
		return nil
	}
	return o.Anonymous
}

func (o *ConfigAuthMethodInsertInput) GetEmailPasswordless() *ConfigAuthMethodEmailPasswordlessInsertInput {
	if o == nil {
		return nil
	}
	return o.EmailPasswordless
}

func (o *ConfigAuthMethodInsertInput) GetOtp() *ConfigAuthMethodOtpInsertInput {
	if o == nil {
		return nil
	}
	return o.Otp
}

func (o *ConfigAuthMethodInsertInput) GetEmailPassword() *ConfigAuthMethodEmailPasswordInsertInput {
	if o == nil {
		return nil
	}
	return o.EmailPassword
}

func (o *ConfigAuthMethodInsertInput) GetSmsPasswordless() *ConfigAuthMethodSmsPasswordlessInsertInput {
	if o == nil {
		return nil
	}
	return o.SmsPasswordless
}

func (o *ConfigAuthMethodInsertInput) GetOauth() *ConfigAuthMethodOauthInsertInput {
	if o == nil {
		return nil
	}
	return o.Oauth
}

func (o *ConfigAuthMethodInsertInput) GetWebauthn() *ConfigAuthMethodWebauthnInsertInput {
	if o == nil {
		return nil
	}
	return o.Webauthn
}

func (s *ConfigAuthMethod) Insert(v *ConfigAuthMethodInsertInput) {
	if v.Anonymous != nil {
		if s.Anonymous == nil {
			s.Anonymous = &ConfigAuthMethodAnonymous{}
		}
		s.Anonymous.Insert(v.Anonymous)
	}
	if v.EmailPasswordless != nil {
		if s.EmailPasswordless == nil {
			s.EmailPasswordless = &ConfigAuthMethodEmailPasswordless{}
		}
		s.EmailPasswordless.Insert(v.EmailPasswordless)
	}
	if v.Otp != nil {
		if s.Otp == nil {
			s.Otp = &ConfigAuthMethodOtp{}
		}
		s.Otp.Insert(v.Otp)
	}
	if v.EmailPassword != nil {
		if s.EmailPassword == nil {
			s.EmailPassword = &ConfigAuthMethodEmailPassword{}
		}
		s.EmailPassword.Insert(v.EmailPassword)
	}
	if v.SmsPasswordless != nil {
		if s.SmsPasswordless == nil {
			s.SmsPasswordless = &ConfigAuthMethodSmsPasswordless{}
		}
		s.SmsPasswordless.Insert(v.SmsPasswordless)
	}
	if v.Oauth != nil {
		if s.Oauth == nil {
			s.Oauth = &ConfigAuthMethodOauth{}
		}
		s.Oauth.Insert(v.Oauth)
	}
	if v.Webauthn != nil {
		if s.Webauthn == nil {
			s.Webauthn = &ConfigAuthMethodWebauthn{}
		}
		s.Webauthn.Insert(v.Webauthn)
	}
}

func (s *ConfigAuthMethod) Clone() *ConfigAuthMethod {
	if s == nil {
		return nil
	}

	v := &ConfigAuthMethod{}
	v.Anonymous = s.Anonymous.Clone()
	v.EmailPasswordless = s.EmailPasswordless.Clone()
	v.Otp = s.Otp.Clone()
	v.EmailPassword = s.EmailPassword.Clone()
	v.SmsPasswordless = s.SmsPasswordless.Clone()
	v.Oauth = s.Oauth.Clone()
	v.Webauthn = s.Webauthn.Clone()
	return v
}

type ConfigAuthMethodComparisonExp struct {
	And               []*ConfigAuthMethodComparisonExp                `json:"_and,omitempty"`
	Not               *ConfigAuthMethodComparisonExp                  `json:"_not,omitempty"`
	Or                []*ConfigAuthMethodComparisonExp                `json:"_or,omitempty"`
	Anonymous         *ConfigAuthMethodAnonymousComparisonExp         `json:"anonymous,omitempty"`
	EmailPasswordless *ConfigAuthMethodEmailPasswordlessComparisonExp `json:"emailPasswordless,omitempty"`
	Otp               *ConfigAuthMethodOtpComparisonExp               `json:"otp,omitempty"`
	EmailPassword     *ConfigAuthMethodEmailPasswordComparisonExp     `json:"emailPassword,omitempty"`
	SmsPasswordless   *ConfigAuthMethodSmsPasswordlessComparisonExp   `json:"smsPasswordless,omitempty"`
	Oauth             *ConfigAuthMethodOauthComparisonExp             `json:"oauth,omitempty"`
	Webauthn          *ConfigAuthMethodWebauthnComparisonExp          `json:"webauthn,omitempty"`
}

func (exp *ConfigAuthMethodComparisonExp) Matches(o *ConfigAuthMethod) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthMethod{
			Anonymous:         &ConfigAuthMethodAnonymous{},
			EmailPasswordless: &ConfigAuthMethodEmailPasswordless{},
			Otp:               &ConfigAuthMethodOtp{},
			EmailPassword:     &ConfigAuthMethodEmailPassword{},
			SmsPasswordless:   &ConfigAuthMethodSmsPasswordless{},
			Oauth:             &ConfigAuthMethodOauth{},
			Webauthn:          &ConfigAuthMethodWebauthn{},
		}
	}
	if !exp.Anonymous.Matches(o.Anonymous) {
		return false
	}
	if !exp.EmailPasswordless.Matches(o.EmailPasswordless) {
		return false
	}
	if !exp.Otp.Matches(o.Otp) {
		return false
	}
	if !exp.EmailPassword.Matches(o.EmailPassword) {
		return false
	}
	if !exp.SmsPasswordless.Matches(o.SmsPasswordless) {
		return false
	}
	if !exp.Oauth.Matches(o.Oauth) {
		return false
	}
	if !exp.Webauthn.Matches(o.Webauthn) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAuthMethodAnonymous struct {
	Enabled *bool `json:"enabled" toml:"enabled"`
}

func (o *ConfigAuthMethodAnonymous) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Enabled != nil {
		m["enabled"] = o.Enabled
	}
	return json.Marshal(m)
}

func (o *ConfigAuthMethodAnonymous) GetEnabled() *bool {
	if o == nil {
		o = &ConfigAuthMethodAnonymous{}
	}
	return o.Enabled
}

type ConfigAuthMethodAnonymousUpdateInput struct {
	Enabled      *bool `json:"enabled,omitempty" toml:"enabled,omitempty"`
	IsSetEnabled bool  `json:"-"`
}

func (o *ConfigAuthMethodAnonymousUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["enabled"]; ok {
		if v == nil {
			o.Enabled = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x bool
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Enabled = &x
		}
		o.IsSetEnabled = true
	}

	return nil
}

func (o *ConfigAuthMethodAnonymousUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigAuthMethodAnonymousUpdateInput) GetEnabled() *bool {
	if o == nil {
		o = &ConfigAuthMethodAnonymousUpdateInput{}
	}
	return o.Enabled
}

func (s *ConfigAuthMethodAnonymous) Update(v *ConfigAuthMethodAnonymousUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetEnabled || v.Enabled != nil {
		s.Enabled = v.Enabled
	}
}

type ConfigAuthMethodAnonymousInsertInput struct {
	Enabled *bool `json:"enabled,omitempty" toml:"enabled,omitempty"`
}

func (o *ConfigAuthMethodAnonymousInsertInput) GetEnabled() *bool {
	if o == nil {
		o = &ConfigAuthMethodAnonymousInsertInput{}
	}
	return o.Enabled
}

func (s *ConfigAuthMethodAnonymous) Insert(v *ConfigAuthMethodAnonymousInsertInput) {
	s.Enabled = v.Enabled
}

func (s *ConfigAuthMethodAnonymous) Clone() *ConfigAuthMethodAnonymous {
	if s == nil {
		return nil
	}

	v := &ConfigAuthMethodAnonymous{}
	v.Enabled = s.Enabled
	return v
}

type ConfigAuthMethodAnonymousComparisonExp struct {
	And     []*ConfigAuthMethodAnonymousComparisonExp `json:"_and,omitempty"`
	Not     *ConfigAuthMethodAnonymousComparisonExp   `json:"_not,omitempty"`
	Or      []*ConfigAuthMethodAnonymousComparisonExp `json:"_or,omitempty"`
	Enabled *ConfigBooleanComparisonExp               `json:"enabled,omitempty"`
}

func (exp *ConfigAuthMethodAnonymousComparisonExp) Matches(o *ConfigAuthMethodAnonymous) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthMethodAnonymous{}
	}
	if o.Enabled != nil && !exp.Enabled.Matches(*o.Enabled) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAuthMethodEmailPassword struct {
	// Disabling email+password sign in is not implmented yet
	// enabled: bool | *true
	HibpEnabled *bool `json:"hibpEnabled" toml:"hibpEnabled"`

	EmailVerificationRequired *bool `json:"emailVerificationRequired" toml:"emailVerificationRequired"`

	PasswordMinLength *uint8 `json:"passwordMinLength" toml:"passwordMinLength"`
}

func (o *ConfigAuthMethodEmailPassword) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.HibpEnabled != nil {
		m["hibpEnabled"] = o.HibpEnabled
	}
	if o.EmailVerificationRequired != nil {
		m["emailVerificationRequired"] = o.EmailVerificationRequired
	}
	if o.PasswordMinLength != nil {
		m["passwordMinLength"] = o.PasswordMinLength
	}
	return json.Marshal(m)
}

func (o *ConfigAuthMethodEmailPassword) GetHibpEnabled() *bool {
	if o == nil {
		o = &ConfigAuthMethodEmailPassword{}
	}
	return o.HibpEnabled
}

func (o *ConfigAuthMethodEmailPassword) GetEmailVerificationRequired() *bool {
	if o == nil {
		o = &ConfigAuthMethodEmailPassword{}
	}
	return o.EmailVerificationRequired
}

func (o *ConfigAuthMethodEmailPassword) GetPasswordMinLength() *uint8 {
	if o == nil {
		o = &ConfigAuthMethodEmailPassword{}
	}
	return o.PasswordMinLength
}

type ConfigAuthMethodEmailPasswordUpdateInput struct {
	HibpEnabled                    *bool  `json:"hibpEnabled,omitempty" toml:"hibpEnabled,omitempty"`
	IsSetHibpEnabled               bool   `json:"-"`
	EmailVerificationRequired      *bool  `json:"emailVerificationRequired,omitempty" toml:"emailVerificationRequired,omitempty"`
	IsSetEmailVerificationRequired bool   `json:"-"`
	PasswordMinLength              *uint8 `json:"passwordMinLength,omitempty" toml:"passwordMinLength,omitempty"`
	IsSetPasswordMinLength         bool   `json:"-"`
}

func (o *ConfigAuthMethodEmailPasswordUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["hibpEnabled"]; ok {
		if v == nil {
			o.HibpEnabled = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x bool
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.HibpEnabled = &x
		}
		o.IsSetHibpEnabled = true
	}
	if v, ok := m["emailVerificationRequired"]; ok {
		if v == nil {
			o.EmailVerificationRequired = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x bool
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.EmailVerificationRequired = &x
		}
		o.IsSetEmailVerificationRequired = true
	}
	if v, ok := m["passwordMinLength"]; ok {
		if v == nil {
			o.PasswordMinLength = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x uint8
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.PasswordMinLength = &x
		}
		o.IsSetPasswordMinLength = true
	}

	return nil
}

func (o *ConfigAuthMethodEmailPasswordUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigAuthMethodEmailPasswordUpdateInput) GetHibpEnabled() *bool {
	if o == nil {
		o = &ConfigAuthMethodEmailPasswordUpdateInput{}
	}
	return o.HibpEnabled
}

func (o *ConfigAuthMethodEmailPasswordUpdateInput) GetEmailVerificationRequired() *bool {
	if o == nil {
		o = &ConfigAuthMethodEmailPasswordUpdateInput{}
	}
	return o.EmailVerificationRequired
}

func (o *ConfigAuthMethodEmailPasswordUpdateInput) GetPasswordMinLength() *uint8 {
	if o == nil {
		o = &ConfigAuthMethodEmailPasswordUpdateInput{}
	}
	return o.PasswordMinLength
}

func (s *ConfigAuthMethodEmailPassword) Update(v *ConfigAuthMethodEmailPasswordUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetHibpEnabled || v.HibpEnabled != nil {
		s.HibpEnabled = v.HibpEnabled
	}
	if v.IsSetEmailVerificationRequired || v.EmailVerificationRequired != nil {
		s.EmailVerificationRequired = v.EmailVerificationRequired
	}
	if v.IsSetPasswordMinLength || v.PasswordMinLength != nil {
		s.PasswordMinLength = v.PasswordMinLength
	}
}

type ConfigAuthMethodEmailPasswordInsertInput struct {
	HibpEnabled               *bool  `json:"hibpEnabled,omitempty" toml:"hibpEnabled,omitempty"`
	EmailVerificationRequired *bool  `json:"emailVerificationRequired,omitempty" toml:"emailVerificationRequired,omitempty"`
	PasswordMinLength         *uint8 `json:"passwordMinLength,omitempty" toml:"passwordMinLength,omitempty"`
}

func (o *ConfigAuthMethodEmailPasswordInsertInput) GetHibpEnabled() *bool {
	if o == nil {
		o = &ConfigAuthMethodEmailPasswordInsertInput{}
	}
	return o.HibpEnabled
}

func (o *ConfigAuthMethodEmailPasswordInsertInput) GetEmailVerificationRequired() *bool {
	if o == nil {
		o = &ConfigAuthMethodEmailPasswordInsertInput{}
	}
	return o.EmailVerificationRequired
}

func (o *ConfigAuthMethodEmailPasswordInsertInput) GetPasswordMinLength() *uint8 {
	if o == nil {
		o = &ConfigAuthMethodEmailPasswordInsertInput{}
	}
	return o.PasswordMinLength
}

func (s *ConfigAuthMethodEmailPassword) Insert(v *ConfigAuthMethodEmailPasswordInsertInput) {
	s.HibpEnabled = v.HibpEnabled
	s.EmailVerificationRequired = v.EmailVerificationRequired
	s.PasswordMinLength = v.PasswordMinLength
}

func (s *ConfigAuthMethodEmailPassword) Clone() *ConfigAuthMethodEmailPassword {
	if s == nil {
		return nil
	}

	v := &ConfigAuthMethodEmailPassword{}
	v.HibpEnabled = s.HibpEnabled
	v.EmailVerificationRequired = s.EmailVerificationRequired
	v.PasswordMinLength = s.PasswordMinLength
	return v
}

type ConfigAuthMethodEmailPasswordComparisonExp struct {
	And                       []*ConfigAuthMethodEmailPasswordComparisonExp `json:"_and,omitempty"`
	Not                       *ConfigAuthMethodEmailPasswordComparisonExp   `json:"_not,omitempty"`
	Or                        []*ConfigAuthMethodEmailPasswordComparisonExp `json:"_or,omitempty"`
	HibpEnabled               *ConfigBooleanComparisonExp                   `json:"hibpEnabled,omitempty"`
	EmailVerificationRequired *ConfigBooleanComparisonExp                   `json:"emailVerificationRequired,omitempty"`
	PasswordMinLength         *ConfigUint8ComparisonExp                     `json:"passwordMinLength,omitempty"`
}

func (exp *ConfigAuthMethodEmailPasswordComparisonExp) Matches(o *ConfigAuthMethodEmailPassword) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthMethodEmailPassword{}
	}
	if o.HibpEnabled != nil && !exp.HibpEnabled.Matches(*o.HibpEnabled) {
		return false
	}
	if o.EmailVerificationRequired != nil && !exp.EmailVerificationRequired.Matches(*o.EmailVerificationRequired) {
		return false
	}
	if o.PasswordMinLength != nil && !exp.PasswordMinLength.Matches(*o.PasswordMinLength) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAuthMethodEmailPasswordless struct {
	Enabled *bool `json:"enabled" toml:"enabled"`
}

func (o *ConfigAuthMethodEmailPasswordless) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Enabled != nil {
		m["enabled"] = o.Enabled
	}
	return json.Marshal(m)
}

func (o *ConfigAuthMethodEmailPasswordless) GetEnabled() *bool {
	if o == nil {
		o = &ConfigAuthMethodEmailPasswordless{}
	}
	return o.Enabled
}

type ConfigAuthMethodEmailPasswordlessUpdateInput struct {
	Enabled      *bool `json:"enabled,omitempty" toml:"enabled,omitempty"`
	IsSetEnabled bool  `json:"-"`
}

func (o *ConfigAuthMethodEmailPasswordlessUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["enabled"]; ok {
		if v == nil {
			o.Enabled = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x bool
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Enabled = &x
		}
		o.IsSetEnabled = true
	}

	return nil
}

func (o *ConfigAuthMethodEmailPasswordlessUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigAuthMethodEmailPasswordlessUpdateInput) GetEnabled() *bool {
	if o == nil {
		o = &ConfigAuthMethodEmailPasswordlessUpdateInput{}
	}
	return o.Enabled
}

func (s *ConfigAuthMethodEmailPasswordless) Update(v *ConfigAuthMethodEmailPasswordlessUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetEnabled || v.Enabled != nil {
		s.Enabled = v.Enabled
	}
}

type ConfigAuthMethodEmailPasswordlessInsertInput struct {
	Enabled *bool `json:"enabled,omitempty" toml:"enabled,omitempty"`
}

func (o *ConfigAuthMethodEmailPasswordlessInsertInput) GetEnabled() *bool {
	if o == nil {
		o = &ConfigAuthMethodEmailPasswordlessInsertInput{}
	}
	return o.Enabled
}

func (s *ConfigAuthMethodEmailPasswordless) Insert(v *ConfigAuthMethodEmailPasswordlessInsertInput) {
	s.Enabled = v.Enabled
}

func (s *ConfigAuthMethodEmailPasswordless) Clone() *ConfigAuthMethodEmailPasswordless {
	if s == nil {
		return nil
	}

	v := &ConfigAuthMethodEmailPasswordless{}
	v.Enabled = s.Enabled
	return v
}

type ConfigAuthMethodEmailPasswordlessComparisonExp struct {
	And     []*ConfigAuthMethodEmailPasswordlessComparisonExp `json:"_and,omitempty"`
	Not     *ConfigAuthMethodEmailPasswordlessComparisonExp   `json:"_not,omitempty"`
	Or      []*ConfigAuthMethodEmailPasswordlessComparisonExp `json:"_or,omitempty"`
	Enabled *ConfigBooleanComparisonExp                       `json:"enabled,omitempty"`
}

func (exp *ConfigAuthMethodEmailPasswordlessComparisonExp) Matches(o *ConfigAuthMethodEmailPasswordless) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthMethodEmailPasswordless{}
	}
	if o.Enabled != nil && !exp.Enabled.Matches(*o.Enabled) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAuthMethodOauth struct {
	Apple *ConfigAuthMethodOauthApple `json:"apple,omitempty" toml:"apple,omitempty"`

	Azuread *ConfigAuthMethodOauthAzuread `json:"azuread,omitempty" toml:"azuread,omitempty"`

	Bitbucket *ConfigStandardOauthProvider `json:"bitbucket,omitempty" toml:"bitbucket,omitempty"`

	Discord *ConfigStandardOauthProviderWithScope `json:"discord,omitempty" toml:"discord,omitempty"`

	Facebook *ConfigStandardOauthProviderWithScope `json:"facebook,omitempty" toml:"facebook,omitempty"`

	Github *ConfigStandardOauthProviderWithScope `json:"github,omitempty" toml:"github,omitempty"`

	Gitlab *ConfigStandardOauthProviderWithScope `json:"gitlab,omitempty" toml:"gitlab,omitempty"`

	Google *ConfigStandardOauthProviderWithScope `json:"google,omitempty" toml:"google,omitempty"`

	Linkedin *ConfigStandardOauthProviderWithScope `json:"linkedin,omitempty" toml:"linkedin,omitempty"`

	Spotify *ConfigStandardOauthProviderWithScope `json:"spotify,omitempty" toml:"spotify,omitempty"`

	Strava *ConfigStandardOauthProviderWithScope `json:"strava,omitempty" toml:"strava,omitempty"`

	Twitch *ConfigStandardOauthProviderWithScope `json:"twitch,omitempty" toml:"twitch,omitempty"`

	Twitter *ConfigAuthMethodOauthTwitter `json:"twitter,omitempty" toml:"twitter,omitempty"`

	Windowslive *ConfigStandardOauthProviderWithScope `json:"windowslive,omitempty" toml:"windowslive,omitempty"`

	Workos *ConfigAuthMethodOauthWorkos `json:"workos,omitempty" toml:"workos,omitempty"`
}

func (o *ConfigAuthMethodOauth) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Apple != nil {
		m["apple"] = o.Apple
	}
	if o.Azuread != nil {
		m["azuread"] = o.Azuread
	}
	if o.Bitbucket != nil {
		m["bitbucket"] = o.Bitbucket
	}
	if o.Discord != nil {
		m["discord"] = o.Discord
	}
	if o.Facebook != nil {
		m["facebook"] = o.Facebook
	}
	if o.Github != nil {
		m["github"] = o.Github
	}
	if o.Gitlab != nil {
		m["gitlab"] = o.Gitlab
	}
	if o.Google != nil {
		m["google"] = o.Google
	}
	if o.Linkedin != nil {
		m["linkedin"] = o.Linkedin
	}
	if o.Spotify != nil {
		m["spotify"] = o.Spotify
	}
	if o.Strava != nil {
		m["strava"] = o.Strava
	}
	if o.Twitch != nil {
		m["twitch"] = o.Twitch
	}
	if o.Twitter != nil {
		m["twitter"] = o.Twitter
	}
	if o.Windowslive != nil {
		m["windowslive"] = o.Windowslive
	}
	if o.Workos != nil {
		m["workos"] = o.Workos
	}
	return json.Marshal(m)
}

func (o *ConfigAuthMethodOauth) GetApple() *ConfigAuthMethodOauthApple {
	if o == nil {
		return nil
	}
	return o.Apple
}

func (o *ConfigAuthMethodOauth) GetAzuread() *ConfigAuthMethodOauthAzuread {
	if o == nil {
		return nil
	}
	return o.Azuread
}

func (o *ConfigAuthMethodOauth) GetBitbucket() *ConfigStandardOauthProvider {
	if o == nil {
		return nil
	}
	return o.Bitbucket
}

func (o *ConfigAuthMethodOauth) GetDiscord() *ConfigStandardOauthProviderWithScope {
	if o == nil {
		return nil
	}
	return o.Discord
}

func (o *ConfigAuthMethodOauth) GetFacebook() *ConfigStandardOauthProviderWithScope {
	if o == nil {
		return nil
	}
	return o.Facebook
}

func (o *ConfigAuthMethodOauth) GetGithub() *ConfigStandardOauthProviderWithScope {
	if o == nil {
		return nil
	}
	return o.Github
}

func (o *ConfigAuthMethodOauth) GetGitlab() *ConfigStandardOauthProviderWithScope {
	if o == nil {
		return nil
	}
	return o.Gitlab
}

func (o *ConfigAuthMethodOauth) GetGoogle() *ConfigStandardOauthProviderWithScope {
	if o == nil {
		return nil
	}
	return o.Google
}

func (o *ConfigAuthMethodOauth) GetLinkedin() *ConfigStandardOauthProviderWithScope {
	if o == nil {
		return nil
	}
	return o.Linkedin
}

func (o *ConfigAuthMethodOauth) GetSpotify() *ConfigStandardOauthProviderWithScope {
	if o == nil {
		return nil
	}
	return o.Spotify
}

func (o *ConfigAuthMethodOauth) GetStrava() *ConfigStandardOauthProviderWithScope {
	if o == nil {
		return nil
	}
	return o.Strava
}

func (o *ConfigAuthMethodOauth) GetTwitch() *ConfigStandardOauthProviderWithScope {
	if o == nil {
		return nil
	}
	return o.Twitch
}

func (o *ConfigAuthMethodOauth) GetTwitter() *ConfigAuthMethodOauthTwitter {
	if o == nil {
		return nil
	}
	return o.Twitter
}

func (o *ConfigAuthMethodOauth) GetWindowslive() *ConfigStandardOauthProviderWithScope {
	if o == nil {
		return nil
	}
	return o.Windowslive
}

func (o *ConfigAuthMethodOauth) GetWorkos() *ConfigAuthMethodOauthWorkos {
	if o == nil {
		return nil
	}
	return o.Workos
}

type ConfigAuthMethodOauthUpdateInput struct {
	Apple            *ConfigAuthMethodOauthAppleUpdateInput           `json:"apple,omitempty" toml:"apple,omitempty"`
	IsSetApple       bool                                             `json:"-"`
	Azuread          *ConfigAuthMethodOauthAzureadUpdateInput         `json:"azuread,omitempty" toml:"azuread,omitempty"`
	IsSetAzuread     bool                                             `json:"-"`
	Bitbucket        *ConfigStandardOauthProviderUpdateInput          `json:"bitbucket,omitempty" toml:"bitbucket,omitempty"`
	IsSetBitbucket   bool                                             `json:"-"`
	Discord          *ConfigStandardOauthProviderWithScopeUpdateInput `json:"discord,omitempty" toml:"discord,omitempty"`
	IsSetDiscord     bool                                             `json:"-"`
	Facebook         *ConfigStandardOauthProviderWithScopeUpdateInput `json:"facebook,omitempty" toml:"facebook,omitempty"`
	IsSetFacebook    bool                                             `json:"-"`
	Github           *ConfigStandardOauthProviderWithScopeUpdateInput `json:"github,omitempty" toml:"github,omitempty"`
	IsSetGithub      bool                                             `json:"-"`
	Gitlab           *ConfigStandardOauthProviderWithScopeUpdateInput `json:"gitlab,omitempty" toml:"gitlab,omitempty"`
	IsSetGitlab      bool                                             `json:"-"`
	Google           *ConfigStandardOauthProviderWithScopeUpdateInput `json:"google,omitempty" toml:"google,omitempty"`
	IsSetGoogle      bool                                             `json:"-"`
	Linkedin         *ConfigStandardOauthProviderWithScopeUpdateInput `json:"linkedin,omitempty" toml:"linkedin,omitempty"`
	IsSetLinkedin    bool                                             `json:"-"`
	Spotify          *ConfigStandardOauthProviderWithScopeUpdateInput `json:"spotify,omitempty" toml:"spotify,omitempty"`
	IsSetSpotify     bool                                             `json:"-"`
	Strava           *ConfigStandardOauthProviderWithScopeUpdateInput `json:"strava,omitempty" toml:"strava,omitempty"`
	IsSetStrava      bool                                             `json:"-"`
	Twitch           *ConfigStandardOauthProviderWithScopeUpdateInput `json:"twitch,omitempty" toml:"twitch,omitempty"`
	IsSetTwitch      bool                                             `json:"-"`
	Twitter          *ConfigAuthMethodOauthTwitterUpdateInput         `json:"twitter,omitempty" toml:"twitter,omitempty"`
	IsSetTwitter     bool                                             `json:"-"`
	Windowslive      *ConfigStandardOauthProviderWithScopeUpdateInput `json:"windowslive,omitempty" toml:"windowslive,omitempty"`
	IsSetWindowslive bool                                             `json:"-"`
	Workos           *ConfigAuthMethodOauthWorkosUpdateInput          `json:"workos,omitempty" toml:"workos,omitempty"`
	IsSetWorkos      bool                                             `json:"-"`
}

func (o *ConfigAuthMethodOauthUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if x, ok := m["apple"]; ok {
		if x != nil {
			t := &ConfigAuthMethodOauthAppleUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Apple = t
		}
		o.IsSetApple = true
	}
	if x, ok := m["azuread"]; ok {
		if x != nil {
			t := &ConfigAuthMethodOauthAzureadUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Azuread = t
		}
		o.IsSetAzuread = true
	}
	if x, ok := m["bitbucket"]; ok {
		if x != nil {
			t := &ConfigStandardOauthProviderUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Bitbucket = t
		}
		o.IsSetBitbucket = true
	}
	if x, ok := m["discord"]; ok {
		if x != nil {
			t := &ConfigStandardOauthProviderWithScopeUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Discord = t
		}
		o.IsSetDiscord = true
	}
	if x, ok := m["facebook"]; ok {
		if x != nil {
			t := &ConfigStandardOauthProviderWithScopeUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Facebook = t
		}
		o.IsSetFacebook = true
	}
	if x, ok := m["github"]; ok {
		if x != nil {
			t := &ConfigStandardOauthProviderWithScopeUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Github = t
		}
		o.IsSetGithub = true
	}
	if x, ok := m["gitlab"]; ok {
		if x != nil {
			t := &ConfigStandardOauthProviderWithScopeUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Gitlab = t
		}
		o.IsSetGitlab = true
	}
	if x, ok := m["google"]; ok {
		if x != nil {
			t := &ConfigStandardOauthProviderWithScopeUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Google = t
		}
		o.IsSetGoogle = true
	}
	if x, ok := m["linkedin"]; ok {
		if x != nil {
			t := &ConfigStandardOauthProviderWithScopeUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Linkedin = t
		}
		o.IsSetLinkedin = true
	}
	if x, ok := m["spotify"]; ok {
		if x != nil {
			t := &ConfigStandardOauthProviderWithScopeUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Spotify = t
		}
		o.IsSetSpotify = true
	}
	if x, ok := m["strava"]; ok {
		if x != nil {
			t := &ConfigStandardOauthProviderWithScopeUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Strava = t
		}
		o.IsSetStrava = true
	}
	if x, ok := m["twitch"]; ok {
		if x != nil {
			t := &ConfigStandardOauthProviderWithScopeUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Twitch = t
		}
		o.IsSetTwitch = true
	}
	if x, ok := m["twitter"]; ok {
		if x != nil {
			t := &ConfigAuthMethodOauthTwitterUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Twitter = t
		}
		o.IsSetTwitter = true
	}
	if x, ok := m["windowslive"]; ok {
		if x != nil {
			t := &ConfigStandardOauthProviderWithScopeUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Windowslive = t
		}
		o.IsSetWindowslive = true
	}
	if x, ok := m["workos"]; ok {
		if x != nil {
			t := &ConfigAuthMethodOauthWorkosUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Workos = t
		}
		o.IsSetWorkos = true
	}

	return nil
}

func (o *ConfigAuthMethodOauthUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigAuthMethodOauthUpdateInput) GetApple() *ConfigAuthMethodOauthAppleUpdateInput {
	if o == nil {
		return nil
	}
	return o.Apple
}

func (o *ConfigAuthMethodOauthUpdateInput) GetAzuread() *ConfigAuthMethodOauthAzureadUpdateInput {
	if o == nil {
		return nil
	}
	return o.Azuread
}

func (o *ConfigAuthMethodOauthUpdateInput) GetBitbucket() *ConfigStandardOauthProviderUpdateInput {
	if o == nil {
		return nil
	}
	return o.Bitbucket
}

func (o *ConfigAuthMethodOauthUpdateInput) GetDiscord() *ConfigStandardOauthProviderWithScopeUpdateInput {
	if o == nil {
		return nil
	}
	return o.Discord
}

func (o *ConfigAuthMethodOauthUpdateInput) GetFacebook() *ConfigStandardOauthProviderWithScopeUpdateInput {
	if o == nil {
		return nil
	}
	return o.Facebook
}

func (o *ConfigAuthMethodOauthUpdateInput) GetGithub() *ConfigStandardOauthProviderWithScopeUpdateInput {
	if o == nil {
		return nil
	}
	return o.Github
}

func (o *ConfigAuthMethodOauthUpdateInput) GetGitlab() *ConfigStandardOauthProviderWithScopeUpdateInput {
	if o == nil {
		return nil
	}
	return o.Gitlab
}

func (o *ConfigAuthMethodOauthUpdateInput) GetGoogle() *ConfigStandardOauthProviderWithScopeUpdateInput {
	if o == nil {
		return nil
	}
	return o.Google
}

func (o *ConfigAuthMethodOauthUpdateInput) GetLinkedin() *ConfigStandardOauthProviderWithScopeUpdateInput {
	if o == nil {
		return nil
	}
	return o.Linkedin
}

func (o *ConfigAuthMethodOauthUpdateInput) GetSpotify() *ConfigStandardOauthProviderWithScopeUpdateInput {
	if o == nil {
		return nil
	}
	return o.Spotify
}

func (o *ConfigAuthMethodOauthUpdateInput) GetStrava() *ConfigStandardOauthProviderWithScopeUpdateInput {
	if o == nil {
		return nil
	}
	return o.Strava
}

func (o *ConfigAuthMethodOauthUpdateInput) GetTwitch() *ConfigStandardOauthProviderWithScopeUpdateInput {
	if o == nil {
		return nil
	}
	return o.Twitch
}

func (o *ConfigAuthMethodOauthUpdateInput) GetTwitter() *ConfigAuthMethodOauthTwitterUpdateInput {
	if o == nil {
		return nil
	}
	return o.Twitter
}

func (o *ConfigAuthMethodOauthUpdateInput) GetWindowslive() *ConfigStandardOauthProviderWithScopeUpdateInput {
	if o == nil {
		return nil
	}
	return o.Windowslive
}

func (o *ConfigAuthMethodOauthUpdateInput) GetWorkos() *ConfigAuthMethodOauthWorkosUpdateInput {
	if o == nil {
		return nil
	}
	return o.Workos
}

func (s *ConfigAuthMethodOauth) Update(v *ConfigAuthMethodOauthUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetApple || v.Apple != nil {
		if v.Apple == nil {
			s.Apple = nil
		} else {
			if s.Apple == nil {
				s.Apple = &ConfigAuthMethodOauthApple{}
			}
			s.Apple.Update(v.Apple)
		}
	}
	if v.IsSetAzuread || v.Azuread != nil {
		if v.Azuread == nil {
			s.Azuread = nil
		} else {
			if s.Azuread == nil {
				s.Azuread = &ConfigAuthMethodOauthAzuread{}
			}
			s.Azuread.Update(v.Azuread)
		}
	}
	if v.IsSetBitbucket || v.Bitbucket != nil {
		if v.Bitbucket == nil {
			s.Bitbucket = nil
		} else {
			if s.Bitbucket == nil {
				s.Bitbucket = &ConfigStandardOauthProvider{}
			}
			s.Bitbucket.Update(v.Bitbucket)
		}
	}
	if v.IsSetDiscord || v.Discord != nil {
		if v.Discord == nil {
			s.Discord = nil
		} else {
			if s.Discord == nil {
				s.Discord = &ConfigStandardOauthProviderWithScope{}
			}
			s.Discord.Update(v.Discord)
		}
	}
	if v.IsSetFacebook || v.Facebook != nil {
		if v.Facebook == nil {
			s.Facebook = nil
		} else {
			if s.Facebook == nil {
				s.Facebook = &ConfigStandardOauthProviderWithScope{}
			}
			s.Facebook.Update(v.Facebook)
		}
	}
	if v.IsSetGithub || v.Github != nil {
		if v.Github == nil {
			s.Github = nil
		} else {
			if s.Github == nil {
				s.Github = &ConfigStandardOauthProviderWithScope{}
			}
			s.Github.Update(v.Github)
		}
	}
	if v.IsSetGitlab || v.Gitlab != nil {
		if v.Gitlab == nil {
			s.Gitlab = nil
		} else {
			if s.Gitlab == nil {
				s.Gitlab = &ConfigStandardOauthProviderWithScope{}
			}
			s.Gitlab.Update(v.Gitlab)
		}
	}
	if v.IsSetGoogle || v.Google != nil {
		if v.Google == nil {
			s.Google = nil
		} else {
			if s.Google == nil {
				s.Google = &ConfigStandardOauthProviderWithScope{}
			}
			s.Google.Update(v.Google)
		}
	}
	if v.IsSetLinkedin || v.Linkedin != nil {
		if v.Linkedin == nil {
			s.Linkedin = nil
		} else {
			if s.Linkedin == nil {
				s.Linkedin = &ConfigStandardOauthProviderWithScope{}
			}
			s.Linkedin.Update(v.Linkedin)
		}
	}
	if v.IsSetSpotify || v.Spotify != nil {
		if v.Spotify == nil {
			s.Spotify = nil
		} else {
			if s.Spotify == nil {
				s.Spotify = &ConfigStandardOauthProviderWithScope{}
			}
			s.Spotify.Update(v.Spotify)
		}
	}
	if v.IsSetStrava || v.Strava != nil {
		if v.Strava == nil {
			s.Strava = nil
		} else {
			if s.Strava == nil {
				s.Strava = &ConfigStandardOauthProviderWithScope{}
			}
			s.Strava.Update(v.Strava)
		}
	}
	if v.IsSetTwitch || v.Twitch != nil {
		if v.Twitch == nil {
			s.Twitch = nil
		} else {
			if s.Twitch == nil {
				s.Twitch = &ConfigStandardOauthProviderWithScope{}
			}
			s.Twitch.Update(v.Twitch)
		}
	}
	if v.IsSetTwitter || v.Twitter != nil {
		if v.Twitter == nil {
			s.Twitter = nil
		} else {
			if s.Twitter == nil {
				s.Twitter = &ConfigAuthMethodOauthTwitter{}
			}
			s.Twitter.Update(v.Twitter)
		}
	}
	if v.IsSetWindowslive || v.Windowslive != nil {
		if v.Windowslive == nil {
			s.Windowslive = nil
		} else {
			if s.Windowslive == nil {
				s.Windowslive = &ConfigStandardOauthProviderWithScope{}
			}
			s.Windowslive.Update(v.Windowslive)
		}
	}
	if v.IsSetWorkos || v.Workos != nil {
		if v.Workos == nil {
			s.Workos = nil
		} else {
			if s.Workos == nil {
				s.Workos = &ConfigAuthMethodOauthWorkos{}
			}
			s.Workos.Update(v.Workos)
		}
	}
}

type ConfigAuthMethodOauthInsertInput struct {
	Apple       *ConfigAuthMethodOauthAppleInsertInput           `json:"apple,omitempty" toml:"apple,omitempty"`
	Azuread     *ConfigAuthMethodOauthAzureadInsertInput         `json:"azuread,omitempty" toml:"azuread,omitempty"`
	Bitbucket   *ConfigStandardOauthProviderInsertInput          `json:"bitbucket,omitempty" toml:"bitbucket,omitempty"`
	Discord     *ConfigStandardOauthProviderWithScopeInsertInput `json:"discord,omitempty" toml:"discord,omitempty"`
	Facebook    *ConfigStandardOauthProviderWithScopeInsertInput `json:"facebook,omitempty" toml:"facebook,omitempty"`
	Github      *ConfigStandardOauthProviderWithScopeInsertInput `json:"github,omitempty" toml:"github,omitempty"`
	Gitlab      *ConfigStandardOauthProviderWithScopeInsertInput `json:"gitlab,omitempty" toml:"gitlab,omitempty"`
	Google      *ConfigStandardOauthProviderWithScopeInsertInput `json:"google,omitempty" toml:"google,omitempty"`
	Linkedin    *ConfigStandardOauthProviderWithScopeInsertInput `json:"linkedin,omitempty" toml:"linkedin,omitempty"`
	Spotify     *ConfigStandardOauthProviderWithScopeInsertInput `json:"spotify,omitempty" toml:"spotify,omitempty"`
	Strava      *ConfigStandardOauthProviderWithScopeInsertInput `json:"strava,omitempty" toml:"strava,omitempty"`
	Twitch      *ConfigStandardOauthProviderWithScopeInsertInput `json:"twitch,omitempty" toml:"twitch,omitempty"`
	Twitter     *ConfigAuthMethodOauthTwitterInsertInput         `json:"twitter,omitempty" toml:"twitter,omitempty"`
	Windowslive *ConfigStandardOauthProviderWithScopeInsertInput `json:"windowslive,omitempty" toml:"windowslive,omitempty"`
	Workos      *ConfigAuthMethodOauthWorkosInsertInput          `json:"workos,omitempty" toml:"workos,omitempty"`
}

func (o *ConfigAuthMethodOauthInsertInput) GetApple() *ConfigAuthMethodOauthAppleInsertInput {
	if o == nil {
		return nil
	}
	return o.Apple
}

func (o *ConfigAuthMethodOauthInsertInput) GetAzuread() *ConfigAuthMethodOauthAzureadInsertInput {
	if o == nil {
		return nil
	}
	return o.Azuread
}

func (o *ConfigAuthMethodOauthInsertInput) GetBitbucket() *ConfigStandardOauthProviderInsertInput {
	if o == nil {
		return nil
	}
	return o.Bitbucket
}

func (o *ConfigAuthMethodOauthInsertInput) GetDiscord() *ConfigStandardOauthProviderWithScopeInsertInput {
	if o == nil {
		return nil
	}
	return o.Discord
}

func (o *ConfigAuthMethodOauthInsertInput) GetFacebook() *ConfigStandardOauthProviderWithScopeInsertInput {
	if o == nil {
		return nil
	}
	return o.Facebook
}

func (o *ConfigAuthMethodOauthInsertInput) GetGithub() *ConfigStandardOauthProviderWithScopeInsertInput {
	if o == nil {
		return nil
	}
	return o.Github
}

func (o *ConfigAuthMethodOauthInsertInput) GetGitlab() *ConfigStandardOauthProviderWithScopeInsertInput {
	if o == nil {
		return nil
	}
	return o.Gitlab
}

func (o *ConfigAuthMethodOauthInsertInput) GetGoogle() *ConfigStandardOauthProviderWithScopeInsertInput {
	if o == nil {
		return nil
	}
	return o.Google
}

func (o *ConfigAuthMethodOauthInsertInput) GetLinkedin() *ConfigStandardOauthProviderWithScopeInsertInput {
	if o == nil {
		return nil
	}
	return o.Linkedin
}

func (o *ConfigAuthMethodOauthInsertInput) GetSpotify() *ConfigStandardOauthProviderWithScopeInsertInput {
	if o == nil {
		return nil
	}
	return o.Spotify
}

func (o *ConfigAuthMethodOauthInsertInput) GetStrava() *ConfigStandardOauthProviderWithScopeInsertInput {
	if o == nil {
		return nil
	}
	return o.Strava
}

func (o *ConfigAuthMethodOauthInsertInput) GetTwitch() *ConfigStandardOauthProviderWithScopeInsertInput {
	if o == nil {
		return nil
	}
	return o.Twitch
}

func (o *ConfigAuthMethodOauthInsertInput) GetTwitter() *ConfigAuthMethodOauthTwitterInsertInput {
	if o == nil {
		return nil
	}
	return o.Twitter
}

func (o *ConfigAuthMethodOauthInsertInput) GetWindowslive() *ConfigStandardOauthProviderWithScopeInsertInput {
	if o == nil {
		return nil
	}
	return o.Windowslive
}

func (o *ConfigAuthMethodOauthInsertInput) GetWorkos() *ConfigAuthMethodOauthWorkosInsertInput {
	if o == nil {
		return nil
	}
	return o.Workos
}

func (s *ConfigAuthMethodOauth) Insert(v *ConfigAuthMethodOauthInsertInput) {
	if v.Apple != nil {
		if s.Apple == nil {
			s.Apple = &ConfigAuthMethodOauthApple{}
		}
		s.Apple.Insert(v.Apple)
	}
	if v.Azuread != nil {
		if s.Azuread == nil {
			s.Azuread = &ConfigAuthMethodOauthAzuread{}
		}
		s.Azuread.Insert(v.Azuread)
	}
	if v.Bitbucket != nil {
		if s.Bitbucket == nil {
			s.Bitbucket = &ConfigStandardOauthProvider{}
		}
		s.Bitbucket.Insert(v.Bitbucket)
	}
	if v.Discord != nil {
		if s.Discord == nil {
			s.Discord = &ConfigStandardOauthProviderWithScope{}
		}
		s.Discord.Insert(v.Discord)
	}
	if v.Facebook != nil {
		if s.Facebook == nil {
			s.Facebook = &ConfigStandardOauthProviderWithScope{}
		}
		s.Facebook.Insert(v.Facebook)
	}
	if v.Github != nil {
		if s.Github == nil {
			s.Github = &ConfigStandardOauthProviderWithScope{}
		}
		s.Github.Insert(v.Github)
	}
	if v.Gitlab != nil {
		if s.Gitlab == nil {
			s.Gitlab = &ConfigStandardOauthProviderWithScope{}
		}
		s.Gitlab.Insert(v.Gitlab)
	}
	if v.Google != nil {
		if s.Google == nil {
			s.Google = &ConfigStandardOauthProviderWithScope{}
		}
		s.Google.Insert(v.Google)
	}
	if v.Linkedin != nil {
		if s.Linkedin == nil {
			s.Linkedin = &ConfigStandardOauthProviderWithScope{}
		}
		s.Linkedin.Insert(v.Linkedin)
	}
	if v.Spotify != nil {
		if s.Spotify == nil {
			s.Spotify = &ConfigStandardOauthProviderWithScope{}
		}
		s.Spotify.Insert(v.Spotify)
	}
	if v.Strava != nil {
		if s.Strava == nil {
			s.Strava = &ConfigStandardOauthProviderWithScope{}
		}
		s.Strava.Insert(v.Strava)
	}
	if v.Twitch != nil {
		if s.Twitch == nil {
			s.Twitch = &ConfigStandardOauthProviderWithScope{}
		}
		s.Twitch.Insert(v.Twitch)
	}
	if v.Twitter != nil {
		if s.Twitter == nil {
			s.Twitter = &ConfigAuthMethodOauthTwitter{}
		}
		s.Twitter.Insert(v.Twitter)
	}
	if v.Windowslive != nil {
		if s.Windowslive == nil {
			s.Windowslive = &ConfigStandardOauthProviderWithScope{}
		}
		s.Windowslive.Insert(v.Windowslive)
	}
	if v.Workos != nil {
		if s.Workos == nil {
			s.Workos = &ConfigAuthMethodOauthWorkos{}
		}
		s.Workos.Insert(v.Workos)
	}
}

func (s *ConfigAuthMethodOauth) Clone() *ConfigAuthMethodOauth {
	if s == nil {
		return nil
	}

	v := &ConfigAuthMethodOauth{}
	v.Apple = s.Apple.Clone()
	v.Azuread = s.Azuread.Clone()
	v.Bitbucket = s.Bitbucket.Clone()
	v.Discord = s.Discord.Clone()
	v.Facebook = s.Facebook.Clone()
	v.Github = s.Github.Clone()
	v.Gitlab = s.Gitlab.Clone()
	v.Google = s.Google.Clone()
	v.Linkedin = s.Linkedin.Clone()
	v.Spotify = s.Spotify.Clone()
	v.Strava = s.Strava.Clone()
	v.Twitch = s.Twitch.Clone()
	v.Twitter = s.Twitter.Clone()
	v.Windowslive = s.Windowslive.Clone()
	v.Workos = s.Workos.Clone()
	return v
}

type ConfigAuthMethodOauthComparisonExp struct {
	And         []*ConfigAuthMethodOauthComparisonExp              `json:"_and,omitempty"`
	Not         *ConfigAuthMethodOauthComparisonExp                `json:"_not,omitempty"`
	Or          []*ConfigAuthMethodOauthComparisonExp              `json:"_or,omitempty"`
	Apple       *ConfigAuthMethodOauthAppleComparisonExp           `json:"apple,omitempty"`
	Azuread     *ConfigAuthMethodOauthAzureadComparisonExp         `json:"azuread,omitempty"`
	Bitbucket   *ConfigStandardOauthProviderComparisonExp          `json:"bitbucket,omitempty"`
	Discord     *ConfigStandardOauthProviderWithScopeComparisonExp `json:"discord,omitempty"`
	Facebook    *ConfigStandardOauthProviderWithScopeComparisonExp `json:"facebook,omitempty"`
	Github      *ConfigStandardOauthProviderWithScopeComparisonExp `json:"github,omitempty"`
	Gitlab      *ConfigStandardOauthProviderWithScopeComparisonExp `json:"gitlab,omitempty"`
	Google      *ConfigStandardOauthProviderWithScopeComparisonExp `json:"google,omitempty"`
	Linkedin    *ConfigStandardOauthProviderWithScopeComparisonExp `json:"linkedin,omitempty"`
	Spotify     *ConfigStandardOauthProviderWithScopeComparisonExp `json:"spotify,omitempty"`
	Strava      *ConfigStandardOauthProviderWithScopeComparisonExp `json:"strava,omitempty"`
	Twitch      *ConfigStandardOauthProviderWithScopeComparisonExp `json:"twitch,omitempty"`
	Twitter     *ConfigAuthMethodOauthTwitterComparisonExp         `json:"twitter,omitempty"`
	Windowslive *ConfigStandardOauthProviderWithScopeComparisonExp `json:"windowslive,omitempty"`
	Workos      *ConfigAuthMethodOauthWorkosComparisonExp          `json:"workos,omitempty"`
}

func (exp *ConfigAuthMethodOauthComparisonExp) Matches(o *ConfigAuthMethodOauth) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthMethodOauth{
			Apple:       &ConfigAuthMethodOauthApple{},
			Azuread:     &ConfigAuthMethodOauthAzuread{},
			Bitbucket:   &ConfigStandardOauthProvider{},
			Discord:     &ConfigStandardOauthProviderWithScope{},
			Facebook:    &ConfigStandardOauthProviderWithScope{},
			Github:      &ConfigStandardOauthProviderWithScope{},
			Gitlab:      &ConfigStandardOauthProviderWithScope{},
			Google:      &ConfigStandardOauthProviderWithScope{},
			Linkedin:    &ConfigStandardOauthProviderWithScope{},
			Spotify:     &ConfigStandardOauthProviderWithScope{},
			Strava:      &ConfigStandardOauthProviderWithScope{},
			Twitch:      &ConfigStandardOauthProviderWithScope{},
			Twitter:     &ConfigAuthMethodOauthTwitter{},
			Windowslive: &ConfigStandardOauthProviderWithScope{},
			Workos:      &ConfigAuthMethodOauthWorkos{},
		}
	}
	if !exp.Apple.Matches(o.Apple) {
		return false
	}
	if !exp.Azuread.Matches(o.Azuread) {
		return false
	}
	if !exp.Bitbucket.Matches(o.Bitbucket) {
		return false
	}
	if !exp.Discord.Matches(o.Discord) {
		return false
	}
	if !exp.Facebook.Matches(o.Facebook) {
		return false
	}
	if !exp.Github.Matches(o.Github) {
		return false
	}
	if !exp.Gitlab.Matches(o.Gitlab) {
		return false
	}
	if !exp.Google.Matches(o.Google) {
		return false
	}
	if !exp.Linkedin.Matches(o.Linkedin) {
		return false
	}
	if !exp.Spotify.Matches(o.Spotify) {
		return false
	}
	if !exp.Strava.Matches(o.Strava) {
		return false
	}
	if !exp.Twitch.Matches(o.Twitch) {
		return false
	}
	if !exp.Twitter.Matches(o.Twitter) {
		return false
	}
	if !exp.Windowslive.Matches(o.Windowslive) {
		return false
	}
	if !exp.Workos.Matches(o.Workos) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAuthMethodOauthApple struct {
	Enabled *bool `json:"enabled" toml:"enabled"`

	Audience *string `json:"audience" toml:"audience"`

	ClientId *string `json:"clientId" toml:"clientId"`

	KeyId *string `json:"keyId" toml:"keyId"`

	TeamId *string `json:"teamId" toml:"teamId"`

	Scope []string `json:"scope,omitempty" toml:"scope,omitempty"`

	PrivateKey *string `json:"privateKey" toml:"privateKey"`
}

func (o *ConfigAuthMethodOauthApple) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Enabled != nil {
		m["enabled"] = o.Enabled
	}
	if o.Audience != nil {
		m["audience"] = o.Audience
	}
	if o.ClientId != nil {
		m["clientId"] = o.ClientId
	}
	if o.KeyId != nil {
		m["keyId"] = o.KeyId
	}
	if o.TeamId != nil {
		m["teamId"] = o.TeamId
	}
	if o.Scope != nil {
		m["scope"] = o.Scope
	}
	if o.PrivateKey != nil {
		m["privateKey"] = o.PrivateKey
	}
	return json.Marshal(m)
}

func (o *ConfigAuthMethodOauthApple) GetEnabled() *bool {
	if o == nil {
		o = &ConfigAuthMethodOauthApple{}
	}
	return o.Enabled
}

func (o *ConfigAuthMethodOauthApple) GetAudience() *string {
	if o == nil {
		o = &ConfigAuthMethodOauthApple{}
	}
	return o.Audience
}

func (o *ConfigAuthMethodOauthApple) GetClientId() *string {
	if o == nil {
		o = &ConfigAuthMethodOauthApple{}
	}
	return o.ClientId
}

func (o *ConfigAuthMethodOauthApple) GetKeyId() *string {
	if o == nil {
		o = &ConfigAuthMethodOauthApple{}
	}
	return o.KeyId
}

func (o *ConfigAuthMethodOauthApple) GetTeamId() *string {
	if o == nil {
		o = &ConfigAuthMethodOauthApple{}
	}
	return o.TeamId
}

func (o *ConfigAuthMethodOauthApple) GetScope() []string {
	if o == nil {
		o = &ConfigAuthMethodOauthApple{}
	}
	return o.Scope
}

func (o *ConfigAuthMethodOauthApple) GetPrivateKey() *string {
	if o == nil {
		o = &ConfigAuthMethodOauthApple{}
	}
	return o.PrivateKey
}

type ConfigAuthMethodOauthAppleUpdateInput struct {
	Enabled         *bool    `json:"enabled,omitempty" toml:"enabled,omitempty"`
	IsSetEnabled    bool     `json:"-"`
	Audience        *string  `json:"audience,omitempty" toml:"audience,omitempty"`
	IsSetAudience   bool     `json:"-"`
	ClientId        *string  `json:"clientId,omitempty" toml:"clientId,omitempty"`
	IsSetClientId   bool     `json:"-"`
	KeyId           *string  `json:"keyId,omitempty" toml:"keyId,omitempty"`
	IsSetKeyId      bool     `json:"-"`
	TeamId          *string  `json:"teamId,omitempty" toml:"teamId,omitempty"`
	IsSetTeamId     bool     `json:"-"`
	Scope           []string `json:"scope,omitempty" toml:"scope,omitempty"`
	IsSetScope      bool     `json:"-"`
	PrivateKey      *string  `json:"privateKey,omitempty" toml:"privateKey,omitempty"`
	IsSetPrivateKey bool     `json:"-"`
}

func (o *ConfigAuthMethodOauthAppleUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["enabled"]; ok {
		if v == nil {
			o.Enabled = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x bool
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Enabled = &x
		}
		o.IsSetEnabled = true
	}
	if v, ok := m["audience"]; ok {
		if v == nil {
			o.Audience = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Audience = &x
		}
		o.IsSetAudience = true
	}
	if v, ok := m["clientId"]; ok {
		if v == nil {
			o.ClientId = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.ClientId = &x
		}
		o.IsSetClientId = true
	}
	if v, ok := m["keyId"]; ok {
		if v == nil {
			o.KeyId = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.KeyId = &x
		}
		o.IsSetKeyId = true
	}
	if v, ok := m["teamId"]; ok {
		if v == nil {
			o.TeamId = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.TeamId = &x
		}
		o.IsSetTeamId = true
	}
	if v, ok := m["scope"]; ok {
		if v != nil {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var l []string
			if err := json.Unmarshal(b, &l); err != nil {
				return err
			}
			o.Scope = l
		}
		o.IsSetScope = true
	}
	if v, ok := m["privateKey"]; ok {
		if v == nil {
			o.PrivateKey = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.PrivateKey = &x
		}
		o.IsSetPrivateKey = true
	}

	return nil
}

func (o *ConfigAuthMethodOauthAppleUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigAuthMethodOauthAppleUpdateInput) GetEnabled() *bool {
	if o == nil {
		o = &ConfigAuthMethodOauthAppleUpdateInput{}
	}
	return o.Enabled
}

func (o *ConfigAuthMethodOauthAppleUpdateInput) GetAudience() *string {
	if o == nil {
		o = &ConfigAuthMethodOauthAppleUpdateInput{}
	}
	return o.Audience
}

func (o *ConfigAuthMethodOauthAppleUpdateInput) GetClientId() *string {
	if o == nil {
		o = &ConfigAuthMethodOauthAppleUpdateInput{}
	}
	return o.ClientId
}

func (o *ConfigAuthMethodOauthAppleUpdateInput) GetKeyId() *string {
	if o == nil {
		o = &ConfigAuthMethodOauthAppleUpdateInput{}
	}
	return o.KeyId
}

func (o *ConfigAuthMethodOauthAppleUpdateInput) GetTeamId() *string {
	if o == nil {
		o = &ConfigAuthMethodOauthAppleUpdateInput{}
	}
	return o.TeamId
}

func (o *ConfigAuthMethodOauthAppleUpdateInput) GetScope() []string {
	if o == nil {
		o = &ConfigAuthMethodOauthAppleUpdateInput{}
	}
	return o.Scope
}

func (o *ConfigAuthMethodOauthAppleUpdateInput) GetPrivateKey() *string {
	if o == nil {
		o = &ConfigAuthMethodOauthAppleUpdateInput{}
	}
	return o.PrivateKey
}

func (s *ConfigAuthMethodOauthApple) Update(v *ConfigAuthMethodOauthAppleUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetEnabled || v.Enabled != nil {
		s.Enabled = v.Enabled
	}
	if v.IsSetAudience || v.Audience != nil {
		s.Audience = v.Audience
	}
	if v.IsSetClientId || v.ClientId != nil {
		s.ClientId = v.ClientId
	}
	if v.IsSetKeyId || v.KeyId != nil {
		s.KeyId = v.KeyId
	}
	if v.IsSetTeamId || v.TeamId != nil {
		s.TeamId = v.TeamId
	}
	if v.IsSetScope || v.Scope != nil {
		if v.Scope == nil {
			s.Scope = nil
		} else {
			s.Scope = make([]string, len(v.Scope))
			for i, e := range v.Scope {
				s.Scope[i] = e
			}
		}
	}
	if v.IsSetPrivateKey || v.PrivateKey != nil {
		s.PrivateKey = v.PrivateKey
	}
}

type ConfigAuthMethodOauthAppleInsertInput struct {
	Enabled    *bool    `json:"enabled,omitempty" toml:"enabled,omitempty"`
	Audience   *string  `json:"audience,omitempty" toml:"audience,omitempty"`
	ClientId   *string  `json:"clientId,omitempty" toml:"clientId,omitempty"`
	KeyId      *string  `json:"keyId,omitempty" toml:"keyId,omitempty"`
	TeamId     *string  `json:"teamId,omitempty" toml:"teamId,omitempty"`
	Scope      []string `json:"scope,omitempty" toml:"scope,omitempty"`
	PrivateKey *string  `json:"privateKey,omitempty" toml:"privateKey,omitempty"`
}

func (o *ConfigAuthMethodOauthAppleInsertInput) GetEnabled() *bool {
	if o == nil {
		o = &ConfigAuthMethodOauthAppleInsertInput{}
	}
	return o.Enabled
}

func (o *ConfigAuthMethodOauthAppleInsertInput) GetAudience() *string {
	if o == nil {
		o = &ConfigAuthMethodOauthAppleInsertInput{}
	}
	return o.Audience
}

func (o *ConfigAuthMethodOauthAppleInsertInput) GetClientId() *string {
	if o == nil {
		o = &ConfigAuthMethodOauthAppleInsertInput{}
	}
	return o.ClientId
}

func (o *ConfigAuthMethodOauthAppleInsertInput) GetKeyId() *string {
	if o == nil {
		o = &ConfigAuthMethodOauthAppleInsertInput{}
	}
	return o.KeyId
}

func (o *ConfigAuthMethodOauthAppleInsertInput) GetTeamId() *string {
	if o == nil {
		o = &ConfigAuthMethodOauthAppleInsertInput{}
	}
	return o.TeamId
}

func (o *ConfigAuthMethodOauthAppleInsertInput) GetScope() []string {
	if o == nil {
		o = &ConfigAuthMethodOauthAppleInsertInput{}
	}
	return o.Scope
}

func (o *ConfigAuthMethodOauthAppleInsertInput) GetPrivateKey() *string {
	if o == nil {
		o = &ConfigAuthMethodOauthAppleInsertInput{}
	}
	return o.PrivateKey
}

func (s *ConfigAuthMethodOauthApple) Insert(v *ConfigAuthMethodOauthAppleInsertInput) {
	s.Enabled = v.Enabled
	s.Audience = v.Audience
	s.ClientId = v.ClientId
	s.KeyId = v.KeyId
	s.TeamId = v.TeamId
	if v.Scope != nil {
		s.Scope = make([]string, len(v.Scope))
		for i, e := range v.Scope {
			s.Scope[i] = e
		}
	}
	s.PrivateKey = v.PrivateKey
}

func (s *ConfigAuthMethodOauthApple) Clone() *ConfigAuthMethodOauthApple {
	if s == nil {
		return nil
	}

	v := &ConfigAuthMethodOauthApple{}
	v.Enabled = s.Enabled
	v.Audience = s.Audience
	v.ClientId = s.ClientId
	v.KeyId = s.KeyId
	v.TeamId = s.TeamId
	if s.Scope != nil {
		v.Scope = make([]string, len(s.Scope))
		copy(v.Scope, s.Scope)
	}
	v.PrivateKey = s.PrivateKey
	return v
}

type ConfigAuthMethodOauthAppleComparisonExp struct {
	And        []*ConfigAuthMethodOauthAppleComparisonExp `json:"_and,omitempty"`
	Not        *ConfigAuthMethodOauthAppleComparisonExp   `json:"_not,omitempty"`
	Or         []*ConfigAuthMethodOauthAppleComparisonExp `json:"_or,omitempty"`
	Enabled    *ConfigBooleanComparisonExp                `json:"enabled,omitempty"`
	Audience   *ConfigStringComparisonExp                 `json:"audience,omitempty"`
	ClientId   *ConfigStringComparisonExp                 `json:"clientId,omitempty"`
	KeyId      *ConfigStringComparisonExp                 `json:"keyId,omitempty"`
	TeamId     *ConfigStringComparisonExp                 `json:"teamId,omitempty"`
	Scope      *ConfigStringComparisonExp                 `json:"scope,omitempty"`
	PrivateKey *ConfigStringComparisonExp                 `json:"privateKey,omitempty"`
}

func (exp *ConfigAuthMethodOauthAppleComparisonExp) Matches(o *ConfigAuthMethodOauthApple) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthMethodOauthApple{
			Scope: []string{},
		}
	}
	if o.Enabled != nil && !exp.Enabled.Matches(*o.Enabled) {
		return false
	}
	if o.Audience != nil && !exp.Audience.Matches(*o.Audience) {
		return false
	}
	if o.ClientId != nil && !exp.ClientId.Matches(*o.ClientId) {
		return false
	}
	if o.KeyId != nil && !exp.KeyId.Matches(*o.KeyId) {
		return false
	}
	if o.TeamId != nil && !exp.TeamId.Matches(*o.TeamId) {
		return false
	}
	{
		found := false
		for _, o := range o.Scope {
			if exp.Scope.Matches(o) {
				found = true
				break
			}
		}
		if !found && exp.Scope != nil {
			return false
		}
	}
	if o.PrivateKey != nil && !exp.PrivateKey.Matches(*o.PrivateKey) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAuthMethodOauthAzuread struct {
	Tenant *string `json:"tenant" toml:"tenant"`

	Enabled *bool `json:"enabled" toml:"enabled"`

	ClientId *string `json:"clientId" toml:"clientId"`

	ClientSecret *string `json:"clientSecret" toml:"clientSecret"`
}

func (o *ConfigAuthMethodOauthAzuread) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Tenant != nil {
		m["tenant"] = o.Tenant
	}
	if o.Enabled != nil {
		m["enabled"] = o.Enabled
	}
	if o.ClientId != nil {
		m["clientId"] = o.ClientId
	}
	if o.ClientSecret != nil {
		m["clientSecret"] = o.ClientSecret
	}
	return json.Marshal(m)
}

func (o *ConfigAuthMethodOauthAzuread) GetTenant() *string {
	if o == nil {
		o = &ConfigAuthMethodOauthAzuread{}
	}
	return o.Tenant
}

func (o *ConfigAuthMethodOauthAzuread) GetEnabled() *bool {
	if o == nil {
		o = &ConfigAuthMethodOauthAzuread{}
	}
	return o.Enabled
}

func (o *ConfigAuthMethodOauthAzuread) GetClientId() *string {
	if o == nil {
		o = &ConfigAuthMethodOauthAzuread{}
	}
	return o.ClientId
}

func (o *ConfigAuthMethodOauthAzuread) GetClientSecret() *string {
	if o == nil {
		o = &ConfigAuthMethodOauthAzuread{}
	}
	return o.ClientSecret
}

type ConfigAuthMethodOauthAzureadUpdateInput struct {
	Tenant            *string `json:"tenant,omitempty" toml:"tenant,omitempty"`
	IsSetTenant       bool    `json:"-"`
	Enabled           *bool   `json:"enabled,omitempty" toml:"enabled,omitempty"`
	IsSetEnabled      bool    `json:"-"`
	ClientId          *string `json:"clientId,omitempty" toml:"clientId,omitempty"`
	IsSetClientId     bool    `json:"-"`
	ClientSecret      *string `json:"clientSecret,omitempty" toml:"clientSecret,omitempty"`
	IsSetClientSecret bool    `json:"-"`
}

func (o *ConfigAuthMethodOauthAzureadUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["tenant"]; ok {
		if v == nil {
			o.Tenant = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Tenant = &x
		}
		o.IsSetTenant = true
	}
	if v, ok := m["enabled"]; ok {
		if v == nil {
			o.Enabled = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x bool
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Enabled = &x
		}
		o.IsSetEnabled = true
	}
	if v, ok := m["clientId"]; ok {
		if v == nil {
			o.ClientId = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.ClientId = &x
		}
		o.IsSetClientId = true
	}
	if v, ok := m["clientSecret"]; ok {
		if v == nil {
			o.ClientSecret = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.ClientSecret = &x
		}
		o.IsSetClientSecret = true
	}

	return nil
}

func (o *ConfigAuthMethodOauthAzureadUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigAuthMethodOauthAzureadUpdateInput) GetTenant() *string {
	if o == nil {
		o = &ConfigAuthMethodOauthAzureadUpdateInput{}
	}
	return o.Tenant
}

func (o *ConfigAuthMethodOauthAzureadUpdateInput) GetEnabled() *bool {
	if o == nil {
		o = &ConfigAuthMethodOauthAzureadUpdateInput{}
	}
	return o.Enabled
}

func (o *ConfigAuthMethodOauthAzureadUpdateInput) GetClientId() *string {
	if o == nil {
		o = &ConfigAuthMethodOauthAzureadUpdateInput{}
	}
	return o.ClientId
}

func (o *ConfigAuthMethodOauthAzureadUpdateInput) GetClientSecret() *string {
	if o == nil {
		o = &ConfigAuthMethodOauthAzureadUpdateInput{}
	}
	return o.ClientSecret
}

func (s *ConfigAuthMethodOauthAzuread) Update(v *ConfigAuthMethodOauthAzureadUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetTenant || v.Tenant != nil {
		s.Tenant = v.Tenant
	}
	if v.IsSetEnabled || v.Enabled != nil {
		s.Enabled = v.Enabled
	}
	if v.IsSetClientId || v.ClientId != nil {
		s.ClientId = v.ClientId
	}
	if v.IsSetClientSecret || v.ClientSecret != nil {
		s.ClientSecret = v.ClientSecret
	}
}

type ConfigAuthMethodOauthAzureadInsertInput struct {
	Tenant       *string `json:"tenant,omitempty" toml:"tenant,omitempty"`
	Enabled      *bool   `json:"enabled,omitempty" toml:"enabled,omitempty"`
	ClientId     *string `json:"clientId,omitempty" toml:"clientId,omitempty"`
	ClientSecret *string `json:"clientSecret,omitempty" toml:"clientSecret,omitempty"`
}

func (o *ConfigAuthMethodOauthAzureadInsertInput) GetTenant() *string {
	if o == nil {
		o = &ConfigAuthMethodOauthAzureadInsertInput{}
	}
	return o.Tenant
}

func (o *ConfigAuthMethodOauthAzureadInsertInput) GetEnabled() *bool {
	if o == nil {
		o = &ConfigAuthMethodOauthAzureadInsertInput{}
	}
	return o.Enabled
}

func (o *ConfigAuthMethodOauthAzureadInsertInput) GetClientId() *string {
	if o == nil {
		o = &ConfigAuthMethodOauthAzureadInsertInput{}
	}
	return o.ClientId
}

func (o *ConfigAuthMethodOauthAzureadInsertInput) GetClientSecret() *string {
	if o == nil {
		o = &ConfigAuthMethodOauthAzureadInsertInput{}
	}
	return o.ClientSecret
}

func (s *ConfigAuthMethodOauthAzuread) Insert(v *ConfigAuthMethodOauthAzureadInsertInput) {
	s.Tenant = v.Tenant
	s.Enabled = v.Enabled
	s.ClientId = v.ClientId
	s.ClientSecret = v.ClientSecret
}

func (s *ConfigAuthMethodOauthAzuread) Clone() *ConfigAuthMethodOauthAzuread {
	if s == nil {
		return nil
	}

	v := &ConfigAuthMethodOauthAzuread{}
	v.Tenant = s.Tenant
	v.Enabled = s.Enabled
	v.ClientId = s.ClientId
	v.ClientSecret = s.ClientSecret
	return v
}

type ConfigAuthMethodOauthAzureadComparisonExp struct {
	And          []*ConfigAuthMethodOauthAzureadComparisonExp `json:"_and,omitempty"`
	Not          *ConfigAuthMethodOauthAzureadComparisonExp   `json:"_not,omitempty"`
	Or           []*ConfigAuthMethodOauthAzureadComparisonExp `json:"_or,omitempty"`
	Tenant       *ConfigStringComparisonExp                   `json:"tenant,omitempty"`
	Enabled      *ConfigBooleanComparisonExp                  `json:"enabled,omitempty"`
	ClientId     *ConfigStringComparisonExp                   `json:"clientId,omitempty"`
	ClientSecret *ConfigStringComparisonExp                   `json:"clientSecret,omitempty"`
}

func (exp *ConfigAuthMethodOauthAzureadComparisonExp) Matches(o *ConfigAuthMethodOauthAzuread) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthMethodOauthAzuread{}
	}
	if o.Tenant != nil && !exp.Tenant.Matches(*o.Tenant) {
		return false
	}
	if o.Enabled != nil && !exp.Enabled.Matches(*o.Enabled) {
		return false
	}
	if o.ClientId != nil && !exp.ClientId.Matches(*o.ClientId) {
		return false
	}
	if o.ClientSecret != nil && !exp.ClientSecret.Matches(*o.ClientSecret) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAuthMethodOauthTwitter struct {
	Enabled *bool `json:"enabled" toml:"enabled"`

	ConsumerKey *string `json:"consumerKey" toml:"consumerKey"`

	ConsumerSecret *string `json:"consumerSecret" toml:"consumerSecret"`
}

func (o *ConfigAuthMethodOauthTwitter) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Enabled != nil {
		m["enabled"] = o.Enabled
	}
	if o.ConsumerKey != nil {
		m["consumerKey"] = o.ConsumerKey
	}
	if o.ConsumerSecret != nil {
		m["consumerSecret"] = o.ConsumerSecret
	}
	return json.Marshal(m)
}

func (o *ConfigAuthMethodOauthTwitter) GetEnabled() *bool {
	if o == nil {
		o = &ConfigAuthMethodOauthTwitter{}
	}
	return o.Enabled
}

func (o *ConfigAuthMethodOauthTwitter) GetConsumerKey() *string {
	if o == nil {
		o = &ConfigAuthMethodOauthTwitter{}
	}
	return o.ConsumerKey
}

func (o *ConfigAuthMethodOauthTwitter) GetConsumerSecret() *string {
	if o == nil {
		o = &ConfigAuthMethodOauthTwitter{}
	}
	return o.ConsumerSecret
}

type ConfigAuthMethodOauthTwitterUpdateInput struct {
	Enabled             *bool   `json:"enabled,omitempty" toml:"enabled,omitempty"`
	IsSetEnabled        bool    `json:"-"`
	ConsumerKey         *string `json:"consumerKey,omitempty" toml:"consumerKey,omitempty"`
	IsSetConsumerKey    bool    `json:"-"`
	ConsumerSecret      *string `json:"consumerSecret,omitempty" toml:"consumerSecret,omitempty"`
	IsSetConsumerSecret bool    `json:"-"`
}

func (o *ConfigAuthMethodOauthTwitterUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["enabled"]; ok {
		if v == nil {
			o.Enabled = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x bool
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Enabled = &x
		}
		o.IsSetEnabled = true
	}
	if v, ok := m["consumerKey"]; ok {
		if v == nil {
			o.ConsumerKey = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.ConsumerKey = &x
		}
		o.IsSetConsumerKey = true
	}
	if v, ok := m["consumerSecret"]; ok {
		if v == nil {
			o.ConsumerSecret = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.ConsumerSecret = &x
		}
		o.IsSetConsumerSecret = true
	}

	return nil
}

func (o *ConfigAuthMethodOauthTwitterUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigAuthMethodOauthTwitterUpdateInput) GetEnabled() *bool {
	if o == nil {
		o = &ConfigAuthMethodOauthTwitterUpdateInput{}
	}
	return o.Enabled
}

func (o *ConfigAuthMethodOauthTwitterUpdateInput) GetConsumerKey() *string {
	if o == nil {
		o = &ConfigAuthMethodOauthTwitterUpdateInput{}
	}
	return o.ConsumerKey
}

func (o *ConfigAuthMethodOauthTwitterUpdateInput) GetConsumerSecret() *string {
	if o == nil {
		o = &ConfigAuthMethodOauthTwitterUpdateInput{}
	}
	return o.ConsumerSecret
}

func (s *ConfigAuthMethodOauthTwitter) Update(v *ConfigAuthMethodOauthTwitterUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetEnabled || v.Enabled != nil {
		s.Enabled = v.Enabled
	}
	if v.IsSetConsumerKey || v.ConsumerKey != nil {
		s.ConsumerKey = v.ConsumerKey
	}
	if v.IsSetConsumerSecret || v.ConsumerSecret != nil {
		s.ConsumerSecret = v.ConsumerSecret
	}
}

type ConfigAuthMethodOauthTwitterInsertInput struct {
	Enabled        *bool   `json:"enabled,omitempty" toml:"enabled,omitempty"`
	ConsumerKey    *string `json:"consumerKey,omitempty" toml:"consumerKey,omitempty"`
	ConsumerSecret *string `json:"consumerSecret,omitempty" toml:"consumerSecret,omitempty"`
}

func (o *ConfigAuthMethodOauthTwitterInsertInput) GetEnabled() *bool {
	if o == nil {
		o = &ConfigAuthMethodOauthTwitterInsertInput{}
	}
	return o.Enabled
}

func (o *ConfigAuthMethodOauthTwitterInsertInput) GetConsumerKey() *string {
	if o == nil {
		o = &ConfigAuthMethodOauthTwitterInsertInput{}
	}
	return o.ConsumerKey
}

func (o *ConfigAuthMethodOauthTwitterInsertInput) GetConsumerSecret() *string {
	if o == nil {
		o = &ConfigAuthMethodOauthTwitterInsertInput{}
	}
	return o.ConsumerSecret
}

func (s *ConfigAuthMethodOauthTwitter) Insert(v *ConfigAuthMethodOauthTwitterInsertInput) {
	s.Enabled = v.Enabled
	s.ConsumerKey = v.ConsumerKey
	s.ConsumerSecret = v.ConsumerSecret
}

func (s *ConfigAuthMethodOauthTwitter) Clone() *ConfigAuthMethodOauthTwitter {
	if s == nil {
		return nil
	}

	v := &ConfigAuthMethodOauthTwitter{}
	v.Enabled = s.Enabled
	v.ConsumerKey = s.ConsumerKey
	v.ConsumerSecret = s.ConsumerSecret
	return v
}

type ConfigAuthMethodOauthTwitterComparisonExp struct {
	And            []*ConfigAuthMethodOauthTwitterComparisonExp `json:"_and,omitempty"`
	Not            *ConfigAuthMethodOauthTwitterComparisonExp   `json:"_not,omitempty"`
	Or             []*ConfigAuthMethodOauthTwitterComparisonExp `json:"_or,omitempty"`
	Enabled        *ConfigBooleanComparisonExp                  `json:"enabled,omitempty"`
	ConsumerKey    *ConfigStringComparisonExp                   `json:"consumerKey,omitempty"`
	ConsumerSecret *ConfigStringComparisonExp                   `json:"consumerSecret,omitempty"`
}

func (exp *ConfigAuthMethodOauthTwitterComparisonExp) Matches(o *ConfigAuthMethodOauthTwitter) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthMethodOauthTwitter{}
	}
	if o.Enabled != nil && !exp.Enabled.Matches(*o.Enabled) {
		return false
	}
	if o.ConsumerKey != nil && !exp.ConsumerKey.Matches(*o.ConsumerKey) {
		return false
	}
	if o.ConsumerSecret != nil && !exp.ConsumerSecret.Matches(*o.ConsumerSecret) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAuthMethodOauthWorkos struct {
	Connection *string `json:"connection" toml:"connection"`

	Enabled *bool `json:"enabled" toml:"enabled"`

	ClientId *string `json:"clientId" toml:"clientId"`

	Organization *string `json:"organization" toml:"organization"`

	ClientSecret *string `json:"clientSecret" toml:"clientSecret"`
}

func (o *ConfigAuthMethodOauthWorkos) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Connection != nil {
		m["connection"] = o.Connection
	}
	if o.Enabled != nil {
		m["enabled"] = o.Enabled
	}
	if o.ClientId != nil {
		m["clientId"] = o.ClientId
	}
	if o.Organization != nil {
		m["organization"] = o.Organization
	}
	if o.ClientSecret != nil {
		m["clientSecret"] = o.ClientSecret
	}
	return json.Marshal(m)
}

func (o *ConfigAuthMethodOauthWorkos) GetConnection() *string {
	if o == nil {
		o = &ConfigAuthMethodOauthWorkos{}
	}
	return o.Connection
}

func (o *ConfigAuthMethodOauthWorkos) GetEnabled() *bool {
	if o == nil {
		o = &ConfigAuthMethodOauthWorkos{}
	}
	return o.Enabled
}

func (o *ConfigAuthMethodOauthWorkos) GetClientId() *string {
	if o == nil {
		o = &ConfigAuthMethodOauthWorkos{}
	}
	return o.ClientId
}

func (o *ConfigAuthMethodOauthWorkos) GetOrganization() *string {
	if o == nil {
		o = &ConfigAuthMethodOauthWorkos{}
	}
	return o.Organization
}

func (o *ConfigAuthMethodOauthWorkos) GetClientSecret() *string {
	if o == nil {
		o = &ConfigAuthMethodOauthWorkos{}
	}
	return o.ClientSecret
}

type ConfigAuthMethodOauthWorkosUpdateInput struct {
	Connection        *string `json:"connection,omitempty" toml:"connection,omitempty"`
	IsSetConnection   bool    `json:"-"`
	Enabled           *bool   `json:"enabled,omitempty" toml:"enabled,omitempty"`
	IsSetEnabled      bool    `json:"-"`
	ClientId          *string `json:"clientId,omitempty" toml:"clientId,omitempty"`
	IsSetClientId     bool    `json:"-"`
	Organization      *string `json:"organization,omitempty" toml:"organization,omitempty"`
	IsSetOrganization bool    `json:"-"`
	ClientSecret      *string `json:"clientSecret,omitempty" toml:"clientSecret,omitempty"`
	IsSetClientSecret bool    `json:"-"`
}

func (o *ConfigAuthMethodOauthWorkosUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["connection"]; ok {
		if v == nil {
			o.Connection = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Connection = &x
		}
		o.IsSetConnection = true
	}
	if v, ok := m["enabled"]; ok {
		if v == nil {
			o.Enabled = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x bool
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Enabled = &x
		}
		o.IsSetEnabled = true
	}
	if v, ok := m["clientId"]; ok {
		if v == nil {
			o.ClientId = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.ClientId = &x
		}
		o.IsSetClientId = true
	}
	if v, ok := m["organization"]; ok {
		if v == nil {
			o.Organization = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Organization = &x
		}
		o.IsSetOrganization = true
	}
	if v, ok := m["clientSecret"]; ok {
		if v == nil {
			o.ClientSecret = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.ClientSecret = &x
		}
		o.IsSetClientSecret = true
	}

	return nil
}

func (o *ConfigAuthMethodOauthWorkosUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigAuthMethodOauthWorkosUpdateInput) GetConnection() *string {
	if o == nil {
		o = &ConfigAuthMethodOauthWorkosUpdateInput{}
	}
	return o.Connection
}

func (o *ConfigAuthMethodOauthWorkosUpdateInput) GetEnabled() *bool {
	if o == nil {
		o = &ConfigAuthMethodOauthWorkosUpdateInput{}
	}
	return o.Enabled
}

func (o *ConfigAuthMethodOauthWorkosUpdateInput) GetClientId() *string {
	if o == nil {
		o = &ConfigAuthMethodOauthWorkosUpdateInput{}
	}
	return o.ClientId
}

func (o *ConfigAuthMethodOauthWorkosUpdateInput) GetOrganization() *string {
	if o == nil {
		o = &ConfigAuthMethodOauthWorkosUpdateInput{}
	}
	return o.Organization
}

func (o *ConfigAuthMethodOauthWorkosUpdateInput) GetClientSecret() *string {
	if o == nil {
		o = &ConfigAuthMethodOauthWorkosUpdateInput{}
	}
	return o.ClientSecret
}

func (s *ConfigAuthMethodOauthWorkos) Update(v *ConfigAuthMethodOauthWorkosUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetConnection || v.Connection != nil {
		s.Connection = v.Connection
	}
	if v.IsSetEnabled || v.Enabled != nil {
		s.Enabled = v.Enabled
	}
	if v.IsSetClientId || v.ClientId != nil {
		s.ClientId = v.ClientId
	}
	if v.IsSetOrganization || v.Organization != nil {
		s.Organization = v.Organization
	}
	if v.IsSetClientSecret || v.ClientSecret != nil {
		s.ClientSecret = v.ClientSecret
	}
}

type ConfigAuthMethodOauthWorkosInsertInput struct {
	Connection   *string `json:"connection,omitempty" toml:"connection,omitempty"`
	Enabled      *bool   `json:"enabled,omitempty" toml:"enabled,omitempty"`
	ClientId     *string `json:"clientId,omitempty" toml:"clientId,omitempty"`
	Organization *string `json:"organization,omitempty" toml:"organization,omitempty"`
	ClientSecret *string `json:"clientSecret,omitempty" toml:"clientSecret,omitempty"`
}

func (o *ConfigAuthMethodOauthWorkosInsertInput) GetConnection() *string {
	if o == nil {
		o = &ConfigAuthMethodOauthWorkosInsertInput{}
	}
	return o.Connection
}

func (o *ConfigAuthMethodOauthWorkosInsertInput) GetEnabled() *bool {
	if o == nil {
		o = &ConfigAuthMethodOauthWorkosInsertInput{}
	}
	return o.Enabled
}

func (o *ConfigAuthMethodOauthWorkosInsertInput) GetClientId() *string {
	if o == nil {
		o = &ConfigAuthMethodOauthWorkosInsertInput{}
	}
	return o.ClientId
}

func (o *ConfigAuthMethodOauthWorkosInsertInput) GetOrganization() *string {
	if o == nil {
		o = &ConfigAuthMethodOauthWorkosInsertInput{}
	}
	return o.Organization
}

func (o *ConfigAuthMethodOauthWorkosInsertInput) GetClientSecret() *string {
	if o == nil {
		o = &ConfigAuthMethodOauthWorkosInsertInput{}
	}
	return o.ClientSecret
}

func (s *ConfigAuthMethodOauthWorkos) Insert(v *ConfigAuthMethodOauthWorkosInsertInput) {
	s.Connection = v.Connection
	s.Enabled = v.Enabled
	s.ClientId = v.ClientId
	s.Organization = v.Organization
	s.ClientSecret = v.ClientSecret
}

func (s *ConfigAuthMethodOauthWorkos) Clone() *ConfigAuthMethodOauthWorkos {
	if s == nil {
		return nil
	}

	v := &ConfigAuthMethodOauthWorkos{}
	v.Connection = s.Connection
	v.Enabled = s.Enabled
	v.ClientId = s.ClientId
	v.Organization = s.Organization
	v.ClientSecret = s.ClientSecret
	return v
}

type ConfigAuthMethodOauthWorkosComparisonExp struct {
	And          []*ConfigAuthMethodOauthWorkosComparisonExp `json:"_and,omitempty"`
	Not          *ConfigAuthMethodOauthWorkosComparisonExp   `json:"_not,omitempty"`
	Or           []*ConfigAuthMethodOauthWorkosComparisonExp `json:"_or,omitempty"`
	Connection   *ConfigStringComparisonExp                  `json:"connection,omitempty"`
	Enabled      *ConfigBooleanComparisonExp                 `json:"enabled,omitempty"`
	ClientId     *ConfigStringComparisonExp                  `json:"clientId,omitempty"`
	Organization *ConfigStringComparisonExp                  `json:"organization,omitempty"`
	ClientSecret *ConfigStringComparisonExp                  `json:"clientSecret,omitempty"`
}

func (exp *ConfigAuthMethodOauthWorkosComparisonExp) Matches(o *ConfigAuthMethodOauthWorkos) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthMethodOauthWorkos{}
	}
	if o.Connection != nil && !exp.Connection.Matches(*o.Connection) {
		return false
	}
	if o.Enabled != nil && !exp.Enabled.Matches(*o.Enabled) {
		return false
	}
	if o.ClientId != nil && !exp.ClientId.Matches(*o.ClientId) {
		return false
	}
	if o.Organization != nil && !exp.Organization.Matches(*o.Organization) {
		return false
	}
	if o.ClientSecret != nil && !exp.ClientSecret.Matches(*o.ClientSecret) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAuthMethodOtp struct {
	Email *ConfigAuthMethodOtpEmail `json:"email,omitempty" toml:"email,omitempty"`
}

func (o *ConfigAuthMethodOtp) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Email != nil {
		m["email"] = o.Email
	}
	return json.Marshal(m)
}

func (o *ConfigAuthMethodOtp) GetEmail() *ConfigAuthMethodOtpEmail {
	if o == nil {
		return nil
	}
	return o.Email
}

type ConfigAuthMethodOtpUpdateInput struct {
	Email      *ConfigAuthMethodOtpEmailUpdateInput `json:"email,omitempty" toml:"email,omitempty"`
	IsSetEmail bool                                 `json:"-"`
}

func (o *ConfigAuthMethodOtpUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if x, ok := m["email"]; ok {
		if x != nil {
			t := &ConfigAuthMethodOtpEmailUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Email = t
		}
		o.IsSetEmail = true
	}

	return nil
}

func (o *ConfigAuthMethodOtpUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigAuthMethodOtpUpdateInput) GetEmail() *ConfigAuthMethodOtpEmailUpdateInput {
	if o == nil {
		return nil
	}
	return o.Email
}

func (s *ConfigAuthMethodOtp) Update(v *ConfigAuthMethodOtpUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetEmail || v.Email != nil {
		if v.Email == nil {
			s.Email = nil
		} else {
			if s.Email == nil {
				s.Email = &ConfigAuthMethodOtpEmail{}
			}
			s.Email.Update(v.Email)
		}
	}
}

type ConfigAuthMethodOtpInsertInput struct {
	Email *ConfigAuthMethodOtpEmailInsertInput `json:"email,omitempty" toml:"email,omitempty"`
}

func (o *ConfigAuthMethodOtpInsertInput) GetEmail() *ConfigAuthMethodOtpEmailInsertInput {
	if o == nil {
		return nil
	}
	return o.Email
}

func (s *ConfigAuthMethodOtp) Insert(v *ConfigAuthMethodOtpInsertInput) {
	if v.Email != nil {
		if s.Email == nil {
			s.Email = &ConfigAuthMethodOtpEmail{}
		}
		s.Email.Insert(v.Email)
	}
}

func (s *ConfigAuthMethodOtp) Clone() *ConfigAuthMethodOtp {
	if s == nil {
		return nil
	}

	v := &ConfigAuthMethodOtp{}
	v.Email = s.Email.Clone()
	return v
}

type ConfigAuthMethodOtpComparisonExp struct {
	And   []*ConfigAuthMethodOtpComparisonExp    `json:"_and,omitempty"`
	Not   *ConfigAuthMethodOtpComparisonExp      `json:"_not,omitempty"`
	Or    []*ConfigAuthMethodOtpComparisonExp    `json:"_or,omitempty"`
	Email *ConfigAuthMethodOtpEmailComparisonExp `json:"email,omitempty"`
}

func (exp *ConfigAuthMethodOtpComparisonExp) Matches(o *ConfigAuthMethodOtp) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthMethodOtp{
			Email: &ConfigAuthMethodOtpEmail{},
		}
	}
	if !exp.Email.Matches(o.Email) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAuthMethodOtpEmail struct {
	Enabled *bool `json:"enabled" toml:"enabled"`
}

func (o *ConfigAuthMethodOtpEmail) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Enabled != nil {
		m["enabled"] = o.Enabled
	}
	return json.Marshal(m)
}

func (o *ConfigAuthMethodOtpEmail) GetEnabled() *bool {
	if o == nil {
		o = &ConfigAuthMethodOtpEmail{}
	}
	return o.Enabled
}

type ConfigAuthMethodOtpEmailUpdateInput struct {
	Enabled      *bool `json:"enabled,omitempty" toml:"enabled,omitempty"`
	IsSetEnabled bool  `json:"-"`
}

func (o *ConfigAuthMethodOtpEmailUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["enabled"]; ok {
		if v == nil {
			o.Enabled = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x bool
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Enabled = &x
		}
		o.IsSetEnabled = true
	}

	return nil
}

func (o *ConfigAuthMethodOtpEmailUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigAuthMethodOtpEmailUpdateInput) GetEnabled() *bool {
	if o == nil {
		o = &ConfigAuthMethodOtpEmailUpdateInput{}
	}
	return o.Enabled
}

func (s *ConfigAuthMethodOtpEmail) Update(v *ConfigAuthMethodOtpEmailUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetEnabled || v.Enabled != nil {
		s.Enabled = v.Enabled
	}
}

type ConfigAuthMethodOtpEmailInsertInput struct {
	Enabled *bool `json:"enabled,omitempty" toml:"enabled,omitempty"`
}

func (o *ConfigAuthMethodOtpEmailInsertInput) GetEnabled() *bool {
	if o == nil {
		o = &ConfigAuthMethodOtpEmailInsertInput{}
	}
	return o.Enabled
}

func (s *ConfigAuthMethodOtpEmail) Insert(v *ConfigAuthMethodOtpEmailInsertInput) {
	s.Enabled = v.Enabled
}

func (s *ConfigAuthMethodOtpEmail) Clone() *ConfigAuthMethodOtpEmail {
	if s == nil {
		return nil
	}

	v := &ConfigAuthMethodOtpEmail{}
	v.Enabled = s.Enabled
	return v
}

type ConfigAuthMethodOtpEmailComparisonExp struct {
	And     []*ConfigAuthMethodOtpEmailComparisonExp `json:"_and,omitempty"`
	Not     *ConfigAuthMethodOtpEmailComparisonExp   `json:"_not,omitempty"`
	Or      []*ConfigAuthMethodOtpEmailComparisonExp `json:"_or,omitempty"`
	Enabled *ConfigBooleanComparisonExp              `json:"enabled,omitempty"`
}

func (exp *ConfigAuthMethodOtpEmailComparisonExp) Matches(o *ConfigAuthMethodOtpEmail) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthMethodOtpEmail{}
	}
	if o.Enabled != nil && !exp.Enabled.Matches(*o.Enabled) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAuthMethodSmsPasswordless struct {
	Enabled *bool `json:"enabled" toml:"enabled"`
}

func (o *ConfigAuthMethodSmsPasswordless) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Enabled != nil {
		m["enabled"] = o.Enabled
	}
	return json.Marshal(m)
}

func (o *ConfigAuthMethodSmsPasswordless) GetEnabled() *bool {
	if o == nil {
		o = &ConfigAuthMethodSmsPasswordless{}
	}
	return o.Enabled
}

type ConfigAuthMethodSmsPasswordlessUpdateInput struct {
	Enabled      *bool `json:"enabled,omitempty" toml:"enabled,omitempty"`
	IsSetEnabled bool  `json:"-"`
}

func (o *ConfigAuthMethodSmsPasswordlessUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["enabled"]; ok {
		if v == nil {
			o.Enabled = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x bool
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Enabled = &x
		}
		o.IsSetEnabled = true
	}

	return nil
}

func (o *ConfigAuthMethodSmsPasswordlessUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigAuthMethodSmsPasswordlessUpdateInput) GetEnabled() *bool {
	if o == nil {
		o = &ConfigAuthMethodSmsPasswordlessUpdateInput{}
	}
	return o.Enabled
}

func (s *ConfigAuthMethodSmsPasswordless) Update(v *ConfigAuthMethodSmsPasswordlessUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetEnabled || v.Enabled != nil {
		s.Enabled = v.Enabled
	}
}

type ConfigAuthMethodSmsPasswordlessInsertInput struct {
	Enabled *bool `json:"enabled,omitempty" toml:"enabled,omitempty"`
}

func (o *ConfigAuthMethodSmsPasswordlessInsertInput) GetEnabled() *bool {
	if o == nil {
		o = &ConfigAuthMethodSmsPasswordlessInsertInput{}
	}
	return o.Enabled
}

func (s *ConfigAuthMethodSmsPasswordless) Insert(v *ConfigAuthMethodSmsPasswordlessInsertInput) {
	s.Enabled = v.Enabled
}

func (s *ConfigAuthMethodSmsPasswordless) Clone() *ConfigAuthMethodSmsPasswordless {
	if s == nil {
		return nil
	}

	v := &ConfigAuthMethodSmsPasswordless{}
	v.Enabled = s.Enabled
	return v
}

type ConfigAuthMethodSmsPasswordlessComparisonExp struct {
	And     []*ConfigAuthMethodSmsPasswordlessComparisonExp `json:"_and,omitempty"`
	Not     *ConfigAuthMethodSmsPasswordlessComparisonExp   `json:"_not,omitempty"`
	Or      []*ConfigAuthMethodSmsPasswordlessComparisonExp `json:"_or,omitempty"`
	Enabled *ConfigBooleanComparisonExp                     `json:"enabled,omitempty"`
}

func (exp *ConfigAuthMethodSmsPasswordlessComparisonExp) Matches(o *ConfigAuthMethodSmsPasswordless) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthMethodSmsPasswordless{}
	}
	if o.Enabled != nil && !exp.Enabled.Matches(*o.Enabled) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAuthMethodWebauthn struct {
	Enabled *bool `json:"enabled" toml:"enabled"`

	RelyingParty *ConfigAuthMethodWebauthnRelyingParty `json:"relyingParty,omitempty" toml:"relyingParty,omitempty"`

	Attestation *ConfigAuthMethodWebauthnAttestation `json:"attestation,omitempty" toml:"attestation,omitempty"`
}

func (o *ConfigAuthMethodWebauthn) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Enabled != nil {
		m["enabled"] = o.Enabled
	}
	if o.RelyingParty != nil {
		m["relyingParty"] = o.RelyingParty
	}
	if o.Attestation != nil {
		m["attestation"] = o.Attestation
	}
	return json.Marshal(m)
}

func (o *ConfigAuthMethodWebauthn) GetEnabled() *bool {
	if o == nil {
		o = &ConfigAuthMethodWebauthn{}
	}
	return o.Enabled
}

func (o *ConfigAuthMethodWebauthn) GetRelyingParty() *ConfigAuthMethodWebauthnRelyingParty {
	if o == nil {
		return nil
	}
	return o.RelyingParty
}

func (o *ConfigAuthMethodWebauthn) GetAttestation() *ConfigAuthMethodWebauthnAttestation {
	if o == nil {
		return nil
	}
	return o.Attestation
}

type ConfigAuthMethodWebauthnUpdateInput struct {
	Enabled           *bool                                            `json:"enabled,omitempty" toml:"enabled,omitempty"`
	IsSetEnabled      bool                                             `json:"-"`
	RelyingParty      *ConfigAuthMethodWebauthnRelyingPartyUpdateInput `json:"relyingParty,omitempty" toml:"relyingParty,omitempty"`
	IsSetRelyingParty bool                                             `json:"-"`
	Attestation       *ConfigAuthMethodWebauthnAttestationUpdateInput  `json:"attestation,omitempty" toml:"attestation,omitempty"`
	IsSetAttestation  bool                                             `json:"-"`
}

func (o *ConfigAuthMethodWebauthnUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["enabled"]; ok {
		if v == nil {
			o.Enabled = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x bool
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Enabled = &x
		}
		o.IsSetEnabled = true
	}
	if x, ok := m["relyingParty"]; ok {
		if x != nil {
			t := &ConfigAuthMethodWebauthnRelyingPartyUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.RelyingParty = t
		}
		o.IsSetRelyingParty = true
	}
	if x, ok := m["attestation"]; ok {
		if x != nil {
			t := &ConfigAuthMethodWebauthnAttestationUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Attestation = t
		}
		o.IsSetAttestation = true
	}

	return nil
}

func (o *ConfigAuthMethodWebauthnUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigAuthMethodWebauthnUpdateInput) GetEnabled() *bool {
	if o == nil {
		o = &ConfigAuthMethodWebauthnUpdateInput{}
	}
	return o.Enabled
}

func (o *ConfigAuthMethodWebauthnUpdateInput) GetRelyingParty() *ConfigAuthMethodWebauthnRelyingPartyUpdateInput {
	if o == nil {
		return nil
	}
	return o.RelyingParty
}

func (o *ConfigAuthMethodWebauthnUpdateInput) GetAttestation() *ConfigAuthMethodWebauthnAttestationUpdateInput {
	if o == nil {
		return nil
	}
	return o.Attestation
}

func (s *ConfigAuthMethodWebauthn) Update(v *ConfigAuthMethodWebauthnUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetEnabled || v.Enabled != nil {
		s.Enabled = v.Enabled
	}
	if v.IsSetRelyingParty || v.RelyingParty != nil {
		if v.RelyingParty == nil {
			s.RelyingParty = nil
		} else {
			if s.RelyingParty == nil {
				s.RelyingParty = &ConfigAuthMethodWebauthnRelyingParty{}
			}
			s.RelyingParty.Update(v.RelyingParty)
		}
	}
	if v.IsSetAttestation || v.Attestation != nil {
		if v.Attestation == nil {
			s.Attestation = nil
		} else {
			if s.Attestation == nil {
				s.Attestation = &ConfigAuthMethodWebauthnAttestation{}
			}
			s.Attestation.Update(v.Attestation)
		}
	}
}

type ConfigAuthMethodWebauthnInsertInput struct {
	Enabled      *bool                                            `json:"enabled,omitempty" toml:"enabled,omitempty"`
	RelyingParty *ConfigAuthMethodWebauthnRelyingPartyInsertInput `json:"relyingParty,omitempty" toml:"relyingParty,omitempty"`
	Attestation  *ConfigAuthMethodWebauthnAttestationInsertInput  `json:"attestation,omitempty" toml:"attestation,omitempty"`
}

func (o *ConfigAuthMethodWebauthnInsertInput) GetEnabled() *bool {
	if o == nil {
		o = &ConfigAuthMethodWebauthnInsertInput{}
	}
	return o.Enabled
}

func (o *ConfigAuthMethodWebauthnInsertInput) GetRelyingParty() *ConfigAuthMethodWebauthnRelyingPartyInsertInput {
	if o == nil {
		return nil
	}
	return o.RelyingParty
}

func (o *ConfigAuthMethodWebauthnInsertInput) GetAttestation() *ConfigAuthMethodWebauthnAttestationInsertInput {
	if o == nil {
		return nil
	}
	return o.Attestation
}

func (s *ConfigAuthMethodWebauthn) Insert(v *ConfigAuthMethodWebauthnInsertInput) {
	s.Enabled = v.Enabled
	if v.RelyingParty != nil {
		if s.RelyingParty == nil {
			s.RelyingParty = &ConfigAuthMethodWebauthnRelyingParty{}
		}
		s.RelyingParty.Insert(v.RelyingParty)
	}
	if v.Attestation != nil {
		if s.Attestation == nil {
			s.Attestation = &ConfigAuthMethodWebauthnAttestation{}
		}
		s.Attestation.Insert(v.Attestation)
	}
}

func (s *ConfigAuthMethodWebauthn) Clone() *ConfigAuthMethodWebauthn {
	if s == nil {
		return nil
	}

	v := &ConfigAuthMethodWebauthn{}
	v.Enabled = s.Enabled
	v.RelyingParty = s.RelyingParty.Clone()
	v.Attestation = s.Attestation.Clone()
	return v
}

type ConfigAuthMethodWebauthnComparisonExp struct {
	And          []*ConfigAuthMethodWebauthnComparisonExp           `json:"_and,omitempty"`
	Not          *ConfigAuthMethodWebauthnComparisonExp             `json:"_not,omitempty"`
	Or           []*ConfigAuthMethodWebauthnComparisonExp           `json:"_or,omitempty"`
	Enabled      *ConfigBooleanComparisonExp                        `json:"enabled,omitempty"`
	RelyingParty *ConfigAuthMethodWebauthnRelyingPartyComparisonExp `json:"relyingParty,omitempty"`
	Attestation  *ConfigAuthMethodWebauthnAttestationComparisonExp  `json:"attestation,omitempty"`
}

func (exp *ConfigAuthMethodWebauthnComparisonExp) Matches(o *ConfigAuthMethodWebauthn) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthMethodWebauthn{
			RelyingParty: &ConfigAuthMethodWebauthnRelyingParty{},
			Attestation:  &ConfigAuthMethodWebauthnAttestation{},
		}
	}
	if o.Enabled != nil && !exp.Enabled.Matches(*o.Enabled) {
		return false
	}
	if !exp.RelyingParty.Matches(o.RelyingParty) {
		return false
	}
	if !exp.Attestation.Matches(o.Attestation) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAuthMethodWebauthnAttestation struct {
	Timeout *uint32 `json:"timeout" toml:"timeout"`
}

func (o *ConfigAuthMethodWebauthnAttestation) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Timeout != nil {
		m["timeout"] = o.Timeout
	}
	return json.Marshal(m)
}

func (o *ConfigAuthMethodWebauthnAttestation) GetTimeout() *uint32 {
	if o == nil {
		o = &ConfigAuthMethodWebauthnAttestation{}
	}
	return o.Timeout
}

type ConfigAuthMethodWebauthnAttestationUpdateInput struct {
	Timeout      *uint32 `json:"timeout,omitempty" toml:"timeout,omitempty"`
	IsSetTimeout bool    `json:"-"`
}

func (o *ConfigAuthMethodWebauthnAttestationUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["timeout"]; ok {
		if v == nil {
			o.Timeout = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x uint32
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Timeout = &x
		}
		o.IsSetTimeout = true
	}

	return nil
}

func (o *ConfigAuthMethodWebauthnAttestationUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigAuthMethodWebauthnAttestationUpdateInput) GetTimeout() *uint32 {
	if o == nil {
		o = &ConfigAuthMethodWebauthnAttestationUpdateInput{}
	}
	return o.Timeout
}

func (s *ConfigAuthMethodWebauthnAttestation) Update(v *ConfigAuthMethodWebauthnAttestationUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetTimeout || v.Timeout != nil {
		s.Timeout = v.Timeout
	}
}

type ConfigAuthMethodWebauthnAttestationInsertInput struct {
	Timeout *uint32 `json:"timeout,omitempty" toml:"timeout,omitempty"`
}

func (o *ConfigAuthMethodWebauthnAttestationInsertInput) GetTimeout() *uint32 {
	if o == nil {
		o = &ConfigAuthMethodWebauthnAttestationInsertInput{}
	}
	return o.Timeout
}

func (s *ConfigAuthMethodWebauthnAttestation) Insert(v *ConfigAuthMethodWebauthnAttestationInsertInput) {
	s.Timeout = v.Timeout
}

func (s *ConfigAuthMethodWebauthnAttestation) Clone() *ConfigAuthMethodWebauthnAttestation {
	if s == nil {
		return nil
	}

	v := &ConfigAuthMethodWebauthnAttestation{}
	v.Timeout = s.Timeout
	return v
}

type ConfigAuthMethodWebauthnAttestationComparisonExp struct {
	And     []*ConfigAuthMethodWebauthnAttestationComparisonExp `json:"_and,omitempty"`
	Not     *ConfigAuthMethodWebauthnAttestationComparisonExp   `json:"_not,omitempty"`
	Or      []*ConfigAuthMethodWebauthnAttestationComparisonExp `json:"_or,omitempty"`
	Timeout *ConfigUint32ComparisonExp                          `json:"timeout,omitempty"`
}

func (exp *ConfigAuthMethodWebauthnAttestationComparisonExp) Matches(o *ConfigAuthMethodWebauthnAttestation) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthMethodWebauthnAttestation{}
	}
	if o.Timeout != nil && !exp.Timeout.Matches(*o.Timeout) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAuthMethodWebauthnRelyingParty struct {
	Id *string `json:"id" toml:"id"`

	Name *string `json:"name" toml:"name"`

	Origins []string `json:"origins,omitempty" toml:"origins,omitempty"`
}

func (o *ConfigAuthMethodWebauthnRelyingParty) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Id != nil {
		m["id"] = o.Id
	}
	if o.Name != nil {
		m["name"] = o.Name
	}
	if o.Origins != nil {
		m["origins"] = o.Origins
	}
	return json.Marshal(m)
}

func (o *ConfigAuthMethodWebauthnRelyingParty) GetId() *string {
	if o == nil {
		o = &ConfigAuthMethodWebauthnRelyingParty{}
	}
	return o.Id
}

func (o *ConfigAuthMethodWebauthnRelyingParty) GetName() *string {
	if o == nil {
		o = &ConfigAuthMethodWebauthnRelyingParty{}
	}
	return o.Name
}

func (o *ConfigAuthMethodWebauthnRelyingParty) GetOrigins() []string {
	if o == nil {
		o = &ConfigAuthMethodWebauthnRelyingParty{}
	}
	return o.Origins
}

type ConfigAuthMethodWebauthnRelyingPartyUpdateInput struct {
	Id           *string  `json:"id,omitempty" toml:"id,omitempty"`
	IsSetId      bool     `json:"-"`
	Name         *string  `json:"name,omitempty" toml:"name,omitempty"`
	IsSetName    bool     `json:"-"`
	Origins      []string `json:"origins,omitempty" toml:"origins,omitempty"`
	IsSetOrigins bool     `json:"-"`
}

func (o *ConfigAuthMethodWebauthnRelyingPartyUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["id"]; ok {
		if v == nil {
			o.Id = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Id = &x
		}
		o.IsSetId = true
	}
	if v, ok := m["name"]; ok {
		if v == nil {
			o.Name = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Name = &x
		}
		o.IsSetName = true
	}
	if v, ok := m["origins"]; ok {
		if v != nil {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var l []string
			if err := json.Unmarshal(b, &l); err != nil {
				return err
			}
			o.Origins = l
		}
		o.IsSetOrigins = true
	}

	return nil
}

func (o *ConfigAuthMethodWebauthnRelyingPartyUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigAuthMethodWebauthnRelyingPartyUpdateInput) GetId() *string {
	if o == nil {
		o = &ConfigAuthMethodWebauthnRelyingPartyUpdateInput{}
	}
	return o.Id
}

func (o *ConfigAuthMethodWebauthnRelyingPartyUpdateInput) GetName() *string {
	if o == nil {
		o = &ConfigAuthMethodWebauthnRelyingPartyUpdateInput{}
	}
	return o.Name
}

func (o *ConfigAuthMethodWebauthnRelyingPartyUpdateInput) GetOrigins() []string {
	if o == nil {
		o = &ConfigAuthMethodWebauthnRelyingPartyUpdateInput{}
	}
	return o.Origins
}

func (s *ConfigAuthMethodWebauthnRelyingParty) Update(v *ConfigAuthMethodWebauthnRelyingPartyUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetId || v.Id != nil {
		s.Id = v.Id
	}
	if v.IsSetName || v.Name != nil {
		s.Name = v.Name
	}
	if v.IsSetOrigins || v.Origins != nil {
		if v.Origins == nil {
			s.Origins = nil
		} else {
			s.Origins = make([]string, len(v.Origins))
			for i, e := range v.Origins {
				s.Origins[i] = e
			}
		}
	}
}

type ConfigAuthMethodWebauthnRelyingPartyInsertInput struct {
	Id      *string  `json:"id,omitempty" toml:"id,omitempty"`
	Name    *string  `json:"name,omitempty" toml:"name,omitempty"`
	Origins []string `json:"origins,omitempty" toml:"origins,omitempty"`
}

func (o *ConfigAuthMethodWebauthnRelyingPartyInsertInput) GetId() *string {
	if o == nil {
		o = &ConfigAuthMethodWebauthnRelyingPartyInsertInput{}
	}
	return o.Id
}

func (o *ConfigAuthMethodWebauthnRelyingPartyInsertInput) GetName() *string {
	if o == nil {
		o = &ConfigAuthMethodWebauthnRelyingPartyInsertInput{}
	}
	return o.Name
}

func (o *ConfigAuthMethodWebauthnRelyingPartyInsertInput) GetOrigins() []string {
	if o == nil {
		o = &ConfigAuthMethodWebauthnRelyingPartyInsertInput{}
	}
	return o.Origins
}

func (s *ConfigAuthMethodWebauthnRelyingParty) Insert(v *ConfigAuthMethodWebauthnRelyingPartyInsertInput) {
	s.Id = v.Id
	s.Name = v.Name
	if v.Origins != nil {
		s.Origins = make([]string, len(v.Origins))
		for i, e := range v.Origins {
			s.Origins[i] = e
		}
	}
}

func (s *ConfigAuthMethodWebauthnRelyingParty) Clone() *ConfigAuthMethodWebauthnRelyingParty {
	if s == nil {
		return nil
	}

	v := &ConfigAuthMethodWebauthnRelyingParty{}
	v.Id = s.Id
	v.Name = s.Name
	if s.Origins != nil {
		v.Origins = make([]string, len(s.Origins))
		copy(v.Origins, s.Origins)
	}
	return v
}

type ConfigAuthMethodWebauthnRelyingPartyComparisonExp struct {
	And     []*ConfigAuthMethodWebauthnRelyingPartyComparisonExp `json:"_and,omitempty"`
	Not     *ConfigAuthMethodWebauthnRelyingPartyComparisonExp   `json:"_not,omitempty"`
	Or      []*ConfigAuthMethodWebauthnRelyingPartyComparisonExp `json:"_or,omitempty"`
	Id      *ConfigStringComparisonExp                           `json:"id,omitempty"`
	Name    *ConfigStringComparisonExp                           `json:"name,omitempty"`
	Origins *ConfigUrlComparisonExp                              `json:"origins,omitempty"`
}

func (exp *ConfigAuthMethodWebauthnRelyingPartyComparisonExp) Matches(o *ConfigAuthMethodWebauthnRelyingParty) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthMethodWebauthnRelyingParty{
			Origins: []string{},
		}
	}
	if o.Id != nil && !exp.Id.Matches(*o.Id) {
		return false
	}
	if o.Name != nil && !exp.Name.Matches(*o.Name) {
		return false
	}
	{
		found := false
		for _, o := range o.Origins {
			if exp.Origins.Matches(o) {
				found = true
				break
			}
		}
		if !found && exp.Origins != nil {
			return false
		}
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAuthMisc struct {
	ConcealErrors *bool `json:"concealErrors" toml:"concealErrors"`
}

func (o *ConfigAuthMisc) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.ConcealErrors != nil {
		m["concealErrors"] = o.ConcealErrors
	}
	return json.Marshal(m)
}

func (o *ConfigAuthMisc) GetConcealErrors() *bool {
	if o == nil {
		o = &ConfigAuthMisc{}
	}
	return o.ConcealErrors
}

type ConfigAuthMiscUpdateInput struct {
	ConcealErrors      *bool `json:"concealErrors,omitempty" toml:"concealErrors,omitempty"`
	IsSetConcealErrors bool  `json:"-"`
}

func (o *ConfigAuthMiscUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["concealErrors"]; ok {
		if v == nil {
			o.ConcealErrors = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x bool
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.ConcealErrors = &x
		}
		o.IsSetConcealErrors = true
	}

	return nil
}

func (o *ConfigAuthMiscUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigAuthMiscUpdateInput) GetConcealErrors() *bool {
	if o == nil {
		o = &ConfigAuthMiscUpdateInput{}
	}
	return o.ConcealErrors
}

func (s *ConfigAuthMisc) Update(v *ConfigAuthMiscUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetConcealErrors || v.ConcealErrors != nil {
		s.ConcealErrors = v.ConcealErrors
	}
}

type ConfigAuthMiscInsertInput struct {
	ConcealErrors *bool `json:"concealErrors,omitempty" toml:"concealErrors,omitempty"`
}

func (o *ConfigAuthMiscInsertInput) GetConcealErrors() *bool {
	if o == nil {
		o = &ConfigAuthMiscInsertInput{}
	}
	return o.ConcealErrors
}

func (s *ConfigAuthMisc) Insert(v *ConfigAuthMiscInsertInput) {
	s.ConcealErrors = v.ConcealErrors
}

func (s *ConfigAuthMisc) Clone() *ConfigAuthMisc {
	if s == nil {
		return nil
	}

	v := &ConfigAuthMisc{}
	v.ConcealErrors = s.ConcealErrors
	return v
}

type ConfigAuthMiscComparisonExp struct {
	And           []*ConfigAuthMiscComparisonExp `json:"_and,omitempty"`
	Not           *ConfigAuthMiscComparisonExp   `json:"_not,omitempty"`
	Or            []*ConfigAuthMiscComparisonExp `json:"_or,omitempty"`
	ConcealErrors *ConfigBooleanComparisonExp    `json:"concealErrors,omitempty"`
}

func (exp *ConfigAuthMiscComparisonExp) Matches(o *ConfigAuthMisc) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthMisc{}
	}
	if o.ConcealErrors != nil && !exp.ConcealErrors.Matches(*o.ConcealErrors) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAuthRateLimit struct {
	Emails *ConfigRateLimit `json:"emails,omitempty" toml:"emails,omitempty"`

	Sms *ConfigRateLimit `json:"sms,omitempty" toml:"sms,omitempty"`

	BruteForce *ConfigRateLimit `json:"bruteForce,omitempty" toml:"bruteForce,omitempty"`

	Signups *ConfigRateLimit `json:"signups,omitempty" toml:"signups,omitempty"`

	Global *ConfigRateLimit `json:"global,omitempty" toml:"global,omitempty"`
}

func (o *ConfigAuthRateLimit) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Emails != nil {
		m["emails"] = o.Emails
	}
	if o.Sms != nil {
		m["sms"] = o.Sms
	}
	if o.BruteForce != nil {
		m["bruteForce"] = o.BruteForce
	}
	if o.Signups != nil {
		m["signups"] = o.Signups
	}
	if o.Global != nil {
		m["global"] = o.Global
	}
	return json.Marshal(m)
}

func (o *ConfigAuthRateLimit) GetEmails() *ConfigRateLimit {
	if o == nil {
		return nil
	}
	return o.Emails
}

func (o *ConfigAuthRateLimit) GetSms() *ConfigRateLimit {
	if o == nil {
		return nil
	}
	return o.Sms
}

func (o *ConfigAuthRateLimit) GetBruteForce() *ConfigRateLimit {
	if o == nil {
		return nil
	}
	return o.BruteForce
}

func (o *ConfigAuthRateLimit) GetSignups() *ConfigRateLimit {
	if o == nil {
		return nil
	}
	return o.Signups
}

func (o *ConfigAuthRateLimit) GetGlobal() *ConfigRateLimit {
	if o == nil {
		return nil
	}
	return o.Global
}

type ConfigAuthRateLimitUpdateInput struct {
	Emails          *ConfigRateLimitUpdateInput `json:"emails,omitempty" toml:"emails,omitempty"`
	IsSetEmails     bool                        `json:"-"`
	Sms             *ConfigRateLimitUpdateInput `json:"sms,omitempty" toml:"sms,omitempty"`
	IsSetSms        bool                        `json:"-"`
	BruteForce      *ConfigRateLimitUpdateInput `json:"bruteForce,omitempty" toml:"bruteForce,omitempty"`
	IsSetBruteForce bool                        `json:"-"`
	Signups         *ConfigRateLimitUpdateInput `json:"signups,omitempty" toml:"signups,omitempty"`
	IsSetSignups    bool                        `json:"-"`
	Global          *ConfigRateLimitUpdateInput `json:"global,omitempty" toml:"global,omitempty"`
	IsSetGlobal     bool                        `json:"-"`
}

func (o *ConfigAuthRateLimitUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if x, ok := m["emails"]; ok {
		if x != nil {
			t := &ConfigRateLimitUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Emails = t
		}
		o.IsSetEmails = true
	}
	if x, ok := m["sms"]; ok {
		if x != nil {
			t := &ConfigRateLimitUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Sms = t
		}
		o.IsSetSms = true
	}
	if x, ok := m["bruteForce"]; ok {
		if x != nil {
			t := &ConfigRateLimitUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.BruteForce = t
		}
		o.IsSetBruteForce = true
	}
	if x, ok := m["signups"]; ok {
		if x != nil {
			t := &ConfigRateLimitUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Signups = t
		}
		o.IsSetSignups = true
	}
	if x, ok := m["global"]; ok {
		if x != nil {
			t := &ConfigRateLimitUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Global = t
		}
		o.IsSetGlobal = true
	}

	return nil
}

func (o *ConfigAuthRateLimitUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigAuthRateLimitUpdateInput) GetEmails() *ConfigRateLimitUpdateInput {
	if o == nil {
		return nil
	}
	return o.Emails
}

func (o *ConfigAuthRateLimitUpdateInput) GetSms() *ConfigRateLimitUpdateInput {
	if o == nil {
		return nil
	}
	return o.Sms
}

func (o *ConfigAuthRateLimitUpdateInput) GetBruteForce() *ConfigRateLimitUpdateInput {
	if o == nil {
		return nil
	}
	return o.BruteForce
}

func (o *ConfigAuthRateLimitUpdateInput) GetSignups() *ConfigRateLimitUpdateInput {
	if o == nil {
		return nil
	}
	return o.Signups
}

func (o *ConfigAuthRateLimitUpdateInput) GetGlobal() *ConfigRateLimitUpdateInput {
	if o == nil {
		return nil
	}
	return o.Global
}

func (s *ConfigAuthRateLimit) Update(v *ConfigAuthRateLimitUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetEmails || v.Emails != nil {
		if v.Emails == nil {
			s.Emails = nil
		} else {
			if s.Emails == nil {
				s.Emails = &ConfigRateLimit{}
			}
			s.Emails.Update(v.Emails)
		}
	}
	if v.IsSetSms || v.Sms != nil {
		if v.Sms == nil {
			s.Sms = nil
		} else {
			if s.Sms == nil {
				s.Sms = &ConfigRateLimit{}
			}
			s.Sms.Update(v.Sms)
		}
	}
	if v.IsSetBruteForce || v.BruteForce != nil {
		if v.BruteForce == nil {
			s.BruteForce = nil
		} else {
			if s.BruteForce == nil {
				s.BruteForce = &ConfigRateLimit{}
			}
			s.BruteForce.Update(v.BruteForce)
		}
	}
	if v.IsSetSignups || v.Signups != nil {
		if v.Signups == nil {
			s.Signups = nil
		} else {
			if s.Signups == nil {
				s.Signups = &ConfigRateLimit{}
			}
			s.Signups.Update(v.Signups)
		}
	}
	if v.IsSetGlobal || v.Global != nil {
		if v.Global == nil {
			s.Global = nil
		} else {
			if s.Global == nil {
				s.Global = &ConfigRateLimit{}
			}
			s.Global.Update(v.Global)
		}
	}
}

type ConfigAuthRateLimitInsertInput struct {
	Emails     *ConfigRateLimitInsertInput `json:"emails,omitempty" toml:"emails,omitempty"`
	Sms        *ConfigRateLimitInsertInput `json:"sms,omitempty" toml:"sms,omitempty"`
	BruteForce *ConfigRateLimitInsertInput `json:"bruteForce,omitempty" toml:"bruteForce,omitempty"`
	Signups    *ConfigRateLimitInsertInput `json:"signups,omitempty" toml:"signups,omitempty"`
	Global     *ConfigRateLimitInsertInput `json:"global,omitempty" toml:"global,omitempty"`
}

func (o *ConfigAuthRateLimitInsertInput) GetEmails() *ConfigRateLimitInsertInput {
	if o == nil {
		return nil
	}
	return o.Emails
}

func (o *ConfigAuthRateLimitInsertInput) GetSms() *ConfigRateLimitInsertInput {
	if o == nil {
		return nil
	}
	return o.Sms
}

func (o *ConfigAuthRateLimitInsertInput) GetBruteForce() *ConfigRateLimitInsertInput {
	if o == nil {
		return nil
	}
	return o.BruteForce
}

func (o *ConfigAuthRateLimitInsertInput) GetSignups() *ConfigRateLimitInsertInput {
	if o == nil {
		return nil
	}
	return o.Signups
}

func (o *ConfigAuthRateLimitInsertInput) GetGlobal() *ConfigRateLimitInsertInput {
	if o == nil {
		return nil
	}
	return o.Global
}

func (s *ConfigAuthRateLimit) Insert(v *ConfigAuthRateLimitInsertInput) {
	if v.Emails != nil {
		if s.Emails == nil {
			s.Emails = &ConfigRateLimit{}
		}
		s.Emails.Insert(v.Emails)
	}
	if v.Sms != nil {
		if s.Sms == nil {
			s.Sms = &ConfigRateLimit{}
		}
		s.Sms.Insert(v.Sms)
	}
	if v.BruteForce != nil {
		if s.BruteForce == nil {
			s.BruteForce = &ConfigRateLimit{}
		}
		s.BruteForce.Insert(v.BruteForce)
	}
	if v.Signups != nil {
		if s.Signups == nil {
			s.Signups = &ConfigRateLimit{}
		}
		s.Signups.Insert(v.Signups)
	}
	if v.Global != nil {
		if s.Global == nil {
			s.Global = &ConfigRateLimit{}
		}
		s.Global.Insert(v.Global)
	}
}

func (s *ConfigAuthRateLimit) Clone() *ConfigAuthRateLimit {
	if s == nil {
		return nil
	}

	v := &ConfigAuthRateLimit{}
	v.Emails = s.Emails.Clone()
	v.Sms = s.Sms.Clone()
	v.BruteForce = s.BruteForce.Clone()
	v.Signups = s.Signups.Clone()
	v.Global = s.Global.Clone()
	return v
}

type ConfigAuthRateLimitComparisonExp struct {
	And        []*ConfigAuthRateLimitComparisonExp `json:"_and,omitempty"`
	Not        *ConfigAuthRateLimitComparisonExp   `json:"_not,omitempty"`
	Or         []*ConfigAuthRateLimitComparisonExp `json:"_or,omitempty"`
	Emails     *ConfigRateLimitComparisonExp       `json:"emails,omitempty"`
	Sms        *ConfigRateLimitComparisonExp       `json:"sms,omitempty"`
	BruteForce *ConfigRateLimitComparisonExp       `json:"bruteForce,omitempty"`
	Signups    *ConfigRateLimitComparisonExp       `json:"signups,omitempty"`
	Global     *ConfigRateLimitComparisonExp       `json:"global,omitempty"`
}

func (exp *ConfigAuthRateLimitComparisonExp) Matches(o *ConfigAuthRateLimit) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthRateLimit{
			Emails:     &ConfigRateLimit{},
			Sms:        &ConfigRateLimit{},
			BruteForce: &ConfigRateLimit{},
			Signups:    &ConfigRateLimit{},
			Global:     &ConfigRateLimit{},
		}
	}
	if !exp.Emails.Matches(o.Emails) {
		return false
	}
	if !exp.Sms.Matches(o.Sms) {
		return false
	}
	if !exp.BruteForce.Matches(o.BruteForce) {
		return false
	}
	if !exp.Signups.Matches(o.Signups) {
		return false
	}
	if !exp.Global.Matches(o.Global) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAuthRedirections struct {
	// AUTH_CLIENT_URL
	ClientUrl *string `json:"clientUrl" toml:"clientUrl"`
	// AUTH_ACCESS_CONTROL_ALLOWED_REDIRECT_URLS
	AllowedUrls []string `json:"allowedUrls,omitempty" toml:"allowedUrls,omitempty"`
}

func (o *ConfigAuthRedirections) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.ClientUrl != nil {
		m["clientUrl"] = o.ClientUrl
	}
	if o.AllowedUrls != nil {
		m["allowedUrls"] = o.AllowedUrls
	}
	return json.Marshal(m)
}

func (o *ConfigAuthRedirections) GetClientUrl() *string {
	if o == nil {
		o = &ConfigAuthRedirections{}
	}
	return o.ClientUrl
}

func (o *ConfigAuthRedirections) GetAllowedUrls() []string {
	if o == nil {
		o = &ConfigAuthRedirections{}
	}
	return o.AllowedUrls
}

type ConfigAuthRedirectionsUpdateInput struct {
	ClientUrl        *string  `json:"clientUrl,omitempty" toml:"clientUrl,omitempty"`
	IsSetClientUrl   bool     `json:"-"`
	AllowedUrls      []string `json:"allowedUrls,omitempty" toml:"allowedUrls,omitempty"`
	IsSetAllowedUrls bool     `json:"-"`
}

func (o *ConfigAuthRedirectionsUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["clientUrl"]; ok {
		if v == nil {
			o.ClientUrl = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.ClientUrl = &x
		}
		o.IsSetClientUrl = true
	}
	if v, ok := m["allowedUrls"]; ok {
		if v != nil {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var l []string
			if err := json.Unmarshal(b, &l); err != nil {
				return err
			}
			o.AllowedUrls = l
		}
		o.IsSetAllowedUrls = true
	}

	return nil
}

func (o *ConfigAuthRedirectionsUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigAuthRedirectionsUpdateInput) GetClientUrl() *string {
	if o == nil {
		o = &ConfigAuthRedirectionsUpdateInput{}
	}
	return o.ClientUrl
}

func (o *ConfigAuthRedirectionsUpdateInput) GetAllowedUrls() []string {
	if o == nil {
		o = &ConfigAuthRedirectionsUpdateInput{}
	}
	return o.AllowedUrls
}

func (s *ConfigAuthRedirections) Update(v *ConfigAuthRedirectionsUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetClientUrl || v.ClientUrl != nil {
		s.ClientUrl = v.ClientUrl
	}
	if v.IsSetAllowedUrls || v.AllowedUrls != nil {
		if v.AllowedUrls == nil {
			s.AllowedUrls = nil
		} else {
			s.AllowedUrls = make([]string, len(v.AllowedUrls))
			for i, e := range v.AllowedUrls {
				s.AllowedUrls[i] = e
			}
		}
	}
}

type ConfigAuthRedirectionsInsertInput struct {
	ClientUrl   *string  `json:"clientUrl,omitempty" toml:"clientUrl,omitempty"`
	AllowedUrls []string `json:"allowedUrls,omitempty" toml:"allowedUrls,omitempty"`
}

func (o *ConfigAuthRedirectionsInsertInput) GetClientUrl() *string {
	if o == nil {
		o = &ConfigAuthRedirectionsInsertInput{}
	}
	return o.ClientUrl
}

func (o *ConfigAuthRedirectionsInsertInput) GetAllowedUrls() []string {
	if o == nil {
		o = &ConfigAuthRedirectionsInsertInput{}
	}
	return o.AllowedUrls
}

func (s *ConfigAuthRedirections) Insert(v *ConfigAuthRedirectionsInsertInput) {
	s.ClientUrl = v.ClientUrl
	if v.AllowedUrls != nil {
		s.AllowedUrls = make([]string, len(v.AllowedUrls))
		for i, e := range v.AllowedUrls {
			s.AllowedUrls[i] = e
		}
	}
}

func (s *ConfigAuthRedirections) Clone() *ConfigAuthRedirections {
	if s == nil {
		return nil
	}

	v := &ConfigAuthRedirections{}
	v.ClientUrl = s.ClientUrl
	if s.AllowedUrls != nil {
		v.AllowedUrls = make([]string, len(s.AllowedUrls))
		copy(v.AllowedUrls, s.AllowedUrls)
	}
	return v
}

type ConfigAuthRedirectionsComparisonExp struct {
	And         []*ConfigAuthRedirectionsComparisonExp `json:"_and,omitempty"`
	Not         *ConfigAuthRedirectionsComparisonExp   `json:"_not,omitempty"`
	Or          []*ConfigAuthRedirectionsComparisonExp `json:"_or,omitempty"`
	ClientUrl   *ConfigUrlComparisonExp                `json:"clientUrl,omitempty"`
	AllowedUrls *ConfigStringComparisonExp             `json:"allowedUrls,omitempty"`
}

func (exp *ConfigAuthRedirectionsComparisonExp) Matches(o *ConfigAuthRedirections) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthRedirections{
			AllowedUrls: []string{},
		}
	}
	if o.ClientUrl != nil && !exp.ClientUrl.Matches(*o.ClientUrl) {
		return false
	}
	{
		found := false
		for _, o := range o.AllowedUrls {
			if exp.AllowedUrls.Matches(o) {
				found = true
				break
			}
		}
		if !found && exp.AllowedUrls != nil {
			return false
		}
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAuthSession struct {
	AccessToken *ConfigAuthSessionAccessToken `json:"accessToken,omitempty" toml:"accessToken,omitempty"`

	RefreshToken *ConfigAuthSessionRefreshToken `json:"refreshToken,omitempty" toml:"refreshToken,omitempty"`
}

func (o *ConfigAuthSession) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.AccessToken != nil {
		m["accessToken"] = o.AccessToken
	}
	if o.RefreshToken != nil {
		m["refreshToken"] = o.RefreshToken
	}
	return json.Marshal(m)
}

func (o *ConfigAuthSession) GetAccessToken() *ConfigAuthSessionAccessToken {
	if o == nil {
		return nil
	}
	return o.AccessToken
}

func (o *ConfigAuthSession) GetRefreshToken() *ConfigAuthSessionRefreshToken {
	if o == nil {
		return nil
	}
	return o.RefreshToken
}

type ConfigAuthSessionUpdateInput struct {
	AccessToken       *ConfigAuthSessionAccessTokenUpdateInput  `json:"accessToken,omitempty" toml:"accessToken,omitempty"`
	IsSetAccessToken  bool                                      `json:"-"`
	RefreshToken      *ConfigAuthSessionRefreshTokenUpdateInput `json:"refreshToken,omitempty" toml:"refreshToken,omitempty"`
	IsSetRefreshToken bool                                      `json:"-"`
}

func (o *ConfigAuthSessionUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if x, ok := m["accessToken"]; ok {
		if x != nil {
			t := &ConfigAuthSessionAccessTokenUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.AccessToken = t
		}
		o.IsSetAccessToken = true
	}
	if x, ok := m["refreshToken"]; ok {
		if x != nil {
			t := &ConfigAuthSessionRefreshTokenUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.RefreshToken = t
		}
		o.IsSetRefreshToken = true
	}

	return nil
}

func (o *ConfigAuthSessionUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigAuthSessionUpdateInput) GetAccessToken() *ConfigAuthSessionAccessTokenUpdateInput {
	if o == nil {
		return nil
	}
	return o.AccessToken
}

func (o *ConfigAuthSessionUpdateInput) GetRefreshToken() *ConfigAuthSessionRefreshTokenUpdateInput {
	if o == nil {
		return nil
	}
	return o.RefreshToken
}

func (s *ConfigAuthSession) Update(v *ConfigAuthSessionUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetAccessToken || v.AccessToken != nil {
		if v.AccessToken == nil {
			s.AccessToken = nil
		} else {
			if s.AccessToken == nil {
				s.AccessToken = &ConfigAuthSessionAccessToken{}
			}
			s.AccessToken.Update(v.AccessToken)
		}
	}
	if v.IsSetRefreshToken || v.RefreshToken != nil {
		if v.RefreshToken == nil {
			s.RefreshToken = nil
		} else {
			if s.RefreshToken == nil {
				s.RefreshToken = &ConfigAuthSessionRefreshToken{}
			}
			s.RefreshToken.Update(v.RefreshToken)
		}
	}
}

type ConfigAuthSessionInsertInput struct {
	AccessToken  *ConfigAuthSessionAccessTokenInsertInput  `json:"accessToken,omitempty" toml:"accessToken,omitempty"`
	RefreshToken *ConfigAuthSessionRefreshTokenInsertInput `json:"refreshToken,omitempty" toml:"refreshToken,omitempty"`
}

func (o *ConfigAuthSessionInsertInput) GetAccessToken() *ConfigAuthSessionAccessTokenInsertInput {
	if o == nil {
		return nil
	}
	return o.AccessToken
}

func (o *ConfigAuthSessionInsertInput) GetRefreshToken() *ConfigAuthSessionRefreshTokenInsertInput {
	if o == nil {
		return nil
	}
	return o.RefreshToken
}

func (s *ConfigAuthSession) Insert(v *ConfigAuthSessionInsertInput) {
	if v.AccessToken != nil {
		if s.AccessToken == nil {
			s.AccessToken = &ConfigAuthSessionAccessToken{}
		}
		s.AccessToken.Insert(v.AccessToken)
	}
	if v.RefreshToken != nil {
		if s.RefreshToken == nil {
			s.RefreshToken = &ConfigAuthSessionRefreshToken{}
		}
		s.RefreshToken.Insert(v.RefreshToken)
	}
}

func (s *ConfigAuthSession) Clone() *ConfigAuthSession {
	if s == nil {
		return nil
	}

	v := &ConfigAuthSession{}
	v.AccessToken = s.AccessToken.Clone()
	v.RefreshToken = s.RefreshToken.Clone()
	return v
}

type ConfigAuthSessionComparisonExp struct {
	And          []*ConfigAuthSessionComparisonExp           `json:"_and,omitempty"`
	Not          *ConfigAuthSessionComparisonExp             `json:"_not,omitempty"`
	Or           []*ConfigAuthSessionComparisonExp           `json:"_or,omitempty"`
	AccessToken  *ConfigAuthSessionAccessTokenComparisonExp  `json:"accessToken,omitempty"`
	RefreshToken *ConfigAuthSessionRefreshTokenComparisonExp `json:"refreshToken,omitempty"`
}

func (exp *ConfigAuthSessionComparisonExp) Matches(o *ConfigAuthSession) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthSession{
			AccessToken:  &ConfigAuthSessionAccessToken{},
			RefreshToken: &ConfigAuthSessionRefreshToken{},
		}
	}
	if !exp.AccessToken.Matches(o.AccessToken) {
		return false
	}
	if !exp.RefreshToken.Matches(o.RefreshToken) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAuthSessionAccessToken struct {
	// AUTH_ACCESS_TOKEN_EXPIRES_IN
	ExpiresIn *uint32 `json:"expiresIn" toml:"expiresIn"`
	// AUTH_JWT_CUSTOM_CLAIMS
	CustomClaims []*ConfigAuthsessionaccessTokenCustomClaims `json:"customClaims,omitempty" toml:"customClaims,omitempty"`
}

func (o *ConfigAuthSessionAccessToken) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.ExpiresIn != nil {
		m["expiresIn"] = o.ExpiresIn
	}
	if o.CustomClaims != nil {
		m["customClaims"] = o.CustomClaims
	}
	return json.Marshal(m)
}

func (o *ConfigAuthSessionAccessToken) GetExpiresIn() *uint32 {
	if o == nil {
		o = &ConfigAuthSessionAccessToken{}
	}
	return o.ExpiresIn
}

func (o *ConfigAuthSessionAccessToken) GetCustomClaims() []*ConfigAuthsessionaccessTokenCustomClaims {
	if o == nil {
		o = &ConfigAuthSessionAccessToken{}
	}
	return o.CustomClaims
}

type ConfigAuthSessionAccessTokenUpdateInput struct {
	ExpiresIn         *uint32                                                `json:"expiresIn,omitempty" toml:"expiresIn,omitempty"`
	IsSetExpiresIn    bool                                                   `json:"-"`
	CustomClaims      []*ConfigAuthsessionaccessTokenCustomClaimsUpdateInput `json:"customClaims,omitempty" toml:"customClaims,omitempty"`
	IsSetCustomClaims bool                                                   `json:"-"`
}

func (o *ConfigAuthSessionAccessTokenUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["expiresIn"]; ok {
		if v == nil {
			o.ExpiresIn = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x uint32
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.ExpiresIn = &x
		}
		o.IsSetExpiresIn = true
	}
	if v, ok := m["customClaims"]; ok {
		if v != nil {
			x, ok := v.([]interface{})
			if !ok {
				return fmt.Errorf("CustomClaims must be []interface{}, got %T", v)
			}

			l := make([]*ConfigAuthsessionaccessTokenCustomClaimsUpdateInput, len(x))
			for i, vv := range x {
				t := &ConfigAuthsessionaccessTokenCustomClaimsUpdateInput{}
				if err := t.UnmarshalGQL(vv); err != nil {
					return err
				}
				l[i] = t
			}
			o.CustomClaims = l
		}
		o.IsSetCustomClaims = true
	}

	return nil
}

func (o *ConfigAuthSessionAccessTokenUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigAuthSessionAccessTokenUpdateInput) GetExpiresIn() *uint32 {
	if o == nil {
		o = &ConfigAuthSessionAccessTokenUpdateInput{}
	}
	return o.ExpiresIn
}

func (o *ConfigAuthSessionAccessTokenUpdateInput) GetCustomClaims() []*ConfigAuthsessionaccessTokenCustomClaimsUpdateInput {
	if o == nil {
		o = &ConfigAuthSessionAccessTokenUpdateInput{}
	}
	return o.CustomClaims
}

func (s *ConfigAuthSessionAccessToken) Update(v *ConfigAuthSessionAccessTokenUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetExpiresIn || v.ExpiresIn != nil {
		s.ExpiresIn = v.ExpiresIn
	}
	if v.IsSetCustomClaims || v.CustomClaims != nil {
		if v.CustomClaims == nil {
			s.CustomClaims = nil
		} else {
			s.CustomClaims = make([]*ConfigAuthsessionaccessTokenCustomClaims, len(v.CustomClaims))
			for i, e := range v.CustomClaims {
				v := &ConfigAuthsessionaccessTokenCustomClaims{}
				v.Update(e)
				s.CustomClaims[i] = v
			}
		}
	}
}

type ConfigAuthSessionAccessTokenInsertInput struct {
	ExpiresIn    *uint32                                                `json:"expiresIn,omitempty" toml:"expiresIn,omitempty"`
	CustomClaims []*ConfigAuthsessionaccessTokenCustomClaimsInsertInput `json:"customClaims,omitempty" toml:"customClaims,omitempty"`
}

func (o *ConfigAuthSessionAccessTokenInsertInput) GetExpiresIn() *uint32 {
	if o == nil {
		o = &ConfigAuthSessionAccessTokenInsertInput{}
	}
	return o.ExpiresIn
}

func (o *ConfigAuthSessionAccessTokenInsertInput) GetCustomClaims() []*ConfigAuthsessionaccessTokenCustomClaimsInsertInput {
	if o == nil {
		o = &ConfigAuthSessionAccessTokenInsertInput{}
	}
	return o.CustomClaims
}

func (s *ConfigAuthSessionAccessToken) Insert(v *ConfigAuthSessionAccessTokenInsertInput) {
	s.ExpiresIn = v.ExpiresIn
	if v.CustomClaims != nil {
		s.CustomClaims = make([]*ConfigAuthsessionaccessTokenCustomClaims, len(v.CustomClaims))
		for i, e := range v.CustomClaims {
			v := &ConfigAuthsessionaccessTokenCustomClaims{}
			v.Insert(e)
			s.CustomClaims[i] = v
		}
	}
}

func (s *ConfigAuthSessionAccessToken) Clone() *ConfigAuthSessionAccessToken {
	if s == nil {
		return nil
	}

	v := &ConfigAuthSessionAccessToken{}
	v.ExpiresIn = s.ExpiresIn
	if s.CustomClaims != nil {
		v.CustomClaims = make([]*ConfigAuthsessionaccessTokenCustomClaims, len(s.CustomClaims))
		for i, e := range s.CustomClaims {
			v.CustomClaims[i] = e.Clone()
		}
	}
	return v
}

type ConfigAuthSessionAccessTokenComparisonExp struct {
	And          []*ConfigAuthSessionAccessTokenComparisonExp           `json:"_and,omitempty"`
	Not          *ConfigAuthSessionAccessTokenComparisonExp             `json:"_not,omitempty"`
	Or           []*ConfigAuthSessionAccessTokenComparisonExp           `json:"_or,omitempty"`
	ExpiresIn    *ConfigUint32ComparisonExp                             `json:"expiresIn,omitempty"`
	CustomClaims *ConfigAuthsessionaccessTokenCustomClaimsComparisonExp `json:"customClaims,omitempty"`
}

func (exp *ConfigAuthSessionAccessTokenComparisonExp) Matches(o *ConfigAuthSessionAccessToken) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthSessionAccessToken{
			CustomClaims: []*ConfigAuthsessionaccessTokenCustomClaims{},
		}
	}
	if o.ExpiresIn != nil && !exp.ExpiresIn.Matches(*o.ExpiresIn) {
		return false
	}
	{
		found := false
		for _, o := range o.CustomClaims {
			if exp.CustomClaims.Matches(o) {
				found = true
				break
			}
		}
		if !found && exp.CustomClaims != nil {
			return false
		}
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAuthSessionRefreshToken struct {
	// AUTH_REFRESH_TOKEN_EXPIRES_IN
	ExpiresIn *uint32 `json:"expiresIn" toml:"expiresIn"`
}

func (o *ConfigAuthSessionRefreshToken) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.ExpiresIn != nil {
		m["expiresIn"] = o.ExpiresIn
	}
	return json.Marshal(m)
}

func (o *ConfigAuthSessionRefreshToken) GetExpiresIn() *uint32 {
	if o == nil {
		o = &ConfigAuthSessionRefreshToken{}
	}
	return o.ExpiresIn
}

type ConfigAuthSessionRefreshTokenUpdateInput struct {
	ExpiresIn      *uint32 `json:"expiresIn,omitempty" toml:"expiresIn,omitempty"`
	IsSetExpiresIn bool    `json:"-"`
}

func (o *ConfigAuthSessionRefreshTokenUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["expiresIn"]; ok {
		if v == nil {
			o.ExpiresIn = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x uint32
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.ExpiresIn = &x
		}
		o.IsSetExpiresIn = true
	}

	return nil
}

func (o *ConfigAuthSessionRefreshTokenUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigAuthSessionRefreshTokenUpdateInput) GetExpiresIn() *uint32 {
	if o == nil {
		o = &ConfigAuthSessionRefreshTokenUpdateInput{}
	}
	return o.ExpiresIn
}

func (s *ConfigAuthSessionRefreshToken) Update(v *ConfigAuthSessionRefreshTokenUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetExpiresIn || v.ExpiresIn != nil {
		s.ExpiresIn = v.ExpiresIn
	}
}

type ConfigAuthSessionRefreshTokenInsertInput struct {
	ExpiresIn *uint32 `json:"expiresIn,omitempty" toml:"expiresIn,omitempty"`
}

func (o *ConfigAuthSessionRefreshTokenInsertInput) GetExpiresIn() *uint32 {
	if o == nil {
		o = &ConfigAuthSessionRefreshTokenInsertInput{}
	}
	return o.ExpiresIn
}

func (s *ConfigAuthSessionRefreshToken) Insert(v *ConfigAuthSessionRefreshTokenInsertInput) {
	s.ExpiresIn = v.ExpiresIn
}

func (s *ConfigAuthSessionRefreshToken) Clone() *ConfigAuthSessionRefreshToken {
	if s == nil {
		return nil
	}

	v := &ConfigAuthSessionRefreshToken{}
	v.ExpiresIn = s.ExpiresIn
	return v
}

type ConfigAuthSessionRefreshTokenComparisonExp struct {
	And       []*ConfigAuthSessionRefreshTokenComparisonExp `json:"_and,omitempty"`
	Not       *ConfigAuthSessionRefreshTokenComparisonExp   `json:"_not,omitempty"`
	Or        []*ConfigAuthSessionRefreshTokenComparisonExp `json:"_or,omitempty"`
	ExpiresIn *ConfigUint32ComparisonExp                    `json:"expiresIn,omitempty"`
}

func (exp *ConfigAuthSessionRefreshTokenComparisonExp) Matches(o *ConfigAuthSessionRefreshToken) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthSessionRefreshToken{}
	}
	if o.ExpiresIn != nil && !exp.ExpiresIn.Matches(*o.ExpiresIn) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAuthSignUp struct {
	// Inverse of AUTH_DISABLE_SIGNUP
	Enabled *bool `json:"enabled" toml:"enabled"`
	// AUTH_DISABLE_NEW_USERS
	DisableNewUsers *bool `json:"disableNewUsers" toml:"disableNewUsers"`

	Turnstile *ConfigAuthSignUpTurnstile `json:"turnstile,omitempty" toml:"turnstile,omitempty"`
}

func (o *ConfigAuthSignUp) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Enabled != nil {
		m["enabled"] = o.Enabled
	}
	if o.DisableNewUsers != nil {
		m["disableNewUsers"] = o.DisableNewUsers
	}
	if o.Turnstile != nil {
		m["turnstile"] = o.Turnstile
	}
	return json.Marshal(m)
}

func (o *ConfigAuthSignUp) GetEnabled() *bool {
	if o == nil {
		o = &ConfigAuthSignUp{}
	}
	return o.Enabled
}

func (o *ConfigAuthSignUp) GetDisableNewUsers() *bool {
	if o == nil {
		o = &ConfigAuthSignUp{}
	}
	return o.DisableNewUsers
}

func (o *ConfigAuthSignUp) GetTurnstile() *ConfigAuthSignUpTurnstile {
	if o == nil {
		return nil
	}
	return o.Turnstile
}

type ConfigAuthSignUpUpdateInput struct {
	Enabled              *bool                                 `json:"enabled,omitempty" toml:"enabled,omitempty"`
	IsSetEnabled         bool                                  `json:"-"`
	DisableNewUsers      *bool                                 `json:"disableNewUsers,omitempty" toml:"disableNewUsers,omitempty"`
	IsSetDisableNewUsers bool                                  `json:"-"`
	Turnstile            *ConfigAuthSignUpTurnstileUpdateInput `json:"turnstile,omitempty" toml:"turnstile,omitempty"`
	IsSetTurnstile       bool                                  `json:"-"`
}

func (o *ConfigAuthSignUpUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["enabled"]; ok {
		if v == nil {
			o.Enabled = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x bool
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Enabled = &x
		}
		o.IsSetEnabled = true
	}
	if v, ok := m["disableNewUsers"]; ok {
		if v == nil {
			o.DisableNewUsers = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x bool
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.DisableNewUsers = &x
		}
		o.IsSetDisableNewUsers = true
	}
	if x, ok := m["turnstile"]; ok {
		if x != nil {
			t := &ConfigAuthSignUpTurnstileUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Turnstile = t
		}
		o.IsSetTurnstile = true
	}

	return nil
}

func (o *ConfigAuthSignUpUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigAuthSignUpUpdateInput) GetEnabled() *bool {
	if o == nil {
		o = &ConfigAuthSignUpUpdateInput{}
	}
	return o.Enabled
}

func (o *ConfigAuthSignUpUpdateInput) GetDisableNewUsers() *bool {
	if o == nil {
		o = &ConfigAuthSignUpUpdateInput{}
	}
	return o.DisableNewUsers
}

func (o *ConfigAuthSignUpUpdateInput) GetTurnstile() *ConfigAuthSignUpTurnstileUpdateInput {
	if o == nil {
		return nil
	}
	return o.Turnstile
}

func (s *ConfigAuthSignUp) Update(v *ConfigAuthSignUpUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetEnabled || v.Enabled != nil {
		s.Enabled = v.Enabled
	}
	if v.IsSetDisableNewUsers || v.DisableNewUsers != nil {
		s.DisableNewUsers = v.DisableNewUsers
	}
	if v.IsSetTurnstile || v.Turnstile != nil {
		if v.Turnstile == nil {
			s.Turnstile = nil
		} else {
			if s.Turnstile == nil {
				s.Turnstile = &ConfigAuthSignUpTurnstile{}
			}
			s.Turnstile.Update(v.Turnstile)
		}
	}
}

type ConfigAuthSignUpInsertInput struct {
	Enabled         *bool                                 `json:"enabled,omitempty" toml:"enabled,omitempty"`
	DisableNewUsers *bool                                 `json:"disableNewUsers,omitempty" toml:"disableNewUsers,omitempty"`
	Turnstile       *ConfigAuthSignUpTurnstileInsertInput `json:"turnstile,omitempty" toml:"turnstile,omitempty"`
}

func (o *ConfigAuthSignUpInsertInput) GetEnabled() *bool {
	if o == nil {
		o = &ConfigAuthSignUpInsertInput{}
	}
	return o.Enabled
}

func (o *ConfigAuthSignUpInsertInput) GetDisableNewUsers() *bool {
	if o == nil {
		o = &ConfigAuthSignUpInsertInput{}
	}
	return o.DisableNewUsers
}

func (o *ConfigAuthSignUpInsertInput) GetTurnstile() *ConfigAuthSignUpTurnstileInsertInput {
	if o == nil {
		return nil
	}
	return o.Turnstile
}

func (s *ConfigAuthSignUp) Insert(v *ConfigAuthSignUpInsertInput) {
	s.Enabled = v.Enabled
	s.DisableNewUsers = v.DisableNewUsers
	if v.Turnstile != nil {
		if s.Turnstile == nil {
			s.Turnstile = &ConfigAuthSignUpTurnstile{}
		}
		s.Turnstile.Insert(v.Turnstile)
	}
}

func (s *ConfigAuthSignUp) Clone() *ConfigAuthSignUp {
	if s == nil {
		return nil
	}

	v := &ConfigAuthSignUp{}
	v.Enabled = s.Enabled
	v.DisableNewUsers = s.DisableNewUsers
	v.Turnstile = s.Turnstile.Clone()
	return v
}

type ConfigAuthSignUpComparisonExp struct {
	And             []*ConfigAuthSignUpComparisonExp        `json:"_and,omitempty"`
	Not             *ConfigAuthSignUpComparisonExp          `json:"_not,omitempty"`
	Or              []*ConfigAuthSignUpComparisonExp        `json:"_or,omitempty"`
	Enabled         *ConfigBooleanComparisonExp             `json:"enabled,omitempty"`
	DisableNewUsers *ConfigBooleanComparisonExp             `json:"disableNewUsers,omitempty"`
	Turnstile       *ConfigAuthSignUpTurnstileComparisonExp `json:"turnstile,omitempty"`
}

func (exp *ConfigAuthSignUpComparisonExp) Matches(o *ConfigAuthSignUp) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthSignUp{
			Turnstile: &ConfigAuthSignUpTurnstile{},
		}
	}
	if o.Enabled != nil && !exp.Enabled.Matches(*o.Enabled) {
		return false
	}
	if o.DisableNewUsers != nil && !exp.DisableNewUsers.Matches(*o.DisableNewUsers) {
		return false
	}
	if !exp.Turnstile.Matches(o.Turnstile) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAuthSignUpTurnstile struct {
	SecretKey string `json:"secretKey" toml:"secretKey"`
}

func (o *ConfigAuthSignUpTurnstile) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	m["secretKey"] = o.SecretKey
	return json.Marshal(m)
}

func (o *ConfigAuthSignUpTurnstile) GetSecretKey() string {
	if o == nil {
		o = &ConfigAuthSignUpTurnstile{}
	}
	return o.SecretKey
}

type ConfigAuthSignUpTurnstileUpdateInput struct {
	SecretKey      *string `json:"secretKey,omitempty" toml:"secretKey,omitempty"`
	IsSetSecretKey bool    `json:"-"`
}

func (o *ConfigAuthSignUpTurnstileUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["secretKey"]; ok {
		if v == nil {
			o.SecretKey = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.SecretKey = &x
		}
		o.IsSetSecretKey = true
	}

	return nil
}

func (o *ConfigAuthSignUpTurnstileUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigAuthSignUpTurnstileUpdateInput) GetSecretKey() *string {
	if o == nil {
		o = &ConfigAuthSignUpTurnstileUpdateInput{}
	}
	return o.SecretKey
}

func (s *ConfigAuthSignUpTurnstile) Update(v *ConfigAuthSignUpTurnstileUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetSecretKey || v.SecretKey != nil {
		if v.SecretKey != nil {
			s.SecretKey = *v.SecretKey
		}
	}
}

type ConfigAuthSignUpTurnstileInsertInput struct {
	SecretKey string `json:"secretKey,omitempty" toml:"secretKey,omitempty"`
}

func (o *ConfigAuthSignUpTurnstileInsertInput) GetSecretKey() string {
	if o == nil {
		o = &ConfigAuthSignUpTurnstileInsertInput{}
	}
	return o.SecretKey
}

func (s *ConfigAuthSignUpTurnstile) Insert(v *ConfigAuthSignUpTurnstileInsertInput) {
	s.SecretKey = v.SecretKey
}

func (s *ConfigAuthSignUpTurnstile) Clone() *ConfigAuthSignUpTurnstile {
	if s == nil {
		return nil
	}

	v := &ConfigAuthSignUpTurnstile{}
	v.SecretKey = s.SecretKey
	return v
}

type ConfigAuthSignUpTurnstileComparisonExp struct {
	And       []*ConfigAuthSignUpTurnstileComparisonExp `json:"_and,omitempty"`
	Not       *ConfigAuthSignUpTurnstileComparisonExp   `json:"_not,omitempty"`
	Or        []*ConfigAuthSignUpTurnstileComparisonExp `json:"_or,omitempty"`
	SecretKey *ConfigStringComparisonExp                `json:"secretKey,omitempty"`
}

func (exp *ConfigAuthSignUpTurnstileComparisonExp) Matches(o *ConfigAuthSignUpTurnstile) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthSignUpTurnstile{}
	}
	if !exp.SecretKey.Matches(o.SecretKey) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAuthTotp struct {
	Enabled *bool `json:"enabled" toml:"enabled"`

	Issuer *string `json:"issuer" toml:"issuer"`
}

func (o *ConfigAuthTotp) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Enabled != nil {
		m["enabled"] = o.Enabled
	}
	if o.Issuer != nil {
		m["issuer"] = o.Issuer
	}
	return json.Marshal(m)
}

func (o *ConfigAuthTotp) GetEnabled() *bool {
	if o == nil {
		o = &ConfigAuthTotp{}
	}
	return o.Enabled
}

func (o *ConfigAuthTotp) GetIssuer() *string {
	if o == nil {
		o = &ConfigAuthTotp{}
	}
	return o.Issuer
}

type ConfigAuthTotpUpdateInput struct {
	Enabled      *bool   `json:"enabled,omitempty" toml:"enabled,omitempty"`
	IsSetEnabled bool    `json:"-"`
	Issuer       *string `json:"issuer,omitempty" toml:"issuer,omitempty"`
	IsSetIssuer  bool    `json:"-"`
}

func (o *ConfigAuthTotpUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["enabled"]; ok {
		if v == nil {
			o.Enabled = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x bool
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Enabled = &x
		}
		o.IsSetEnabled = true
	}
	if v, ok := m["issuer"]; ok {
		if v == nil {
			o.Issuer = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Issuer = &x
		}
		o.IsSetIssuer = true
	}

	return nil
}

func (o *ConfigAuthTotpUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigAuthTotpUpdateInput) GetEnabled() *bool {
	if o == nil {
		o = &ConfigAuthTotpUpdateInput{}
	}
	return o.Enabled
}

func (o *ConfigAuthTotpUpdateInput) GetIssuer() *string {
	if o == nil {
		o = &ConfigAuthTotpUpdateInput{}
	}
	return o.Issuer
}

func (s *ConfigAuthTotp) Update(v *ConfigAuthTotpUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetEnabled || v.Enabled != nil {
		s.Enabled = v.Enabled
	}
	if v.IsSetIssuer || v.Issuer != nil {
		s.Issuer = v.Issuer
	}
}

type ConfigAuthTotpInsertInput struct {
	Enabled *bool   `json:"enabled,omitempty" toml:"enabled,omitempty"`
	Issuer  *string `json:"issuer,omitempty" toml:"issuer,omitempty"`
}

func (o *ConfigAuthTotpInsertInput) GetEnabled() *bool {
	if o == nil {
		o = &ConfigAuthTotpInsertInput{}
	}
	return o.Enabled
}

func (o *ConfigAuthTotpInsertInput) GetIssuer() *string {
	if o == nil {
		o = &ConfigAuthTotpInsertInput{}
	}
	return o.Issuer
}

func (s *ConfigAuthTotp) Insert(v *ConfigAuthTotpInsertInput) {
	s.Enabled = v.Enabled
	s.Issuer = v.Issuer
}

func (s *ConfigAuthTotp) Clone() *ConfigAuthTotp {
	if s == nil {
		return nil
	}

	v := &ConfigAuthTotp{}
	v.Enabled = s.Enabled
	v.Issuer = s.Issuer
	return v
}

type ConfigAuthTotpComparisonExp struct {
	And     []*ConfigAuthTotpComparisonExp `json:"_and,omitempty"`
	Not     *ConfigAuthTotpComparisonExp   `json:"_not,omitempty"`
	Or      []*ConfigAuthTotpComparisonExp `json:"_or,omitempty"`
	Enabled *ConfigBooleanComparisonExp    `json:"enabled,omitempty"`
	Issuer  *ConfigStringComparisonExp     `json:"issuer,omitempty"`
}

func (exp *ConfigAuthTotpComparisonExp) Matches(o *ConfigAuthTotp) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthTotp{}
	}
	if o.Enabled != nil && !exp.Enabled.Matches(*o.Enabled) {
		return false
	}
	if o.Issuer != nil && !exp.Issuer.Matches(*o.Issuer) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAuthUser struct {
	Roles *ConfigAuthUserRoles `json:"roles,omitempty" toml:"roles,omitempty"`

	Locale *ConfigAuthUserLocale `json:"locale,omitempty" toml:"locale,omitempty"`

	Gravatar *ConfigAuthUserGravatar `json:"gravatar,omitempty" toml:"gravatar,omitempty"`

	Email *ConfigAuthUserEmail `json:"email,omitempty" toml:"email,omitempty"`

	EmailDomains *ConfigAuthUserEmailDomains `json:"emailDomains,omitempty" toml:"emailDomains,omitempty"`
}

func (o *ConfigAuthUser) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Roles != nil {
		m["roles"] = o.Roles
	}
	if o.Locale != nil {
		m["locale"] = o.Locale
	}
	if o.Gravatar != nil {
		m["gravatar"] = o.Gravatar
	}
	if o.Email != nil {
		m["email"] = o.Email
	}
	if o.EmailDomains != nil {
		m["emailDomains"] = o.EmailDomains
	}
	return json.Marshal(m)
}

func (o *ConfigAuthUser) GetRoles() *ConfigAuthUserRoles {
	if o == nil {
		return nil
	}
	return o.Roles
}

func (o *ConfigAuthUser) GetLocale() *ConfigAuthUserLocale {
	if o == nil {
		return nil
	}
	return o.Locale
}

func (o *ConfigAuthUser) GetGravatar() *ConfigAuthUserGravatar {
	if o == nil {
		return nil
	}
	return o.Gravatar
}

func (o *ConfigAuthUser) GetEmail() *ConfigAuthUserEmail {
	if o == nil {
		return nil
	}
	return o.Email
}

func (o *ConfigAuthUser) GetEmailDomains() *ConfigAuthUserEmailDomains {
	if o == nil {
		return nil
	}
	return o.EmailDomains
}

type ConfigAuthUserUpdateInput struct {
	Roles             *ConfigAuthUserRolesUpdateInput        `json:"roles,omitempty" toml:"roles,omitempty"`
	IsSetRoles        bool                                   `json:"-"`
	Locale            *ConfigAuthUserLocaleUpdateInput       `json:"locale,omitempty" toml:"locale,omitempty"`
	IsSetLocale       bool                                   `json:"-"`
	Gravatar          *ConfigAuthUserGravatarUpdateInput     `json:"gravatar,omitempty" toml:"gravatar,omitempty"`
	IsSetGravatar     bool                                   `json:"-"`
	Email             *ConfigAuthUserEmailUpdateInput        `json:"email,omitempty" toml:"email,omitempty"`
	IsSetEmail        bool                                   `json:"-"`
	EmailDomains      *ConfigAuthUserEmailDomainsUpdateInput `json:"emailDomains,omitempty" toml:"emailDomains,omitempty"`
	IsSetEmailDomains bool                                   `json:"-"`
}

func (o *ConfigAuthUserUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if x, ok := m["roles"]; ok {
		if x != nil {
			t := &ConfigAuthUserRolesUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Roles = t
		}
		o.IsSetRoles = true
	}
	if x, ok := m["locale"]; ok {
		if x != nil {
			t := &ConfigAuthUserLocaleUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Locale = t
		}
		o.IsSetLocale = true
	}
	if x, ok := m["gravatar"]; ok {
		if x != nil {
			t := &ConfigAuthUserGravatarUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Gravatar = t
		}
		o.IsSetGravatar = true
	}
	if x, ok := m["email"]; ok {
		if x != nil {
			t := &ConfigAuthUserEmailUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Email = t
		}
		o.IsSetEmail = true
	}
	if x, ok := m["emailDomains"]; ok {
		if x != nil {
			t := &ConfigAuthUserEmailDomainsUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.EmailDomains = t
		}
		o.IsSetEmailDomains = true
	}

	return nil
}

func (o *ConfigAuthUserUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigAuthUserUpdateInput) GetRoles() *ConfigAuthUserRolesUpdateInput {
	if o == nil {
		return nil
	}
	return o.Roles
}

func (o *ConfigAuthUserUpdateInput) GetLocale() *ConfigAuthUserLocaleUpdateInput {
	if o == nil {
		return nil
	}
	return o.Locale
}

func (o *ConfigAuthUserUpdateInput) GetGravatar() *ConfigAuthUserGravatarUpdateInput {
	if o == nil {
		return nil
	}
	return o.Gravatar
}

func (o *ConfigAuthUserUpdateInput) GetEmail() *ConfigAuthUserEmailUpdateInput {
	if o == nil {
		return nil
	}
	return o.Email
}

func (o *ConfigAuthUserUpdateInput) GetEmailDomains() *ConfigAuthUserEmailDomainsUpdateInput {
	if o == nil {
		return nil
	}
	return o.EmailDomains
}

func (s *ConfigAuthUser) Update(v *ConfigAuthUserUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetRoles || v.Roles != nil {
		if v.Roles == nil {
			s.Roles = nil
		} else {
			if s.Roles == nil {
				s.Roles = &ConfigAuthUserRoles{}
			}
			s.Roles.Update(v.Roles)
		}
	}
	if v.IsSetLocale || v.Locale != nil {
		if v.Locale == nil {
			s.Locale = nil
		} else {
			if s.Locale == nil {
				s.Locale = &ConfigAuthUserLocale{}
			}
			s.Locale.Update(v.Locale)
		}
	}
	if v.IsSetGravatar || v.Gravatar != nil {
		if v.Gravatar == nil {
			s.Gravatar = nil
		} else {
			if s.Gravatar == nil {
				s.Gravatar = &ConfigAuthUserGravatar{}
			}
			s.Gravatar.Update(v.Gravatar)
		}
	}
	if v.IsSetEmail || v.Email != nil {
		if v.Email == nil {
			s.Email = nil
		} else {
			if s.Email == nil {
				s.Email = &ConfigAuthUserEmail{}
			}
			s.Email.Update(v.Email)
		}
	}
	if v.IsSetEmailDomains || v.EmailDomains != nil {
		if v.EmailDomains == nil {
			s.EmailDomains = nil
		} else {
			if s.EmailDomains == nil {
				s.EmailDomains = &ConfigAuthUserEmailDomains{}
			}
			s.EmailDomains.Update(v.EmailDomains)
		}
	}
}

type ConfigAuthUserInsertInput struct {
	Roles        *ConfigAuthUserRolesInsertInput        `json:"roles,omitempty" toml:"roles,omitempty"`
	Locale       *ConfigAuthUserLocaleInsertInput       `json:"locale,omitempty" toml:"locale,omitempty"`
	Gravatar     *ConfigAuthUserGravatarInsertInput     `json:"gravatar,omitempty" toml:"gravatar,omitempty"`
	Email        *ConfigAuthUserEmailInsertInput        `json:"email,omitempty" toml:"email,omitempty"`
	EmailDomains *ConfigAuthUserEmailDomainsInsertInput `json:"emailDomains,omitempty" toml:"emailDomains,omitempty"`
}

func (o *ConfigAuthUserInsertInput) GetRoles() *ConfigAuthUserRolesInsertInput {
	if o == nil {
		return nil
	}
	return o.Roles
}

func (o *ConfigAuthUserInsertInput) GetLocale() *ConfigAuthUserLocaleInsertInput {
	if o == nil {
		return nil
	}
	return o.Locale
}

func (o *ConfigAuthUserInsertInput) GetGravatar() *ConfigAuthUserGravatarInsertInput {
	if o == nil {
		return nil
	}
	return o.Gravatar
}

func (o *ConfigAuthUserInsertInput) GetEmail() *ConfigAuthUserEmailInsertInput {
	if o == nil {
		return nil
	}
	return o.Email
}

func (o *ConfigAuthUserInsertInput) GetEmailDomains() *ConfigAuthUserEmailDomainsInsertInput {
	if o == nil {
		return nil
	}
	return o.EmailDomains
}

func (s *ConfigAuthUser) Insert(v *ConfigAuthUserInsertInput) {
	if v.Roles != nil {
		if s.Roles == nil {
			s.Roles = &ConfigAuthUserRoles{}
		}
		s.Roles.Insert(v.Roles)
	}
	if v.Locale != nil {
		if s.Locale == nil {
			s.Locale = &ConfigAuthUserLocale{}
		}
		s.Locale.Insert(v.Locale)
	}
	if v.Gravatar != nil {
		if s.Gravatar == nil {
			s.Gravatar = &ConfigAuthUserGravatar{}
		}
		s.Gravatar.Insert(v.Gravatar)
	}
	if v.Email != nil {
		if s.Email == nil {
			s.Email = &ConfigAuthUserEmail{}
		}
		s.Email.Insert(v.Email)
	}
	if v.EmailDomains != nil {
		if s.EmailDomains == nil {
			s.EmailDomains = &ConfigAuthUserEmailDomains{}
		}
		s.EmailDomains.Insert(v.EmailDomains)
	}
}

func (s *ConfigAuthUser) Clone() *ConfigAuthUser {
	if s == nil {
		return nil
	}

	v := &ConfigAuthUser{}
	v.Roles = s.Roles.Clone()
	v.Locale = s.Locale.Clone()
	v.Gravatar = s.Gravatar.Clone()
	v.Email = s.Email.Clone()
	v.EmailDomains = s.EmailDomains.Clone()
	return v
}

type ConfigAuthUserComparisonExp struct {
	And          []*ConfigAuthUserComparisonExp           `json:"_and,omitempty"`
	Not          *ConfigAuthUserComparisonExp             `json:"_not,omitempty"`
	Or           []*ConfigAuthUserComparisonExp           `json:"_or,omitempty"`
	Roles        *ConfigAuthUserRolesComparisonExp        `json:"roles,omitempty"`
	Locale       *ConfigAuthUserLocaleComparisonExp       `json:"locale,omitempty"`
	Gravatar     *ConfigAuthUserGravatarComparisonExp     `json:"gravatar,omitempty"`
	Email        *ConfigAuthUserEmailComparisonExp        `json:"email,omitempty"`
	EmailDomains *ConfigAuthUserEmailDomainsComparisonExp `json:"emailDomains,omitempty"`
}

func (exp *ConfigAuthUserComparisonExp) Matches(o *ConfigAuthUser) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthUser{
			Roles:        &ConfigAuthUserRoles{},
			Locale:       &ConfigAuthUserLocale{},
			Gravatar:     &ConfigAuthUserGravatar{},
			Email:        &ConfigAuthUserEmail{},
			EmailDomains: &ConfigAuthUserEmailDomains{},
		}
	}
	if !exp.Roles.Matches(o.Roles) {
		return false
	}
	if !exp.Locale.Matches(o.Locale) {
		return false
	}
	if !exp.Gravatar.Matches(o.Gravatar) {
		return false
	}
	if !exp.Email.Matches(o.Email) {
		return false
	}
	if !exp.EmailDomains.Matches(o.EmailDomains) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAuthUserEmail struct {
	// AUTH_ACCESS_CONTROL_ALLOWED_EMAILS
	Allowed []string `json:"allowed,omitempty" toml:"allowed,omitempty"`
	// AUTH_ACCESS_CONTROL_BLOCKED_EMAILS
	Blocked []string `json:"blocked,omitempty" toml:"blocked,omitempty"`
}

func (o *ConfigAuthUserEmail) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Allowed != nil {
		m["allowed"] = o.Allowed
	}
	if o.Blocked != nil {
		m["blocked"] = o.Blocked
	}
	return json.Marshal(m)
}

func (o *ConfigAuthUserEmail) GetAllowed() []string {
	if o == nil {
		o = &ConfigAuthUserEmail{}
	}
	return o.Allowed
}

func (o *ConfigAuthUserEmail) GetBlocked() []string {
	if o == nil {
		o = &ConfigAuthUserEmail{}
	}
	return o.Blocked
}

type ConfigAuthUserEmailUpdateInput struct {
	Allowed      []string `json:"allowed,omitempty" toml:"allowed,omitempty"`
	IsSetAllowed bool     `json:"-"`
	Blocked      []string `json:"blocked,omitempty" toml:"blocked,omitempty"`
	IsSetBlocked bool     `json:"-"`
}

func (o *ConfigAuthUserEmailUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["allowed"]; ok {
		if v != nil {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var l []string
			if err := json.Unmarshal(b, &l); err != nil {
				return err
			}
			o.Allowed = l
		}
		o.IsSetAllowed = true
	}
	if v, ok := m["blocked"]; ok {
		if v != nil {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var l []string
			if err := json.Unmarshal(b, &l); err != nil {
				return err
			}
			o.Blocked = l
		}
		o.IsSetBlocked = true
	}

	return nil
}

func (o *ConfigAuthUserEmailUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigAuthUserEmailUpdateInput) GetAllowed() []string {
	if o == nil {
		o = &ConfigAuthUserEmailUpdateInput{}
	}
	return o.Allowed
}

func (o *ConfigAuthUserEmailUpdateInput) GetBlocked() []string {
	if o == nil {
		o = &ConfigAuthUserEmailUpdateInput{}
	}
	return o.Blocked
}

func (s *ConfigAuthUserEmail) Update(v *ConfigAuthUserEmailUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetAllowed || v.Allowed != nil {
		if v.Allowed == nil {
			s.Allowed = nil
		} else {
			s.Allowed = make([]string, len(v.Allowed))
			for i, e := range v.Allowed {
				s.Allowed[i] = e
			}
		}
	}
	if v.IsSetBlocked || v.Blocked != nil {
		if v.Blocked == nil {
			s.Blocked = nil
		} else {
			s.Blocked = make([]string, len(v.Blocked))
			for i, e := range v.Blocked {
				s.Blocked[i] = e
			}
		}
	}
}

type ConfigAuthUserEmailInsertInput struct {
	Allowed []string `json:"allowed,omitempty" toml:"allowed,omitempty"`
	Blocked []string `json:"blocked,omitempty" toml:"blocked,omitempty"`
}

func (o *ConfigAuthUserEmailInsertInput) GetAllowed() []string {
	if o == nil {
		o = &ConfigAuthUserEmailInsertInput{}
	}
	return o.Allowed
}

func (o *ConfigAuthUserEmailInsertInput) GetBlocked() []string {
	if o == nil {
		o = &ConfigAuthUserEmailInsertInput{}
	}
	return o.Blocked
}

func (s *ConfigAuthUserEmail) Insert(v *ConfigAuthUserEmailInsertInput) {
	if v.Allowed != nil {
		s.Allowed = make([]string, len(v.Allowed))
		for i, e := range v.Allowed {
			s.Allowed[i] = e
		}
	}
	if v.Blocked != nil {
		s.Blocked = make([]string, len(v.Blocked))
		for i, e := range v.Blocked {
			s.Blocked[i] = e
		}
	}
}

func (s *ConfigAuthUserEmail) Clone() *ConfigAuthUserEmail {
	if s == nil {
		return nil
	}

	v := &ConfigAuthUserEmail{}
	if s.Allowed != nil {
		v.Allowed = make([]string, len(s.Allowed))
		copy(v.Allowed, s.Allowed)
	}
	if s.Blocked != nil {
		v.Blocked = make([]string, len(s.Blocked))
		copy(v.Blocked, s.Blocked)
	}
	return v
}

type ConfigAuthUserEmailComparisonExp struct {
	And     []*ConfigAuthUserEmailComparisonExp `json:"_and,omitempty"`
	Not     *ConfigAuthUserEmailComparisonExp   `json:"_not,omitempty"`
	Or      []*ConfigAuthUserEmailComparisonExp `json:"_or,omitempty"`
	Allowed *ConfigEmailComparisonExp           `json:"allowed,omitempty"`
	Blocked *ConfigEmailComparisonExp           `json:"blocked,omitempty"`
}

func (exp *ConfigAuthUserEmailComparisonExp) Matches(o *ConfigAuthUserEmail) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthUserEmail{
			Allowed: []string{},
			Blocked: []string{},
		}
	}
	{
		found := false
		for _, o := range o.Allowed {
			if exp.Allowed.Matches(o) {
				found = true
				break
			}
		}
		if !found && exp.Allowed != nil {
			return false
		}
	}
	{
		found := false
		for _, o := range o.Blocked {
			if exp.Blocked.Matches(o) {
				found = true
				break
			}
		}
		if !found && exp.Blocked != nil {
			return false
		}
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAuthUserEmailDomains struct {
	// AUTH_ACCESS_CONTROL_ALLOWED_EMAIL_DOMAINS
	Allowed []string `json:"allowed,omitempty" toml:"allowed,omitempty"`
	// AUTH_ACCESS_CONTROL_BLOCKED_EMAIL_DOMAINS
	Blocked []string `json:"blocked,omitempty" toml:"blocked,omitempty"`
}

func (o *ConfigAuthUserEmailDomains) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Allowed != nil {
		m["allowed"] = o.Allowed
	}
	if o.Blocked != nil {
		m["blocked"] = o.Blocked
	}
	return json.Marshal(m)
}

func (o *ConfigAuthUserEmailDomains) GetAllowed() []string {
	if o == nil {
		o = &ConfigAuthUserEmailDomains{}
	}
	return o.Allowed
}

func (o *ConfigAuthUserEmailDomains) GetBlocked() []string {
	if o == nil {
		o = &ConfigAuthUserEmailDomains{}
	}
	return o.Blocked
}

type ConfigAuthUserEmailDomainsUpdateInput struct {
	Allowed      []string `json:"allowed,omitempty" toml:"allowed,omitempty"`
	IsSetAllowed bool     `json:"-"`
	Blocked      []string `json:"blocked,omitempty" toml:"blocked,omitempty"`
	IsSetBlocked bool     `json:"-"`
}

func (o *ConfigAuthUserEmailDomainsUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["allowed"]; ok {
		if v != nil {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var l []string
			if err := json.Unmarshal(b, &l); err != nil {
				return err
			}
			o.Allowed = l
		}
		o.IsSetAllowed = true
	}
	if v, ok := m["blocked"]; ok {
		if v != nil {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var l []string
			if err := json.Unmarshal(b, &l); err != nil {
				return err
			}
			o.Blocked = l
		}
		o.IsSetBlocked = true
	}

	return nil
}

func (o *ConfigAuthUserEmailDomainsUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigAuthUserEmailDomainsUpdateInput) GetAllowed() []string {
	if o == nil {
		o = &ConfigAuthUserEmailDomainsUpdateInput{}
	}
	return o.Allowed
}

func (o *ConfigAuthUserEmailDomainsUpdateInput) GetBlocked() []string {
	if o == nil {
		o = &ConfigAuthUserEmailDomainsUpdateInput{}
	}
	return o.Blocked
}

func (s *ConfigAuthUserEmailDomains) Update(v *ConfigAuthUserEmailDomainsUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetAllowed || v.Allowed != nil {
		if v.Allowed == nil {
			s.Allowed = nil
		} else {
			s.Allowed = make([]string, len(v.Allowed))
			for i, e := range v.Allowed {
				s.Allowed[i] = e
			}
		}
	}
	if v.IsSetBlocked || v.Blocked != nil {
		if v.Blocked == nil {
			s.Blocked = nil
		} else {
			s.Blocked = make([]string, len(v.Blocked))
			for i, e := range v.Blocked {
				s.Blocked[i] = e
			}
		}
	}
}

type ConfigAuthUserEmailDomainsInsertInput struct {
	Allowed []string `json:"allowed,omitempty" toml:"allowed,omitempty"`
	Blocked []string `json:"blocked,omitempty" toml:"blocked,omitempty"`
}

func (o *ConfigAuthUserEmailDomainsInsertInput) GetAllowed() []string {
	if o == nil {
		o = &ConfigAuthUserEmailDomainsInsertInput{}
	}
	return o.Allowed
}

func (o *ConfigAuthUserEmailDomainsInsertInput) GetBlocked() []string {
	if o == nil {
		o = &ConfigAuthUserEmailDomainsInsertInput{}
	}
	return o.Blocked
}

func (s *ConfigAuthUserEmailDomains) Insert(v *ConfigAuthUserEmailDomainsInsertInput) {
	if v.Allowed != nil {
		s.Allowed = make([]string, len(v.Allowed))
		for i, e := range v.Allowed {
			s.Allowed[i] = e
		}
	}
	if v.Blocked != nil {
		s.Blocked = make([]string, len(v.Blocked))
		for i, e := range v.Blocked {
			s.Blocked[i] = e
		}
	}
}

func (s *ConfigAuthUserEmailDomains) Clone() *ConfigAuthUserEmailDomains {
	if s == nil {
		return nil
	}

	v := &ConfigAuthUserEmailDomains{}
	if s.Allowed != nil {
		v.Allowed = make([]string, len(s.Allowed))
		copy(v.Allowed, s.Allowed)
	}
	if s.Blocked != nil {
		v.Blocked = make([]string, len(s.Blocked))
		copy(v.Blocked, s.Blocked)
	}
	return v
}

type ConfigAuthUserEmailDomainsComparisonExp struct {
	And     []*ConfigAuthUserEmailDomainsComparisonExp `json:"_and,omitempty"`
	Not     *ConfigAuthUserEmailDomainsComparisonExp   `json:"_not,omitempty"`
	Or      []*ConfigAuthUserEmailDomainsComparisonExp `json:"_or,omitempty"`
	Allowed *ConfigStringComparisonExp                 `json:"allowed,omitempty"`
	Blocked *ConfigStringComparisonExp                 `json:"blocked,omitempty"`
}

func (exp *ConfigAuthUserEmailDomainsComparisonExp) Matches(o *ConfigAuthUserEmailDomains) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthUserEmailDomains{
			Allowed: []string{},
			Blocked: []string{},
		}
	}
	{
		found := false
		for _, o := range o.Allowed {
			if exp.Allowed.Matches(o) {
				found = true
				break
			}
		}
		if !found && exp.Allowed != nil {
			return false
		}
	}
	{
		found := false
		for _, o := range o.Blocked {
			if exp.Blocked.Matches(o) {
				found = true
				break
			}
		}
		if !found && exp.Blocked != nil {
			return false
		}
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAuthUserGravatar struct {
	// AUTH_GRAVATAR_ENABLED
	Enabled *bool `json:"enabled" toml:"enabled"`

	Default *string `json:"default" toml:"default"`

	Rating *string `json:"rating" toml:"rating"`
}

func (o *ConfigAuthUserGravatar) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Enabled != nil {
		m["enabled"] = o.Enabled
	}
	if o.Default != nil {
		m["default"] = o.Default
	}
	if o.Rating != nil {
		m["rating"] = o.Rating
	}
	return json.Marshal(m)
}

func (o *ConfigAuthUserGravatar) GetEnabled() *bool {
	if o == nil {
		o = &ConfigAuthUserGravatar{}
	}
	return o.Enabled
}

func (o *ConfigAuthUserGravatar) GetDefault() *string {
	if o == nil {
		o = &ConfigAuthUserGravatar{}
	}
	return o.Default
}

func (o *ConfigAuthUserGravatar) GetRating() *string {
	if o == nil {
		o = &ConfigAuthUserGravatar{}
	}
	return o.Rating
}

type ConfigAuthUserGravatarUpdateInput struct {
	Enabled      *bool   `json:"enabled,omitempty" toml:"enabled,omitempty"`
	IsSetEnabled bool    `json:"-"`
	Default      *string `json:"default,omitempty" toml:"default,omitempty"`
	IsSetDefault bool    `json:"-"`
	Rating       *string `json:"rating,omitempty" toml:"rating,omitempty"`
	IsSetRating  bool    `json:"-"`
}

func (o *ConfigAuthUserGravatarUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["enabled"]; ok {
		if v == nil {
			o.Enabled = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x bool
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Enabled = &x
		}
		o.IsSetEnabled = true
	}
	if v, ok := m["default"]; ok {
		if v == nil {
			o.Default = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Default = &x
		}
		o.IsSetDefault = true
	}
	if v, ok := m["rating"]; ok {
		if v == nil {
			o.Rating = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Rating = &x
		}
		o.IsSetRating = true
	}

	return nil
}

func (o *ConfigAuthUserGravatarUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigAuthUserGravatarUpdateInput) GetEnabled() *bool {
	if o == nil {
		o = &ConfigAuthUserGravatarUpdateInput{}
	}
	return o.Enabled
}

func (o *ConfigAuthUserGravatarUpdateInput) GetDefault() *string {
	if o == nil {
		o = &ConfigAuthUserGravatarUpdateInput{}
	}
	return o.Default
}

func (o *ConfigAuthUserGravatarUpdateInput) GetRating() *string {
	if o == nil {
		o = &ConfigAuthUserGravatarUpdateInput{}
	}
	return o.Rating
}

func (s *ConfigAuthUserGravatar) Update(v *ConfigAuthUserGravatarUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetEnabled || v.Enabled != nil {
		s.Enabled = v.Enabled
	}
	if v.IsSetDefault || v.Default != nil {
		s.Default = v.Default
	}
	if v.IsSetRating || v.Rating != nil {
		s.Rating = v.Rating
	}
}

type ConfigAuthUserGravatarInsertInput struct {
	Enabled *bool   `json:"enabled,omitempty" toml:"enabled,omitempty"`
	Default *string `json:"default,omitempty" toml:"default,omitempty"`
	Rating  *string `json:"rating,omitempty" toml:"rating,omitempty"`
}

func (o *ConfigAuthUserGravatarInsertInput) GetEnabled() *bool {
	if o == nil {
		o = &ConfigAuthUserGravatarInsertInput{}
	}
	return o.Enabled
}

func (o *ConfigAuthUserGravatarInsertInput) GetDefault() *string {
	if o == nil {
		o = &ConfigAuthUserGravatarInsertInput{}
	}
	return o.Default
}

func (o *ConfigAuthUserGravatarInsertInput) GetRating() *string {
	if o == nil {
		o = &ConfigAuthUserGravatarInsertInput{}
	}
	return o.Rating
}

func (s *ConfigAuthUserGravatar) Insert(v *ConfigAuthUserGravatarInsertInput) {
	s.Enabled = v.Enabled
	s.Default = v.Default
	s.Rating = v.Rating
}

func (s *ConfigAuthUserGravatar) Clone() *ConfigAuthUserGravatar {
	if s == nil {
		return nil
	}

	v := &ConfigAuthUserGravatar{}
	v.Enabled = s.Enabled
	v.Default = s.Default
	v.Rating = s.Rating
	return v
}

type ConfigAuthUserGravatarComparisonExp struct {
	And     []*ConfigAuthUserGravatarComparisonExp `json:"_and,omitempty"`
	Not     *ConfigAuthUserGravatarComparisonExp   `json:"_not,omitempty"`
	Or      []*ConfigAuthUserGravatarComparisonExp `json:"_or,omitempty"`
	Enabled *ConfigBooleanComparisonExp            `json:"enabled,omitempty"`
	Default *ConfigStringComparisonExp             `json:"default,omitempty"`
	Rating  *ConfigStringComparisonExp             `json:"rating,omitempty"`
}

func (exp *ConfigAuthUserGravatarComparisonExp) Matches(o *ConfigAuthUserGravatar) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthUserGravatar{}
	}
	if o.Enabled != nil && !exp.Enabled.Matches(*o.Enabled) {
		return false
	}
	if o.Default != nil && !exp.Default.Matches(*o.Default) {
		return false
	}
	if o.Rating != nil && !exp.Rating.Matches(*o.Rating) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAuthUserLocale struct {
	// AUTH_LOCALE_DEFAULT
	Default *string `json:"default" toml:"default"`
	// AUTH_LOCALE_ALLOWED_LOCALES
	Allowed []string `json:"allowed,omitempty" toml:"allowed,omitempty"`
}

func (o *ConfigAuthUserLocale) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Default != nil {
		m["default"] = o.Default
	}
	if o.Allowed != nil {
		m["allowed"] = o.Allowed
	}
	return json.Marshal(m)
}

func (o *ConfigAuthUserLocale) GetDefault() *string {
	if o == nil {
		o = &ConfigAuthUserLocale{}
	}
	return o.Default
}

func (o *ConfigAuthUserLocale) GetAllowed() []string {
	if o == nil {
		o = &ConfigAuthUserLocale{}
	}
	return o.Allowed
}

type ConfigAuthUserLocaleUpdateInput struct {
	Default      *string  `json:"default,omitempty" toml:"default,omitempty"`
	IsSetDefault bool     `json:"-"`
	Allowed      []string `json:"allowed,omitempty" toml:"allowed,omitempty"`
	IsSetAllowed bool     `json:"-"`
}

func (o *ConfigAuthUserLocaleUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["default"]; ok {
		if v == nil {
			o.Default = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Default = &x
		}
		o.IsSetDefault = true
	}
	if v, ok := m["allowed"]; ok {
		if v != nil {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var l []string
			if err := json.Unmarshal(b, &l); err != nil {
				return err
			}
			o.Allowed = l
		}
		o.IsSetAllowed = true
	}

	return nil
}

func (o *ConfigAuthUserLocaleUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigAuthUserLocaleUpdateInput) GetDefault() *string {
	if o == nil {
		o = &ConfigAuthUserLocaleUpdateInput{}
	}
	return o.Default
}

func (o *ConfigAuthUserLocaleUpdateInput) GetAllowed() []string {
	if o == nil {
		o = &ConfigAuthUserLocaleUpdateInput{}
	}
	return o.Allowed
}

func (s *ConfigAuthUserLocale) Update(v *ConfigAuthUserLocaleUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetDefault || v.Default != nil {
		s.Default = v.Default
	}
	if v.IsSetAllowed || v.Allowed != nil {
		if v.Allowed == nil {
			s.Allowed = nil
		} else {
			s.Allowed = make([]string, len(v.Allowed))
			for i, e := range v.Allowed {
				s.Allowed[i] = e
			}
		}
	}
}

type ConfigAuthUserLocaleInsertInput struct {
	Default *string  `json:"default,omitempty" toml:"default,omitempty"`
	Allowed []string `json:"allowed,omitempty" toml:"allowed,omitempty"`
}

func (o *ConfigAuthUserLocaleInsertInput) GetDefault() *string {
	if o == nil {
		o = &ConfigAuthUserLocaleInsertInput{}
	}
	return o.Default
}

func (o *ConfigAuthUserLocaleInsertInput) GetAllowed() []string {
	if o == nil {
		o = &ConfigAuthUserLocaleInsertInput{}
	}
	return o.Allowed
}

func (s *ConfigAuthUserLocale) Insert(v *ConfigAuthUserLocaleInsertInput) {
	s.Default = v.Default
	if v.Allowed != nil {
		s.Allowed = make([]string, len(v.Allowed))
		for i, e := range v.Allowed {
			s.Allowed[i] = e
		}
	}
}

func (s *ConfigAuthUserLocale) Clone() *ConfigAuthUserLocale {
	if s == nil {
		return nil
	}

	v := &ConfigAuthUserLocale{}
	v.Default = s.Default
	if s.Allowed != nil {
		v.Allowed = make([]string, len(s.Allowed))
		copy(v.Allowed, s.Allowed)
	}
	return v
}

type ConfigAuthUserLocaleComparisonExp struct {
	And     []*ConfigAuthUserLocaleComparisonExp `json:"_and,omitempty"`
	Not     *ConfigAuthUserLocaleComparisonExp   `json:"_not,omitempty"`
	Or      []*ConfigAuthUserLocaleComparisonExp `json:"_or,omitempty"`
	Default *ConfigLocaleComparisonExp           `json:"default,omitempty"`
	Allowed *ConfigLocaleComparisonExp           `json:"allowed,omitempty"`
}

func (exp *ConfigAuthUserLocaleComparisonExp) Matches(o *ConfigAuthUserLocale) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthUserLocale{
			Allowed: []string{},
		}
	}
	if o.Default != nil && !exp.Default.Matches(*o.Default) {
		return false
	}
	{
		found := false
		for _, o := range o.Allowed {
			if exp.Allowed.Matches(o) {
				found = true
				break
			}
		}
		if !found && exp.Allowed != nil {
			return false
		}
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAuthUserRoles struct {
	// AUTH_USER_DEFAULT_ROLE
	Default *string `json:"default" toml:"default"`
	// AUTH_USER_DEFAULT_ALLOWED_ROLES
	Allowed []string `json:"allowed,omitempty" toml:"allowed,omitempty"`
}

func (o *ConfigAuthUserRoles) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Default != nil {
		m["default"] = o.Default
	}
	if o.Allowed != nil {
		m["allowed"] = o.Allowed
	}
	return json.Marshal(m)
}

func (o *ConfigAuthUserRoles) GetDefault() *string {
	if o == nil {
		o = &ConfigAuthUserRoles{}
	}
	return o.Default
}

func (o *ConfigAuthUserRoles) GetAllowed() []string {
	if o == nil {
		o = &ConfigAuthUserRoles{}
	}
	return o.Allowed
}

type ConfigAuthUserRolesUpdateInput struct {
	Default      *string  `json:"default,omitempty" toml:"default,omitempty"`
	IsSetDefault bool     `json:"-"`
	Allowed      []string `json:"allowed,omitempty" toml:"allowed,omitempty"`
	IsSetAllowed bool     `json:"-"`
}

func (o *ConfigAuthUserRolesUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["default"]; ok {
		if v == nil {
			o.Default = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Default = &x
		}
		o.IsSetDefault = true
	}
	if v, ok := m["allowed"]; ok {
		if v != nil {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var l []string
			if err := json.Unmarshal(b, &l); err != nil {
				return err
			}
			o.Allowed = l
		}
		o.IsSetAllowed = true
	}

	return nil
}

func (o *ConfigAuthUserRolesUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigAuthUserRolesUpdateInput) GetDefault() *string {
	if o == nil {
		o = &ConfigAuthUserRolesUpdateInput{}
	}
	return o.Default
}

func (o *ConfigAuthUserRolesUpdateInput) GetAllowed() []string {
	if o == nil {
		o = &ConfigAuthUserRolesUpdateInput{}
	}
	return o.Allowed
}

func (s *ConfigAuthUserRoles) Update(v *ConfigAuthUserRolesUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetDefault || v.Default != nil {
		s.Default = v.Default
	}
	if v.IsSetAllowed || v.Allowed != nil {
		if v.Allowed == nil {
			s.Allowed = nil
		} else {
			s.Allowed = make([]string, len(v.Allowed))
			for i, e := range v.Allowed {
				s.Allowed[i] = e
			}
		}
	}
}

type ConfigAuthUserRolesInsertInput struct {
	Default *string  `json:"default,omitempty" toml:"default,omitempty"`
	Allowed []string `json:"allowed,omitempty" toml:"allowed,omitempty"`
}

func (o *ConfigAuthUserRolesInsertInput) GetDefault() *string {
	if o == nil {
		o = &ConfigAuthUserRolesInsertInput{}
	}
	return o.Default
}

func (o *ConfigAuthUserRolesInsertInput) GetAllowed() []string {
	if o == nil {
		o = &ConfigAuthUserRolesInsertInput{}
	}
	return o.Allowed
}

func (s *ConfigAuthUserRoles) Insert(v *ConfigAuthUserRolesInsertInput) {
	s.Default = v.Default
	if v.Allowed != nil {
		s.Allowed = make([]string, len(v.Allowed))
		for i, e := range v.Allowed {
			s.Allowed[i] = e
		}
	}
}

func (s *ConfigAuthUserRoles) Clone() *ConfigAuthUserRoles {
	if s == nil {
		return nil
	}

	v := &ConfigAuthUserRoles{}
	v.Default = s.Default
	if s.Allowed != nil {
		v.Allowed = make([]string, len(s.Allowed))
		copy(v.Allowed, s.Allowed)
	}
	return v
}

type ConfigAuthUserRolesComparisonExp struct {
	And     []*ConfigAuthUserRolesComparisonExp `json:"_and,omitempty"`
	Not     *ConfigAuthUserRolesComparisonExp   `json:"_not,omitempty"`
	Or      []*ConfigAuthUserRolesComparisonExp `json:"_or,omitempty"`
	Default *ConfigUserRoleComparisonExp        `json:"default,omitempty"`
	Allowed *ConfigUserRoleComparisonExp        `json:"allowed,omitempty"`
}

func (exp *ConfigAuthUserRolesComparisonExp) Matches(o *ConfigAuthUserRoles) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthUserRoles{
			Allowed: []string{},
		}
	}
	if o.Default != nil && !exp.Default.Matches(*o.Default) {
		return false
	}
	{
		found := false
		for _, o := range o.Allowed {
			if exp.Allowed.Matches(o) {
				found = true
				break
			}
		}
		if !found && exp.Allowed != nil {
			return false
		}
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

// AUTH_JWT_CUSTOM_CLAIMS
type ConfigAuthsessionaccessTokenCustomClaims struct {
	Key string `json:"key" toml:"key"`

	Value string `json:"value" toml:"value"`
}

func (o *ConfigAuthsessionaccessTokenCustomClaims) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	m["key"] = o.Key
	m["value"] = o.Value
	return json.Marshal(m)
}

func (o *ConfigAuthsessionaccessTokenCustomClaims) GetKey() string {
	if o == nil {
		o = &ConfigAuthsessionaccessTokenCustomClaims{}
	}
	return o.Key
}

func (o *ConfigAuthsessionaccessTokenCustomClaims) GetValue() string {
	if o == nil {
		o = &ConfigAuthsessionaccessTokenCustomClaims{}
	}
	return o.Value
}

type ConfigAuthsessionaccessTokenCustomClaimsUpdateInput struct {
	Key        *string `json:"key,omitempty" toml:"key,omitempty"`
	IsSetKey   bool    `json:"-"`
	Value      *string `json:"value,omitempty" toml:"value,omitempty"`
	IsSetValue bool    `json:"-"`
}

func (o *ConfigAuthsessionaccessTokenCustomClaimsUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["key"]; ok {
		if v == nil {
			o.Key = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Key = &x
		}
		o.IsSetKey = true
	}
	if v, ok := m["value"]; ok {
		if v == nil {
			o.Value = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Value = &x
		}
		o.IsSetValue = true
	}

	return nil
}

func (o *ConfigAuthsessionaccessTokenCustomClaimsUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigAuthsessionaccessTokenCustomClaimsUpdateInput) GetKey() *string {
	if o == nil {
		o = &ConfigAuthsessionaccessTokenCustomClaimsUpdateInput{}
	}
	return o.Key
}

func (o *ConfigAuthsessionaccessTokenCustomClaimsUpdateInput) GetValue() *string {
	if o == nil {
		o = &ConfigAuthsessionaccessTokenCustomClaimsUpdateInput{}
	}
	return o.Value
}

func (s *ConfigAuthsessionaccessTokenCustomClaims) Update(v *ConfigAuthsessionaccessTokenCustomClaimsUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetKey || v.Key != nil {
		if v.Key != nil {
			s.Key = *v.Key
		}
	}
	if v.IsSetValue || v.Value != nil {
		if v.Value != nil {
			s.Value = *v.Value
		}
	}
}

type ConfigAuthsessionaccessTokenCustomClaimsInsertInput struct {
	Key   string `json:"key,omitempty" toml:"key,omitempty"`
	Value string `json:"value,omitempty" toml:"value,omitempty"`
}

func (o *ConfigAuthsessionaccessTokenCustomClaimsInsertInput) GetKey() string {
	if o == nil {
		o = &ConfigAuthsessionaccessTokenCustomClaimsInsertInput{}
	}
	return o.Key
}

func (o *ConfigAuthsessionaccessTokenCustomClaimsInsertInput) GetValue() string {
	if o == nil {
		o = &ConfigAuthsessionaccessTokenCustomClaimsInsertInput{}
	}
	return o.Value
}

func (s *ConfigAuthsessionaccessTokenCustomClaims) Insert(v *ConfigAuthsessionaccessTokenCustomClaimsInsertInput) {
	s.Key = v.Key
	s.Value = v.Value
}

func (s *ConfigAuthsessionaccessTokenCustomClaims) Clone() *ConfigAuthsessionaccessTokenCustomClaims {
	if s == nil {
		return nil
	}

	v := &ConfigAuthsessionaccessTokenCustomClaims{}
	v.Key = s.Key
	v.Value = s.Value
	return v
}

type ConfigAuthsessionaccessTokenCustomClaimsComparisonExp struct {
	And   []*ConfigAuthsessionaccessTokenCustomClaimsComparisonExp `json:"_and,omitempty"`
	Not   *ConfigAuthsessionaccessTokenCustomClaimsComparisonExp   `json:"_not,omitempty"`
	Or    []*ConfigAuthsessionaccessTokenCustomClaimsComparisonExp `json:"_or,omitempty"`
	Key   *ConfigStringComparisonExp                               `json:"key,omitempty"`
	Value *ConfigStringComparisonExp                               `json:"value,omitempty"`
}

func (exp *ConfigAuthsessionaccessTokenCustomClaimsComparisonExp) Matches(o *ConfigAuthsessionaccessTokenCustomClaims) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAuthsessionaccessTokenCustomClaims{}
	}
	if !exp.Key.Matches(o.Key) {
		return false
	}
	if !exp.Value.Matches(o.Value) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigAutoscaler struct {
	MaxReplicas uint8 `json:"maxReplicas" toml:"maxReplicas"`
}

func (o *ConfigAutoscaler) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	m["maxReplicas"] = o.MaxReplicas
	return json.Marshal(m)
}

func (o *ConfigAutoscaler) GetMaxReplicas() uint8 {
	if o == nil {
		o = &ConfigAutoscaler{}
	}
	return o.MaxReplicas
}

type ConfigAutoscalerUpdateInput struct {
	MaxReplicas      *uint8 `json:"maxReplicas,omitempty" toml:"maxReplicas,omitempty"`
	IsSetMaxReplicas bool   `json:"-"`
}

func (o *ConfigAutoscalerUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["maxReplicas"]; ok {
		if v == nil {
			o.MaxReplicas = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x uint8
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.MaxReplicas = &x
		}
		o.IsSetMaxReplicas = true
	}

	return nil
}

func (o *ConfigAutoscalerUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigAutoscalerUpdateInput) GetMaxReplicas() *uint8 {
	if o == nil {
		o = &ConfigAutoscalerUpdateInput{}
	}
	return o.MaxReplicas
}

func (s *ConfigAutoscaler) Update(v *ConfigAutoscalerUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetMaxReplicas || v.MaxReplicas != nil {
		if v.MaxReplicas != nil {
			s.MaxReplicas = *v.MaxReplicas
		}
	}
}

type ConfigAutoscalerInsertInput struct {
	MaxReplicas uint8 `json:"maxReplicas,omitempty" toml:"maxReplicas,omitempty"`
}

func (o *ConfigAutoscalerInsertInput) GetMaxReplicas() uint8 {
	if o == nil {
		o = &ConfigAutoscalerInsertInput{}
	}
	return o.MaxReplicas
}

func (s *ConfigAutoscaler) Insert(v *ConfigAutoscalerInsertInput) {
	s.MaxReplicas = v.MaxReplicas
}

func (s *ConfigAutoscaler) Clone() *ConfigAutoscaler {
	if s == nil {
		return nil
	}

	v := &ConfigAutoscaler{}
	v.MaxReplicas = s.MaxReplicas
	return v
}

type ConfigAutoscalerComparisonExp struct {
	And         []*ConfigAutoscalerComparisonExp `json:"_and,omitempty"`
	Not         *ConfigAutoscalerComparisonExp   `json:"_not,omitempty"`
	Or          []*ConfigAutoscalerComparisonExp `json:"_or,omitempty"`
	MaxReplicas *ConfigUint8ComparisonExp        `json:"maxReplicas,omitempty"`
}

func (exp *ConfigAutoscalerComparisonExp) Matches(o *ConfigAutoscaler) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigAutoscaler{}
	}
	if !exp.MaxReplicas.Matches(o.MaxReplicas) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigClaimMap struct {
	Claim string `json:"claim" toml:"claim"`

	Value *string `json:"value" toml:"value"`

	Path *string `json:"path" toml:"path"`

	Default *string `json:"default" toml:"default"`
}

func (o *ConfigClaimMap) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	m["claim"] = o.Claim
	if o.Value != nil {
		m["value"] = o.Value
	}
	if o.Path != nil {
		m["path"] = o.Path
	}
	if o.Default != nil {
		m["default"] = o.Default
	}
	return json.Marshal(m)
}

func (o *ConfigClaimMap) GetClaim() string {
	if o == nil {
		o = &ConfigClaimMap{}
	}
	return o.Claim
}

func (o *ConfigClaimMap) GetValue() *string {
	if o == nil {
		o = &ConfigClaimMap{}
	}
	return o.Value
}

func (o *ConfigClaimMap) GetPath() *string {
	if o == nil {
		o = &ConfigClaimMap{}
	}
	return o.Path
}

func (o *ConfigClaimMap) GetDefault() *string {
	if o == nil {
		o = &ConfigClaimMap{}
	}
	return o.Default
}

type ConfigClaimMapUpdateInput struct {
	Claim        *string `json:"claim,omitempty" toml:"claim,omitempty"`
	IsSetClaim   bool    `json:"-"`
	Value        *string `json:"value,omitempty" toml:"value,omitempty"`
	IsSetValue   bool    `json:"-"`
	Path         *string `json:"path,omitempty" toml:"path,omitempty"`
	IsSetPath    bool    `json:"-"`
	Default      *string `json:"default,omitempty" toml:"default,omitempty"`
	IsSetDefault bool    `json:"-"`
}

func (o *ConfigClaimMapUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["claim"]; ok {
		if v == nil {
			o.Claim = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Claim = &x
		}
		o.IsSetClaim = true
	}
	if v, ok := m["value"]; ok {
		if v == nil {
			o.Value = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Value = &x
		}
		o.IsSetValue = true
	}
	if v, ok := m["path"]; ok {
		if v == nil {
			o.Path = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Path = &x
		}
		o.IsSetPath = true
	}
	if v, ok := m["default"]; ok {
		if v == nil {
			o.Default = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Default = &x
		}
		o.IsSetDefault = true
	}

	return nil
}

func (o *ConfigClaimMapUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigClaimMapUpdateInput) GetClaim() *string {
	if o == nil {
		o = &ConfigClaimMapUpdateInput{}
	}
	return o.Claim
}

func (o *ConfigClaimMapUpdateInput) GetValue() *string {
	if o == nil {
		o = &ConfigClaimMapUpdateInput{}
	}
	return o.Value
}

func (o *ConfigClaimMapUpdateInput) GetPath() *string {
	if o == nil {
		o = &ConfigClaimMapUpdateInput{}
	}
	return o.Path
}

func (o *ConfigClaimMapUpdateInput) GetDefault() *string {
	if o == nil {
		o = &ConfigClaimMapUpdateInput{}
	}
	return o.Default
}

func (s *ConfigClaimMap) Update(v *ConfigClaimMapUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetClaim || v.Claim != nil {
		if v.Claim != nil {
			s.Claim = *v.Claim
		}
	}
	if v.IsSetValue || v.Value != nil {
		s.Value = v.Value
	}
	if v.IsSetPath || v.Path != nil {
		s.Path = v.Path
	}
	if v.IsSetDefault || v.Default != nil {
		s.Default = v.Default
	}
}

type ConfigClaimMapInsertInput struct {
	Claim   string  `json:"claim,omitempty" toml:"claim,omitempty"`
	Value   *string `json:"value,omitempty" toml:"value,omitempty"`
	Path    *string `json:"path,omitempty" toml:"path,omitempty"`
	Default *string `json:"default,omitempty" toml:"default,omitempty"`
}

func (o *ConfigClaimMapInsertInput) GetClaim() string {
	if o == nil {
		o = &ConfigClaimMapInsertInput{}
	}
	return o.Claim
}

func (o *ConfigClaimMapInsertInput) GetValue() *string {
	if o == nil {
		o = &ConfigClaimMapInsertInput{}
	}
	return o.Value
}

func (o *ConfigClaimMapInsertInput) GetPath() *string {
	if o == nil {
		o = &ConfigClaimMapInsertInput{}
	}
	return o.Path
}

func (o *ConfigClaimMapInsertInput) GetDefault() *string {
	if o == nil {
		o = &ConfigClaimMapInsertInput{}
	}
	return o.Default
}

func (s *ConfigClaimMap) Insert(v *ConfigClaimMapInsertInput) {
	s.Claim = v.Claim
	s.Value = v.Value
	s.Path = v.Path
	s.Default = v.Default
}

func (s *ConfigClaimMap) Clone() *ConfigClaimMap {
	if s == nil {
		return nil
	}

	v := &ConfigClaimMap{}
	v.Claim = s.Claim
	v.Value = s.Value
	v.Path = s.Path
	v.Default = s.Default
	return v
}

type ConfigClaimMapComparisonExp struct {
	And     []*ConfigClaimMapComparisonExp `json:"_and,omitempty"`
	Not     *ConfigClaimMapComparisonExp   `json:"_not,omitempty"`
	Or      []*ConfigClaimMapComparisonExp `json:"_or,omitempty"`
	Claim   *ConfigStringComparisonExp     `json:"claim,omitempty"`
	Value   *ConfigStringComparisonExp     `json:"value,omitempty"`
	Path    *ConfigStringComparisonExp     `json:"path,omitempty"`
	Default *ConfigStringComparisonExp     `json:"default,omitempty"`
}

func (exp *ConfigClaimMapComparisonExp) Matches(o *ConfigClaimMap) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigClaimMap{}
	}
	if !exp.Claim.Matches(o.Claim) {
		return false
	}
	if o.Value != nil && !exp.Value.Matches(*o.Value) {
		return false
	}
	if o.Path != nil && !exp.Path.Matches(*o.Path) {
		return false
	}
	if o.Default != nil && !exp.Default.Matches(*o.Default) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

// Resource configuration for a service
type ConfigComputeResources struct {
	// milicpus, 1000 milicpus = 1 cpu
	Cpu uint32 `json:"cpu" toml:"cpu"`
	// MiB: 128MiB to 30GiB
	Memory uint32 `json:"memory" toml:"memory"`
}

func (o *ConfigComputeResources) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	m["cpu"] = o.Cpu
	m["memory"] = o.Memory
	return json.Marshal(m)
}

func (o *ConfigComputeResources) GetCpu() uint32 {
	if o == nil {
		o = &ConfigComputeResources{}
	}
	return o.Cpu
}

func (o *ConfigComputeResources) GetMemory() uint32 {
	if o == nil {
		o = &ConfigComputeResources{}
	}
	return o.Memory
}

type ConfigComputeResourcesUpdateInput struct {
	Cpu         *uint32 `json:"cpu,omitempty" toml:"cpu,omitempty"`
	IsSetCpu    bool    `json:"-"`
	Memory      *uint32 `json:"memory,omitempty" toml:"memory,omitempty"`
	IsSetMemory bool    `json:"-"`
}

func (o *ConfigComputeResourcesUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["cpu"]; ok {
		if v == nil {
			o.Cpu = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x uint32
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Cpu = &x
		}
		o.IsSetCpu = true
	}
	if v, ok := m["memory"]; ok {
		if v == nil {
			o.Memory = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x uint32
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Memory = &x
		}
		o.IsSetMemory = true
	}

	return nil
}

func (o *ConfigComputeResourcesUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigComputeResourcesUpdateInput) GetCpu() *uint32 {
	if o == nil {
		o = &ConfigComputeResourcesUpdateInput{}
	}
	return o.Cpu
}

func (o *ConfigComputeResourcesUpdateInput) GetMemory() *uint32 {
	if o == nil {
		o = &ConfigComputeResourcesUpdateInput{}
	}
	return o.Memory
}

func (s *ConfigComputeResources) Update(v *ConfigComputeResourcesUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetCpu || v.Cpu != nil {
		if v.Cpu != nil {
			s.Cpu = *v.Cpu
		}
	}
	if v.IsSetMemory || v.Memory != nil {
		if v.Memory != nil {
			s.Memory = *v.Memory
		}
	}
}

type ConfigComputeResourcesInsertInput struct {
	Cpu    uint32 `json:"cpu,omitempty" toml:"cpu,omitempty"`
	Memory uint32 `json:"memory,omitempty" toml:"memory,omitempty"`
}

func (o *ConfigComputeResourcesInsertInput) GetCpu() uint32 {
	if o == nil {
		o = &ConfigComputeResourcesInsertInput{}
	}
	return o.Cpu
}

func (o *ConfigComputeResourcesInsertInput) GetMemory() uint32 {
	if o == nil {
		o = &ConfigComputeResourcesInsertInput{}
	}
	return o.Memory
}

func (s *ConfigComputeResources) Insert(v *ConfigComputeResourcesInsertInput) {
	s.Cpu = v.Cpu
	s.Memory = v.Memory
}

func (s *ConfigComputeResources) Clone() *ConfigComputeResources {
	if s == nil {
		return nil
	}

	v := &ConfigComputeResources{}
	v.Cpu = s.Cpu
	v.Memory = s.Memory
	return v
}

type ConfigComputeResourcesComparisonExp struct {
	And    []*ConfigComputeResourcesComparisonExp `json:"_and,omitempty"`
	Not    *ConfigComputeResourcesComparisonExp   `json:"_not,omitempty"`
	Or     []*ConfigComputeResourcesComparisonExp `json:"_or,omitempty"`
	Cpu    *ConfigUint32ComparisonExp             `json:"cpu,omitempty"`
	Memory *ConfigUint32ComparisonExp             `json:"memory,omitempty"`
}

func (exp *ConfigComputeResourcesComparisonExp) Matches(o *ConfigComputeResources) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigComputeResources{}
	}
	if !exp.Cpu.Matches(o.Cpu) {
		return false
	}
	if !exp.Memory.Matches(o.Memory) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

// main entrypoint to the configuration
type ConfigConfig struct {
	// Global configuration that applies to all services
	Global *ConfigGlobal `json:"global,omitempty" toml:"global,omitempty"`
	// Configuration for hasura
	Hasura *ConfigHasura `json:"hasura,omitempty" toml:"hasura,omitempty"`
	// Advanced configuration for GraphQL
	Graphql *ConfigGraphql `json:"graphql,omitempty" toml:"graphql,omitempty"`
	// Configuration for functions service
	Functions *ConfigFunctions `json:"functions,omitempty" toml:"functions,omitempty"`
	// Configuration for auth service
	Auth *ConfigAuth `json:"auth,omitempty" toml:"auth,omitempty"`
	// Configuration for postgres service
	Postgres *ConfigPostgres `json:"postgres,omitempty" toml:"postgres,omitempty"`
	// Configuration for third party providers like SMTP, SMS, etc.
	Provider *ConfigProvider `json:"provider,omitempty" toml:"provider,omitempty"`
	// Configuration for storage service
	Storage *ConfigStorage `json:"storage,omitempty" toml:"storage,omitempty"`
	// Configuration for graphite service
	Ai *ConfigAI `json:"ai,omitempty" toml:"ai,omitempty"`
	// Configuration for observability service
	Observability *ConfigObservability `json:"observability,omitempty" toml:"observability,omitempty"`
}

func (o *ConfigConfig) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Global != nil {
		m["global"] = o.Global
	}
	if o.Hasura != nil {
		m["hasura"] = o.Hasura
	}
	if o.Graphql != nil {
		m["graphql"] = o.Graphql
	}
	if o.Functions != nil {
		m["functions"] = o.Functions
	}
	if o.Auth != nil {
		m["auth"] = o.Auth
	}
	if o.Postgres != nil {
		m["postgres"] = o.Postgres
	}
	if o.Provider != nil {
		m["provider"] = o.Provider
	}
	if o.Storage != nil {
		m["storage"] = o.Storage
	}
	if o.Ai != nil {
		m["ai"] = o.Ai
	}
	if o.Observability != nil {
		m["observability"] = o.Observability
	}
	return json.Marshal(m)
}

func (o *ConfigConfig) GetGlobal() *ConfigGlobal {
	if o == nil {
		return nil
	}
	return o.Global
}

func (o *ConfigConfig) GetHasura() *ConfigHasura {
	if o == nil {
		return nil
	}
	return o.Hasura
}

func (o *ConfigConfig) GetGraphql() *ConfigGraphql {
	if o == nil {
		return nil
	}
	return o.Graphql
}

func (o *ConfigConfig) GetFunctions() *ConfigFunctions {
	if o == nil {
		return nil
	}
	return o.Functions
}

func (o *ConfigConfig) GetAuth() *ConfigAuth {
	if o == nil {
		return nil
	}
	return o.Auth
}

func (o *ConfigConfig) GetPostgres() *ConfigPostgres {
	if o == nil {
		return nil
	}
	return o.Postgres
}

func (o *ConfigConfig) GetProvider() *ConfigProvider {
	if o == nil {
		return nil
	}
	return o.Provider
}

func (o *ConfigConfig) GetStorage() *ConfigStorage {
	if o == nil {
		return nil
	}
	return o.Storage
}

func (o *ConfigConfig) GetAi() *ConfigAI {
	if o == nil {
		return nil
	}
	return o.Ai
}

func (o *ConfigConfig) GetObservability() *ConfigObservability {
	if o == nil {
		return nil
	}
	return o.Observability
}

type ConfigConfigUpdateInput struct {
	Global             *ConfigGlobalUpdateInput        `json:"global,omitempty" toml:"global,omitempty"`
	IsSetGlobal        bool                            `json:"-"`
	Hasura             *ConfigHasuraUpdateInput        `json:"hasura,omitempty" toml:"hasura,omitempty"`
	IsSetHasura        bool                            `json:"-"`
	Graphql            *ConfigGraphqlUpdateInput       `json:"graphql,omitempty" toml:"graphql,omitempty"`
	IsSetGraphql       bool                            `json:"-"`
	Functions          *ConfigFunctionsUpdateInput     `json:"functions,omitempty" toml:"functions,omitempty"`
	IsSetFunctions     bool                            `json:"-"`
	Auth               *ConfigAuthUpdateInput          `json:"auth,omitempty" toml:"auth,omitempty"`
	IsSetAuth          bool                            `json:"-"`
	Postgres           *ConfigPostgresUpdateInput      `json:"postgres,omitempty" toml:"postgres,omitempty"`
	IsSetPostgres      bool                            `json:"-"`
	Provider           *ConfigProviderUpdateInput      `json:"provider,omitempty" toml:"provider,omitempty"`
	IsSetProvider      bool                            `json:"-"`
	Storage            *ConfigStorageUpdateInput       `json:"storage,omitempty" toml:"storage,omitempty"`
	IsSetStorage       bool                            `json:"-"`
	Ai                 *ConfigAIUpdateInput            `json:"ai,omitempty" toml:"ai,omitempty"`
	IsSetAi            bool                            `json:"-"`
	Observability      *ConfigObservabilityUpdateInput `json:"observability,omitempty" toml:"observability,omitempty"`
	IsSetObservability bool                            `json:"-"`
}

func (o *ConfigConfigUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if x, ok := m["global"]; ok {
		if x != nil {
			t := &ConfigGlobalUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Global = t
		}
		o.IsSetGlobal = true
	}
	if x, ok := m["hasura"]; ok {
		if x != nil {
			t := &ConfigHasuraUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Hasura = t
		}
		o.IsSetHasura = true
	}
	if x, ok := m["graphql"]; ok {
		if x != nil {
			t := &ConfigGraphqlUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Graphql = t
		}
		o.IsSetGraphql = true
	}
	if x, ok := m["functions"]; ok {
		if x != nil {
			t := &ConfigFunctionsUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Functions = t
		}
		o.IsSetFunctions = true
	}
	if x, ok := m["auth"]; ok {
		if x != nil {
			t := &ConfigAuthUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Auth = t
		}
		o.IsSetAuth = true
	}
	if x, ok := m["postgres"]; ok {
		if x != nil {
			t := &ConfigPostgresUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Postgres = t
		}
		o.IsSetPostgres = true
	}
	if x, ok := m["provider"]; ok {
		if x != nil {
			t := &ConfigProviderUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Provider = t
		}
		o.IsSetProvider = true
	}
	if x, ok := m["storage"]; ok {
		if x != nil {
			t := &ConfigStorageUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Storage = t
		}
		o.IsSetStorage = true
	}
	if x, ok := m["ai"]; ok {
		if x != nil {
			t := &ConfigAIUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Ai = t
		}
		o.IsSetAi = true
	}
	if x, ok := m["observability"]; ok {
		if x != nil {
			t := &ConfigObservabilityUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Observability = t
		}
		o.IsSetObservability = true
	}

	return nil
}

func (o *ConfigConfigUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigConfigUpdateInput) GetGlobal() *ConfigGlobalUpdateInput {
	if o == nil {
		return nil
	}
	return o.Global
}

func (o *ConfigConfigUpdateInput) GetHasura() *ConfigHasuraUpdateInput {
	if o == nil {
		return nil
	}
	return o.Hasura
}

func (o *ConfigConfigUpdateInput) GetGraphql() *ConfigGraphqlUpdateInput {
	if o == nil {
		return nil
	}
	return o.Graphql
}

func (o *ConfigConfigUpdateInput) GetFunctions() *ConfigFunctionsUpdateInput {
	if o == nil {
		return nil
	}
	return o.Functions
}

func (o *ConfigConfigUpdateInput) GetAuth() *ConfigAuthUpdateInput {
	if o == nil {
		return nil
	}
	return o.Auth
}

func (o *ConfigConfigUpdateInput) GetPostgres() *ConfigPostgresUpdateInput {
	if o == nil {
		return nil
	}
	return o.Postgres
}

func (o *ConfigConfigUpdateInput) GetProvider() *ConfigProviderUpdateInput {
	if o == nil {
		return nil
	}
	return o.Provider
}

func (o *ConfigConfigUpdateInput) GetStorage() *ConfigStorageUpdateInput {
	if o == nil {
		return nil
	}
	return o.Storage
}

func (o *ConfigConfigUpdateInput) GetAi() *ConfigAIUpdateInput {
	if o == nil {
		return nil
	}
	return o.Ai
}

func (o *ConfigConfigUpdateInput) GetObservability() *ConfigObservabilityUpdateInput {
	if o == nil {
		return nil
	}
	return o.Observability
}

func (s *ConfigConfig) Update(v *ConfigConfigUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetGlobal || v.Global != nil {
		if v.Global == nil {
			s.Global = nil
		} else {
			if s.Global == nil {
				s.Global = &ConfigGlobal{}
			}
			s.Global.Update(v.Global)
		}
	}
	if v.IsSetHasura || v.Hasura != nil {
		if v.Hasura == nil {
			s.Hasura = nil
		} else {
			if s.Hasura == nil {
				s.Hasura = &ConfigHasura{}
			}
			s.Hasura.Update(v.Hasura)
		}
	}
	if v.IsSetGraphql || v.Graphql != nil {
		if v.Graphql == nil {
			s.Graphql = nil
		} else {
			if s.Graphql == nil {
				s.Graphql = &ConfigGraphql{}
			}
			s.Graphql.Update(v.Graphql)
		}
	}
	if v.IsSetFunctions || v.Functions != nil {
		if v.Functions == nil {
			s.Functions = nil
		} else {
			if s.Functions == nil {
				s.Functions = &ConfigFunctions{}
			}
			s.Functions.Update(v.Functions)
		}
	}
	if v.IsSetAuth || v.Auth != nil {
		if v.Auth == nil {
			s.Auth = nil
		} else {
			if s.Auth == nil {
				s.Auth = &ConfigAuth{}
			}
			s.Auth.Update(v.Auth)
		}
	}
	if v.IsSetPostgres || v.Postgres != nil {
		if v.Postgres == nil {
			s.Postgres = nil
		} else {
			if s.Postgres == nil {
				s.Postgres = &ConfigPostgres{}
			}
			s.Postgres.Update(v.Postgres)
		}
	}
	if v.IsSetProvider || v.Provider != nil {
		if v.Provider == nil {
			s.Provider = nil
		} else {
			if s.Provider == nil {
				s.Provider = &ConfigProvider{}
			}
			s.Provider.Update(v.Provider)
		}
	}
	if v.IsSetStorage || v.Storage != nil {
		if v.Storage == nil {
			s.Storage = nil
		} else {
			if s.Storage == nil {
				s.Storage = &ConfigStorage{}
			}
			s.Storage.Update(v.Storage)
		}
	}
	if v.IsSetAi || v.Ai != nil {
		if v.Ai == nil {
			s.Ai = nil
		} else {
			if s.Ai == nil {
				s.Ai = &ConfigAI{}
			}
			s.Ai.Update(v.Ai)
		}
	}
	if v.IsSetObservability || v.Observability != nil {
		if v.Observability == nil {
			s.Observability = nil
		} else {
			if s.Observability == nil {
				s.Observability = &ConfigObservability{}
			}
			s.Observability.Update(v.Observability)
		}
	}
}

type ConfigConfigInsertInput struct {
	Global        *ConfigGlobalInsertInput        `json:"global,omitempty" toml:"global,omitempty"`
	Hasura        *ConfigHasuraInsertInput        `json:"hasura,omitempty" toml:"hasura,omitempty"`
	Graphql       *ConfigGraphqlInsertInput       `json:"graphql,omitempty" toml:"graphql,omitempty"`
	Functions     *ConfigFunctionsInsertInput     `json:"functions,omitempty" toml:"functions,omitempty"`
	Auth          *ConfigAuthInsertInput          `json:"auth,omitempty" toml:"auth,omitempty"`
	Postgres      *ConfigPostgresInsertInput      `json:"postgres,omitempty" toml:"postgres,omitempty"`
	Provider      *ConfigProviderInsertInput      `json:"provider,omitempty" toml:"provider,omitempty"`
	Storage       *ConfigStorageInsertInput       `json:"storage,omitempty" toml:"storage,omitempty"`
	Ai            *ConfigAIInsertInput            `json:"ai,omitempty" toml:"ai,omitempty"`
	Observability *ConfigObservabilityInsertInput `json:"observability,omitempty" toml:"observability,omitempty"`
}

func (o *ConfigConfigInsertInput) GetGlobal() *ConfigGlobalInsertInput {
	if o == nil {
		return nil
	}
	return o.Global
}

func (o *ConfigConfigInsertInput) GetHasura() *ConfigHasuraInsertInput {
	if o == nil {
		return nil
	}
	return o.Hasura
}

func (o *ConfigConfigInsertInput) GetGraphql() *ConfigGraphqlInsertInput {
	if o == nil {
		return nil
	}
	return o.Graphql
}

func (o *ConfigConfigInsertInput) GetFunctions() *ConfigFunctionsInsertInput {
	if o == nil {
		return nil
	}
	return o.Functions
}

func (o *ConfigConfigInsertInput) GetAuth() *ConfigAuthInsertInput {
	if o == nil {
		return nil
	}
	return o.Auth
}

func (o *ConfigConfigInsertInput) GetPostgres() *ConfigPostgresInsertInput {
	if o == nil {
		return nil
	}
	return o.Postgres
}

func (o *ConfigConfigInsertInput) GetProvider() *ConfigProviderInsertInput {
	if o == nil {
		return nil
	}
	return o.Provider
}

func (o *ConfigConfigInsertInput) GetStorage() *ConfigStorageInsertInput {
	if o == nil {
		return nil
	}
	return o.Storage
}

func (o *ConfigConfigInsertInput) GetAi() *ConfigAIInsertInput {
	if o == nil {
		return nil
	}
	return o.Ai
}

func (o *ConfigConfigInsertInput) GetObservability() *ConfigObservabilityInsertInput {
	if o == nil {
		return nil
	}
	return o.Observability
}

func (s *ConfigConfig) Insert(v *ConfigConfigInsertInput) {
	if v.Global != nil {
		if s.Global == nil {
			s.Global = &ConfigGlobal{}
		}
		s.Global.Insert(v.Global)
	}
	if v.Hasura != nil {
		if s.Hasura == nil {
			s.Hasura = &ConfigHasura{}
		}
		s.Hasura.Insert(v.Hasura)
	}
	if v.Graphql != nil {
		if s.Graphql == nil {
			s.Graphql = &ConfigGraphql{}
		}
		s.Graphql.Insert(v.Graphql)
	}
	if v.Functions != nil {
		if s.Functions == nil {
			s.Functions = &ConfigFunctions{}
		}
		s.Functions.Insert(v.Functions)
	}
	if v.Auth != nil {
		if s.Auth == nil {
			s.Auth = &ConfigAuth{}
		}
		s.Auth.Insert(v.Auth)
	}
	if v.Postgres != nil {
		if s.Postgres == nil {
			s.Postgres = &ConfigPostgres{}
		}
		s.Postgres.Insert(v.Postgres)
	}
	if v.Provider != nil {
		if s.Provider == nil {
			s.Provider = &ConfigProvider{}
		}
		s.Provider.Insert(v.Provider)
	}
	if v.Storage != nil {
		if s.Storage == nil {
			s.Storage = &ConfigStorage{}
		}
		s.Storage.Insert(v.Storage)
	}
	if v.Ai != nil {
		if s.Ai == nil {
			s.Ai = &ConfigAI{}
		}
		s.Ai.Insert(v.Ai)
	}
	if v.Observability != nil {
		if s.Observability == nil {
			s.Observability = &ConfigObservability{}
		}
		s.Observability.Insert(v.Observability)
	}
}

func (s *ConfigConfig) Clone() *ConfigConfig {
	if s == nil {
		return nil
	}

	v := &ConfigConfig{}
	v.Global = s.Global.Clone()
	v.Hasura = s.Hasura.Clone()
	v.Graphql = s.Graphql.Clone()
	v.Functions = s.Functions.Clone()
	v.Auth = s.Auth.Clone()
	v.Postgres = s.Postgres.Clone()
	v.Provider = s.Provider.Clone()
	v.Storage = s.Storage.Clone()
	v.Ai = s.Ai.Clone()
	v.Observability = s.Observability.Clone()
	return v
}

type ConfigConfigComparisonExp struct {
	And           []*ConfigConfigComparisonExp      `json:"_and,omitempty"`
	Not           *ConfigConfigComparisonExp        `json:"_not,omitempty"`
	Or            []*ConfigConfigComparisonExp      `json:"_or,omitempty"`
	Global        *ConfigGlobalComparisonExp        `json:"global,omitempty"`
	Hasura        *ConfigHasuraComparisonExp        `json:"hasura,omitempty"`
	Graphql       *ConfigGraphqlComparisonExp       `json:"graphql,omitempty"`
	Functions     *ConfigFunctionsComparisonExp     `json:"functions,omitempty"`
	Auth          *ConfigAuthComparisonExp          `json:"auth,omitempty"`
	Postgres      *ConfigPostgresComparisonExp      `json:"postgres,omitempty"`
	Provider      *ConfigProviderComparisonExp      `json:"provider,omitempty"`
	Storage       *ConfigStorageComparisonExp       `json:"storage,omitempty"`
	Ai            *ConfigAIComparisonExp            `json:"ai,omitempty"`
	Observability *ConfigObservabilityComparisonExp `json:"observability,omitempty"`
}

func (exp *ConfigConfigComparisonExp) Matches(o *ConfigConfig) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigConfig{
			Global:        &ConfigGlobal{},
			Hasura:        &ConfigHasura{},
			Graphql:       &ConfigGraphql{},
			Functions:     &ConfigFunctions{},
			Auth:          &ConfigAuth{},
			Postgres:      &ConfigPostgres{},
			Provider:      &ConfigProvider{},
			Storage:       &ConfigStorage{},
			Ai:            &ConfigAI{},
			Observability: &ConfigObservability{},
		}
	}
	if !exp.Global.Matches(o.Global) {
		return false
	}
	if !exp.Hasura.Matches(o.Hasura) {
		return false
	}
	if !exp.Graphql.Matches(o.Graphql) {
		return false
	}
	if !exp.Functions.Matches(o.Functions) {
		return false
	}
	if !exp.Auth.Matches(o.Auth) {
		return false
	}
	if !exp.Postgres.Matches(o.Postgres) {
		return false
	}
	if !exp.Provider.Matches(o.Provider) {
		return false
	}
	if !exp.Storage.Matches(o.Storage) {
		return false
	}
	if !exp.Ai.Matches(o.Ai) {
		return false
	}
	if !exp.Observability.Matches(o.Observability) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigEmailComparisonExp struct {
	Eq  *string  `json:"_eq,omitempty"`
	Neq *string  `json:"_neq,omitempty"`
	In  []string `json:"_in,omitempty"`
	Nin []string `json:"_nin,omitempty"`
}

func (exp *ConfigEmailComparisonExp) Matches(o string) bool {
	if exp == nil {
		return true
	}

	if exp.Eq != nil && *exp.Eq != o {
		return false
	}

	if exp.Neq != nil && *exp.Neq == o {
		return false
	}

	if exp.In != nil && !contains(exp.In, o) {
		return false
	}

	if exp.Nin != nil && contains(exp.Nin, o) {
		return false
	}

	return true
}

type ConfigEnvironmentVariable struct {
	Name string `json:"name" toml:"name"`
	// Value of the environment variable
	Value string `json:"value" toml:"value"`
}

func (o *ConfigEnvironmentVariable) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	m["name"] = o.Name
	m["value"] = o.Value
	return json.Marshal(m)
}

func (o *ConfigEnvironmentVariable) GetName() string {
	if o == nil {
		o = &ConfigEnvironmentVariable{}
	}
	return o.Name
}

func (o *ConfigEnvironmentVariable) GetValue() string {
	if o == nil {
		o = &ConfigEnvironmentVariable{}
	}
	return o.Value
}

type ConfigEnvironmentVariableUpdateInput struct {
	Name       *string `json:"name,omitempty" toml:"name,omitempty"`
	IsSetName  bool    `json:"-"`
	Value      *string `json:"value,omitempty" toml:"value,omitempty"`
	IsSetValue bool    `json:"-"`
}

func (o *ConfigEnvironmentVariableUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["name"]; ok {
		if v == nil {
			o.Name = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Name = &x
		}
		o.IsSetName = true
	}
	if v, ok := m["value"]; ok {
		if v == nil {
			o.Value = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Value = &x
		}
		o.IsSetValue = true
	}

	return nil
}

func (o *ConfigEnvironmentVariableUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigEnvironmentVariableUpdateInput) GetName() *string {
	if o == nil {
		o = &ConfigEnvironmentVariableUpdateInput{}
	}
	return o.Name
}

func (o *ConfigEnvironmentVariableUpdateInput) GetValue() *string {
	if o == nil {
		o = &ConfigEnvironmentVariableUpdateInput{}
	}
	return o.Value
}

func (s *ConfigEnvironmentVariable) Update(v *ConfigEnvironmentVariableUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetName || v.Name != nil {
		if v.Name != nil {
			s.Name = *v.Name
		}
	}
	if v.IsSetValue || v.Value != nil {
		if v.Value != nil {
			s.Value = *v.Value
		}
	}
}

type ConfigEnvironmentVariableInsertInput struct {
	Name  string `json:"name,omitempty" toml:"name,omitempty"`
	Value string `json:"value,omitempty" toml:"value,omitempty"`
}

func (o *ConfigEnvironmentVariableInsertInput) GetName() string {
	if o == nil {
		o = &ConfigEnvironmentVariableInsertInput{}
	}
	return o.Name
}

func (o *ConfigEnvironmentVariableInsertInput) GetValue() string {
	if o == nil {
		o = &ConfigEnvironmentVariableInsertInput{}
	}
	return o.Value
}

func (s *ConfigEnvironmentVariable) Insert(v *ConfigEnvironmentVariableInsertInput) {
	s.Name = v.Name
	s.Value = v.Value
}

func (s *ConfigEnvironmentVariable) Clone() *ConfigEnvironmentVariable {
	if s == nil {
		return nil
	}

	v := &ConfigEnvironmentVariable{}
	v.Name = s.Name
	v.Value = s.Value
	return v
}

type ConfigEnvironmentVariableComparisonExp struct {
	And   []*ConfigEnvironmentVariableComparisonExp `json:"_and,omitempty"`
	Not   *ConfigEnvironmentVariableComparisonExp   `json:"_not,omitempty"`
	Or    []*ConfigEnvironmentVariableComparisonExp `json:"_or,omitempty"`
	Name  *ConfigStringComparisonExp                `json:"name,omitempty"`
	Value *ConfigStringComparisonExp                `json:"value,omitempty"`
}

func (exp *ConfigEnvironmentVariableComparisonExp) Matches(o *ConfigEnvironmentVariable) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigEnvironmentVariable{}
	}
	if !exp.Name.Matches(o.Name) {
		return false
	}
	if !exp.Value.Matches(o.Value) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

// Configuration for functions service
type ConfigFunctions struct {
	Node *ConfigFunctionsNode `json:"node,omitempty" toml:"node,omitempty"`

	Resources *ConfigFunctionsResources `json:"resources,omitempty" toml:"resources,omitempty"`

	RateLimit *ConfigRateLimit `json:"rateLimit,omitempty" toml:"rateLimit,omitempty"`
}

func (o *ConfigFunctions) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Node != nil {
		m["node"] = o.Node
	}
	if o.Resources != nil {
		m["resources"] = o.Resources
	}
	if o.RateLimit != nil {
		m["rateLimit"] = o.RateLimit
	}
	return json.Marshal(m)
}

func (o *ConfigFunctions) GetNode() *ConfigFunctionsNode {
	if o == nil {
		return nil
	}
	return o.Node
}

func (o *ConfigFunctions) GetResources() *ConfigFunctionsResources {
	if o == nil {
		return nil
	}
	return o.Resources
}

func (o *ConfigFunctions) GetRateLimit() *ConfigRateLimit {
	if o == nil {
		return nil
	}
	return o.RateLimit
}

type ConfigFunctionsUpdateInput struct {
	Node           *ConfigFunctionsNodeUpdateInput      `json:"node,omitempty" toml:"node,omitempty"`
	IsSetNode      bool                                 `json:"-"`
	Resources      *ConfigFunctionsResourcesUpdateInput `json:"resources,omitempty" toml:"resources,omitempty"`
	IsSetResources bool                                 `json:"-"`
	RateLimit      *ConfigRateLimitUpdateInput          `json:"rateLimit,omitempty" toml:"rateLimit,omitempty"`
	IsSetRateLimit bool                                 `json:"-"`
}

func (o *ConfigFunctionsUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if x, ok := m["node"]; ok {
		if x != nil {
			t := &ConfigFunctionsNodeUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Node = t
		}
		o.IsSetNode = true
	}
	if x, ok := m["resources"]; ok {
		if x != nil {
			t := &ConfigFunctionsResourcesUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Resources = t
		}
		o.IsSetResources = true
	}
	if x, ok := m["rateLimit"]; ok {
		if x != nil {
			t := &ConfigRateLimitUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.RateLimit = t
		}
		o.IsSetRateLimit = true
	}

	return nil
}

func (o *ConfigFunctionsUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigFunctionsUpdateInput) GetNode() *ConfigFunctionsNodeUpdateInput {
	if o == nil {
		return nil
	}
	return o.Node
}

func (o *ConfigFunctionsUpdateInput) GetResources() *ConfigFunctionsResourcesUpdateInput {
	if o == nil {
		return nil
	}
	return o.Resources
}

func (o *ConfigFunctionsUpdateInput) GetRateLimit() *ConfigRateLimitUpdateInput {
	if o == nil {
		return nil
	}
	return o.RateLimit
}

func (s *ConfigFunctions) Update(v *ConfigFunctionsUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetNode || v.Node != nil {
		if v.Node == nil {
			s.Node = nil
		} else {
			if s.Node == nil {
				s.Node = &ConfigFunctionsNode{}
			}
			s.Node.Update(v.Node)
		}
	}
	if v.IsSetResources || v.Resources != nil {
		if v.Resources == nil {
			s.Resources = nil
		} else {
			if s.Resources == nil {
				s.Resources = &ConfigFunctionsResources{}
			}
			s.Resources.Update(v.Resources)
		}
	}
	if v.IsSetRateLimit || v.RateLimit != nil {
		if v.RateLimit == nil {
			s.RateLimit = nil
		} else {
			if s.RateLimit == nil {
				s.RateLimit = &ConfigRateLimit{}
			}
			s.RateLimit.Update(v.RateLimit)
		}
	}
}

type ConfigFunctionsInsertInput struct {
	Node      *ConfigFunctionsNodeInsertInput      `json:"node,omitempty" toml:"node,omitempty"`
	Resources *ConfigFunctionsResourcesInsertInput `json:"resources,omitempty" toml:"resources,omitempty"`
	RateLimit *ConfigRateLimitInsertInput          `json:"rateLimit,omitempty" toml:"rateLimit,omitempty"`
}

func (o *ConfigFunctionsInsertInput) GetNode() *ConfigFunctionsNodeInsertInput {
	if o == nil {
		return nil
	}
	return o.Node
}

func (o *ConfigFunctionsInsertInput) GetResources() *ConfigFunctionsResourcesInsertInput {
	if o == nil {
		return nil
	}
	return o.Resources
}

func (o *ConfigFunctionsInsertInput) GetRateLimit() *ConfigRateLimitInsertInput {
	if o == nil {
		return nil
	}
	return o.RateLimit
}

func (s *ConfigFunctions) Insert(v *ConfigFunctionsInsertInput) {
	if v.Node != nil {
		if s.Node == nil {
			s.Node = &ConfigFunctionsNode{}
		}
		s.Node.Insert(v.Node)
	}
	if v.Resources != nil {
		if s.Resources == nil {
			s.Resources = &ConfigFunctionsResources{}
		}
		s.Resources.Insert(v.Resources)
	}
	if v.RateLimit != nil {
		if s.RateLimit == nil {
			s.RateLimit = &ConfigRateLimit{}
		}
		s.RateLimit.Insert(v.RateLimit)
	}
}

func (s *ConfigFunctions) Clone() *ConfigFunctions {
	if s == nil {
		return nil
	}

	v := &ConfigFunctions{}
	v.Node = s.Node.Clone()
	v.Resources = s.Resources.Clone()
	v.RateLimit = s.RateLimit.Clone()
	return v
}

type ConfigFunctionsComparisonExp struct {
	And       []*ConfigFunctionsComparisonExp        `json:"_and,omitempty"`
	Not       *ConfigFunctionsComparisonExp          `json:"_not,omitempty"`
	Or        []*ConfigFunctionsComparisonExp        `json:"_or,omitempty"`
	Node      *ConfigFunctionsNodeComparisonExp      `json:"node,omitempty"`
	Resources *ConfigFunctionsResourcesComparisonExp `json:"resources,omitempty"`
	RateLimit *ConfigRateLimitComparisonExp          `json:"rateLimit,omitempty"`
}

func (exp *ConfigFunctionsComparisonExp) Matches(o *ConfigFunctions) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigFunctions{
			Node:      &ConfigFunctionsNode{},
			Resources: &ConfigFunctionsResources{},
			RateLimit: &ConfigRateLimit{},
		}
	}
	if !exp.Node.Matches(o.Node) {
		return false
	}
	if !exp.Resources.Matches(o.Resources) {
		return false
	}
	if !exp.RateLimit.Matches(o.RateLimit) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigFunctionsNode struct {
	Version *int `json:"version" toml:"version"`
}

func (o *ConfigFunctionsNode) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Version != nil {
		m["version"] = o.Version
	}
	return json.Marshal(m)
}

func (o *ConfigFunctionsNode) GetVersion() *int {
	if o == nil {
		o = &ConfigFunctionsNode{}
	}
	return o.Version
}

type ConfigFunctionsNodeUpdateInput struct {
	Version      *int `json:"version,omitempty" toml:"version,omitempty"`
	IsSetVersion bool `json:"-"`
}

func (o *ConfigFunctionsNodeUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["version"]; ok {
		if v == nil {
			o.Version = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x int
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Version = &x
		}
		o.IsSetVersion = true
	}

	return nil
}

func (o *ConfigFunctionsNodeUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigFunctionsNodeUpdateInput) GetVersion() *int {
	if o == nil {
		o = &ConfigFunctionsNodeUpdateInput{}
	}
	return o.Version
}

func (s *ConfigFunctionsNode) Update(v *ConfigFunctionsNodeUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetVersion || v.Version != nil {
		s.Version = v.Version
	}
}

type ConfigFunctionsNodeInsertInput struct {
	Version *int `json:"version,omitempty" toml:"version,omitempty"`
}

func (o *ConfigFunctionsNodeInsertInput) GetVersion() *int {
	if o == nil {
		o = &ConfigFunctionsNodeInsertInput{}
	}
	return o.Version
}

func (s *ConfigFunctionsNode) Insert(v *ConfigFunctionsNodeInsertInput) {
	s.Version = v.Version
}

func (s *ConfigFunctionsNode) Clone() *ConfigFunctionsNode {
	if s == nil {
		return nil
	}

	v := &ConfigFunctionsNode{}
	v.Version = s.Version
	return v
}

type ConfigFunctionsNodeComparisonExp struct {
	And     []*ConfigFunctionsNodeComparisonExp `json:"_and,omitempty"`
	Not     *ConfigFunctionsNodeComparisonExp   `json:"_not,omitempty"`
	Or      []*ConfigFunctionsNodeComparisonExp `json:"_or,omitempty"`
	Version *ConfigIntComparisonExp             `json:"version,omitempty"`
}

func (exp *ConfigFunctionsNodeComparisonExp) Matches(o *ConfigFunctionsNode) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigFunctionsNode{}
	}
	if o.Version != nil && !exp.Version.Matches(*o.Version) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigFunctionsResources struct {
	Networking *ConfigNetworking `json:"networking,omitempty" toml:"networking,omitempty"`
}

func (o *ConfigFunctionsResources) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Networking != nil {
		m["networking"] = o.Networking
	}
	return json.Marshal(m)
}

func (o *ConfigFunctionsResources) GetNetworking() *ConfigNetworking {
	if o == nil {
		return nil
	}
	return o.Networking
}

type ConfigFunctionsResourcesUpdateInput struct {
	Networking      *ConfigNetworkingUpdateInput `json:"networking,omitempty" toml:"networking,omitempty"`
	IsSetNetworking bool                         `json:"-"`
}

func (o *ConfigFunctionsResourcesUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if x, ok := m["networking"]; ok {
		if x != nil {
			t := &ConfigNetworkingUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Networking = t
		}
		o.IsSetNetworking = true
	}

	return nil
}

func (o *ConfigFunctionsResourcesUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigFunctionsResourcesUpdateInput) GetNetworking() *ConfigNetworkingUpdateInput {
	if o == nil {
		return nil
	}
	return o.Networking
}

func (s *ConfigFunctionsResources) Update(v *ConfigFunctionsResourcesUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetNetworking || v.Networking != nil {
		if v.Networking == nil {
			s.Networking = nil
		} else {
			if s.Networking == nil {
				s.Networking = &ConfigNetworking{}
			}
			s.Networking.Update(v.Networking)
		}
	}
}

type ConfigFunctionsResourcesInsertInput struct {
	Networking *ConfigNetworkingInsertInput `json:"networking,omitempty" toml:"networking,omitempty"`
}

func (o *ConfigFunctionsResourcesInsertInput) GetNetworking() *ConfigNetworkingInsertInput {
	if o == nil {
		return nil
	}
	return o.Networking
}

func (s *ConfigFunctionsResources) Insert(v *ConfigFunctionsResourcesInsertInput) {
	if v.Networking != nil {
		if s.Networking == nil {
			s.Networking = &ConfigNetworking{}
		}
		s.Networking.Insert(v.Networking)
	}
}

func (s *ConfigFunctionsResources) Clone() *ConfigFunctionsResources {
	if s == nil {
		return nil
	}

	v := &ConfigFunctionsResources{}
	v.Networking = s.Networking.Clone()
	return v
}

type ConfigFunctionsResourcesComparisonExp struct {
	And        []*ConfigFunctionsResourcesComparisonExp `json:"_and,omitempty"`
	Not        *ConfigFunctionsResourcesComparisonExp   `json:"_not,omitempty"`
	Or         []*ConfigFunctionsResourcesComparisonExp `json:"_or,omitempty"`
	Networking *ConfigNetworkingComparisonExp           `json:"networking,omitempty"`
}

func (exp *ConfigFunctionsResourcesComparisonExp) Matches(o *ConfigFunctionsResources) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigFunctionsResources{
			Networking: &ConfigNetworking{},
		}
	}
	if !exp.Networking.Matches(o.Networking) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

// Global configuration that applies to all services
type ConfigGlobal struct {
	// User-defined environment variables that are spread over all services
	Environment []*ConfigGlobalEnvironmentVariable `json:"environment,omitempty" toml:"environment,omitempty"`
}

func (o *ConfigGlobal) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Environment != nil {
		m["environment"] = o.Environment
	}
	return json.Marshal(m)
}

func (o *ConfigGlobal) GetEnvironment() []*ConfigGlobalEnvironmentVariable {
	if o == nil {
		o = &ConfigGlobal{}
	}
	return o.Environment
}

type ConfigGlobalUpdateInput struct {
	Environment      []*ConfigGlobalEnvironmentVariableUpdateInput `json:"environment,omitempty" toml:"environment,omitempty"`
	IsSetEnvironment bool                                          `json:"-"`
}

func (o *ConfigGlobalUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["environment"]; ok {
		if v != nil {
			x, ok := v.([]interface{})
			if !ok {
				return fmt.Errorf("Environment must be []interface{}, got %T", v)
			}

			l := make([]*ConfigGlobalEnvironmentVariableUpdateInput, len(x))
			for i, vv := range x {
				t := &ConfigGlobalEnvironmentVariableUpdateInput{}
				if err := t.UnmarshalGQL(vv); err != nil {
					return err
				}
				l[i] = t
			}
			o.Environment = l
		}
		o.IsSetEnvironment = true
	}

	return nil
}

func (o *ConfigGlobalUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigGlobalUpdateInput) GetEnvironment() []*ConfigGlobalEnvironmentVariableUpdateInput {
	if o == nil {
		o = &ConfigGlobalUpdateInput{}
	}
	return o.Environment
}

func (s *ConfigGlobal) Update(v *ConfigGlobalUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetEnvironment || v.Environment != nil {
		if v.Environment == nil {
			s.Environment = nil
		} else {
			s.Environment = make([]*ConfigGlobalEnvironmentVariable, len(v.Environment))
			for i, e := range v.Environment {
				v := &ConfigGlobalEnvironmentVariable{}
				v.Update(e)
				s.Environment[i] = v
			}
		}
	}
}

type ConfigGlobalInsertInput struct {
	Environment []*ConfigGlobalEnvironmentVariableInsertInput `json:"environment,omitempty" toml:"environment,omitempty"`
}

func (o *ConfigGlobalInsertInput) GetEnvironment() []*ConfigGlobalEnvironmentVariableInsertInput {
	if o == nil {
		o = &ConfigGlobalInsertInput{}
	}
	return o.Environment
}

func (s *ConfigGlobal) Insert(v *ConfigGlobalInsertInput) {
	if v.Environment != nil {
		s.Environment = make([]*ConfigGlobalEnvironmentVariable, len(v.Environment))
		for i, e := range v.Environment {
			v := &ConfigGlobalEnvironmentVariable{}
			v.Insert(e)
			s.Environment[i] = v
		}
	}
}

func (s *ConfigGlobal) Clone() *ConfigGlobal {
	if s == nil {
		return nil
	}

	v := &ConfigGlobal{}
	if s.Environment != nil {
		v.Environment = make([]*ConfigGlobalEnvironmentVariable, len(s.Environment))
		for i, e := range s.Environment {
			v.Environment[i] = e.Clone()
		}
	}
	return v
}

type ConfigGlobalComparisonExp struct {
	And         []*ConfigGlobalComparisonExp                  `json:"_and,omitempty"`
	Not         *ConfigGlobalComparisonExp                    `json:"_not,omitempty"`
	Or          []*ConfigGlobalComparisonExp                  `json:"_or,omitempty"`
	Environment *ConfigGlobalEnvironmentVariableComparisonExp `json:"environment,omitempty"`
}

func (exp *ConfigGlobalComparisonExp) Matches(o *ConfigGlobal) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigGlobal{
			Environment: []*ConfigGlobalEnvironmentVariable{},
		}
	}
	{
		found := false
		for _, o := range o.Environment {
			if exp.Environment.Matches(o) {
				found = true
				break
			}
		}
		if !found && exp.Environment != nil {
			return false
		}
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigGlobalEnvironmentVariable struct {
	Name string `json:"name" toml:"name"`
	// Value of the environment variable
	Value string `json:"value" toml:"value"`
}

func (o *ConfigGlobalEnvironmentVariable) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	m["name"] = o.Name
	m["value"] = o.Value
	return json.Marshal(m)
}

func (o *ConfigGlobalEnvironmentVariable) GetName() string {
	if o == nil {
		o = &ConfigGlobalEnvironmentVariable{}
	}
	return o.Name
}

func (o *ConfigGlobalEnvironmentVariable) GetValue() string {
	if o == nil {
		o = &ConfigGlobalEnvironmentVariable{}
	}
	return o.Value
}

type ConfigGlobalEnvironmentVariableUpdateInput struct {
	Name       *string `json:"name,omitempty" toml:"name,omitempty"`
	IsSetName  bool    `json:"-"`
	Value      *string `json:"value,omitempty" toml:"value,omitempty"`
	IsSetValue bool    `json:"-"`
}

func (o *ConfigGlobalEnvironmentVariableUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["name"]; ok {
		if v == nil {
			o.Name = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Name = &x
		}
		o.IsSetName = true
	}
	if v, ok := m["value"]; ok {
		if v == nil {
			o.Value = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Value = &x
		}
		o.IsSetValue = true
	}

	return nil
}

func (o *ConfigGlobalEnvironmentVariableUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigGlobalEnvironmentVariableUpdateInput) GetName() *string {
	if o == nil {
		o = &ConfigGlobalEnvironmentVariableUpdateInput{}
	}
	return o.Name
}

func (o *ConfigGlobalEnvironmentVariableUpdateInput) GetValue() *string {
	if o == nil {
		o = &ConfigGlobalEnvironmentVariableUpdateInput{}
	}
	return o.Value
}

func (s *ConfigGlobalEnvironmentVariable) Update(v *ConfigGlobalEnvironmentVariableUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetName || v.Name != nil {
		if v.Name != nil {
			s.Name = *v.Name
		}
	}
	if v.IsSetValue || v.Value != nil {
		if v.Value != nil {
			s.Value = *v.Value
		}
	}
}

type ConfigGlobalEnvironmentVariableInsertInput struct {
	Name  string `json:"name,omitempty" toml:"name,omitempty"`
	Value string `json:"value,omitempty" toml:"value,omitempty"`
}

func (o *ConfigGlobalEnvironmentVariableInsertInput) GetName() string {
	if o == nil {
		o = &ConfigGlobalEnvironmentVariableInsertInput{}
	}
	return o.Name
}

func (o *ConfigGlobalEnvironmentVariableInsertInput) GetValue() string {
	if o == nil {
		o = &ConfigGlobalEnvironmentVariableInsertInput{}
	}
	return o.Value
}

func (s *ConfigGlobalEnvironmentVariable) Insert(v *ConfigGlobalEnvironmentVariableInsertInput) {
	s.Name = v.Name
	s.Value = v.Value
}

func (s *ConfigGlobalEnvironmentVariable) Clone() *ConfigGlobalEnvironmentVariable {
	if s == nil {
		return nil
	}

	v := &ConfigGlobalEnvironmentVariable{}
	v.Name = s.Name
	v.Value = s.Value
	return v
}

type ConfigGlobalEnvironmentVariableComparisonExp struct {
	And   []*ConfigGlobalEnvironmentVariableComparisonExp `json:"_and,omitempty"`
	Not   *ConfigGlobalEnvironmentVariableComparisonExp   `json:"_not,omitempty"`
	Or    []*ConfigGlobalEnvironmentVariableComparisonExp `json:"_or,omitempty"`
	Name  *ConfigStringComparisonExp                      `json:"name,omitempty"`
	Value *ConfigStringComparisonExp                      `json:"value,omitempty"`
}

func (exp *ConfigGlobalEnvironmentVariableComparisonExp) Matches(o *ConfigGlobalEnvironmentVariable) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigGlobalEnvironmentVariable{}
	}
	if !exp.Name.Matches(o.Name) {
		return false
	}
	if !exp.Value.Matches(o.Value) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigGrafana struct {
	AdminPassword string `json:"adminPassword" toml:"adminPassword"`

	Smtp *ConfigGrafanaSmtp `json:"smtp,omitempty" toml:"smtp,omitempty"`

	Alerting *ConfigGrafanaAlerting `json:"alerting,omitempty" toml:"alerting,omitempty"`

	Contacts *ConfigGrafanaContacts `json:"contacts,omitempty" toml:"contacts,omitempty"`
}

func (o *ConfigGrafana) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	m["adminPassword"] = o.AdminPassword
	if o.Smtp != nil {
		m["smtp"] = o.Smtp
	}
	if o.Alerting != nil {
		m["alerting"] = o.Alerting
	}
	if o.Contacts != nil {
		m["contacts"] = o.Contacts
	}
	return json.Marshal(m)
}

func (o *ConfigGrafana) GetAdminPassword() string {
	if o == nil {
		o = &ConfigGrafana{}
	}
	return o.AdminPassword
}

func (o *ConfigGrafana) GetSmtp() *ConfigGrafanaSmtp {
	if o == nil {
		return nil
	}
	return o.Smtp
}

func (o *ConfigGrafana) GetAlerting() *ConfigGrafanaAlerting {
	if o == nil {
		return nil
	}
	return o.Alerting
}

func (o *ConfigGrafana) GetContacts() *ConfigGrafanaContacts {
	if o == nil {
		return nil
	}
	return o.Contacts
}

type ConfigGrafanaUpdateInput struct {
	AdminPassword      *string                           `json:"adminPassword,omitempty" toml:"adminPassword,omitempty"`
	IsSetAdminPassword bool                              `json:"-"`
	Smtp               *ConfigGrafanaSmtpUpdateInput     `json:"smtp,omitempty" toml:"smtp,omitempty"`
	IsSetSmtp          bool                              `json:"-"`
	Alerting           *ConfigGrafanaAlertingUpdateInput `json:"alerting,omitempty" toml:"alerting,omitempty"`
	IsSetAlerting      bool                              `json:"-"`
	Contacts           *ConfigGrafanaContactsUpdateInput `json:"contacts,omitempty" toml:"contacts,omitempty"`
	IsSetContacts      bool                              `json:"-"`
}

func (o *ConfigGrafanaUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["adminPassword"]; ok {
		if v == nil {
			o.AdminPassword = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.AdminPassword = &x
		}
		o.IsSetAdminPassword = true
	}
	if x, ok := m["smtp"]; ok {
		if x != nil {
			t := &ConfigGrafanaSmtpUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Smtp = t
		}
		o.IsSetSmtp = true
	}
	if x, ok := m["alerting"]; ok {
		if x != nil {
			t := &ConfigGrafanaAlertingUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Alerting = t
		}
		o.IsSetAlerting = true
	}
	if x, ok := m["contacts"]; ok {
		if x != nil {
			t := &ConfigGrafanaContactsUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Contacts = t
		}
		o.IsSetContacts = true
	}

	return nil
}

func (o *ConfigGrafanaUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigGrafanaUpdateInput) GetAdminPassword() *string {
	if o == nil {
		o = &ConfigGrafanaUpdateInput{}
	}
	return o.AdminPassword
}

func (o *ConfigGrafanaUpdateInput) GetSmtp() *ConfigGrafanaSmtpUpdateInput {
	if o == nil {
		return nil
	}
	return o.Smtp
}

func (o *ConfigGrafanaUpdateInput) GetAlerting() *ConfigGrafanaAlertingUpdateInput {
	if o == nil {
		return nil
	}
	return o.Alerting
}

func (o *ConfigGrafanaUpdateInput) GetContacts() *ConfigGrafanaContactsUpdateInput {
	if o == nil {
		return nil
	}
	return o.Contacts
}

func (s *ConfigGrafana) Update(v *ConfigGrafanaUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetAdminPassword || v.AdminPassword != nil {
		if v.AdminPassword != nil {
			s.AdminPassword = *v.AdminPassword
		}
	}
	if v.IsSetSmtp || v.Smtp != nil {
		if v.Smtp == nil {
			s.Smtp = nil
		} else {
			if s.Smtp == nil {
				s.Smtp = &ConfigGrafanaSmtp{}
			}
			s.Smtp.Update(v.Smtp)
		}
	}
	if v.IsSetAlerting || v.Alerting != nil {
		if v.Alerting == nil {
			s.Alerting = nil
		} else {
			if s.Alerting == nil {
				s.Alerting = &ConfigGrafanaAlerting{}
			}
			s.Alerting.Update(v.Alerting)
		}
	}
	if v.IsSetContacts || v.Contacts != nil {
		if v.Contacts == nil {
			s.Contacts = nil
		} else {
			if s.Contacts == nil {
				s.Contacts = &ConfigGrafanaContacts{}
			}
			s.Contacts.Update(v.Contacts)
		}
	}
}

type ConfigGrafanaInsertInput struct {
	AdminPassword string                            `json:"adminPassword,omitempty" toml:"adminPassword,omitempty"`
	Smtp          *ConfigGrafanaSmtpInsertInput     `json:"smtp,omitempty" toml:"smtp,omitempty"`
	Alerting      *ConfigGrafanaAlertingInsertInput `json:"alerting,omitempty" toml:"alerting,omitempty"`
	Contacts      *ConfigGrafanaContactsInsertInput `json:"contacts,omitempty" toml:"contacts,omitempty"`
}

func (o *ConfigGrafanaInsertInput) GetAdminPassword() string {
	if o == nil {
		o = &ConfigGrafanaInsertInput{}
	}
	return o.AdminPassword
}

func (o *ConfigGrafanaInsertInput) GetSmtp() *ConfigGrafanaSmtpInsertInput {
	if o == nil {
		return nil
	}
	return o.Smtp
}

func (o *ConfigGrafanaInsertInput) GetAlerting() *ConfigGrafanaAlertingInsertInput {
	if o == nil {
		return nil
	}
	return o.Alerting
}

func (o *ConfigGrafanaInsertInput) GetContacts() *ConfigGrafanaContactsInsertInput {
	if o == nil {
		return nil
	}
	return o.Contacts
}

func (s *ConfigGrafana) Insert(v *ConfigGrafanaInsertInput) {
	s.AdminPassword = v.AdminPassword
	if v.Smtp != nil {
		if s.Smtp == nil {
			s.Smtp = &ConfigGrafanaSmtp{}
		}
		s.Smtp.Insert(v.Smtp)
	}
	if v.Alerting != nil {
		if s.Alerting == nil {
			s.Alerting = &ConfigGrafanaAlerting{}
		}
		s.Alerting.Insert(v.Alerting)
	}
	if v.Contacts != nil {
		if s.Contacts == nil {
			s.Contacts = &ConfigGrafanaContacts{}
		}
		s.Contacts.Insert(v.Contacts)
	}
}

func (s *ConfigGrafana) Clone() *ConfigGrafana {
	if s == nil {
		return nil
	}

	v := &ConfigGrafana{}
	v.AdminPassword = s.AdminPassword
	v.Smtp = s.Smtp.Clone()
	v.Alerting = s.Alerting.Clone()
	v.Contacts = s.Contacts.Clone()
	return v
}

type ConfigGrafanaComparisonExp struct {
	And           []*ConfigGrafanaComparisonExp       `json:"_and,omitempty"`
	Not           *ConfigGrafanaComparisonExp         `json:"_not,omitempty"`
	Or            []*ConfigGrafanaComparisonExp       `json:"_or,omitempty"`
	AdminPassword *ConfigStringComparisonExp          `json:"adminPassword,omitempty"`
	Smtp          *ConfigGrafanaSmtpComparisonExp     `json:"smtp,omitempty"`
	Alerting      *ConfigGrafanaAlertingComparisonExp `json:"alerting,omitempty"`
	Contacts      *ConfigGrafanaContactsComparisonExp `json:"contacts,omitempty"`
}

func (exp *ConfigGrafanaComparisonExp) Matches(o *ConfigGrafana) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigGrafana{
			Smtp:     &ConfigGrafanaSmtp{},
			Alerting: &ConfigGrafanaAlerting{},
			Contacts: &ConfigGrafanaContacts{},
		}
	}
	if !exp.AdminPassword.Matches(o.AdminPassword) {
		return false
	}
	if !exp.Smtp.Matches(o.Smtp) {
		return false
	}
	if !exp.Alerting.Matches(o.Alerting) {
		return false
	}
	if !exp.Contacts.Matches(o.Contacts) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigGrafanaAlerting struct {
	Enabled *bool `json:"enabled" toml:"enabled"`
}

func (o *ConfigGrafanaAlerting) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Enabled != nil {
		m["enabled"] = o.Enabled
	}
	return json.Marshal(m)
}

func (o *ConfigGrafanaAlerting) GetEnabled() *bool {
	if o == nil {
		o = &ConfigGrafanaAlerting{}
	}
	return o.Enabled
}

type ConfigGrafanaAlertingUpdateInput struct {
	Enabled      *bool `json:"enabled,omitempty" toml:"enabled,omitempty"`
	IsSetEnabled bool  `json:"-"`
}

func (o *ConfigGrafanaAlertingUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["enabled"]; ok {
		if v == nil {
			o.Enabled = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x bool
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Enabled = &x
		}
		o.IsSetEnabled = true
	}

	return nil
}

func (o *ConfigGrafanaAlertingUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigGrafanaAlertingUpdateInput) GetEnabled() *bool {
	if o == nil {
		o = &ConfigGrafanaAlertingUpdateInput{}
	}
	return o.Enabled
}

func (s *ConfigGrafanaAlerting) Update(v *ConfigGrafanaAlertingUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetEnabled || v.Enabled != nil {
		s.Enabled = v.Enabled
	}
}

type ConfigGrafanaAlertingInsertInput struct {
	Enabled *bool `json:"enabled,omitempty" toml:"enabled,omitempty"`
}

func (o *ConfigGrafanaAlertingInsertInput) GetEnabled() *bool {
	if o == nil {
		o = &ConfigGrafanaAlertingInsertInput{}
	}
	return o.Enabled
}

func (s *ConfigGrafanaAlerting) Insert(v *ConfigGrafanaAlertingInsertInput) {
	s.Enabled = v.Enabled
}

func (s *ConfigGrafanaAlerting) Clone() *ConfigGrafanaAlerting {
	if s == nil {
		return nil
	}

	v := &ConfigGrafanaAlerting{}
	v.Enabled = s.Enabled
	return v
}

type ConfigGrafanaAlertingComparisonExp struct {
	And     []*ConfigGrafanaAlertingComparisonExp `json:"_and,omitempty"`
	Not     *ConfigGrafanaAlertingComparisonExp   `json:"_not,omitempty"`
	Or      []*ConfigGrafanaAlertingComparisonExp `json:"_or,omitempty"`
	Enabled *ConfigBooleanComparisonExp           `json:"enabled,omitempty"`
}

func (exp *ConfigGrafanaAlertingComparisonExp) Matches(o *ConfigGrafanaAlerting) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigGrafanaAlerting{}
	}
	if o.Enabled != nil && !exp.Enabled.Matches(*o.Enabled) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigGrafanaContacts struct {
	Emails []string `json:"emails,omitempty" toml:"emails,omitempty"`

	Pagerduty []*ConfigGrafanacontactsPagerduty `json:"pagerduty,omitempty" toml:"pagerduty,omitempty"`

	Discord []*ConfigGrafanacontactsDiscord `json:"discord,omitempty" toml:"discord,omitempty"`

	Slack []*ConfigGrafanacontactsSlack `json:"slack,omitempty" toml:"slack,omitempty"`

	Webhook []*ConfigGrafanacontactsWebhook `json:"webhook,omitempty" toml:"webhook,omitempty"`
}

func (o *ConfigGrafanaContacts) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Emails != nil {
		m["emails"] = o.Emails
	}
	if o.Pagerduty != nil {
		m["pagerduty"] = o.Pagerduty
	}
	if o.Discord != nil {
		m["discord"] = o.Discord
	}
	if o.Slack != nil {
		m["slack"] = o.Slack
	}
	if o.Webhook != nil {
		m["webhook"] = o.Webhook
	}
	return json.Marshal(m)
}

func (o *ConfigGrafanaContacts) GetEmails() []string {
	if o == nil {
		o = &ConfigGrafanaContacts{}
	}
	return o.Emails
}

func (o *ConfigGrafanaContacts) GetPagerduty() []*ConfigGrafanacontactsPagerduty {
	if o == nil {
		o = &ConfigGrafanaContacts{}
	}
	return o.Pagerduty
}

func (o *ConfigGrafanaContacts) GetDiscord() []*ConfigGrafanacontactsDiscord {
	if o == nil {
		o = &ConfigGrafanaContacts{}
	}
	return o.Discord
}

func (o *ConfigGrafanaContacts) GetSlack() []*ConfigGrafanacontactsSlack {
	if o == nil {
		o = &ConfigGrafanaContacts{}
	}
	return o.Slack
}

func (o *ConfigGrafanaContacts) GetWebhook() []*ConfigGrafanacontactsWebhook {
	if o == nil {
		o = &ConfigGrafanaContacts{}
	}
	return o.Webhook
}

type ConfigGrafanaContactsUpdateInput struct {
	Emails         []string                                     `json:"emails,omitempty" toml:"emails,omitempty"`
	IsSetEmails    bool                                         `json:"-"`
	Pagerduty      []*ConfigGrafanacontactsPagerdutyUpdateInput `json:"pagerduty,omitempty" toml:"pagerduty,omitempty"`
	IsSetPagerduty bool                                         `json:"-"`
	Discord        []*ConfigGrafanacontactsDiscordUpdateInput   `json:"discord,omitempty" toml:"discord,omitempty"`
	IsSetDiscord   bool                                         `json:"-"`
	Slack          []*ConfigGrafanacontactsSlackUpdateInput     `json:"slack,omitempty" toml:"slack,omitempty"`
	IsSetSlack     bool                                         `json:"-"`
	Webhook        []*ConfigGrafanacontactsWebhookUpdateInput   `json:"webhook,omitempty" toml:"webhook,omitempty"`
	IsSetWebhook   bool                                         `json:"-"`
}

func (o *ConfigGrafanaContactsUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["emails"]; ok {
		if v != nil {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var l []string
			if err := json.Unmarshal(b, &l); err != nil {
				return err
			}
			o.Emails = l
		}
		o.IsSetEmails = true
	}
	if v, ok := m["pagerduty"]; ok {
		if v != nil {
			x, ok := v.([]interface{})
			if !ok {
				return fmt.Errorf("Pagerduty must be []interface{}, got %T", v)
			}

			l := make([]*ConfigGrafanacontactsPagerdutyUpdateInput, len(x))
			for i, vv := range x {
				t := &ConfigGrafanacontactsPagerdutyUpdateInput{}
				if err := t.UnmarshalGQL(vv); err != nil {
					return err
				}
				l[i] = t
			}
			o.Pagerduty = l
		}
		o.IsSetPagerduty = true
	}
	if v, ok := m["discord"]; ok {
		if v != nil {
			x, ok := v.([]interface{})
			if !ok {
				return fmt.Errorf("Discord must be []interface{}, got %T", v)
			}

			l := make([]*ConfigGrafanacontactsDiscordUpdateInput, len(x))
			for i, vv := range x {
				t := &ConfigGrafanacontactsDiscordUpdateInput{}
				if err := t.UnmarshalGQL(vv); err != nil {
					return err
				}
				l[i] = t
			}
			o.Discord = l
		}
		o.IsSetDiscord = true
	}
	if v, ok := m["slack"]; ok {
		if v != nil {
			x, ok := v.([]interface{})
			if !ok {
				return fmt.Errorf("Slack must be []interface{}, got %T", v)
			}

			l := make([]*ConfigGrafanacontactsSlackUpdateInput, len(x))
			for i, vv := range x {
				t := &ConfigGrafanacontactsSlackUpdateInput{}
				if err := t.UnmarshalGQL(vv); err != nil {
					return err
				}
				l[i] = t
			}
			o.Slack = l
		}
		o.IsSetSlack = true
	}
	if v, ok := m["webhook"]; ok {
		if v != nil {
			x, ok := v.([]interface{})
			if !ok {
				return fmt.Errorf("Webhook must be []interface{}, got %T", v)
			}

			l := make([]*ConfigGrafanacontactsWebhookUpdateInput, len(x))
			for i, vv := range x {
				t := &ConfigGrafanacontactsWebhookUpdateInput{}
				if err := t.UnmarshalGQL(vv); err != nil {
					return err
				}
				l[i] = t
			}
			o.Webhook = l
		}
		o.IsSetWebhook = true
	}

	return nil
}

func (o *ConfigGrafanaContactsUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigGrafanaContactsUpdateInput) GetEmails() []string {
	if o == nil {
		o = &ConfigGrafanaContactsUpdateInput{}
	}
	return o.Emails
}

func (o *ConfigGrafanaContactsUpdateInput) GetPagerduty() []*ConfigGrafanacontactsPagerdutyUpdateInput {
	if o == nil {
		o = &ConfigGrafanaContactsUpdateInput{}
	}
	return o.Pagerduty
}

func (o *ConfigGrafanaContactsUpdateInput) GetDiscord() []*ConfigGrafanacontactsDiscordUpdateInput {
	if o == nil {
		o = &ConfigGrafanaContactsUpdateInput{}
	}
	return o.Discord
}

func (o *ConfigGrafanaContactsUpdateInput) GetSlack() []*ConfigGrafanacontactsSlackUpdateInput {
	if o == nil {
		o = &ConfigGrafanaContactsUpdateInput{}
	}
	return o.Slack
}

func (o *ConfigGrafanaContactsUpdateInput) GetWebhook() []*ConfigGrafanacontactsWebhookUpdateInput {
	if o == nil {
		o = &ConfigGrafanaContactsUpdateInput{}
	}
	return o.Webhook
}

func (s *ConfigGrafanaContacts) Update(v *ConfigGrafanaContactsUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetEmails || v.Emails != nil {
		if v.Emails == nil {
			s.Emails = nil
		} else {
			s.Emails = make([]string, len(v.Emails))
			for i, e := range v.Emails {
				s.Emails[i] = e
			}
		}
	}
	if v.IsSetPagerduty || v.Pagerduty != nil {
		if v.Pagerduty == nil {
			s.Pagerduty = nil
		} else {
			s.Pagerduty = make([]*ConfigGrafanacontactsPagerduty, len(v.Pagerduty))
			for i, e := range v.Pagerduty {
				v := &ConfigGrafanacontactsPagerduty{}
				v.Update(e)
				s.Pagerduty[i] = v
			}
		}
	}
	if v.IsSetDiscord || v.Discord != nil {
		if v.Discord == nil {
			s.Discord = nil
		} else {
			s.Discord = make([]*ConfigGrafanacontactsDiscord, len(v.Discord))
			for i, e := range v.Discord {
				v := &ConfigGrafanacontactsDiscord{}
				v.Update(e)
				s.Discord[i] = v
			}
		}
	}
	if v.IsSetSlack || v.Slack != nil {
		if v.Slack == nil {
			s.Slack = nil
		} else {
			s.Slack = make([]*ConfigGrafanacontactsSlack, len(v.Slack))
			for i, e := range v.Slack {
				v := &ConfigGrafanacontactsSlack{}
				v.Update(e)
				s.Slack[i] = v
			}
		}
	}
	if v.IsSetWebhook || v.Webhook != nil {
		if v.Webhook == nil {
			s.Webhook = nil
		} else {
			s.Webhook = make([]*ConfigGrafanacontactsWebhook, len(v.Webhook))
			for i, e := range v.Webhook {
				v := &ConfigGrafanacontactsWebhook{}
				v.Update(e)
				s.Webhook[i] = v
			}
		}
	}
}

type ConfigGrafanaContactsInsertInput struct {
	Emails    []string                                     `json:"emails,omitempty" toml:"emails,omitempty"`
	Pagerduty []*ConfigGrafanacontactsPagerdutyInsertInput `json:"pagerduty,omitempty" toml:"pagerduty,omitempty"`
	Discord   []*ConfigGrafanacontactsDiscordInsertInput   `json:"discord,omitempty" toml:"discord,omitempty"`
	Slack     []*ConfigGrafanacontactsSlackInsertInput     `json:"slack,omitempty" toml:"slack,omitempty"`
	Webhook   []*ConfigGrafanacontactsWebhookInsertInput   `json:"webhook,omitempty" toml:"webhook,omitempty"`
}

func (o *ConfigGrafanaContactsInsertInput) GetEmails() []string {
	if o == nil {
		o = &ConfigGrafanaContactsInsertInput{}
	}
	return o.Emails
}

func (o *ConfigGrafanaContactsInsertInput) GetPagerduty() []*ConfigGrafanacontactsPagerdutyInsertInput {
	if o == nil {
		o = &ConfigGrafanaContactsInsertInput{}
	}
	return o.Pagerduty
}

func (o *ConfigGrafanaContactsInsertInput) GetDiscord() []*ConfigGrafanacontactsDiscordInsertInput {
	if o == nil {
		o = &ConfigGrafanaContactsInsertInput{}
	}
	return o.Discord
}

func (o *ConfigGrafanaContactsInsertInput) GetSlack() []*ConfigGrafanacontactsSlackInsertInput {
	if o == nil {
		o = &ConfigGrafanaContactsInsertInput{}
	}
	return o.Slack
}

func (o *ConfigGrafanaContactsInsertInput) GetWebhook() []*ConfigGrafanacontactsWebhookInsertInput {
	if o == nil {
		o = &ConfigGrafanaContactsInsertInput{}
	}
	return o.Webhook
}

func (s *ConfigGrafanaContacts) Insert(v *ConfigGrafanaContactsInsertInput) {
	if v.Emails != nil {
		s.Emails = make([]string, len(v.Emails))
		for i, e := range v.Emails {
			s.Emails[i] = e
		}
	}
	if v.Pagerduty != nil {
		s.Pagerduty = make([]*ConfigGrafanacontactsPagerduty, len(v.Pagerduty))
		for i, e := range v.Pagerduty {
			v := &ConfigGrafanacontactsPagerduty{}
			v.Insert(e)
			s.Pagerduty[i] = v
		}
	}
	if v.Discord != nil {
		s.Discord = make([]*ConfigGrafanacontactsDiscord, len(v.Discord))
		for i, e := range v.Discord {
			v := &ConfigGrafanacontactsDiscord{}
			v.Insert(e)
			s.Discord[i] = v
		}
	}
	if v.Slack != nil {
		s.Slack = make([]*ConfigGrafanacontactsSlack, len(v.Slack))
		for i, e := range v.Slack {
			v := &ConfigGrafanacontactsSlack{}
			v.Insert(e)
			s.Slack[i] = v
		}
	}
	if v.Webhook != nil {
		s.Webhook = make([]*ConfigGrafanacontactsWebhook, len(v.Webhook))
		for i, e := range v.Webhook {
			v := &ConfigGrafanacontactsWebhook{}
			v.Insert(e)
			s.Webhook[i] = v
		}
	}
}

func (s *ConfigGrafanaContacts) Clone() *ConfigGrafanaContacts {
	if s == nil {
		return nil
	}

	v := &ConfigGrafanaContacts{}
	if s.Emails != nil {
		v.Emails = make([]string, len(s.Emails))
		copy(v.Emails, s.Emails)
	}
	if s.Pagerduty != nil {
		v.Pagerduty = make([]*ConfigGrafanacontactsPagerduty, len(s.Pagerduty))
		for i, e := range s.Pagerduty {
			v.Pagerduty[i] = e.Clone()
		}
	}
	if s.Discord != nil {
		v.Discord = make([]*ConfigGrafanacontactsDiscord, len(s.Discord))
		for i, e := range s.Discord {
			v.Discord[i] = e.Clone()
		}
	}
	if s.Slack != nil {
		v.Slack = make([]*ConfigGrafanacontactsSlack, len(s.Slack))
		for i, e := range s.Slack {
			v.Slack[i] = e.Clone()
		}
	}
	if s.Webhook != nil {
		v.Webhook = make([]*ConfigGrafanacontactsWebhook, len(s.Webhook))
		for i, e := range s.Webhook {
			v.Webhook[i] = e.Clone()
		}
	}
	return v
}

type ConfigGrafanaContactsComparisonExp struct {
	And       []*ConfigGrafanaContactsComparisonExp        `json:"_and,omitempty"`
	Not       *ConfigGrafanaContactsComparisonExp          `json:"_not,omitempty"`
	Or        []*ConfigGrafanaContactsComparisonExp        `json:"_or,omitempty"`
	Emails    *ConfigStringComparisonExp                   `json:"emails,omitempty"`
	Pagerduty *ConfigGrafanacontactsPagerdutyComparisonExp `json:"pagerduty,omitempty"`
	Discord   *ConfigGrafanacontactsDiscordComparisonExp   `json:"discord,omitempty"`
	Slack     *ConfigGrafanacontactsSlackComparisonExp     `json:"slack,omitempty"`
	Webhook   *ConfigGrafanacontactsWebhookComparisonExp   `json:"webhook,omitempty"`
}

func (exp *ConfigGrafanaContactsComparisonExp) Matches(o *ConfigGrafanaContacts) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigGrafanaContacts{
			Emails:    []string{},
			Pagerduty: []*ConfigGrafanacontactsPagerduty{},
			Discord:   []*ConfigGrafanacontactsDiscord{},
			Slack:     []*ConfigGrafanacontactsSlack{},
			Webhook:   []*ConfigGrafanacontactsWebhook{},
		}
	}
	{
		found := false
		for _, o := range o.Emails {
			if exp.Emails.Matches(o) {
				found = true
				break
			}
		}
		if !found && exp.Emails != nil {
			return false
		}
	}
	{
		found := false
		for _, o := range o.Pagerduty {
			if exp.Pagerduty.Matches(o) {
				found = true
				break
			}
		}
		if !found && exp.Pagerduty != nil {
			return false
		}
	}
	{
		found := false
		for _, o := range o.Discord {
			if exp.Discord.Matches(o) {
				found = true
				break
			}
		}
		if !found && exp.Discord != nil {
			return false
		}
	}
	{
		found := false
		for _, o := range o.Slack {
			if exp.Slack.Matches(o) {
				found = true
				break
			}
		}
		if !found && exp.Slack != nil {
			return false
		}
	}
	{
		found := false
		for _, o := range o.Webhook {
			if exp.Webhook.Matches(o) {
				found = true
				break
			}
		}
		if !found && exp.Webhook != nil {
			return false
		}
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigGrafanaSmtp struct {
	Host string `json:"host" toml:"host"`

	Port uint16 `json:"port" toml:"port"`

	Sender string `json:"sender" toml:"sender"`

	User string `json:"user" toml:"user"`

	Password string `json:"password" toml:"password"`
}

func (o *ConfigGrafanaSmtp) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	m["host"] = o.Host
	m["port"] = o.Port
	m["sender"] = o.Sender
	m["user"] = o.User
	m["password"] = o.Password
	return json.Marshal(m)
}

func (o *ConfigGrafanaSmtp) GetHost() string {
	if o == nil {
		o = &ConfigGrafanaSmtp{}
	}
	return o.Host
}

func (o *ConfigGrafanaSmtp) GetPort() uint16 {
	if o == nil {
		o = &ConfigGrafanaSmtp{}
	}
	return o.Port
}

func (o *ConfigGrafanaSmtp) GetSender() string {
	if o == nil {
		o = &ConfigGrafanaSmtp{}
	}
	return o.Sender
}

func (o *ConfigGrafanaSmtp) GetUser() string {
	if o == nil {
		o = &ConfigGrafanaSmtp{}
	}
	return o.User
}

func (o *ConfigGrafanaSmtp) GetPassword() string {
	if o == nil {
		o = &ConfigGrafanaSmtp{}
	}
	return o.Password
}

type ConfigGrafanaSmtpUpdateInput struct {
	Host          *string `json:"host,omitempty" toml:"host,omitempty"`
	IsSetHost     bool    `json:"-"`
	Port          *uint16 `json:"port,omitempty" toml:"port,omitempty"`
	IsSetPort     bool    `json:"-"`
	Sender        *string `json:"sender,omitempty" toml:"sender,omitempty"`
	IsSetSender   bool    `json:"-"`
	User          *string `json:"user,omitempty" toml:"user,omitempty"`
	IsSetUser     bool    `json:"-"`
	Password      *string `json:"password,omitempty" toml:"password,omitempty"`
	IsSetPassword bool    `json:"-"`
}

func (o *ConfigGrafanaSmtpUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["host"]; ok {
		if v == nil {
			o.Host = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Host = &x
		}
		o.IsSetHost = true
	}
	if v, ok := m["port"]; ok {
		if v == nil {
			o.Port = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x uint16
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Port = &x
		}
		o.IsSetPort = true
	}
	if v, ok := m["sender"]; ok {
		if v == nil {
			o.Sender = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Sender = &x
		}
		o.IsSetSender = true
	}
	if v, ok := m["user"]; ok {
		if v == nil {
			o.User = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.User = &x
		}
		o.IsSetUser = true
	}
	if v, ok := m["password"]; ok {
		if v == nil {
			o.Password = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Password = &x
		}
		o.IsSetPassword = true
	}

	return nil
}

func (o *ConfigGrafanaSmtpUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigGrafanaSmtpUpdateInput) GetHost() *string {
	if o == nil {
		o = &ConfigGrafanaSmtpUpdateInput{}
	}
	return o.Host
}

func (o *ConfigGrafanaSmtpUpdateInput) GetPort() *uint16 {
	if o == nil {
		o = &ConfigGrafanaSmtpUpdateInput{}
	}
	return o.Port
}

func (o *ConfigGrafanaSmtpUpdateInput) GetSender() *string {
	if o == nil {
		o = &ConfigGrafanaSmtpUpdateInput{}
	}
	return o.Sender
}

func (o *ConfigGrafanaSmtpUpdateInput) GetUser() *string {
	if o == nil {
		o = &ConfigGrafanaSmtpUpdateInput{}
	}
	return o.User
}

func (o *ConfigGrafanaSmtpUpdateInput) GetPassword() *string {
	if o == nil {
		o = &ConfigGrafanaSmtpUpdateInput{}
	}
	return o.Password
}

func (s *ConfigGrafanaSmtp) Update(v *ConfigGrafanaSmtpUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetHost || v.Host != nil {
		if v.Host != nil {
			s.Host = *v.Host
		}
	}
	if v.IsSetPort || v.Port != nil {
		if v.Port != nil {
			s.Port = *v.Port
		}
	}
	if v.IsSetSender || v.Sender != nil {
		if v.Sender != nil {
			s.Sender = *v.Sender
		}
	}
	if v.IsSetUser || v.User != nil {
		if v.User != nil {
			s.User = *v.User
		}
	}
	if v.IsSetPassword || v.Password != nil {
		if v.Password != nil {
			s.Password = *v.Password
		}
	}
}

type ConfigGrafanaSmtpInsertInput struct {
	Host     string `json:"host,omitempty" toml:"host,omitempty"`
	Port     uint16 `json:"port,omitempty" toml:"port,omitempty"`
	Sender   string `json:"sender,omitempty" toml:"sender,omitempty"`
	User     string `json:"user,omitempty" toml:"user,omitempty"`
	Password string `json:"password,omitempty" toml:"password,omitempty"`
}

func (o *ConfigGrafanaSmtpInsertInput) GetHost() string {
	if o == nil {
		o = &ConfigGrafanaSmtpInsertInput{}
	}
	return o.Host
}

func (o *ConfigGrafanaSmtpInsertInput) GetPort() uint16 {
	if o == nil {
		o = &ConfigGrafanaSmtpInsertInput{}
	}
	return o.Port
}

func (o *ConfigGrafanaSmtpInsertInput) GetSender() string {
	if o == nil {
		o = &ConfigGrafanaSmtpInsertInput{}
	}
	return o.Sender
}

func (o *ConfigGrafanaSmtpInsertInput) GetUser() string {
	if o == nil {
		o = &ConfigGrafanaSmtpInsertInput{}
	}
	return o.User
}

func (o *ConfigGrafanaSmtpInsertInput) GetPassword() string {
	if o == nil {
		o = &ConfigGrafanaSmtpInsertInput{}
	}
	return o.Password
}

func (s *ConfigGrafanaSmtp) Insert(v *ConfigGrafanaSmtpInsertInput) {
	s.Host = v.Host
	s.Port = v.Port
	s.Sender = v.Sender
	s.User = v.User
	s.Password = v.Password
}

func (s *ConfigGrafanaSmtp) Clone() *ConfigGrafanaSmtp {
	if s == nil {
		return nil
	}

	v := &ConfigGrafanaSmtp{}
	v.Host = s.Host
	v.Port = s.Port
	v.Sender = s.Sender
	v.User = s.User
	v.Password = s.Password
	return v
}

type ConfigGrafanaSmtpComparisonExp struct {
	And      []*ConfigGrafanaSmtpComparisonExp `json:"_and,omitempty"`
	Not      *ConfigGrafanaSmtpComparisonExp   `json:"_not,omitempty"`
	Or       []*ConfigGrafanaSmtpComparisonExp `json:"_or,omitempty"`
	Host     *ConfigStringComparisonExp        `json:"host,omitempty"`
	Port     *ConfigPortComparisonExp          `json:"port,omitempty"`
	Sender   *ConfigStringComparisonExp        `json:"sender,omitempty"`
	User     *ConfigStringComparisonExp        `json:"user,omitempty"`
	Password *ConfigStringComparisonExp        `json:"password,omitempty"`
}

func (exp *ConfigGrafanaSmtpComparisonExp) Matches(o *ConfigGrafanaSmtp) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigGrafanaSmtp{}
	}
	if !exp.Host.Matches(o.Host) {
		return false
	}
	if !exp.Port.Matches(o.Port) {
		return false
	}
	if !exp.Sender.Matches(o.Sender) {
		return false
	}
	if !exp.User.Matches(o.User) {
		return false
	}
	if !exp.Password.Matches(o.Password) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigGrafanacontactsDiscord struct {
	Url string `json:"url" toml:"url"`

	AvatarUrl string `json:"avatarUrl" toml:"avatarUrl"`
}

func (o *ConfigGrafanacontactsDiscord) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	m["url"] = o.Url
	m["avatarUrl"] = o.AvatarUrl
	return json.Marshal(m)
}

func (o *ConfigGrafanacontactsDiscord) GetUrl() string {
	if o == nil {
		o = &ConfigGrafanacontactsDiscord{}
	}
	return o.Url
}

func (o *ConfigGrafanacontactsDiscord) GetAvatarUrl() string {
	if o == nil {
		o = &ConfigGrafanacontactsDiscord{}
	}
	return o.AvatarUrl
}

type ConfigGrafanacontactsDiscordUpdateInput struct {
	Url            *string `json:"url,omitempty" toml:"url,omitempty"`
	IsSetUrl       bool    `json:"-"`
	AvatarUrl      *string `json:"avatarUrl,omitempty" toml:"avatarUrl,omitempty"`
	IsSetAvatarUrl bool    `json:"-"`
}

func (o *ConfigGrafanacontactsDiscordUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["url"]; ok {
		if v == nil {
			o.Url = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Url = &x
		}
		o.IsSetUrl = true
	}
	if v, ok := m["avatarUrl"]; ok {
		if v == nil {
			o.AvatarUrl = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.AvatarUrl = &x
		}
		o.IsSetAvatarUrl = true
	}

	return nil
}

func (o *ConfigGrafanacontactsDiscordUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigGrafanacontactsDiscordUpdateInput) GetUrl() *string {
	if o == nil {
		o = &ConfigGrafanacontactsDiscordUpdateInput{}
	}
	return o.Url
}

func (o *ConfigGrafanacontactsDiscordUpdateInput) GetAvatarUrl() *string {
	if o == nil {
		o = &ConfigGrafanacontactsDiscordUpdateInput{}
	}
	return o.AvatarUrl
}

func (s *ConfigGrafanacontactsDiscord) Update(v *ConfigGrafanacontactsDiscordUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetUrl || v.Url != nil {
		if v.Url != nil {
			s.Url = *v.Url
		}
	}
	if v.IsSetAvatarUrl || v.AvatarUrl != nil {
		if v.AvatarUrl != nil {
			s.AvatarUrl = *v.AvatarUrl
		}
	}
}

type ConfigGrafanacontactsDiscordInsertInput struct {
	Url       string `json:"url,omitempty" toml:"url,omitempty"`
	AvatarUrl string `json:"avatarUrl,omitempty" toml:"avatarUrl,omitempty"`
}

func (o *ConfigGrafanacontactsDiscordInsertInput) GetUrl() string {
	if o == nil {
		o = &ConfigGrafanacontactsDiscordInsertInput{}
	}
	return o.Url
}

func (o *ConfigGrafanacontactsDiscordInsertInput) GetAvatarUrl() string {
	if o == nil {
		o = &ConfigGrafanacontactsDiscordInsertInput{}
	}
	return o.AvatarUrl
}

func (s *ConfigGrafanacontactsDiscord) Insert(v *ConfigGrafanacontactsDiscordInsertInput) {
	s.Url = v.Url
	s.AvatarUrl = v.AvatarUrl
}

func (s *ConfigGrafanacontactsDiscord) Clone() *ConfigGrafanacontactsDiscord {
	if s == nil {
		return nil
	}

	v := &ConfigGrafanacontactsDiscord{}
	v.Url = s.Url
	v.AvatarUrl = s.AvatarUrl
	return v
}

type ConfigGrafanacontactsDiscordComparisonExp struct {
	And       []*ConfigGrafanacontactsDiscordComparisonExp `json:"_and,omitempty"`
	Not       *ConfigGrafanacontactsDiscordComparisonExp   `json:"_not,omitempty"`
	Or        []*ConfigGrafanacontactsDiscordComparisonExp `json:"_or,omitempty"`
	Url       *ConfigStringComparisonExp                   `json:"url,omitempty"`
	AvatarUrl *ConfigStringComparisonExp                   `json:"avatarUrl,omitempty"`
}

func (exp *ConfigGrafanacontactsDiscordComparisonExp) Matches(o *ConfigGrafanacontactsDiscord) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigGrafanacontactsDiscord{}
	}
	if !exp.Url.Matches(o.Url) {
		return false
	}
	if !exp.AvatarUrl.Matches(o.AvatarUrl) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigGrafanacontactsPagerduty struct {
	IntegrationKey string `json:"integrationKey" toml:"integrationKey"`

	Severity string `json:"severity" toml:"severity"`

	Class string `json:"class" toml:"class"`

	Component string `json:"component" toml:"component"`

	Group string `json:"group" toml:"group"`
}

func (o *ConfigGrafanacontactsPagerduty) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	m["integrationKey"] = o.IntegrationKey
	m["severity"] = o.Severity
	m["class"] = o.Class
	m["component"] = o.Component
	m["group"] = o.Group
	return json.Marshal(m)
}

func (o *ConfigGrafanacontactsPagerduty) GetIntegrationKey() string {
	if o == nil {
		o = &ConfigGrafanacontactsPagerduty{}
	}
	return o.IntegrationKey
}

func (o *ConfigGrafanacontactsPagerduty) GetSeverity() string {
	if o == nil {
		o = &ConfigGrafanacontactsPagerduty{}
	}
	return o.Severity
}

func (o *ConfigGrafanacontactsPagerduty) GetClass() string {
	if o == nil {
		o = &ConfigGrafanacontactsPagerduty{}
	}
	return o.Class
}

func (o *ConfigGrafanacontactsPagerduty) GetComponent() string {
	if o == nil {
		o = &ConfigGrafanacontactsPagerduty{}
	}
	return o.Component
}

func (o *ConfigGrafanacontactsPagerduty) GetGroup() string {
	if o == nil {
		o = &ConfigGrafanacontactsPagerduty{}
	}
	return o.Group
}

type ConfigGrafanacontactsPagerdutyUpdateInput struct {
	IntegrationKey      *string `json:"integrationKey,omitempty" toml:"integrationKey,omitempty"`
	IsSetIntegrationKey bool    `json:"-"`
	Severity            *string `json:"severity,omitempty" toml:"severity,omitempty"`
	IsSetSeverity       bool    `json:"-"`
	Class               *string `json:"class,omitempty" toml:"class,omitempty"`
	IsSetClass          bool    `json:"-"`
	Component           *string `json:"component,omitempty" toml:"component,omitempty"`
	IsSetComponent      bool    `json:"-"`
	Group               *string `json:"group,omitempty" toml:"group,omitempty"`
	IsSetGroup          bool    `json:"-"`
}

func (o *ConfigGrafanacontactsPagerdutyUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["integrationKey"]; ok {
		if v == nil {
			o.IntegrationKey = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.IntegrationKey = &x
		}
		o.IsSetIntegrationKey = true
	}
	if v, ok := m["severity"]; ok {
		if v == nil {
			o.Severity = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Severity = &x
		}
		o.IsSetSeverity = true
	}
	if v, ok := m["class"]; ok {
		if v == nil {
			o.Class = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Class = &x
		}
		o.IsSetClass = true
	}
	if v, ok := m["component"]; ok {
		if v == nil {
			o.Component = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Component = &x
		}
		o.IsSetComponent = true
	}
	if v, ok := m["group"]; ok {
		if v == nil {
			o.Group = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Group = &x
		}
		o.IsSetGroup = true
	}

	return nil
}

func (o *ConfigGrafanacontactsPagerdutyUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigGrafanacontactsPagerdutyUpdateInput) GetIntegrationKey() *string {
	if o == nil {
		o = &ConfigGrafanacontactsPagerdutyUpdateInput{}
	}
	return o.IntegrationKey
}

func (o *ConfigGrafanacontactsPagerdutyUpdateInput) GetSeverity() *string {
	if o == nil {
		o = &ConfigGrafanacontactsPagerdutyUpdateInput{}
	}
	return o.Severity
}

func (o *ConfigGrafanacontactsPagerdutyUpdateInput) GetClass() *string {
	if o == nil {
		o = &ConfigGrafanacontactsPagerdutyUpdateInput{}
	}
	return o.Class
}

func (o *ConfigGrafanacontactsPagerdutyUpdateInput) GetComponent() *string {
	if o == nil {
		o = &ConfigGrafanacontactsPagerdutyUpdateInput{}
	}
	return o.Component
}

func (o *ConfigGrafanacontactsPagerdutyUpdateInput) GetGroup() *string {
	if o == nil {
		o = &ConfigGrafanacontactsPagerdutyUpdateInput{}
	}
	return o.Group
}

func (s *ConfigGrafanacontactsPagerduty) Update(v *ConfigGrafanacontactsPagerdutyUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetIntegrationKey || v.IntegrationKey != nil {
		if v.IntegrationKey != nil {
			s.IntegrationKey = *v.IntegrationKey
		}
	}
	if v.IsSetSeverity || v.Severity != nil {
		if v.Severity != nil {
			s.Severity = *v.Severity
		}
	}
	if v.IsSetClass || v.Class != nil {
		if v.Class != nil {
			s.Class = *v.Class
		}
	}
	if v.IsSetComponent || v.Component != nil {
		if v.Component != nil {
			s.Component = *v.Component
		}
	}
	if v.IsSetGroup || v.Group != nil {
		if v.Group != nil {
			s.Group = *v.Group
		}
	}
}

type ConfigGrafanacontactsPagerdutyInsertInput struct {
	IntegrationKey string `json:"integrationKey,omitempty" toml:"integrationKey,omitempty"`
	Severity       string `json:"severity,omitempty" toml:"severity,omitempty"`
	Class          string `json:"class,omitempty" toml:"class,omitempty"`
	Component      string `json:"component,omitempty" toml:"component,omitempty"`
	Group          string `json:"group,omitempty" toml:"group,omitempty"`
}

func (o *ConfigGrafanacontactsPagerdutyInsertInput) GetIntegrationKey() string {
	if o == nil {
		o = &ConfigGrafanacontactsPagerdutyInsertInput{}
	}
	return o.IntegrationKey
}

func (o *ConfigGrafanacontactsPagerdutyInsertInput) GetSeverity() string {
	if o == nil {
		o = &ConfigGrafanacontactsPagerdutyInsertInput{}
	}
	return o.Severity
}

func (o *ConfigGrafanacontactsPagerdutyInsertInput) GetClass() string {
	if o == nil {
		o = &ConfigGrafanacontactsPagerdutyInsertInput{}
	}
	return o.Class
}

func (o *ConfigGrafanacontactsPagerdutyInsertInput) GetComponent() string {
	if o == nil {
		o = &ConfigGrafanacontactsPagerdutyInsertInput{}
	}
	return o.Component
}

func (o *ConfigGrafanacontactsPagerdutyInsertInput) GetGroup() string {
	if o == nil {
		o = &ConfigGrafanacontactsPagerdutyInsertInput{}
	}
	return o.Group
}

func (s *ConfigGrafanacontactsPagerduty) Insert(v *ConfigGrafanacontactsPagerdutyInsertInput) {
	s.IntegrationKey = v.IntegrationKey
	s.Severity = v.Severity
	s.Class = v.Class
	s.Component = v.Component
	s.Group = v.Group
}

func (s *ConfigGrafanacontactsPagerduty) Clone() *ConfigGrafanacontactsPagerduty {
	if s == nil {
		return nil
	}

	v := &ConfigGrafanacontactsPagerduty{}
	v.IntegrationKey = s.IntegrationKey
	v.Severity = s.Severity
	v.Class = s.Class
	v.Component = s.Component
	v.Group = s.Group
	return v
}

type ConfigGrafanacontactsPagerdutyComparisonExp struct {
	And            []*ConfigGrafanacontactsPagerdutyComparisonExp `json:"_and,omitempty"`
	Not            *ConfigGrafanacontactsPagerdutyComparisonExp   `json:"_not,omitempty"`
	Or             []*ConfigGrafanacontactsPagerdutyComparisonExp `json:"_or,omitempty"`
	IntegrationKey *ConfigStringComparisonExp                     `json:"integrationKey,omitempty"`
	Severity       *ConfigStringComparisonExp                     `json:"severity,omitempty"`
	Class          *ConfigStringComparisonExp                     `json:"class,omitempty"`
	Component      *ConfigStringComparisonExp                     `json:"component,omitempty"`
	Group          *ConfigStringComparisonExp                     `json:"group,omitempty"`
}

func (exp *ConfigGrafanacontactsPagerdutyComparisonExp) Matches(o *ConfigGrafanacontactsPagerduty) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigGrafanacontactsPagerduty{}
	}
	if !exp.IntegrationKey.Matches(o.IntegrationKey) {
		return false
	}
	if !exp.Severity.Matches(o.Severity) {
		return false
	}
	if !exp.Class.Matches(o.Class) {
		return false
	}
	if !exp.Component.Matches(o.Component) {
		return false
	}
	if !exp.Group.Matches(o.Group) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigGrafanacontactsSlack struct {
	Recipient string `json:"recipient" toml:"recipient"`

	Token string `json:"token" toml:"token"`

	Username string `json:"username" toml:"username"`

	IconEmoji string `json:"iconEmoji" toml:"iconEmoji"`

	IconURL string `json:"iconURL" toml:"iconURL"`

	MentionUsers []string `json:"mentionUsers,omitempty" toml:"mentionUsers,omitempty"`

	MentionGroups []string `json:"mentionGroups,omitempty" toml:"mentionGroups,omitempty"`

	MentionChannel string `json:"mentionChannel" toml:"mentionChannel"`

	Url string `json:"url" toml:"url"`

	EndpointURL string `json:"endpointURL" toml:"endpointURL"`
}

func (o *ConfigGrafanacontactsSlack) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	m["recipient"] = o.Recipient
	m["token"] = o.Token
	m["username"] = o.Username
	m["iconEmoji"] = o.IconEmoji
	m["iconURL"] = o.IconURL
	if o.MentionUsers != nil {
		m["mentionUsers"] = o.MentionUsers
	}
	if o.MentionGroups != nil {
		m["mentionGroups"] = o.MentionGroups
	}
	m["mentionChannel"] = o.MentionChannel
	m["url"] = o.Url
	m["endpointURL"] = o.EndpointURL
	return json.Marshal(m)
}

func (o *ConfigGrafanacontactsSlack) GetRecipient() string {
	if o == nil {
		o = &ConfigGrafanacontactsSlack{}
	}
	return o.Recipient
}

func (o *ConfigGrafanacontactsSlack) GetToken() string {
	if o == nil {
		o = &ConfigGrafanacontactsSlack{}
	}
	return o.Token
}

func (o *ConfigGrafanacontactsSlack) GetUsername() string {
	if o == nil {
		o = &ConfigGrafanacontactsSlack{}
	}
	return o.Username
}

func (o *ConfigGrafanacontactsSlack) GetIconEmoji() string {
	if o == nil {
		o = &ConfigGrafanacontactsSlack{}
	}
	return o.IconEmoji
}

func (o *ConfigGrafanacontactsSlack) GetIconURL() string {
	if o == nil {
		o = &ConfigGrafanacontactsSlack{}
	}
	return o.IconURL
}

func (o *ConfigGrafanacontactsSlack) GetMentionUsers() []string {
	if o == nil {
		o = &ConfigGrafanacontactsSlack{}
	}
	return o.MentionUsers
}

func (o *ConfigGrafanacontactsSlack) GetMentionGroups() []string {
	if o == nil {
		o = &ConfigGrafanacontactsSlack{}
	}
	return o.MentionGroups
}

func (o *ConfigGrafanacontactsSlack) GetMentionChannel() string {
	if o == nil {
		o = &ConfigGrafanacontactsSlack{}
	}
	return o.MentionChannel
}

func (o *ConfigGrafanacontactsSlack) GetUrl() string {
	if o == nil {
		o = &ConfigGrafanacontactsSlack{}
	}
	return o.Url
}

func (o *ConfigGrafanacontactsSlack) GetEndpointURL() string {
	if o == nil {
		o = &ConfigGrafanacontactsSlack{}
	}
	return o.EndpointURL
}

type ConfigGrafanacontactsSlackUpdateInput struct {
	Recipient           *string  `json:"recipient,omitempty" toml:"recipient,omitempty"`
	IsSetRecipient      bool     `json:"-"`
	Token               *string  `json:"token,omitempty" toml:"token,omitempty"`
	IsSetToken          bool     `json:"-"`
	Username            *string  `json:"username,omitempty" toml:"username,omitempty"`
	IsSetUsername       bool     `json:"-"`
	IconEmoji           *string  `json:"iconEmoji,omitempty" toml:"iconEmoji,omitempty"`
	IsSetIconEmoji      bool     `json:"-"`
	IconURL             *string  `json:"iconURL,omitempty" toml:"iconURL,omitempty"`
	IsSetIconURL        bool     `json:"-"`
	MentionUsers        []string `json:"mentionUsers,omitempty" toml:"mentionUsers,omitempty"`
	IsSetMentionUsers   bool     `json:"-"`
	MentionGroups       []string `json:"mentionGroups,omitempty" toml:"mentionGroups,omitempty"`
	IsSetMentionGroups  bool     `json:"-"`
	MentionChannel      *string  `json:"mentionChannel,omitempty" toml:"mentionChannel,omitempty"`
	IsSetMentionChannel bool     `json:"-"`
	Url                 *string  `json:"url,omitempty" toml:"url,omitempty"`
	IsSetUrl            bool     `json:"-"`
	EndpointURL         *string  `json:"endpointURL,omitempty" toml:"endpointURL,omitempty"`
	IsSetEndpointURL    bool     `json:"-"`
}

func (o *ConfigGrafanacontactsSlackUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["recipient"]; ok {
		if v == nil {
			o.Recipient = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Recipient = &x
		}
		o.IsSetRecipient = true
	}
	if v, ok := m["token"]; ok {
		if v == nil {
			o.Token = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Token = &x
		}
		o.IsSetToken = true
	}
	if v, ok := m["username"]; ok {
		if v == nil {
			o.Username = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Username = &x
		}
		o.IsSetUsername = true
	}
	if v, ok := m["iconEmoji"]; ok {
		if v == nil {
			o.IconEmoji = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.IconEmoji = &x
		}
		o.IsSetIconEmoji = true
	}
	if v, ok := m["iconURL"]; ok {
		if v == nil {
			o.IconURL = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.IconURL = &x
		}
		o.IsSetIconURL = true
	}
	if v, ok := m["mentionUsers"]; ok {
		if v != nil {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var l []string
			if err := json.Unmarshal(b, &l); err != nil {
				return err
			}
			o.MentionUsers = l
		}
		o.IsSetMentionUsers = true
	}
	if v, ok := m["mentionGroups"]; ok {
		if v != nil {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var l []string
			if err := json.Unmarshal(b, &l); err != nil {
				return err
			}
			o.MentionGroups = l
		}
		o.IsSetMentionGroups = true
	}
	if v, ok := m["mentionChannel"]; ok {
		if v == nil {
			o.MentionChannel = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.MentionChannel = &x
		}
		o.IsSetMentionChannel = true
	}
	if v, ok := m["url"]; ok {
		if v == nil {
			o.Url = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Url = &x
		}
		o.IsSetUrl = true
	}
	if v, ok := m["endpointURL"]; ok {
		if v == nil {
			o.EndpointURL = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.EndpointURL = &x
		}
		o.IsSetEndpointURL = true
	}

	return nil
}

func (o *ConfigGrafanacontactsSlackUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigGrafanacontactsSlackUpdateInput) GetRecipient() *string {
	if o == nil {
		o = &ConfigGrafanacontactsSlackUpdateInput{}
	}
	return o.Recipient
}

func (o *ConfigGrafanacontactsSlackUpdateInput) GetToken() *string {
	if o == nil {
		o = &ConfigGrafanacontactsSlackUpdateInput{}
	}
	return o.Token
}

func (o *ConfigGrafanacontactsSlackUpdateInput) GetUsername() *string {
	if o == nil {
		o = &ConfigGrafanacontactsSlackUpdateInput{}
	}
	return o.Username
}

func (o *ConfigGrafanacontactsSlackUpdateInput) GetIconEmoji() *string {
	if o == nil {
		o = &ConfigGrafanacontactsSlackUpdateInput{}
	}
	return o.IconEmoji
}

func (o *ConfigGrafanacontactsSlackUpdateInput) GetIconURL() *string {
	if o == nil {
		o = &ConfigGrafanacontactsSlackUpdateInput{}
	}
	return o.IconURL
}

func (o *ConfigGrafanacontactsSlackUpdateInput) GetMentionUsers() []string {
	if o == nil {
		o = &ConfigGrafanacontactsSlackUpdateInput{}
	}
	return o.MentionUsers
}

func (o *ConfigGrafanacontactsSlackUpdateInput) GetMentionGroups() []string {
	if o == nil {
		o = &ConfigGrafanacontactsSlackUpdateInput{}
	}
	return o.MentionGroups
}

func (o *ConfigGrafanacontactsSlackUpdateInput) GetMentionChannel() *string {
	if o == nil {
		o = &ConfigGrafanacontactsSlackUpdateInput{}
	}
	return o.MentionChannel
}

func (o *ConfigGrafanacontactsSlackUpdateInput) GetUrl() *string {
	if o == nil {
		o = &ConfigGrafanacontactsSlackUpdateInput{}
	}
	return o.Url
}

func (o *ConfigGrafanacontactsSlackUpdateInput) GetEndpointURL() *string {
	if o == nil {
		o = &ConfigGrafanacontactsSlackUpdateInput{}
	}
	return o.EndpointURL
}

func (s *ConfigGrafanacontactsSlack) Update(v *ConfigGrafanacontactsSlackUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetRecipient || v.Recipient != nil {
		if v.Recipient != nil {
			s.Recipient = *v.Recipient
		}
	}
	if v.IsSetToken || v.Token != nil {
		if v.Token != nil {
			s.Token = *v.Token
		}
	}
	if v.IsSetUsername || v.Username != nil {
		if v.Username != nil {
			s.Username = *v.Username
		}
	}
	if v.IsSetIconEmoji || v.IconEmoji != nil {
		if v.IconEmoji != nil {
			s.IconEmoji = *v.IconEmoji
		}
	}
	if v.IsSetIconURL || v.IconURL != nil {
		if v.IconURL != nil {
			s.IconURL = *v.IconURL
		}
	}
	if v.IsSetMentionUsers || v.MentionUsers != nil {
		if v.MentionUsers == nil {
			s.MentionUsers = nil
		} else {
			s.MentionUsers = make([]string, len(v.MentionUsers))
			for i, e := range v.MentionUsers {
				s.MentionUsers[i] = e
			}
		}
	}
	if v.IsSetMentionGroups || v.MentionGroups != nil {
		if v.MentionGroups == nil {
			s.MentionGroups = nil
		} else {
			s.MentionGroups = make([]string, len(v.MentionGroups))
			for i, e := range v.MentionGroups {
				s.MentionGroups[i] = e
			}
		}
	}
	if v.IsSetMentionChannel || v.MentionChannel != nil {
		if v.MentionChannel != nil {
			s.MentionChannel = *v.MentionChannel
		}
	}
	if v.IsSetUrl || v.Url != nil {
		if v.Url != nil {
			s.Url = *v.Url
		}
	}
	if v.IsSetEndpointURL || v.EndpointURL != nil {
		if v.EndpointURL != nil {
			s.EndpointURL = *v.EndpointURL
		}
	}
}

type ConfigGrafanacontactsSlackInsertInput struct {
	Recipient      string   `json:"recipient,omitempty" toml:"recipient,omitempty"`
	Token          string   `json:"token,omitempty" toml:"token,omitempty"`
	Username       string   `json:"username,omitempty" toml:"username,omitempty"`
	IconEmoji      string   `json:"iconEmoji,omitempty" toml:"iconEmoji,omitempty"`
	IconURL        string   `json:"iconURL,omitempty" toml:"iconURL,omitempty"`
	MentionUsers   []string `json:"mentionUsers,omitempty" toml:"mentionUsers,omitempty"`
	MentionGroups  []string `json:"mentionGroups,omitempty" toml:"mentionGroups,omitempty"`
	MentionChannel string   `json:"mentionChannel,omitempty" toml:"mentionChannel,omitempty"`
	Url            string   `json:"url,omitempty" toml:"url,omitempty"`
	EndpointURL    string   `json:"endpointURL,omitempty" toml:"endpointURL,omitempty"`
}

func (o *ConfigGrafanacontactsSlackInsertInput) GetRecipient() string {
	if o == nil {
		o = &ConfigGrafanacontactsSlackInsertInput{}
	}
	return o.Recipient
}

func (o *ConfigGrafanacontactsSlackInsertInput) GetToken() string {
	if o == nil {
		o = &ConfigGrafanacontactsSlackInsertInput{}
	}
	return o.Token
}

func (o *ConfigGrafanacontactsSlackInsertInput) GetUsername() string {
	if o == nil {
		o = &ConfigGrafanacontactsSlackInsertInput{}
	}
	return o.Username
}

func (o *ConfigGrafanacontactsSlackInsertInput) GetIconEmoji() string {
	if o == nil {
		o = &ConfigGrafanacontactsSlackInsertInput{}
	}
	return o.IconEmoji
}

func (o *ConfigGrafanacontactsSlackInsertInput) GetIconURL() string {
	if o == nil {
		o = &ConfigGrafanacontactsSlackInsertInput{}
	}
	return o.IconURL
}

func (o *ConfigGrafanacontactsSlackInsertInput) GetMentionUsers() []string {
	if o == nil {
		o = &ConfigGrafanacontactsSlackInsertInput{}
	}
	return o.MentionUsers
}

func (o *ConfigGrafanacontactsSlackInsertInput) GetMentionGroups() []string {
	if o == nil {
		o = &ConfigGrafanacontactsSlackInsertInput{}
	}
	return o.MentionGroups
}

func (o *ConfigGrafanacontactsSlackInsertInput) GetMentionChannel() string {
	if o == nil {
		o = &ConfigGrafanacontactsSlackInsertInput{}
	}
	return o.MentionChannel
}

func (o *ConfigGrafanacontactsSlackInsertInput) GetUrl() string {
	if o == nil {
		o = &ConfigGrafanacontactsSlackInsertInput{}
	}
	return o.Url
}

func (o *ConfigGrafanacontactsSlackInsertInput) GetEndpointURL() string {
	if o == nil {
		o = &ConfigGrafanacontactsSlackInsertInput{}
	}
	return o.EndpointURL
}

func (s *ConfigGrafanacontactsSlack) Insert(v *ConfigGrafanacontactsSlackInsertInput) {
	s.Recipient = v.Recipient
	s.Token = v.Token
	s.Username = v.Username
	s.IconEmoji = v.IconEmoji
	s.IconURL = v.IconURL
	if v.MentionUsers != nil {
		s.MentionUsers = make([]string, len(v.MentionUsers))
		for i, e := range v.MentionUsers {
			s.MentionUsers[i] = e
		}
	}
	if v.MentionGroups != nil {
		s.MentionGroups = make([]string, len(v.MentionGroups))
		for i, e := range v.MentionGroups {
			s.MentionGroups[i] = e
		}
	}
	s.MentionChannel = v.MentionChannel
	s.Url = v.Url
	s.EndpointURL = v.EndpointURL
}

func (s *ConfigGrafanacontactsSlack) Clone() *ConfigGrafanacontactsSlack {
	if s == nil {
		return nil
	}

	v := &ConfigGrafanacontactsSlack{}
	v.Recipient = s.Recipient
	v.Token = s.Token
	v.Username = s.Username
	v.IconEmoji = s.IconEmoji
	v.IconURL = s.IconURL
	if s.MentionUsers != nil {
		v.MentionUsers = make([]string, len(s.MentionUsers))
		copy(v.MentionUsers, s.MentionUsers)
	}
	if s.MentionGroups != nil {
		v.MentionGroups = make([]string, len(s.MentionGroups))
		copy(v.MentionGroups, s.MentionGroups)
	}
	v.MentionChannel = s.MentionChannel
	v.Url = s.Url
	v.EndpointURL = s.EndpointURL
	return v
}

type ConfigGrafanacontactsSlackComparisonExp struct {
	And            []*ConfigGrafanacontactsSlackComparisonExp `json:"_and,omitempty"`
	Not            *ConfigGrafanacontactsSlackComparisonExp   `json:"_not,omitempty"`
	Or             []*ConfigGrafanacontactsSlackComparisonExp `json:"_or,omitempty"`
	Recipient      *ConfigStringComparisonExp                 `json:"recipient,omitempty"`
	Token          *ConfigStringComparisonExp                 `json:"token,omitempty"`
	Username       *ConfigStringComparisonExp                 `json:"username,omitempty"`
	IconEmoji      *ConfigStringComparisonExp                 `json:"iconEmoji,omitempty"`
	IconURL        *ConfigStringComparisonExp                 `json:"iconURL,omitempty"`
	MentionUsers   *ConfigStringComparisonExp                 `json:"mentionUsers,omitempty"`
	MentionGroups  *ConfigStringComparisonExp                 `json:"mentionGroups,omitempty"`
	MentionChannel *ConfigStringComparisonExp                 `json:"mentionChannel,omitempty"`
	Url            *ConfigStringComparisonExp                 `json:"url,omitempty"`
	EndpointURL    *ConfigStringComparisonExp                 `json:"endpointURL,omitempty"`
}

func (exp *ConfigGrafanacontactsSlackComparisonExp) Matches(o *ConfigGrafanacontactsSlack) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigGrafanacontactsSlack{
			MentionUsers:  []string{},
			MentionGroups: []string{},
		}
	}
	if !exp.Recipient.Matches(o.Recipient) {
		return false
	}
	if !exp.Token.Matches(o.Token) {
		return false
	}
	if !exp.Username.Matches(o.Username) {
		return false
	}
	if !exp.IconEmoji.Matches(o.IconEmoji) {
		return false
	}
	if !exp.IconURL.Matches(o.IconURL) {
		return false
	}
	{
		found := false
		for _, o := range o.MentionUsers {
			if exp.MentionUsers.Matches(o) {
				found = true
				break
			}
		}
		if !found && exp.MentionUsers != nil {
			return false
		}
	}
	{
		found := false
		for _, o := range o.MentionGroups {
			if exp.MentionGroups.Matches(o) {
				found = true
				break
			}
		}
		if !found && exp.MentionGroups != nil {
			return false
		}
	}
	if !exp.MentionChannel.Matches(o.MentionChannel) {
		return false
	}
	if !exp.Url.Matches(o.Url) {
		return false
	}
	if !exp.EndpointURL.Matches(o.EndpointURL) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigGrafanacontactsWebhook struct {
	Url string `json:"url" toml:"url"`

	HttpMethod string `json:"httpMethod" toml:"httpMethod"`

	Username string `json:"username" toml:"username"`

	Password string `json:"password" toml:"password"`

	AuthorizationScheme string `json:"authorizationScheme" toml:"authorizationScheme"`

	AuthorizationCredentials string `json:"authorizationCredentials" toml:"authorizationCredentials"`

	MaxAlerts int `json:"maxAlerts" toml:"maxAlerts"`
}

func (o *ConfigGrafanacontactsWebhook) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	m["url"] = o.Url
	m["httpMethod"] = o.HttpMethod
	m["username"] = o.Username
	m["password"] = o.Password
	m["authorizationScheme"] = o.AuthorizationScheme
	m["authorizationCredentials"] = o.AuthorizationCredentials
	m["maxAlerts"] = o.MaxAlerts
	return json.Marshal(m)
}

func (o *ConfigGrafanacontactsWebhook) GetUrl() string {
	if o == nil {
		o = &ConfigGrafanacontactsWebhook{}
	}
	return o.Url
}

func (o *ConfigGrafanacontactsWebhook) GetHttpMethod() string {
	if o == nil {
		o = &ConfigGrafanacontactsWebhook{}
	}
	return o.HttpMethod
}

func (o *ConfigGrafanacontactsWebhook) GetUsername() string {
	if o == nil {
		o = &ConfigGrafanacontactsWebhook{}
	}
	return o.Username
}

func (o *ConfigGrafanacontactsWebhook) GetPassword() string {
	if o == nil {
		o = &ConfigGrafanacontactsWebhook{}
	}
	return o.Password
}

func (o *ConfigGrafanacontactsWebhook) GetAuthorizationScheme() string {
	if o == nil {
		o = &ConfigGrafanacontactsWebhook{}
	}
	return o.AuthorizationScheme
}

func (o *ConfigGrafanacontactsWebhook) GetAuthorizationCredentials() string {
	if o == nil {
		o = &ConfigGrafanacontactsWebhook{}
	}
	return o.AuthorizationCredentials
}

func (o *ConfigGrafanacontactsWebhook) GetMaxAlerts() int {
	if o == nil {
		o = &ConfigGrafanacontactsWebhook{}
	}
	return o.MaxAlerts
}

type ConfigGrafanacontactsWebhookUpdateInput struct {
	Url                           *string `json:"url,omitempty" toml:"url,omitempty"`
	IsSetUrl                      bool    `json:"-"`
	HttpMethod                    *string `json:"httpMethod,omitempty" toml:"httpMethod,omitempty"`
	IsSetHttpMethod               bool    `json:"-"`
	Username                      *string `json:"username,omitempty" toml:"username,omitempty"`
	IsSetUsername                 bool    `json:"-"`
	Password                      *string `json:"password,omitempty" toml:"password,omitempty"`
	IsSetPassword                 bool    `json:"-"`
	AuthorizationScheme           *string `json:"authorizationScheme,omitempty" toml:"authorizationScheme,omitempty"`
	IsSetAuthorizationScheme      bool    `json:"-"`
	AuthorizationCredentials      *string `json:"authorizationCredentials,omitempty" toml:"authorizationCredentials,omitempty"`
	IsSetAuthorizationCredentials bool    `json:"-"`
	MaxAlerts                     *int    `json:"maxAlerts,omitempty" toml:"maxAlerts,omitempty"`
	IsSetMaxAlerts                bool    `json:"-"`
}

func (o *ConfigGrafanacontactsWebhookUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["url"]; ok {
		if v == nil {
			o.Url = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Url = &x
		}
		o.IsSetUrl = true
	}
	if v, ok := m["httpMethod"]; ok {
		if v == nil {
			o.HttpMethod = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.HttpMethod = &x
		}
		o.IsSetHttpMethod = true
	}
	if v, ok := m["username"]; ok {
		if v == nil {
			o.Username = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Username = &x
		}
		o.IsSetUsername = true
	}
	if v, ok := m["password"]; ok {
		if v == nil {
			o.Password = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Password = &x
		}
		o.IsSetPassword = true
	}
	if v, ok := m["authorizationScheme"]; ok {
		if v == nil {
			o.AuthorizationScheme = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.AuthorizationScheme = &x
		}
		o.IsSetAuthorizationScheme = true
	}
	if v, ok := m["authorizationCredentials"]; ok {
		if v == nil {
			o.AuthorizationCredentials = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.AuthorizationCredentials = &x
		}
		o.IsSetAuthorizationCredentials = true
	}
	if v, ok := m["maxAlerts"]; ok {
		if v == nil {
			o.MaxAlerts = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x int
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.MaxAlerts = &x
		}
		o.IsSetMaxAlerts = true
	}

	return nil
}

func (o *ConfigGrafanacontactsWebhookUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigGrafanacontactsWebhookUpdateInput) GetUrl() *string {
	if o == nil {
		o = &ConfigGrafanacontactsWebhookUpdateInput{}
	}
	return o.Url
}

func (o *ConfigGrafanacontactsWebhookUpdateInput) GetHttpMethod() *string {
	if o == nil {
		o = &ConfigGrafanacontactsWebhookUpdateInput{}
	}
	return o.HttpMethod
}

func (o *ConfigGrafanacontactsWebhookUpdateInput) GetUsername() *string {
	if o == nil {
		o = &ConfigGrafanacontactsWebhookUpdateInput{}
	}
	return o.Username
}

func (o *ConfigGrafanacontactsWebhookUpdateInput) GetPassword() *string {
	if o == nil {
		o = &ConfigGrafanacontactsWebhookUpdateInput{}
	}
	return o.Password
}

func (o *ConfigGrafanacontactsWebhookUpdateInput) GetAuthorizationScheme() *string {
	if o == nil {
		o = &ConfigGrafanacontactsWebhookUpdateInput{}
	}
	return o.AuthorizationScheme
}

func (o *ConfigGrafanacontactsWebhookUpdateInput) GetAuthorizationCredentials() *string {
	if o == nil {
		o = &ConfigGrafanacontactsWebhookUpdateInput{}
	}
	return o.AuthorizationCredentials
}

func (o *ConfigGrafanacontactsWebhookUpdateInput) GetMaxAlerts() *int {
	if o == nil {
		o = &ConfigGrafanacontactsWebhookUpdateInput{}
	}
	return o.MaxAlerts
}

func (s *ConfigGrafanacontactsWebhook) Update(v *ConfigGrafanacontactsWebhookUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetUrl || v.Url != nil {
		if v.Url != nil {
			s.Url = *v.Url
		}
	}
	if v.IsSetHttpMethod || v.HttpMethod != nil {
		if v.HttpMethod != nil {
			s.HttpMethod = *v.HttpMethod
		}
	}
	if v.IsSetUsername || v.Username != nil {
		if v.Username != nil {
			s.Username = *v.Username
		}
	}
	if v.IsSetPassword || v.Password != nil {
		if v.Password != nil {
			s.Password = *v.Password
		}
	}
	if v.IsSetAuthorizationScheme || v.AuthorizationScheme != nil {
		if v.AuthorizationScheme != nil {
			s.AuthorizationScheme = *v.AuthorizationScheme
		}
	}
	if v.IsSetAuthorizationCredentials || v.AuthorizationCredentials != nil {
		if v.AuthorizationCredentials != nil {
			s.AuthorizationCredentials = *v.AuthorizationCredentials
		}
	}
	if v.IsSetMaxAlerts || v.MaxAlerts != nil {
		if v.MaxAlerts != nil {
			s.MaxAlerts = *v.MaxAlerts
		}
	}
}

type ConfigGrafanacontactsWebhookInsertInput struct {
	Url                      string `json:"url,omitempty" toml:"url,omitempty"`
	HttpMethod               string `json:"httpMethod,omitempty" toml:"httpMethod,omitempty"`
	Username                 string `json:"username,omitempty" toml:"username,omitempty"`
	Password                 string `json:"password,omitempty" toml:"password,omitempty"`
	AuthorizationScheme      string `json:"authorizationScheme,omitempty" toml:"authorizationScheme,omitempty"`
	AuthorizationCredentials string `json:"authorizationCredentials,omitempty" toml:"authorizationCredentials,omitempty"`
	MaxAlerts                int    `json:"maxAlerts,omitempty" toml:"maxAlerts,omitempty"`
}

func (o *ConfigGrafanacontactsWebhookInsertInput) GetUrl() string {
	if o == nil {
		o = &ConfigGrafanacontactsWebhookInsertInput{}
	}
	return o.Url
}

func (o *ConfigGrafanacontactsWebhookInsertInput) GetHttpMethod() string {
	if o == nil {
		o = &ConfigGrafanacontactsWebhookInsertInput{}
	}
	return o.HttpMethod
}

func (o *ConfigGrafanacontactsWebhookInsertInput) GetUsername() string {
	if o == nil {
		o = &ConfigGrafanacontactsWebhookInsertInput{}
	}
	return o.Username
}

func (o *ConfigGrafanacontactsWebhookInsertInput) GetPassword() string {
	if o == nil {
		o = &ConfigGrafanacontactsWebhookInsertInput{}
	}
	return o.Password
}

func (o *ConfigGrafanacontactsWebhookInsertInput) GetAuthorizationScheme() string {
	if o == nil {
		o = &ConfigGrafanacontactsWebhookInsertInput{}
	}
	return o.AuthorizationScheme
}

func (o *ConfigGrafanacontactsWebhookInsertInput) GetAuthorizationCredentials() string {
	if o == nil {
		o = &ConfigGrafanacontactsWebhookInsertInput{}
	}
	return o.AuthorizationCredentials
}

func (o *ConfigGrafanacontactsWebhookInsertInput) GetMaxAlerts() int {
	if o == nil {
		o = &ConfigGrafanacontactsWebhookInsertInput{}
	}
	return o.MaxAlerts
}

func (s *ConfigGrafanacontactsWebhook) Insert(v *ConfigGrafanacontactsWebhookInsertInput) {
	s.Url = v.Url
	s.HttpMethod = v.HttpMethod
	s.Username = v.Username
	s.Password = v.Password
	s.AuthorizationScheme = v.AuthorizationScheme
	s.AuthorizationCredentials = v.AuthorizationCredentials
	s.MaxAlerts = v.MaxAlerts
}

func (s *ConfigGrafanacontactsWebhook) Clone() *ConfigGrafanacontactsWebhook {
	if s == nil {
		return nil
	}

	v := &ConfigGrafanacontactsWebhook{}
	v.Url = s.Url
	v.HttpMethod = s.HttpMethod
	v.Username = s.Username
	v.Password = s.Password
	v.AuthorizationScheme = s.AuthorizationScheme
	v.AuthorizationCredentials = s.AuthorizationCredentials
	v.MaxAlerts = s.MaxAlerts
	return v
}

type ConfigGrafanacontactsWebhookComparisonExp struct {
	And                      []*ConfigGrafanacontactsWebhookComparisonExp `json:"_and,omitempty"`
	Not                      *ConfigGrafanacontactsWebhookComparisonExp   `json:"_not,omitempty"`
	Or                       []*ConfigGrafanacontactsWebhookComparisonExp `json:"_or,omitempty"`
	Url                      *ConfigStringComparisonExp                   `json:"url,omitempty"`
	HttpMethod               *ConfigStringComparisonExp                   `json:"httpMethod,omitempty"`
	Username                 *ConfigStringComparisonExp                   `json:"username,omitempty"`
	Password                 *ConfigStringComparisonExp                   `json:"password,omitempty"`
	AuthorizationScheme      *ConfigStringComparisonExp                   `json:"authorizationScheme,omitempty"`
	AuthorizationCredentials *ConfigStringComparisonExp                   `json:"authorizationCredentials,omitempty"`
	MaxAlerts                *ConfigIntComparisonExp                      `json:"maxAlerts,omitempty"`
}

func (exp *ConfigGrafanacontactsWebhookComparisonExp) Matches(o *ConfigGrafanacontactsWebhook) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigGrafanacontactsWebhook{}
	}
	if !exp.Url.Matches(o.Url) {
		return false
	}
	if !exp.HttpMethod.Matches(o.HttpMethod) {
		return false
	}
	if !exp.Username.Matches(o.Username) {
		return false
	}
	if !exp.Password.Matches(o.Password) {
		return false
	}
	if !exp.AuthorizationScheme.Matches(o.AuthorizationScheme) {
		return false
	}
	if !exp.AuthorizationCredentials.Matches(o.AuthorizationCredentials) {
		return false
	}
	if !exp.MaxAlerts.Matches(o.MaxAlerts) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigGraphql struct {
	Security *ConfigGraphqlSecurity `json:"security,omitempty" toml:"security,omitempty"`
}

func (o *ConfigGraphql) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Security != nil {
		m["security"] = o.Security
	}
	return json.Marshal(m)
}

func (o *ConfigGraphql) GetSecurity() *ConfigGraphqlSecurity {
	if o == nil {
		return nil
	}
	return o.Security
}

type ConfigGraphqlUpdateInput struct {
	Security      *ConfigGraphqlSecurityUpdateInput `json:"security,omitempty" toml:"security,omitempty"`
	IsSetSecurity bool                              `json:"-"`
}

func (o *ConfigGraphqlUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if x, ok := m["security"]; ok {
		if x != nil {
			t := &ConfigGraphqlSecurityUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Security = t
		}
		o.IsSetSecurity = true
	}

	return nil
}

func (o *ConfigGraphqlUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigGraphqlUpdateInput) GetSecurity() *ConfigGraphqlSecurityUpdateInput {
	if o == nil {
		return nil
	}
	return o.Security
}

func (s *ConfigGraphql) Update(v *ConfigGraphqlUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetSecurity || v.Security != nil {
		if v.Security == nil {
			s.Security = nil
		} else {
			if s.Security == nil {
				s.Security = &ConfigGraphqlSecurity{}
			}
			s.Security.Update(v.Security)
		}
	}
}

type ConfigGraphqlInsertInput struct {
	Security *ConfigGraphqlSecurityInsertInput `json:"security,omitempty" toml:"security,omitempty"`
}

func (o *ConfigGraphqlInsertInput) GetSecurity() *ConfigGraphqlSecurityInsertInput {
	if o == nil {
		return nil
	}
	return o.Security
}

func (s *ConfigGraphql) Insert(v *ConfigGraphqlInsertInput) {
	if v.Security != nil {
		if s.Security == nil {
			s.Security = &ConfigGraphqlSecurity{}
		}
		s.Security.Insert(v.Security)
	}
}

func (s *ConfigGraphql) Clone() *ConfigGraphql {
	if s == nil {
		return nil
	}

	v := &ConfigGraphql{}
	v.Security = s.Security.Clone()
	return v
}

type ConfigGraphqlComparisonExp struct {
	And      []*ConfigGraphqlComparisonExp       `json:"_and,omitempty"`
	Not      *ConfigGraphqlComparisonExp         `json:"_not,omitempty"`
	Or       []*ConfigGraphqlComparisonExp       `json:"_or,omitempty"`
	Security *ConfigGraphqlSecurityComparisonExp `json:"security,omitempty"`
}

func (exp *ConfigGraphqlComparisonExp) Matches(o *ConfigGraphql) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigGraphql{
			Security: &ConfigGraphqlSecurity{},
		}
	}
	if !exp.Security.Matches(o.Security) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigGraphqlSecurity struct {
	ForbidAminSecret *bool `json:"forbidAminSecret" toml:"forbidAminSecret"`

	MaxDepthQueries *uint `json:"maxDepthQueries" toml:"maxDepthQueries"`
}

func (o *ConfigGraphqlSecurity) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.ForbidAminSecret != nil {
		m["forbidAminSecret"] = o.ForbidAminSecret
	}
	if o.MaxDepthQueries != nil {
		m["maxDepthQueries"] = o.MaxDepthQueries
	}
	return json.Marshal(m)
}

func (o *ConfigGraphqlSecurity) GetForbidAminSecret() *bool {
	if o == nil {
		o = &ConfigGraphqlSecurity{}
	}
	return o.ForbidAminSecret
}

func (o *ConfigGraphqlSecurity) GetMaxDepthQueries() *uint {
	if o == nil {
		o = &ConfigGraphqlSecurity{}
	}
	return o.MaxDepthQueries
}

type ConfigGraphqlSecurityUpdateInput struct {
	ForbidAminSecret      *bool `json:"forbidAminSecret,omitempty" toml:"forbidAminSecret,omitempty"`
	IsSetForbidAminSecret bool  `json:"-"`
	MaxDepthQueries       *uint `json:"maxDepthQueries,omitempty" toml:"maxDepthQueries,omitempty"`
	IsSetMaxDepthQueries  bool  `json:"-"`
}

func (o *ConfigGraphqlSecurityUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["forbidAminSecret"]; ok {
		if v == nil {
			o.ForbidAminSecret = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x bool
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.ForbidAminSecret = &x
		}
		o.IsSetForbidAminSecret = true
	}
	if v, ok := m["maxDepthQueries"]; ok {
		if v == nil {
			o.MaxDepthQueries = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x uint
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.MaxDepthQueries = &x
		}
		o.IsSetMaxDepthQueries = true
	}

	return nil
}

func (o *ConfigGraphqlSecurityUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigGraphqlSecurityUpdateInput) GetForbidAminSecret() *bool {
	if o == nil {
		o = &ConfigGraphqlSecurityUpdateInput{}
	}
	return o.ForbidAminSecret
}

func (o *ConfigGraphqlSecurityUpdateInput) GetMaxDepthQueries() *uint {
	if o == nil {
		o = &ConfigGraphqlSecurityUpdateInput{}
	}
	return o.MaxDepthQueries
}

func (s *ConfigGraphqlSecurity) Update(v *ConfigGraphqlSecurityUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetForbidAminSecret || v.ForbidAminSecret != nil {
		s.ForbidAminSecret = v.ForbidAminSecret
	}
	if v.IsSetMaxDepthQueries || v.MaxDepthQueries != nil {
		s.MaxDepthQueries = v.MaxDepthQueries
	}
}

type ConfigGraphqlSecurityInsertInput struct {
	ForbidAminSecret *bool `json:"forbidAminSecret,omitempty" toml:"forbidAminSecret,omitempty"`
	MaxDepthQueries  *uint `json:"maxDepthQueries,omitempty" toml:"maxDepthQueries,omitempty"`
}

func (o *ConfigGraphqlSecurityInsertInput) GetForbidAminSecret() *bool {
	if o == nil {
		o = &ConfigGraphqlSecurityInsertInput{}
	}
	return o.ForbidAminSecret
}

func (o *ConfigGraphqlSecurityInsertInput) GetMaxDepthQueries() *uint {
	if o == nil {
		o = &ConfigGraphqlSecurityInsertInput{}
	}
	return o.MaxDepthQueries
}

func (s *ConfigGraphqlSecurity) Insert(v *ConfigGraphqlSecurityInsertInput) {
	s.ForbidAminSecret = v.ForbidAminSecret
	s.MaxDepthQueries = v.MaxDepthQueries
}

func (s *ConfigGraphqlSecurity) Clone() *ConfigGraphqlSecurity {
	if s == nil {
		return nil
	}

	v := &ConfigGraphqlSecurity{}
	v.ForbidAminSecret = s.ForbidAminSecret
	v.MaxDepthQueries = s.MaxDepthQueries
	return v
}

type ConfigGraphqlSecurityComparisonExp struct {
	And              []*ConfigGraphqlSecurityComparisonExp `json:"_and,omitempty"`
	Not              *ConfigGraphqlSecurityComparisonExp   `json:"_not,omitempty"`
	Or               []*ConfigGraphqlSecurityComparisonExp `json:"_or,omitempty"`
	ForbidAminSecret *ConfigBooleanComparisonExp           `json:"forbidAminSecret,omitempty"`
	MaxDepthQueries  *ConfigUintComparisonExp              `json:"maxDepthQueries,omitempty"`
}

func (exp *ConfigGraphqlSecurityComparisonExp) Matches(o *ConfigGraphqlSecurity) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigGraphqlSecurity{}
	}
	if o.ForbidAminSecret != nil && !exp.ForbidAminSecret.Matches(*o.ForbidAminSecret) {
		return false
	}
	if o.MaxDepthQueries != nil && !exp.MaxDepthQueries.Matches(*o.MaxDepthQueries) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

// Configuration for hasura service
type ConfigHasura struct {
	// Version of hasura, you can see available versions in the URL below:
	// https://hub.docker.com/r/hasura/graphql-engine/tags
	Version *string `json:"version" toml:"version"`
	// JWT Secrets configuration
	JwtSecrets []*ConfigJWTSecret `json:"jwtSecrets,omitempty" toml:"jwtSecrets,omitempty"`
	// Admin secret
	AdminSecret string `json:"adminSecret" toml:"adminSecret"`
	// Webhook secret
	WebhookSecret string `json:"webhookSecret" toml:"webhookSecret"`
	// Configuration for hasura services
	// Reference: https://hasura.io/docs/latest/deployment/graphql-engine-flags/reference/
	Settings *ConfigHasuraSettings `json:"settings,omitempty" toml:"settings,omitempty"`

	AuthHook *ConfigHasuraAuthHook `json:"authHook,omitempty" toml:"authHook,omitempty"`

	Logs *ConfigHasuraLogs `json:"logs,omitempty" toml:"logs,omitempty"`

	Events *ConfigHasuraEvents `json:"events,omitempty" toml:"events,omitempty"`
	// Resources for the service
	Resources *ConfigResources `json:"resources,omitempty" toml:"resources,omitempty"`

	RateLimit *ConfigRateLimit `json:"rateLimit,omitempty" toml:"rateLimit,omitempty"`
}

func (o *ConfigHasura) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Version != nil {
		m["version"] = o.Version
	}
	if o.JwtSecrets != nil {
		m["jwtSecrets"] = o.JwtSecrets
	}
	m["adminSecret"] = o.AdminSecret
	m["webhookSecret"] = o.WebhookSecret
	if o.Settings != nil {
		m["settings"] = o.Settings
	}
	if o.AuthHook != nil {
		m["authHook"] = o.AuthHook
	}
	if o.Logs != nil {
		m["logs"] = o.Logs
	}
	if o.Events != nil {
		m["events"] = o.Events
	}
	if o.Resources != nil {
		m["resources"] = o.Resources
	}
	if o.RateLimit != nil {
		m["rateLimit"] = o.RateLimit
	}
	return json.Marshal(m)
}

func (o *ConfigHasura) GetVersion() *string {
	if o == nil {
		o = &ConfigHasura{}
	}
	return o.Version
}

func (o *ConfigHasura) GetJwtSecrets() []*ConfigJWTSecret {
	if o == nil {
		o = &ConfigHasura{}
	}
	return o.JwtSecrets
}

func (o *ConfigHasura) GetAdminSecret() string {
	if o == nil {
		o = &ConfigHasura{}
	}
	return o.AdminSecret
}

func (o *ConfigHasura) GetWebhookSecret() string {
	if o == nil {
		o = &ConfigHasura{}
	}
	return o.WebhookSecret
}

func (o *ConfigHasura) GetSettings() *ConfigHasuraSettings {
	if o == nil {
		return nil
	}
	return o.Settings
}

func (o *ConfigHasura) GetAuthHook() *ConfigHasuraAuthHook {
	if o == nil {
		return nil
	}
	return o.AuthHook
}

func (o *ConfigHasura) GetLogs() *ConfigHasuraLogs {
	if o == nil {
		return nil
	}
	return o.Logs
}

func (o *ConfigHasura) GetEvents() *ConfigHasuraEvents {
	if o == nil {
		return nil
	}
	return o.Events
}

func (o *ConfigHasura) GetResources() *ConfigResources {
	if o == nil {
		return nil
	}
	return o.Resources
}

func (o *ConfigHasura) GetRateLimit() *ConfigRateLimit {
	if o == nil {
		return nil
	}
	return o.RateLimit
}

type ConfigHasuraUpdateInput struct {
	Version            *string                          `json:"version,omitempty" toml:"version,omitempty"`
	IsSetVersion       bool                             `json:"-"`
	JwtSecrets         []*ConfigJWTSecretUpdateInput    `json:"jwtSecrets,omitempty" toml:"jwtSecrets,omitempty"`
	IsSetJwtSecrets    bool                             `json:"-"`
	AdminSecret        *string                          `json:"adminSecret,omitempty" toml:"adminSecret,omitempty"`
	IsSetAdminSecret   bool                             `json:"-"`
	WebhookSecret      *string                          `json:"webhookSecret,omitempty" toml:"webhookSecret,omitempty"`
	IsSetWebhookSecret bool                             `json:"-"`
	Settings           *ConfigHasuraSettingsUpdateInput `json:"settings,omitempty" toml:"settings,omitempty"`
	IsSetSettings      bool                             `json:"-"`
	AuthHook           *ConfigHasuraAuthHookUpdateInput `json:"authHook,omitempty" toml:"authHook,omitempty"`
	IsSetAuthHook      bool                             `json:"-"`
	Logs               *ConfigHasuraLogsUpdateInput     `json:"logs,omitempty" toml:"logs,omitempty"`
	IsSetLogs          bool                             `json:"-"`
	Events             *ConfigHasuraEventsUpdateInput   `json:"events,omitempty" toml:"events,omitempty"`
	IsSetEvents        bool                             `json:"-"`
	Resources          *ConfigResourcesUpdateInput      `json:"resources,omitempty" toml:"resources,omitempty"`
	IsSetResources     bool                             `json:"-"`
	RateLimit          *ConfigRateLimitUpdateInput      `json:"rateLimit,omitempty" toml:"rateLimit,omitempty"`
	IsSetRateLimit     bool                             `json:"-"`
}

func (o *ConfigHasuraUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["version"]; ok {
		if v == nil {
			o.Version = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Version = &x
		}
		o.IsSetVersion = true
	}
	if v, ok := m["jwtSecrets"]; ok {
		if v != nil {
			x, ok := v.([]interface{})
			if !ok {
				return fmt.Errorf("JwtSecrets must be []interface{}, got %T", v)
			}

			l := make([]*ConfigJWTSecretUpdateInput, len(x))
			for i, vv := range x {
				t := &ConfigJWTSecretUpdateInput{}
				if err := t.UnmarshalGQL(vv); err != nil {
					return err
				}
				l[i] = t
			}
			o.JwtSecrets = l
		}
		o.IsSetJwtSecrets = true
	}
	if v, ok := m["adminSecret"]; ok {
		if v == nil {
			o.AdminSecret = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.AdminSecret = &x
		}
		o.IsSetAdminSecret = true
	}
	if v, ok := m["webhookSecret"]; ok {
		if v == nil {
			o.WebhookSecret = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.WebhookSecret = &x
		}
		o.IsSetWebhookSecret = true
	}
	if x, ok := m["settings"]; ok {
		if x != nil {
			t := &ConfigHasuraSettingsUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Settings = t
		}
		o.IsSetSettings = true
	}
	if x, ok := m["authHook"]; ok {
		if x != nil {
			t := &ConfigHasuraAuthHookUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.AuthHook = t
		}
		o.IsSetAuthHook = true
	}
	if x, ok := m["logs"]; ok {
		if x != nil {
			t := &ConfigHasuraLogsUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Logs = t
		}
		o.IsSetLogs = true
	}
	if x, ok := m["events"]; ok {
		if x != nil {
			t := &ConfigHasuraEventsUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Events = t
		}
		o.IsSetEvents = true
	}
	if x, ok := m["resources"]; ok {
		if x != nil {
			t := &ConfigResourcesUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Resources = t
		}
		o.IsSetResources = true
	}
	if x, ok := m["rateLimit"]; ok {
		if x != nil {
			t := &ConfigRateLimitUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.RateLimit = t
		}
		o.IsSetRateLimit = true
	}

	return nil
}

func (o *ConfigHasuraUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigHasuraUpdateInput) GetVersion() *string {
	if o == nil {
		o = &ConfigHasuraUpdateInput{}
	}
	return o.Version
}

func (o *ConfigHasuraUpdateInput) GetJwtSecrets() []*ConfigJWTSecretUpdateInput {
	if o == nil {
		o = &ConfigHasuraUpdateInput{}
	}
	return o.JwtSecrets
}

func (o *ConfigHasuraUpdateInput) GetAdminSecret() *string {
	if o == nil {
		o = &ConfigHasuraUpdateInput{}
	}
	return o.AdminSecret
}

func (o *ConfigHasuraUpdateInput) GetWebhookSecret() *string {
	if o == nil {
		o = &ConfigHasuraUpdateInput{}
	}
	return o.WebhookSecret
}

func (o *ConfigHasuraUpdateInput) GetSettings() *ConfigHasuraSettingsUpdateInput {
	if o == nil {
		return nil
	}
	return o.Settings
}

func (o *ConfigHasuraUpdateInput) GetAuthHook() *ConfigHasuraAuthHookUpdateInput {
	if o == nil {
		return nil
	}
	return o.AuthHook
}

func (o *ConfigHasuraUpdateInput) GetLogs() *ConfigHasuraLogsUpdateInput {
	if o == nil {
		return nil
	}
	return o.Logs
}

func (o *ConfigHasuraUpdateInput) GetEvents() *ConfigHasuraEventsUpdateInput {
	if o == nil {
		return nil
	}
	return o.Events
}

func (o *ConfigHasuraUpdateInput) GetResources() *ConfigResourcesUpdateInput {
	if o == nil {
		return nil
	}
	return o.Resources
}

func (o *ConfigHasuraUpdateInput) GetRateLimit() *ConfigRateLimitUpdateInput {
	if o == nil {
		return nil
	}
	return o.RateLimit
}

func (s *ConfigHasura) Update(v *ConfigHasuraUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetVersion || v.Version != nil {
		s.Version = v.Version
	}
	if v.IsSetJwtSecrets || v.JwtSecrets != nil {
		if v.JwtSecrets == nil {
			s.JwtSecrets = nil
		} else {
			s.JwtSecrets = make([]*ConfigJWTSecret, len(v.JwtSecrets))
			for i, e := range v.JwtSecrets {
				v := &ConfigJWTSecret{}
				v.Update(e)
				s.JwtSecrets[i] = v
			}
		}
	}
	if v.IsSetAdminSecret || v.AdminSecret != nil {
		if v.AdminSecret != nil {
			s.AdminSecret = *v.AdminSecret
		}
	}
	if v.IsSetWebhookSecret || v.WebhookSecret != nil {
		if v.WebhookSecret != nil {
			s.WebhookSecret = *v.WebhookSecret
		}
	}
	if v.IsSetSettings || v.Settings != nil {
		if v.Settings == nil {
			s.Settings = nil
		} else {
			if s.Settings == nil {
				s.Settings = &ConfigHasuraSettings{}
			}
			s.Settings.Update(v.Settings)
		}
	}
	if v.IsSetAuthHook || v.AuthHook != nil {
		if v.AuthHook == nil {
			s.AuthHook = nil
		} else {
			if s.AuthHook == nil {
				s.AuthHook = &ConfigHasuraAuthHook{}
			}
			s.AuthHook.Update(v.AuthHook)
		}
	}
	if v.IsSetLogs || v.Logs != nil {
		if v.Logs == nil {
			s.Logs = nil
		} else {
			if s.Logs == nil {
				s.Logs = &ConfigHasuraLogs{}
			}
			s.Logs.Update(v.Logs)
		}
	}
	if v.IsSetEvents || v.Events != nil {
		if v.Events == nil {
			s.Events = nil
		} else {
			if s.Events == nil {
				s.Events = &ConfigHasuraEvents{}
			}
			s.Events.Update(v.Events)
		}
	}
	if v.IsSetResources || v.Resources != nil {
		if v.Resources == nil {
			s.Resources = nil
		} else {
			if s.Resources == nil {
				s.Resources = &ConfigResources{}
			}
			s.Resources.Update(v.Resources)
		}
	}
	if v.IsSetRateLimit || v.RateLimit != nil {
		if v.RateLimit == nil {
			s.RateLimit = nil
		} else {
			if s.RateLimit == nil {
				s.RateLimit = &ConfigRateLimit{}
			}
			s.RateLimit.Update(v.RateLimit)
		}
	}
}

type ConfigHasuraInsertInput struct {
	Version       *string                          `json:"version,omitempty" toml:"version,omitempty"`
	JwtSecrets    []*ConfigJWTSecretInsertInput    `json:"jwtSecrets,omitempty" toml:"jwtSecrets,omitempty"`
	AdminSecret   string                           `json:"adminSecret,omitempty" toml:"adminSecret,omitempty"`
	WebhookSecret string                           `json:"webhookSecret,omitempty" toml:"webhookSecret,omitempty"`
	Settings      *ConfigHasuraSettingsInsertInput `json:"settings,omitempty" toml:"settings,omitempty"`
	AuthHook      *ConfigHasuraAuthHookInsertInput `json:"authHook,omitempty" toml:"authHook,omitempty"`
	Logs          *ConfigHasuraLogsInsertInput     `json:"logs,omitempty" toml:"logs,omitempty"`
	Events        *ConfigHasuraEventsInsertInput   `json:"events,omitempty" toml:"events,omitempty"`
	Resources     *ConfigResourcesInsertInput      `json:"resources,omitempty" toml:"resources,omitempty"`
	RateLimit     *ConfigRateLimitInsertInput      `json:"rateLimit,omitempty" toml:"rateLimit,omitempty"`
}

func (o *ConfigHasuraInsertInput) GetVersion() *string {
	if o == nil {
		o = &ConfigHasuraInsertInput{}
	}
	return o.Version
}

func (o *ConfigHasuraInsertInput) GetJwtSecrets() []*ConfigJWTSecretInsertInput {
	if o == nil {
		o = &ConfigHasuraInsertInput{}
	}
	return o.JwtSecrets
}

func (o *ConfigHasuraInsertInput) GetAdminSecret() string {
	if o == nil {
		o = &ConfigHasuraInsertInput{}
	}
	return o.AdminSecret
}

func (o *ConfigHasuraInsertInput) GetWebhookSecret() string {
	if o == nil {
		o = &ConfigHasuraInsertInput{}
	}
	return o.WebhookSecret
}

func (o *ConfigHasuraInsertInput) GetSettings() *ConfigHasuraSettingsInsertInput {
	if o == nil {
		return nil
	}
	return o.Settings
}

func (o *ConfigHasuraInsertInput) GetAuthHook() *ConfigHasuraAuthHookInsertInput {
	if o == nil {
		return nil
	}
	return o.AuthHook
}

func (o *ConfigHasuraInsertInput) GetLogs() *ConfigHasuraLogsInsertInput {
	if o == nil {
		return nil
	}
	return o.Logs
}

func (o *ConfigHasuraInsertInput) GetEvents() *ConfigHasuraEventsInsertInput {
	if o == nil {
		return nil
	}
	return o.Events
}

func (o *ConfigHasuraInsertInput) GetResources() *ConfigResourcesInsertInput {
	if o == nil {
		return nil
	}
	return o.Resources
}

func (o *ConfigHasuraInsertInput) GetRateLimit() *ConfigRateLimitInsertInput {
	if o == nil {
		return nil
	}
	return o.RateLimit
}

func (s *ConfigHasura) Insert(v *ConfigHasuraInsertInput) {
	s.Version = v.Version
	if v.JwtSecrets != nil {
		s.JwtSecrets = make([]*ConfigJWTSecret, len(v.JwtSecrets))
		for i, e := range v.JwtSecrets {
			v := &ConfigJWTSecret{}
			v.Insert(e)
			s.JwtSecrets[i] = v
		}
	}
	s.AdminSecret = v.AdminSecret
	s.WebhookSecret = v.WebhookSecret
	if v.Settings != nil {
		if s.Settings == nil {
			s.Settings = &ConfigHasuraSettings{}
		}
		s.Settings.Insert(v.Settings)
	}
	if v.AuthHook != nil {
		if s.AuthHook == nil {
			s.AuthHook = &ConfigHasuraAuthHook{}
		}
		s.AuthHook.Insert(v.AuthHook)
	}
	if v.Logs != nil {
		if s.Logs == nil {
			s.Logs = &ConfigHasuraLogs{}
		}
		s.Logs.Insert(v.Logs)
	}
	if v.Events != nil {
		if s.Events == nil {
			s.Events = &ConfigHasuraEvents{}
		}
		s.Events.Insert(v.Events)
	}
	if v.Resources != nil {
		if s.Resources == nil {
			s.Resources = &ConfigResources{}
		}
		s.Resources.Insert(v.Resources)
	}
	if v.RateLimit != nil {
		if s.RateLimit == nil {
			s.RateLimit = &ConfigRateLimit{}
		}
		s.RateLimit.Insert(v.RateLimit)
	}
}

func (s *ConfigHasura) Clone() *ConfigHasura {
	if s == nil {
		return nil
	}

	v := &ConfigHasura{}
	v.Version = s.Version
	if s.JwtSecrets != nil {
		v.JwtSecrets = make([]*ConfigJWTSecret, len(s.JwtSecrets))
		for i, e := range s.JwtSecrets {
			v.JwtSecrets[i] = e.Clone()
		}
	}
	v.AdminSecret = s.AdminSecret
	v.WebhookSecret = s.WebhookSecret
	v.Settings = s.Settings.Clone()
	v.AuthHook = s.AuthHook.Clone()
	v.Logs = s.Logs.Clone()
	v.Events = s.Events.Clone()
	v.Resources = s.Resources.Clone()
	v.RateLimit = s.RateLimit.Clone()
	return v
}

type ConfigHasuraComparisonExp struct {
	And           []*ConfigHasuraComparisonExp       `json:"_and,omitempty"`
	Not           *ConfigHasuraComparisonExp         `json:"_not,omitempty"`
	Or            []*ConfigHasuraComparisonExp       `json:"_or,omitempty"`
	Version       *ConfigStringComparisonExp         `json:"version,omitempty"`
	JwtSecrets    *ConfigJWTSecretComparisonExp      `json:"jwtSecrets,omitempty"`
	AdminSecret   *ConfigStringComparisonExp         `json:"adminSecret,omitempty"`
	WebhookSecret *ConfigStringComparisonExp         `json:"webhookSecret,omitempty"`
	Settings      *ConfigHasuraSettingsComparisonExp `json:"settings,omitempty"`
	AuthHook      *ConfigHasuraAuthHookComparisonExp `json:"authHook,omitempty"`
	Logs          *ConfigHasuraLogsComparisonExp     `json:"logs,omitempty"`
	Events        *ConfigHasuraEventsComparisonExp   `json:"events,omitempty"`
	Resources     *ConfigResourcesComparisonExp      `json:"resources,omitempty"`
	RateLimit     *ConfigRateLimitComparisonExp      `json:"rateLimit,omitempty"`
}

func (exp *ConfigHasuraComparisonExp) Matches(o *ConfigHasura) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigHasura{
			JwtSecrets: []*ConfigJWTSecret{},
			Settings:   &ConfigHasuraSettings{},
			AuthHook:   &ConfigHasuraAuthHook{},
			Logs:       &ConfigHasuraLogs{},
			Events:     &ConfigHasuraEvents{},
			Resources:  &ConfigResources{},
			RateLimit:  &ConfigRateLimit{},
		}
	}
	if o.Version != nil && !exp.Version.Matches(*o.Version) {
		return false
	}
	{
		found := false
		for _, o := range o.JwtSecrets {
			if exp.JwtSecrets.Matches(o) {
				found = true
				break
			}
		}
		if !found && exp.JwtSecrets != nil {
			return false
		}
	}
	if !exp.AdminSecret.Matches(o.AdminSecret) {
		return false
	}
	if !exp.WebhookSecret.Matches(o.WebhookSecret) {
		return false
	}
	if !exp.Settings.Matches(o.Settings) {
		return false
	}
	if !exp.AuthHook.Matches(o.AuthHook) {
		return false
	}
	if !exp.Logs.Matches(o.Logs) {
		return false
	}
	if !exp.Events.Matches(o.Events) {
		return false
	}
	if !exp.Resources.Matches(o.Resources) {
		return false
	}
	if !exp.RateLimit.Matches(o.RateLimit) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigHasuraAPIsComparisonExp struct {
	Eq  *string  `json:"_eq,omitempty"`
	Neq *string  `json:"_neq,omitempty"`
	In  []string `json:"_in,omitempty"`
	Nin []string `json:"_nin,omitempty"`
}

func (exp *ConfigHasuraAPIsComparisonExp) Matches(o string) bool {
	if exp == nil {
		return true
	}

	if exp.Eq != nil && *exp.Eq != o {
		return false
	}

	if exp.Neq != nil && *exp.Neq == o {
		return false
	}

	if exp.In != nil && !contains(exp.In, o) {
		return false
	}

	if exp.Nin != nil && contains(exp.Nin, o) {
		return false
	}

	return true
}

type ConfigHasuraAuthHook struct {
	// HASURA_GRAPHQL_AUTH_HOOK
	Url string `json:"url" toml:"url"`

	Mode *string `json:"mode" toml:"mode"`
	// HASURA_GRAPHQL_AUTH_HOOK_SEND_REQUEST_BODY
	SendRequestBody *bool `json:"sendRequestBody" toml:"sendRequestBody"`
}

func (o *ConfigHasuraAuthHook) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	m["url"] = o.Url
	if o.Mode != nil {
		m["mode"] = o.Mode
	}
	if o.SendRequestBody != nil {
		m["sendRequestBody"] = o.SendRequestBody
	}
	return json.Marshal(m)
}

func (o *ConfigHasuraAuthHook) GetUrl() string {
	if o == nil {
		o = &ConfigHasuraAuthHook{}
	}
	return o.Url
}

func (o *ConfigHasuraAuthHook) GetMode() *string {
	if o == nil {
		o = &ConfigHasuraAuthHook{}
	}
	return o.Mode
}

func (o *ConfigHasuraAuthHook) GetSendRequestBody() *bool {
	if o == nil {
		o = &ConfigHasuraAuthHook{}
	}
	return o.SendRequestBody
}

type ConfigHasuraAuthHookUpdateInput struct {
	Url                  *string `json:"url,omitempty" toml:"url,omitempty"`
	IsSetUrl             bool    `json:"-"`
	Mode                 *string `json:"mode,omitempty" toml:"mode,omitempty"`
	IsSetMode            bool    `json:"-"`
	SendRequestBody      *bool   `json:"sendRequestBody,omitempty" toml:"sendRequestBody,omitempty"`
	IsSetSendRequestBody bool    `json:"-"`
}

func (o *ConfigHasuraAuthHookUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["url"]; ok {
		if v == nil {
			o.Url = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Url = &x
		}
		o.IsSetUrl = true
	}
	if v, ok := m["mode"]; ok {
		if v == nil {
			o.Mode = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Mode = &x
		}
		o.IsSetMode = true
	}
	if v, ok := m["sendRequestBody"]; ok {
		if v == nil {
			o.SendRequestBody = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x bool
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.SendRequestBody = &x
		}
		o.IsSetSendRequestBody = true
	}

	return nil
}

func (o *ConfigHasuraAuthHookUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigHasuraAuthHookUpdateInput) GetUrl() *string {
	if o == nil {
		o = &ConfigHasuraAuthHookUpdateInput{}
	}
	return o.Url
}

func (o *ConfigHasuraAuthHookUpdateInput) GetMode() *string {
	if o == nil {
		o = &ConfigHasuraAuthHookUpdateInput{}
	}
	return o.Mode
}

func (o *ConfigHasuraAuthHookUpdateInput) GetSendRequestBody() *bool {
	if o == nil {
		o = &ConfigHasuraAuthHookUpdateInput{}
	}
	return o.SendRequestBody
}

func (s *ConfigHasuraAuthHook) Update(v *ConfigHasuraAuthHookUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetUrl || v.Url != nil {
		if v.Url != nil {
			s.Url = *v.Url
		}
	}
	if v.IsSetMode || v.Mode != nil {
		s.Mode = v.Mode
	}
	if v.IsSetSendRequestBody || v.SendRequestBody != nil {
		s.SendRequestBody = v.SendRequestBody
	}
}

type ConfigHasuraAuthHookInsertInput struct {
	Url             string  `json:"url,omitempty" toml:"url,omitempty"`
	Mode            *string `json:"mode,omitempty" toml:"mode,omitempty"`
	SendRequestBody *bool   `json:"sendRequestBody,omitempty" toml:"sendRequestBody,omitempty"`
}

func (o *ConfigHasuraAuthHookInsertInput) GetUrl() string {
	if o == nil {
		o = &ConfigHasuraAuthHookInsertInput{}
	}
	return o.Url
}

func (o *ConfigHasuraAuthHookInsertInput) GetMode() *string {
	if o == nil {
		o = &ConfigHasuraAuthHookInsertInput{}
	}
	return o.Mode
}

func (o *ConfigHasuraAuthHookInsertInput) GetSendRequestBody() *bool {
	if o == nil {
		o = &ConfigHasuraAuthHookInsertInput{}
	}
	return o.SendRequestBody
}

func (s *ConfigHasuraAuthHook) Insert(v *ConfigHasuraAuthHookInsertInput) {
	s.Url = v.Url
	s.Mode = v.Mode
	s.SendRequestBody = v.SendRequestBody
}

func (s *ConfigHasuraAuthHook) Clone() *ConfigHasuraAuthHook {
	if s == nil {
		return nil
	}

	v := &ConfigHasuraAuthHook{}
	v.Url = s.Url
	v.Mode = s.Mode
	v.SendRequestBody = s.SendRequestBody
	return v
}

type ConfigHasuraAuthHookComparisonExp struct {
	And             []*ConfigHasuraAuthHookComparisonExp `json:"_and,omitempty"`
	Not             *ConfigHasuraAuthHookComparisonExp   `json:"_not,omitempty"`
	Or              []*ConfigHasuraAuthHookComparisonExp `json:"_or,omitempty"`
	Url             *ConfigStringComparisonExp           `json:"url,omitempty"`
	Mode            *ConfigStringComparisonExp           `json:"mode,omitempty"`
	SendRequestBody *ConfigBooleanComparisonExp          `json:"sendRequestBody,omitempty"`
}

func (exp *ConfigHasuraAuthHookComparisonExp) Matches(o *ConfigHasuraAuthHook) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigHasuraAuthHook{}
	}
	if !exp.Url.Matches(o.Url) {
		return false
	}
	if o.Mode != nil && !exp.Mode.Matches(*o.Mode) {
		return false
	}
	if o.SendRequestBody != nil && !exp.SendRequestBody.Matches(*o.SendRequestBody) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigHasuraEvents struct {
	// HASURA_GRAPHQL_EVENTS_HTTP_POOL_SIZE
	HttpPoolSize *uint32 `json:"httpPoolSize" toml:"httpPoolSize"`
}

func (o *ConfigHasuraEvents) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.HttpPoolSize != nil {
		m["httpPoolSize"] = o.HttpPoolSize
	}
	return json.Marshal(m)
}

func (o *ConfigHasuraEvents) GetHttpPoolSize() *uint32 {
	if o == nil {
		o = &ConfigHasuraEvents{}
	}
	return o.HttpPoolSize
}

type ConfigHasuraEventsUpdateInput struct {
	HttpPoolSize      *uint32 `json:"httpPoolSize,omitempty" toml:"httpPoolSize,omitempty"`
	IsSetHttpPoolSize bool    `json:"-"`
}

func (o *ConfigHasuraEventsUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["httpPoolSize"]; ok {
		if v == nil {
			o.HttpPoolSize = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x uint32
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.HttpPoolSize = &x
		}
		o.IsSetHttpPoolSize = true
	}

	return nil
}

func (o *ConfigHasuraEventsUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigHasuraEventsUpdateInput) GetHttpPoolSize() *uint32 {
	if o == nil {
		o = &ConfigHasuraEventsUpdateInput{}
	}
	return o.HttpPoolSize
}

func (s *ConfigHasuraEvents) Update(v *ConfigHasuraEventsUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetHttpPoolSize || v.HttpPoolSize != nil {
		s.HttpPoolSize = v.HttpPoolSize
	}
}

type ConfigHasuraEventsInsertInput struct {
	HttpPoolSize *uint32 `json:"httpPoolSize,omitempty" toml:"httpPoolSize,omitempty"`
}

func (o *ConfigHasuraEventsInsertInput) GetHttpPoolSize() *uint32 {
	if o == nil {
		o = &ConfigHasuraEventsInsertInput{}
	}
	return o.HttpPoolSize
}

func (s *ConfigHasuraEvents) Insert(v *ConfigHasuraEventsInsertInput) {
	s.HttpPoolSize = v.HttpPoolSize
}

func (s *ConfigHasuraEvents) Clone() *ConfigHasuraEvents {
	if s == nil {
		return nil
	}

	v := &ConfigHasuraEvents{}
	v.HttpPoolSize = s.HttpPoolSize
	return v
}

type ConfigHasuraEventsComparisonExp struct {
	And          []*ConfigHasuraEventsComparisonExp `json:"_and,omitempty"`
	Not          *ConfigHasuraEventsComparisonExp   `json:"_not,omitempty"`
	Or           []*ConfigHasuraEventsComparisonExp `json:"_or,omitempty"`
	HttpPoolSize *ConfigUint32ComparisonExp         `json:"httpPoolSize,omitempty"`
}

func (exp *ConfigHasuraEventsComparisonExp) Matches(o *ConfigHasuraEvents) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigHasuraEvents{}
	}
	if o.HttpPoolSize != nil && !exp.HttpPoolSize.Matches(*o.HttpPoolSize) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigHasuraLogs struct {
	Level *string `json:"level" toml:"level"`
}

func (o *ConfigHasuraLogs) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Level != nil {
		m["level"] = o.Level
	}
	return json.Marshal(m)
}

func (o *ConfigHasuraLogs) GetLevel() *string {
	if o == nil {
		o = &ConfigHasuraLogs{}
	}
	return o.Level
}

type ConfigHasuraLogsUpdateInput struct {
	Level      *string `json:"level,omitempty" toml:"level,omitempty"`
	IsSetLevel bool    `json:"-"`
}

func (o *ConfigHasuraLogsUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["level"]; ok {
		if v == nil {
			o.Level = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Level = &x
		}
		o.IsSetLevel = true
	}

	return nil
}

func (o *ConfigHasuraLogsUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigHasuraLogsUpdateInput) GetLevel() *string {
	if o == nil {
		o = &ConfigHasuraLogsUpdateInput{}
	}
	return o.Level
}

func (s *ConfigHasuraLogs) Update(v *ConfigHasuraLogsUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetLevel || v.Level != nil {
		s.Level = v.Level
	}
}

type ConfigHasuraLogsInsertInput struct {
	Level *string `json:"level,omitempty" toml:"level,omitempty"`
}

func (o *ConfigHasuraLogsInsertInput) GetLevel() *string {
	if o == nil {
		o = &ConfigHasuraLogsInsertInput{}
	}
	return o.Level
}

func (s *ConfigHasuraLogs) Insert(v *ConfigHasuraLogsInsertInput) {
	s.Level = v.Level
}

func (s *ConfigHasuraLogs) Clone() *ConfigHasuraLogs {
	if s == nil {
		return nil
	}

	v := &ConfigHasuraLogs{}
	v.Level = s.Level
	return v
}

type ConfigHasuraLogsComparisonExp struct {
	And   []*ConfigHasuraLogsComparisonExp `json:"_and,omitempty"`
	Not   *ConfigHasuraLogsComparisonExp   `json:"_not,omitempty"`
	Or    []*ConfigHasuraLogsComparisonExp `json:"_or,omitempty"`
	Level *ConfigStringComparisonExp       `json:"level,omitempty"`
}

func (exp *ConfigHasuraLogsComparisonExp) Matches(o *ConfigHasuraLogs) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigHasuraLogs{}
	}
	if o.Level != nil && !exp.Level.Matches(*o.Level) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

// Configuration for hasura services
// Reference: https://hasura.io/docs/latest/deployment/graphql-engine-flags/reference/
type ConfigHasuraSettings struct {
	// HASURA_GRAPHQL_CORS_DOMAIN
	CorsDomain []string `json:"corsDomain,omitempty" toml:"corsDomain,omitempty"`
	// HASURA_GRAPHQL_DEV_MODE
	DevMode *bool `json:"devMode" toml:"devMode"`
	// HASURA_GRAPHQL_ENABLE_ALLOWLIST
	EnableAllowList *bool `json:"enableAllowList" toml:"enableAllowList"`
	// HASURA_GRAPHQL_ENABLE_CONSOLE
	EnableConsole *bool `json:"enableConsole" toml:"enableConsole"`
	// HASURA_GRAPHQL_ENABLE_REMOTE_SCHEMA_PERMISSIONS
	EnableRemoteSchemaPermissions *bool `json:"enableRemoteSchemaPermissions" toml:"enableRemoteSchemaPermissions"`
	// HASURA_GRAPHQL_ENABLED_APIS
	EnabledAPIs []string `json:"enabledAPIs,omitempty" toml:"enabledAPIs,omitempty"`
	// HASURA_GRAPHQL_INFER_FUNCTION_PERMISSIONS
	InferFunctionPermissions *bool `json:"inferFunctionPermissions" toml:"inferFunctionPermissions"`
	// HASURA_GRAPHQL_LIVE_QUERIES_MULTIPLEXED_REFETCH_INTERVAL
	LiveQueriesMultiplexedRefetchInterval *uint32 `json:"liveQueriesMultiplexedRefetchInterval" toml:"liveQueriesMultiplexedRefetchInterval"`
	// HASURA_GRAPHQL_STRINGIFY_NUMERIC_TYPES
	StringifyNumericTypes *bool `json:"stringifyNumericTypes" toml:"stringifyNumericTypes"`
}

func (o *ConfigHasuraSettings) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.CorsDomain != nil {
		m["corsDomain"] = o.CorsDomain
	}
	if o.DevMode != nil {
		m["devMode"] = o.DevMode
	}
	if o.EnableAllowList != nil {
		m["enableAllowList"] = o.EnableAllowList
	}
	if o.EnableConsole != nil {
		m["enableConsole"] = o.EnableConsole
	}
	if o.EnableRemoteSchemaPermissions != nil {
		m["enableRemoteSchemaPermissions"] = o.EnableRemoteSchemaPermissions
	}
	if o.EnabledAPIs != nil {
		m["enabledAPIs"] = o.EnabledAPIs
	}
	if o.InferFunctionPermissions != nil {
		m["inferFunctionPermissions"] = o.InferFunctionPermissions
	}
	if o.LiveQueriesMultiplexedRefetchInterval != nil {
		m["liveQueriesMultiplexedRefetchInterval"] = o.LiveQueriesMultiplexedRefetchInterval
	}
	if o.StringifyNumericTypes != nil {
		m["stringifyNumericTypes"] = o.StringifyNumericTypes
	}
	return json.Marshal(m)
}

func (o *ConfigHasuraSettings) GetCorsDomain() []string {
	if o == nil {
		o = &ConfigHasuraSettings{}
	}
	return o.CorsDomain
}

func (o *ConfigHasuraSettings) GetDevMode() *bool {
	if o == nil {
		o = &ConfigHasuraSettings{}
	}
	return o.DevMode
}

func (o *ConfigHasuraSettings) GetEnableAllowList() *bool {
	if o == nil {
		o = &ConfigHasuraSettings{}
	}
	return o.EnableAllowList
}

func (o *ConfigHasuraSettings) GetEnableConsole() *bool {
	if o == nil {
		o = &ConfigHasuraSettings{}
	}
	return o.EnableConsole
}

func (o *ConfigHasuraSettings) GetEnableRemoteSchemaPermissions() *bool {
	if o == nil {
		o = &ConfigHasuraSettings{}
	}
	return o.EnableRemoteSchemaPermissions
}

func (o *ConfigHasuraSettings) GetEnabledAPIs() []string {
	if o == nil {
		o = &ConfigHasuraSettings{}
	}
	return o.EnabledAPIs
}

func (o *ConfigHasuraSettings) GetInferFunctionPermissions() *bool {
	if o == nil {
		o = &ConfigHasuraSettings{}
	}
	return o.InferFunctionPermissions
}

func (o *ConfigHasuraSettings) GetLiveQueriesMultiplexedRefetchInterval() *uint32 {
	if o == nil {
		o = &ConfigHasuraSettings{}
	}
	return o.LiveQueriesMultiplexedRefetchInterval
}

func (o *ConfigHasuraSettings) GetStringifyNumericTypes() *bool {
	if o == nil {
		o = &ConfigHasuraSettings{}
	}
	return o.StringifyNumericTypes
}

type ConfigHasuraSettingsUpdateInput struct {
	CorsDomain                                 []string `json:"corsDomain,omitempty" toml:"corsDomain,omitempty"`
	IsSetCorsDomain                            bool     `json:"-"`
	DevMode                                    *bool    `json:"devMode,omitempty" toml:"devMode,omitempty"`
	IsSetDevMode                               bool     `json:"-"`
	EnableAllowList                            *bool    `json:"enableAllowList,omitempty" toml:"enableAllowList,omitempty"`
	IsSetEnableAllowList                       bool     `json:"-"`
	EnableConsole                              *bool    `json:"enableConsole,omitempty" toml:"enableConsole,omitempty"`
	IsSetEnableConsole                         bool     `json:"-"`
	EnableRemoteSchemaPermissions              *bool    `json:"enableRemoteSchemaPermissions,omitempty" toml:"enableRemoteSchemaPermissions,omitempty"`
	IsSetEnableRemoteSchemaPermissions         bool     `json:"-"`
	EnabledAPIs                                []string `json:"enabledAPIs,omitempty" toml:"enabledAPIs,omitempty"`
	IsSetEnabledAPIs                           bool     `json:"-"`
	InferFunctionPermissions                   *bool    `json:"inferFunctionPermissions,omitempty" toml:"inferFunctionPermissions,omitempty"`
	IsSetInferFunctionPermissions              bool     `json:"-"`
	LiveQueriesMultiplexedRefetchInterval      *uint32  `json:"liveQueriesMultiplexedRefetchInterval,omitempty" toml:"liveQueriesMultiplexedRefetchInterval,omitempty"`
	IsSetLiveQueriesMultiplexedRefetchInterval bool     `json:"-"`
	StringifyNumericTypes                      *bool    `json:"stringifyNumericTypes,omitempty" toml:"stringifyNumericTypes,omitempty"`
	IsSetStringifyNumericTypes                 bool     `json:"-"`
}

func (o *ConfigHasuraSettingsUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["corsDomain"]; ok {
		if v != nil {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var l []string
			if err := json.Unmarshal(b, &l); err != nil {
				return err
			}
			o.CorsDomain = l
		}
		o.IsSetCorsDomain = true
	}
	if v, ok := m["devMode"]; ok {
		if v == nil {
			o.DevMode = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x bool
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.DevMode = &x
		}
		o.IsSetDevMode = true
	}
	if v, ok := m["enableAllowList"]; ok {
		if v == nil {
			o.EnableAllowList = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x bool
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.EnableAllowList = &x
		}
		o.IsSetEnableAllowList = true
	}
	if v, ok := m["enableConsole"]; ok {
		if v == nil {
			o.EnableConsole = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x bool
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.EnableConsole = &x
		}
		o.IsSetEnableConsole = true
	}
	if v, ok := m["enableRemoteSchemaPermissions"]; ok {
		if v == nil {
			o.EnableRemoteSchemaPermissions = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x bool
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.EnableRemoteSchemaPermissions = &x
		}
		o.IsSetEnableRemoteSchemaPermissions = true
	}
	if v, ok := m["enabledAPIs"]; ok {
		if v != nil {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var l []string
			if err := json.Unmarshal(b, &l); err != nil {
				return err
			}
			o.EnabledAPIs = l
		}
		o.IsSetEnabledAPIs = true
	}
	if v, ok := m["inferFunctionPermissions"]; ok {
		if v == nil {
			o.InferFunctionPermissions = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x bool
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.InferFunctionPermissions = &x
		}
		o.IsSetInferFunctionPermissions = true
	}
	if v, ok := m["liveQueriesMultiplexedRefetchInterval"]; ok {
		if v == nil {
			o.LiveQueriesMultiplexedRefetchInterval = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x uint32
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.LiveQueriesMultiplexedRefetchInterval = &x
		}
		o.IsSetLiveQueriesMultiplexedRefetchInterval = true
	}
	if v, ok := m["stringifyNumericTypes"]; ok {
		if v == nil {
			o.StringifyNumericTypes = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x bool
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.StringifyNumericTypes = &x
		}
		o.IsSetStringifyNumericTypes = true
	}

	return nil
}

func (o *ConfigHasuraSettingsUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigHasuraSettingsUpdateInput) GetCorsDomain() []string {
	if o == nil {
		o = &ConfigHasuraSettingsUpdateInput{}
	}
	return o.CorsDomain
}

func (o *ConfigHasuraSettingsUpdateInput) GetDevMode() *bool {
	if o == nil {
		o = &ConfigHasuraSettingsUpdateInput{}
	}
	return o.DevMode
}

func (o *ConfigHasuraSettingsUpdateInput) GetEnableAllowList() *bool {
	if o == nil {
		o = &ConfigHasuraSettingsUpdateInput{}
	}
	return o.EnableAllowList
}

func (o *ConfigHasuraSettingsUpdateInput) GetEnableConsole() *bool {
	if o == nil {
		o = &ConfigHasuraSettingsUpdateInput{}
	}
	return o.EnableConsole
}

func (o *ConfigHasuraSettingsUpdateInput) GetEnableRemoteSchemaPermissions() *bool {
	if o == nil {
		o = &ConfigHasuraSettingsUpdateInput{}
	}
	return o.EnableRemoteSchemaPermissions
}

func (o *ConfigHasuraSettingsUpdateInput) GetEnabledAPIs() []string {
	if o == nil {
		o = &ConfigHasuraSettingsUpdateInput{}
	}
	return o.EnabledAPIs
}

func (o *ConfigHasuraSettingsUpdateInput) GetInferFunctionPermissions() *bool {
	if o == nil {
		o = &ConfigHasuraSettingsUpdateInput{}
	}
	return o.InferFunctionPermissions
}

func (o *ConfigHasuraSettingsUpdateInput) GetLiveQueriesMultiplexedRefetchInterval() *uint32 {
	if o == nil {
		o = &ConfigHasuraSettingsUpdateInput{}
	}
	return o.LiveQueriesMultiplexedRefetchInterval
}

func (o *ConfigHasuraSettingsUpdateInput) GetStringifyNumericTypes() *bool {
	if o == nil {
		o = &ConfigHasuraSettingsUpdateInput{}
	}
	return o.StringifyNumericTypes
}

func (s *ConfigHasuraSettings) Update(v *ConfigHasuraSettingsUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetCorsDomain || v.CorsDomain != nil {
		if v.CorsDomain == nil {
			s.CorsDomain = nil
		} else {
			s.CorsDomain = make([]string, len(v.CorsDomain))
			for i, e := range v.CorsDomain {
				s.CorsDomain[i] = e
			}
		}
	}
	if v.IsSetDevMode || v.DevMode != nil {
		s.DevMode = v.DevMode
	}
	if v.IsSetEnableAllowList || v.EnableAllowList != nil {
		s.EnableAllowList = v.EnableAllowList
	}
	if v.IsSetEnableConsole || v.EnableConsole != nil {
		s.EnableConsole = v.EnableConsole
	}
	if v.IsSetEnableRemoteSchemaPermissions || v.EnableRemoteSchemaPermissions != nil {
		s.EnableRemoteSchemaPermissions = v.EnableRemoteSchemaPermissions
	}
	if v.IsSetEnabledAPIs || v.EnabledAPIs != nil {
		if v.EnabledAPIs == nil {
			s.EnabledAPIs = nil
		} else {
			s.EnabledAPIs = make([]string, len(v.EnabledAPIs))
			for i, e := range v.EnabledAPIs {
				s.EnabledAPIs[i] = e
			}
		}
	}
	if v.IsSetInferFunctionPermissions || v.InferFunctionPermissions != nil {
		s.InferFunctionPermissions = v.InferFunctionPermissions
	}
	if v.IsSetLiveQueriesMultiplexedRefetchInterval || v.LiveQueriesMultiplexedRefetchInterval != nil {
		s.LiveQueriesMultiplexedRefetchInterval = v.LiveQueriesMultiplexedRefetchInterval
	}
	if v.IsSetStringifyNumericTypes || v.StringifyNumericTypes != nil {
		s.StringifyNumericTypes = v.StringifyNumericTypes
	}
}

type ConfigHasuraSettingsInsertInput struct {
	CorsDomain                            []string `json:"corsDomain,omitempty" toml:"corsDomain,omitempty"`
	DevMode                               *bool    `json:"devMode,omitempty" toml:"devMode,omitempty"`
	EnableAllowList                       *bool    `json:"enableAllowList,omitempty" toml:"enableAllowList,omitempty"`
	EnableConsole                         *bool    `json:"enableConsole,omitempty" toml:"enableConsole,omitempty"`
	EnableRemoteSchemaPermissions         *bool    `json:"enableRemoteSchemaPermissions,omitempty" toml:"enableRemoteSchemaPermissions,omitempty"`
	EnabledAPIs                           []string `json:"enabledAPIs,omitempty" toml:"enabledAPIs,omitempty"`
	InferFunctionPermissions              *bool    `json:"inferFunctionPermissions,omitempty" toml:"inferFunctionPermissions,omitempty"`
	LiveQueriesMultiplexedRefetchInterval *uint32  `json:"liveQueriesMultiplexedRefetchInterval,omitempty" toml:"liveQueriesMultiplexedRefetchInterval,omitempty"`
	StringifyNumericTypes                 *bool    `json:"stringifyNumericTypes,omitempty" toml:"stringifyNumericTypes,omitempty"`
}

func (o *ConfigHasuraSettingsInsertInput) GetCorsDomain() []string {
	if o == nil {
		o = &ConfigHasuraSettingsInsertInput{}
	}
	return o.CorsDomain
}

func (o *ConfigHasuraSettingsInsertInput) GetDevMode() *bool {
	if o == nil {
		o = &ConfigHasuraSettingsInsertInput{}
	}
	return o.DevMode
}

func (o *ConfigHasuraSettingsInsertInput) GetEnableAllowList() *bool {
	if o == nil {
		o = &ConfigHasuraSettingsInsertInput{}
	}
	return o.EnableAllowList
}

func (o *ConfigHasuraSettingsInsertInput) GetEnableConsole() *bool {
	if o == nil {
		o = &ConfigHasuraSettingsInsertInput{}
	}
	return o.EnableConsole
}

func (o *ConfigHasuraSettingsInsertInput) GetEnableRemoteSchemaPermissions() *bool {
	if o == nil {
		o = &ConfigHasuraSettingsInsertInput{}
	}
	return o.EnableRemoteSchemaPermissions
}

func (o *ConfigHasuraSettingsInsertInput) GetEnabledAPIs() []string {
	if o == nil {
		o = &ConfigHasuraSettingsInsertInput{}
	}
	return o.EnabledAPIs
}

func (o *ConfigHasuraSettingsInsertInput) GetInferFunctionPermissions() *bool {
	if o == nil {
		o = &ConfigHasuraSettingsInsertInput{}
	}
	return o.InferFunctionPermissions
}

func (o *ConfigHasuraSettingsInsertInput) GetLiveQueriesMultiplexedRefetchInterval() *uint32 {
	if o == nil {
		o = &ConfigHasuraSettingsInsertInput{}
	}
	return o.LiveQueriesMultiplexedRefetchInterval
}

func (o *ConfigHasuraSettingsInsertInput) GetStringifyNumericTypes() *bool {
	if o == nil {
		o = &ConfigHasuraSettingsInsertInput{}
	}
	return o.StringifyNumericTypes
}

func (s *ConfigHasuraSettings) Insert(v *ConfigHasuraSettingsInsertInput) {
	if v.CorsDomain != nil {
		s.CorsDomain = make([]string, len(v.CorsDomain))
		for i, e := range v.CorsDomain {
			s.CorsDomain[i] = e
		}
	}
	s.DevMode = v.DevMode
	s.EnableAllowList = v.EnableAllowList
	s.EnableConsole = v.EnableConsole
	s.EnableRemoteSchemaPermissions = v.EnableRemoteSchemaPermissions
	if v.EnabledAPIs != nil {
		s.EnabledAPIs = make([]string, len(v.EnabledAPIs))
		for i, e := range v.EnabledAPIs {
			s.EnabledAPIs[i] = e
		}
	}
	s.InferFunctionPermissions = v.InferFunctionPermissions
	s.LiveQueriesMultiplexedRefetchInterval = v.LiveQueriesMultiplexedRefetchInterval
	s.StringifyNumericTypes = v.StringifyNumericTypes
}

func (s *ConfigHasuraSettings) Clone() *ConfigHasuraSettings {
	if s == nil {
		return nil
	}

	v := &ConfigHasuraSettings{}
	if s.CorsDomain != nil {
		v.CorsDomain = make([]string, len(s.CorsDomain))
		copy(v.CorsDomain, s.CorsDomain)
	}
	v.DevMode = s.DevMode
	v.EnableAllowList = s.EnableAllowList
	v.EnableConsole = s.EnableConsole
	v.EnableRemoteSchemaPermissions = s.EnableRemoteSchemaPermissions
	if s.EnabledAPIs != nil {
		v.EnabledAPIs = make([]string, len(s.EnabledAPIs))
		copy(v.EnabledAPIs, s.EnabledAPIs)
	}
	v.InferFunctionPermissions = s.InferFunctionPermissions
	v.LiveQueriesMultiplexedRefetchInterval = s.LiveQueriesMultiplexedRefetchInterval
	v.StringifyNumericTypes = s.StringifyNumericTypes
	return v
}

type ConfigHasuraSettingsComparisonExp struct {
	And                                   []*ConfigHasuraSettingsComparisonExp `json:"_and,omitempty"`
	Not                                   *ConfigHasuraSettingsComparisonExp   `json:"_not,omitempty"`
	Or                                    []*ConfigHasuraSettingsComparisonExp `json:"_or,omitempty"`
	CorsDomain                            *ConfigUrlComparisonExp              `json:"corsDomain,omitempty"`
	DevMode                               *ConfigBooleanComparisonExp          `json:"devMode,omitempty"`
	EnableAllowList                       *ConfigBooleanComparisonExp          `json:"enableAllowList,omitempty"`
	EnableConsole                         *ConfigBooleanComparisonExp          `json:"enableConsole,omitempty"`
	EnableRemoteSchemaPermissions         *ConfigBooleanComparisonExp          `json:"enableRemoteSchemaPermissions,omitempty"`
	EnabledAPIs                           *ConfigHasuraAPIsComparisonExp       `json:"enabledAPIs,omitempty"`
	InferFunctionPermissions              *ConfigBooleanComparisonExp          `json:"inferFunctionPermissions,omitempty"`
	LiveQueriesMultiplexedRefetchInterval *ConfigUint32ComparisonExp           `json:"liveQueriesMultiplexedRefetchInterval,omitempty"`
	StringifyNumericTypes                 *ConfigBooleanComparisonExp          `json:"stringifyNumericTypes,omitempty"`
}

func (exp *ConfigHasuraSettingsComparisonExp) Matches(o *ConfigHasuraSettings) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigHasuraSettings{
			CorsDomain:  []string{},
			EnabledAPIs: []string{},
		}
	}
	{
		found := false
		for _, o := range o.CorsDomain {
			if exp.CorsDomain.Matches(o) {
				found = true
				break
			}
		}
		if !found && exp.CorsDomain != nil {
			return false
		}
	}
	if o.DevMode != nil && !exp.DevMode.Matches(*o.DevMode) {
		return false
	}
	if o.EnableAllowList != nil && !exp.EnableAllowList.Matches(*o.EnableAllowList) {
		return false
	}
	if o.EnableConsole != nil && !exp.EnableConsole.Matches(*o.EnableConsole) {
		return false
	}
	if o.EnableRemoteSchemaPermissions != nil && !exp.EnableRemoteSchemaPermissions.Matches(*o.EnableRemoteSchemaPermissions) {
		return false
	}
	{
		found := false
		for _, o := range o.EnabledAPIs {
			if exp.EnabledAPIs.Matches(o) {
				found = true
				break
			}
		}
		if !found && exp.EnabledAPIs != nil {
			return false
		}
	}
	if o.InferFunctionPermissions != nil && !exp.InferFunctionPermissions.Matches(*o.InferFunctionPermissions) {
		return false
	}
	if o.LiveQueriesMultiplexedRefetchInterval != nil && !exp.LiveQueriesMultiplexedRefetchInterval.Matches(*o.LiveQueriesMultiplexedRefetchInterval) {
		return false
	}
	if o.StringifyNumericTypes != nil && !exp.StringifyNumericTypes.Matches(*o.StringifyNumericTypes) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigHealthCheck struct {
	Port uint16 `json:"port" toml:"port"`

	InitialDelaySeconds *int `json:"initialDelaySeconds" toml:"initialDelaySeconds"`

	ProbePeriodSeconds *int `json:"probePeriodSeconds" toml:"probePeriodSeconds"`
}

func (o *ConfigHealthCheck) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	m["port"] = o.Port
	if o.InitialDelaySeconds != nil {
		m["initialDelaySeconds"] = o.InitialDelaySeconds
	}
	if o.ProbePeriodSeconds != nil {
		m["probePeriodSeconds"] = o.ProbePeriodSeconds
	}
	return json.Marshal(m)
}

func (o *ConfigHealthCheck) GetPort() uint16 {
	if o == nil {
		o = &ConfigHealthCheck{}
	}
	return o.Port
}

func (o *ConfigHealthCheck) GetInitialDelaySeconds() *int {
	if o == nil {
		o = &ConfigHealthCheck{}
	}
	return o.InitialDelaySeconds
}

func (o *ConfigHealthCheck) GetProbePeriodSeconds() *int {
	if o == nil {
		o = &ConfigHealthCheck{}
	}
	return o.ProbePeriodSeconds
}

type ConfigHealthCheckUpdateInput struct {
	Port                     *uint16 `json:"port,omitempty" toml:"port,omitempty"`
	IsSetPort                bool    `json:"-"`
	InitialDelaySeconds      *int    `json:"initialDelaySeconds,omitempty" toml:"initialDelaySeconds,omitempty"`
	IsSetInitialDelaySeconds bool    `json:"-"`
	ProbePeriodSeconds       *int    `json:"probePeriodSeconds,omitempty" toml:"probePeriodSeconds,omitempty"`
	IsSetProbePeriodSeconds  bool    `json:"-"`
}

func (o *ConfigHealthCheckUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["port"]; ok {
		if v == nil {
			o.Port = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x uint16
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Port = &x
		}
		o.IsSetPort = true
	}
	if v, ok := m["initialDelaySeconds"]; ok {
		if v == nil {
			o.InitialDelaySeconds = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x int
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.InitialDelaySeconds = &x
		}
		o.IsSetInitialDelaySeconds = true
	}
	if v, ok := m["probePeriodSeconds"]; ok {
		if v == nil {
			o.ProbePeriodSeconds = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x int
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.ProbePeriodSeconds = &x
		}
		o.IsSetProbePeriodSeconds = true
	}

	return nil
}

func (o *ConfigHealthCheckUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigHealthCheckUpdateInput) GetPort() *uint16 {
	if o == nil {
		o = &ConfigHealthCheckUpdateInput{}
	}
	return o.Port
}

func (o *ConfigHealthCheckUpdateInput) GetInitialDelaySeconds() *int {
	if o == nil {
		o = &ConfigHealthCheckUpdateInput{}
	}
	return o.InitialDelaySeconds
}

func (o *ConfigHealthCheckUpdateInput) GetProbePeriodSeconds() *int {
	if o == nil {
		o = &ConfigHealthCheckUpdateInput{}
	}
	return o.ProbePeriodSeconds
}

func (s *ConfigHealthCheck) Update(v *ConfigHealthCheckUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetPort || v.Port != nil {
		if v.Port != nil {
			s.Port = *v.Port
		}
	}
	if v.IsSetInitialDelaySeconds || v.InitialDelaySeconds != nil {
		s.InitialDelaySeconds = v.InitialDelaySeconds
	}
	if v.IsSetProbePeriodSeconds || v.ProbePeriodSeconds != nil {
		s.ProbePeriodSeconds = v.ProbePeriodSeconds
	}
}

type ConfigHealthCheckInsertInput struct {
	Port                uint16 `json:"port,omitempty" toml:"port,omitempty"`
	InitialDelaySeconds *int   `json:"initialDelaySeconds,omitempty" toml:"initialDelaySeconds,omitempty"`
	ProbePeriodSeconds  *int   `json:"probePeriodSeconds,omitempty" toml:"probePeriodSeconds,omitempty"`
}

func (o *ConfigHealthCheckInsertInput) GetPort() uint16 {
	if o == nil {
		o = &ConfigHealthCheckInsertInput{}
	}
	return o.Port
}

func (o *ConfigHealthCheckInsertInput) GetInitialDelaySeconds() *int {
	if o == nil {
		o = &ConfigHealthCheckInsertInput{}
	}
	return o.InitialDelaySeconds
}

func (o *ConfigHealthCheckInsertInput) GetProbePeriodSeconds() *int {
	if o == nil {
		o = &ConfigHealthCheckInsertInput{}
	}
	return o.ProbePeriodSeconds
}

func (s *ConfigHealthCheck) Insert(v *ConfigHealthCheckInsertInput) {
	s.Port = v.Port
	s.InitialDelaySeconds = v.InitialDelaySeconds
	s.ProbePeriodSeconds = v.ProbePeriodSeconds
}

func (s *ConfigHealthCheck) Clone() *ConfigHealthCheck {
	if s == nil {
		return nil
	}

	v := &ConfigHealthCheck{}
	v.Port = s.Port
	v.InitialDelaySeconds = s.InitialDelaySeconds
	v.ProbePeriodSeconds = s.ProbePeriodSeconds
	return v
}

type ConfigHealthCheckComparisonExp struct {
	And                 []*ConfigHealthCheckComparisonExp `json:"_and,omitempty"`
	Not                 *ConfigHealthCheckComparisonExp   `json:"_not,omitempty"`
	Or                  []*ConfigHealthCheckComparisonExp `json:"_or,omitempty"`
	Port                *ConfigPortComparisonExp          `json:"port,omitempty"`
	InitialDelaySeconds *ConfigIntComparisonExp           `json:"initialDelaySeconds,omitempty"`
	ProbePeriodSeconds  *ConfigIntComparisonExp           `json:"probePeriodSeconds,omitempty"`
}

func (exp *ConfigHealthCheckComparisonExp) Matches(o *ConfigHealthCheck) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigHealthCheck{}
	}
	if !exp.Port.Matches(o.Port) {
		return false
	}
	if o.InitialDelaySeconds != nil && !exp.InitialDelaySeconds.Matches(*o.InitialDelaySeconds) {
		return false
	}
	if o.ProbePeriodSeconds != nil && !exp.ProbePeriodSeconds.Matches(*o.ProbePeriodSeconds) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigIngress struct {
	Fqdn []string `json:"fqdn,omitempty" toml:"fqdn,omitempty"`

	Tls *ConfigIngressTls `json:"tls,omitempty" toml:"tls,omitempty"`
}

func (o *ConfigIngress) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Fqdn != nil {
		m["fqdn"] = o.Fqdn
	}
	if o.Tls != nil {
		m["tls"] = o.Tls
	}
	return json.Marshal(m)
}

func (o *ConfigIngress) GetFqdn() []string {
	if o == nil {
		o = &ConfigIngress{}
	}
	return o.Fqdn
}

func (o *ConfigIngress) GetTls() *ConfigIngressTls {
	if o == nil {
		return nil
	}
	return o.Tls
}

type ConfigIngressUpdateInput struct {
	Fqdn      []string                     `json:"fqdn,omitempty" toml:"fqdn,omitempty"`
	IsSetFqdn bool                         `json:"-"`
	Tls       *ConfigIngressTlsUpdateInput `json:"tls,omitempty" toml:"tls,omitempty"`
	IsSetTls  bool                         `json:"-"`
}

func (o *ConfigIngressUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["fqdn"]; ok {
		if v != nil {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var l []string
			if err := json.Unmarshal(b, &l); err != nil {
				return err
			}
			o.Fqdn = l
		}
		o.IsSetFqdn = true
	}
	if x, ok := m["tls"]; ok {
		if x != nil {
			t := &ConfigIngressTlsUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Tls = t
		}
		o.IsSetTls = true
	}

	return nil
}

func (o *ConfigIngressUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigIngressUpdateInput) GetFqdn() []string {
	if o == nil {
		o = &ConfigIngressUpdateInput{}
	}
	return o.Fqdn
}

func (o *ConfigIngressUpdateInput) GetTls() *ConfigIngressTlsUpdateInput {
	if o == nil {
		return nil
	}
	return o.Tls
}

func (s *ConfigIngress) Update(v *ConfigIngressUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetFqdn || v.Fqdn != nil {
		if v.Fqdn == nil {
			s.Fqdn = nil
		} else {
			s.Fqdn = make([]string, len(v.Fqdn))
			for i, e := range v.Fqdn {
				s.Fqdn[i] = e
			}
		}
	}
	if v.IsSetTls || v.Tls != nil {
		if v.Tls == nil {
			s.Tls = nil
		} else {
			if s.Tls == nil {
				s.Tls = &ConfigIngressTls{}
			}
			s.Tls.Update(v.Tls)
		}
	}
}

type ConfigIngressInsertInput struct {
	Fqdn []string                     `json:"fqdn,omitempty" toml:"fqdn,omitempty"`
	Tls  *ConfigIngressTlsInsertInput `json:"tls,omitempty" toml:"tls,omitempty"`
}

func (o *ConfigIngressInsertInput) GetFqdn() []string {
	if o == nil {
		o = &ConfigIngressInsertInput{}
	}
	return o.Fqdn
}

func (o *ConfigIngressInsertInput) GetTls() *ConfigIngressTlsInsertInput {
	if o == nil {
		return nil
	}
	return o.Tls
}

func (s *ConfigIngress) Insert(v *ConfigIngressInsertInput) {
	if v.Fqdn != nil {
		s.Fqdn = make([]string, len(v.Fqdn))
		for i, e := range v.Fqdn {
			s.Fqdn[i] = e
		}
	}
	if v.Tls != nil {
		if s.Tls == nil {
			s.Tls = &ConfigIngressTls{}
		}
		s.Tls.Insert(v.Tls)
	}
}

func (s *ConfigIngress) Clone() *ConfigIngress {
	if s == nil {
		return nil
	}

	v := &ConfigIngress{}
	if s.Fqdn != nil {
		v.Fqdn = make([]string, len(s.Fqdn))
		copy(v.Fqdn, s.Fqdn)
	}
	v.Tls = s.Tls.Clone()
	return v
}

type ConfigIngressComparisonExp struct {
	And  []*ConfigIngressComparisonExp  `json:"_and,omitempty"`
	Not  *ConfigIngressComparisonExp    `json:"_not,omitempty"`
	Or   []*ConfigIngressComparisonExp  `json:"_or,omitempty"`
	Fqdn *ConfigStringComparisonExp     `json:"fqdn,omitempty"`
	Tls  *ConfigIngressTlsComparisonExp `json:"tls,omitempty"`
}

func (exp *ConfigIngressComparisonExp) Matches(o *ConfigIngress) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigIngress{
			Fqdn: []string{},
			Tls:  &ConfigIngressTls{},
		}
	}
	{
		found := false
		for _, o := range o.Fqdn {
			if exp.Fqdn.Matches(o) {
				found = true
				break
			}
		}
		if !found && exp.Fqdn != nil {
			return false
		}
	}
	if !exp.Tls.Matches(o.Tls) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigIngressTls struct {
	ClientCA *string `json:"clientCA" toml:"clientCA"`
}

func (o *ConfigIngressTls) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.ClientCA != nil {
		m["clientCA"] = o.ClientCA
	}
	return json.Marshal(m)
}

func (o *ConfigIngressTls) GetClientCA() *string {
	if o == nil {
		o = &ConfigIngressTls{}
	}
	return o.ClientCA
}

type ConfigIngressTlsUpdateInput struct {
	ClientCA      *string `json:"clientCA,omitempty" toml:"clientCA,omitempty"`
	IsSetClientCA bool    `json:"-"`
}

func (o *ConfigIngressTlsUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["clientCA"]; ok {
		if v == nil {
			o.ClientCA = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.ClientCA = &x
		}
		o.IsSetClientCA = true
	}

	return nil
}

func (o *ConfigIngressTlsUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigIngressTlsUpdateInput) GetClientCA() *string {
	if o == nil {
		o = &ConfigIngressTlsUpdateInput{}
	}
	return o.ClientCA
}

func (s *ConfigIngressTls) Update(v *ConfigIngressTlsUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetClientCA || v.ClientCA != nil {
		s.ClientCA = v.ClientCA
	}
}

type ConfigIngressTlsInsertInput struct {
	ClientCA *string `json:"clientCA,omitempty" toml:"clientCA,omitempty"`
}

func (o *ConfigIngressTlsInsertInput) GetClientCA() *string {
	if o == nil {
		o = &ConfigIngressTlsInsertInput{}
	}
	return o.ClientCA
}

func (s *ConfigIngressTls) Insert(v *ConfigIngressTlsInsertInput) {
	s.ClientCA = v.ClientCA
}

func (s *ConfigIngressTls) Clone() *ConfigIngressTls {
	if s == nil {
		return nil
	}

	v := &ConfigIngressTls{}
	v.ClientCA = s.ClientCA
	return v
}

type ConfigIngressTlsComparisonExp struct {
	And      []*ConfigIngressTlsComparisonExp `json:"_and,omitempty"`
	Not      *ConfigIngressTlsComparisonExp   `json:"_not,omitempty"`
	Or       []*ConfigIngressTlsComparisonExp `json:"_or,omitempty"`
	ClientCA *ConfigStringComparisonExp       `json:"clientCA,omitempty"`
}

func (exp *ConfigIngressTlsComparisonExp) Matches(o *ConfigIngressTls) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigIngressTls{}
	}
	if o.ClientCA != nil && !exp.ClientCA.Matches(*o.ClientCA) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

// See https://hasura.io/docs/latest/auth/authentication/jwt/
type ConfigJWTSecret struct {
	Type *string `json:"type" toml:"type"`

	Key *string `json:"key" toml:"key"`

	SigningKey *string `json:"signingKey" toml:"signingKey"`

	Kid *string `json:"kid" toml:"kid"`

	JwkUrl *string `json:"jwk_url" toml:"jwk_url"`

	ClaimsFormat *string `json:"claims_format" toml:"claims_format"`

	Audience *string `json:"audience" toml:"audience"`

	Issuer *string `json:"issuer" toml:"issuer"`

	AllowedSkew *uint32 `json:"allowed_skew" toml:"allowed_skew"`

	Header *string `json:"header" toml:"header"`

	ClaimsMap []*ConfigClaimMap `json:"claims_map,omitempty" toml:"claims_map,omitempty"`

	ClaimsNamespace *string `json:"claims_namespace" toml:"claims_namespace"`

	ClaimsNamespacePath *string `json:"claims_namespace_path" toml:"claims_namespace_path"`
}

func (o *ConfigJWTSecret) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Type != nil {
		m["type"] = o.Type
	}
	if o.Key != nil {
		m["key"] = o.Key
	}
	if o.SigningKey != nil {
		m["signingKey"] = o.SigningKey
	}
	if o.Kid != nil {
		m["kid"] = o.Kid
	}
	if o.JwkUrl != nil {
		m["jwk_url"] = o.JwkUrl
	}
	if o.ClaimsFormat != nil {
		m["claims_format"] = o.ClaimsFormat
	}
	if o.Audience != nil {
		m["audience"] = o.Audience
	}
	if o.Issuer != nil {
		m["issuer"] = o.Issuer
	}
	if o.AllowedSkew != nil {
		m["allowed_skew"] = o.AllowedSkew
	}
	if o.Header != nil {
		m["header"] = o.Header
	}
	if o.ClaimsMap != nil {
		m["claims_map"] = o.ClaimsMap
	}
	if o.ClaimsNamespace != nil {
		m["claims_namespace"] = o.ClaimsNamespace
	}
	if o.ClaimsNamespacePath != nil {
		m["claims_namespace_path"] = o.ClaimsNamespacePath
	}
	return json.Marshal(m)
}

func (o *ConfigJWTSecret) GetType() *string {
	if o == nil {
		o = &ConfigJWTSecret{}
	}
	return o.Type
}

func (o *ConfigJWTSecret) GetKey() *string {
	if o == nil {
		o = &ConfigJWTSecret{}
	}
	return o.Key
}

func (o *ConfigJWTSecret) GetSigningKey() *string {
	if o == nil {
		o = &ConfigJWTSecret{}
	}
	return o.SigningKey
}

func (o *ConfigJWTSecret) GetKid() *string {
	if o == nil {
		o = &ConfigJWTSecret{}
	}
	return o.Kid
}

func (o *ConfigJWTSecret) GetJwkUrl() *string {
	if o == nil {
		o = &ConfigJWTSecret{}
	}
	return o.JwkUrl
}

func (o *ConfigJWTSecret) GetClaimsFormat() *string {
	if o == nil {
		o = &ConfigJWTSecret{}
	}
	return o.ClaimsFormat
}

func (o *ConfigJWTSecret) GetAudience() *string {
	if o == nil {
		o = &ConfigJWTSecret{}
	}
	return o.Audience
}

func (o *ConfigJWTSecret) GetIssuer() *string {
	if o == nil {
		o = &ConfigJWTSecret{}
	}
	return o.Issuer
}

func (o *ConfigJWTSecret) GetAllowedSkew() *uint32 {
	if o == nil {
		o = &ConfigJWTSecret{}
	}
	return o.AllowedSkew
}

func (o *ConfigJWTSecret) GetHeader() *string {
	if o == nil {
		o = &ConfigJWTSecret{}
	}
	return o.Header
}

func (o *ConfigJWTSecret) GetClaimsMap() []*ConfigClaimMap {
	if o == nil {
		o = &ConfigJWTSecret{}
	}
	return o.ClaimsMap
}

func (o *ConfigJWTSecret) GetClaimsNamespace() *string {
	if o == nil {
		o = &ConfigJWTSecret{}
	}
	return o.ClaimsNamespace
}

func (o *ConfigJWTSecret) GetClaimsNamespacePath() *string {
	if o == nil {
		o = &ConfigJWTSecret{}
	}
	return o.ClaimsNamespacePath
}

type ConfigJWTSecretUpdateInput struct {
	Type                     *string                      `json:"type,omitempty" toml:"type,omitempty"`
	IsSetType                bool                         `json:"-"`
	Key                      *string                      `json:"key,omitempty" toml:"key,omitempty"`
	IsSetKey                 bool                         `json:"-"`
	SigningKey               *string                      `json:"signingKey,omitempty" toml:"signingKey,omitempty"`
	IsSetSigningKey          bool                         `json:"-"`
	Kid                      *string                      `json:"kid,omitempty" toml:"kid,omitempty"`
	IsSetKid                 bool                         `json:"-"`
	JwkUrl                   *string                      `json:"jwk_url,omitempty" toml:"jwk_url,omitempty"`
	IsSetJwkUrl              bool                         `json:"-"`
	ClaimsFormat             *string                      `json:"claims_format,omitempty" toml:"claims_format,omitempty"`
	IsSetClaimsFormat        bool                         `json:"-"`
	Audience                 *string                      `json:"audience,omitempty" toml:"audience,omitempty"`
	IsSetAudience            bool                         `json:"-"`
	Issuer                   *string                      `json:"issuer,omitempty" toml:"issuer,omitempty"`
	IsSetIssuer              bool                         `json:"-"`
	AllowedSkew              *uint32                      `json:"allowed_skew,omitempty" toml:"allowed_skew,omitempty"`
	IsSetAllowedSkew         bool                         `json:"-"`
	Header                   *string                      `json:"header,omitempty" toml:"header,omitempty"`
	IsSetHeader              bool                         `json:"-"`
	ClaimsMap                []*ConfigClaimMapUpdateInput `json:"claims_map,omitempty" toml:"claims_map,omitempty"`
	IsSetClaimsMap           bool                         `json:"-"`
	ClaimsNamespace          *string                      `json:"claims_namespace,omitempty" toml:"claims_namespace,omitempty"`
	IsSetClaimsNamespace     bool                         `json:"-"`
	ClaimsNamespacePath      *string                      `json:"claims_namespace_path,omitempty" toml:"claims_namespace_path,omitempty"`
	IsSetClaimsNamespacePath bool                         `json:"-"`
}

func (o *ConfigJWTSecretUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["type"]; ok {
		if v == nil {
			o.Type = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Type = &x
		}
		o.IsSetType = true
	}
	if v, ok := m["key"]; ok {
		if v == nil {
			o.Key = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Key = &x
		}
		o.IsSetKey = true
	}
	if v, ok := m["signingKey"]; ok {
		if v == nil {
			o.SigningKey = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.SigningKey = &x
		}
		o.IsSetSigningKey = true
	}
	if v, ok := m["kid"]; ok {
		if v == nil {
			o.Kid = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Kid = &x
		}
		o.IsSetKid = true
	}
	if v, ok := m["jwk_url"]; ok {
		if v == nil {
			o.JwkUrl = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.JwkUrl = &x
		}
		o.IsSetJwkUrl = true
	}
	if v, ok := m["claims_format"]; ok {
		if v == nil {
			o.ClaimsFormat = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.ClaimsFormat = &x
		}
		o.IsSetClaimsFormat = true
	}
	if v, ok := m["audience"]; ok {
		if v == nil {
			o.Audience = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Audience = &x
		}
		o.IsSetAudience = true
	}
	if v, ok := m["issuer"]; ok {
		if v == nil {
			o.Issuer = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Issuer = &x
		}
		o.IsSetIssuer = true
	}
	if v, ok := m["allowed_skew"]; ok {
		if v == nil {
			o.AllowedSkew = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x uint32
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.AllowedSkew = &x
		}
		o.IsSetAllowedSkew = true
	}
	if v, ok := m["header"]; ok {
		if v == nil {
			o.Header = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Header = &x
		}
		o.IsSetHeader = true
	}
	if v, ok := m["claims_map"]; ok {
		if v != nil {
			x, ok := v.([]interface{})
			if !ok {
				return fmt.Errorf("ClaimsMap must be []interface{}, got %T", v)
			}

			l := make([]*ConfigClaimMapUpdateInput, len(x))
			for i, vv := range x {
				t := &ConfigClaimMapUpdateInput{}
				if err := t.UnmarshalGQL(vv); err != nil {
					return err
				}
				l[i] = t
			}
			o.ClaimsMap = l
		}
		o.IsSetClaimsMap = true
	}
	if v, ok := m["claims_namespace"]; ok {
		if v == nil {
			o.ClaimsNamespace = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.ClaimsNamespace = &x
		}
		o.IsSetClaimsNamespace = true
	}
	if v, ok := m["claims_namespace_path"]; ok {
		if v == nil {
			o.ClaimsNamespacePath = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.ClaimsNamespacePath = &x
		}
		o.IsSetClaimsNamespacePath = true
	}

	return nil
}

func (o *ConfigJWTSecretUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigJWTSecretUpdateInput) GetType() *string {
	if o == nil {
		o = &ConfigJWTSecretUpdateInput{}
	}
	return o.Type
}

func (o *ConfigJWTSecretUpdateInput) GetKey() *string {
	if o == nil {
		o = &ConfigJWTSecretUpdateInput{}
	}
	return o.Key
}

func (o *ConfigJWTSecretUpdateInput) GetSigningKey() *string {
	if o == nil {
		o = &ConfigJWTSecretUpdateInput{}
	}
	return o.SigningKey
}

func (o *ConfigJWTSecretUpdateInput) GetKid() *string {
	if o == nil {
		o = &ConfigJWTSecretUpdateInput{}
	}
	return o.Kid
}

func (o *ConfigJWTSecretUpdateInput) GetJwkUrl() *string {
	if o == nil {
		o = &ConfigJWTSecretUpdateInput{}
	}
	return o.JwkUrl
}

func (o *ConfigJWTSecretUpdateInput) GetClaimsFormat() *string {
	if o == nil {
		o = &ConfigJWTSecretUpdateInput{}
	}
	return o.ClaimsFormat
}

func (o *ConfigJWTSecretUpdateInput) GetAudience() *string {
	if o == nil {
		o = &ConfigJWTSecretUpdateInput{}
	}
	return o.Audience
}

func (o *ConfigJWTSecretUpdateInput) GetIssuer() *string {
	if o == nil {
		o = &ConfigJWTSecretUpdateInput{}
	}
	return o.Issuer
}

func (o *ConfigJWTSecretUpdateInput) GetAllowedSkew() *uint32 {
	if o == nil {
		o = &ConfigJWTSecretUpdateInput{}
	}
	return o.AllowedSkew
}

func (o *ConfigJWTSecretUpdateInput) GetHeader() *string {
	if o == nil {
		o = &ConfigJWTSecretUpdateInput{}
	}
	return o.Header
}

func (o *ConfigJWTSecretUpdateInput) GetClaimsMap() []*ConfigClaimMapUpdateInput {
	if o == nil {
		o = &ConfigJWTSecretUpdateInput{}
	}
	return o.ClaimsMap
}

func (o *ConfigJWTSecretUpdateInput) GetClaimsNamespace() *string {
	if o == nil {
		o = &ConfigJWTSecretUpdateInput{}
	}
	return o.ClaimsNamespace
}

func (o *ConfigJWTSecretUpdateInput) GetClaimsNamespacePath() *string {
	if o == nil {
		o = &ConfigJWTSecretUpdateInput{}
	}
	return o.ClaimsNamespacePath
}

func (s *ConfigJWTSecret) Update(v *ConfigJWTSecretUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetType || v.Type != nil {
		s.Type = v.Type
	}
	if v.IsSetKey || v.Key != nil {
		s.Key = v.Key
	}
	if v.IsSetSigningKey || v.SigningKey != nil {
		s.SigningKey = v.SigningKey
	}
	if v.IsSetKid || v.Kid != nil {
		s.Kid = v.Kid
	}
	if v.IsSetJwkUrl || v.JwkUrl != nil {
		s.JwkUrl = v.JwkUrl
	}
	if v.IsSetClaimsFormat || v.ClaimsFormat != nil {
		s.ClaimsFormat = v.ClaimsFormat
	}
	if v.IsSetAudience || v.Audience != nil {
		s.Audience = v.Audience
	}
	if v.IsSetIssuer || v.Issuer != nil {
		s.Issuer = v.Issuer
	}
	if v.IsSetAllowedSkew || v.AllowedSkew != nil {
		s.AllowedSkew = v.AllowedSkew
	}
	if v.IsSetHeader || v.Header != nil {
		s.Header = v.Header
	}
	if v.IsSetClaimsMap || v.ClaimsMap != nil {
		if v.ClaimsMap == nil {
			s.ClaimsMap = nil
		} else {
			s.ClaimsMap = make([]*ConfigClaimMap, len(v.ClaimsMap))
			for i, e := range v.ClaimsMap {
				v := &ConfigClaimMap{}
				v.Update(e)
				s.ClaimsMap[i] = v
			}
		}
	}
	if v.IsSetClaimsNamespace || v.ClaimsNamespace != nil {
		s.ClaimsNamespace = v.ClaimsNamespace
	}
	if v.IsSetClaimsNamespacePath || v.ClaimsNamespacePath != nil {
		s.ClaimsNamespacePath = v.ClaimsNamespacePath
	}
}

type ConfigJWTSecretInsertInput struct {
	Type                *string                      `json:"type,omitempty" toml:"type,omitempty"`
	Key                 *string                      `json:"key,omitempty" toml:"key,omitempty"`
	SigningKey          *string                      `json:"signingKey,omitempty" toml:"signingKey,omitempty"`
	Kid                 *string                      `json:"kid,omitempty" toml:"kid,omitempty"`
	JwkUrl              *string                      `json:"jwk_url,omitempty" toml:"jwk_url,omitempty"`
	ClaimsFormat        *string                      `json:"claims_format,omitempty" toml:"claims_format,omitempty"`
	Audience            *string                      `json:"audience,omitempty" toml:"audience,omitempty"`
	Issuer              *string                      `json:"issuer,omitempty" toml:"issuer,omitempty"`
	AllowedSkew         *uint32                      `json:"allowed_skew,omitempty" toml:"allowed_skew,omitempty"`
	Header              *string                      `json:"header,omitempty" toml:"header,omitempty"`
	ClaimsMap           []*ConfigClaimMapInsertInput `json:"claims_map,omitempty" toml:"claims_map,omitempty"`
	ClaimsNamespace     *string                      `json:"claims_namespace,omitempty" toml:"claims_namespace,omitempty"`
	ClaimsNamespacePath *string                      `json:"claims_namespace_path,omitempty" toml:"claims_namespace_path,omitempty"`
}

func (o *ConfigJWTSecretInsertInput) GetType() *string {
	if o == nil {
		o = &ConfigJWTSecretInsertInput{}
	}
	return o.Type
}

func (o *ConfigJWTSecretInsertInput) GetKey() *string {
	if o == nil {
		o = &ConfigJWTSecretInsertInput{}
	}
	return o.Key
}

func (o *ConfigJWTSecretInsertInput) GetSigningKey() *string {
	if o == nil {
		o = &ConfigJWTSecretInsertInput{}
	}
	return o.SigningKey
}

func (o *ConfigJWTSecretInsertInput) GetKid() *string {
	if o == nil {
		o = &ConfigJWTSecretInsertInput{}
	}
	return o.Kid
}

func (o *ConfigJWTSecretInsertInput) GetJwkUrl() *string {
	if o == nil {
		o = &ConfigJWTSecretInsertInput{}
	}
	return o.JwkUrl
}

func (o *ConfigJWTSecretInsertInput) GetClaimsFormat() *string {
	if o == nil {
		o = &ConfigJWTSecretInsertInput{}
	}
	return o.ClaimsFormat
}

func (o *ConfigJWTSecretInsertInput) GetAudience() *string {
	if o == nil {
		o = &ConfigJWTSecretInsertInput{}
	}
	return o.Audience
}

func (o *ConfigJWTSecretInsertInput) GetIssuer() *string {
	if o == nil {
		o = &ConfigJWTSecretInsertInput{}
	}
	return o.Issuer
}

func (o *ConfigJWTSecretInsertInput) GetAllowedSkew() *uint32 {
	if o == nil {
		o = &ConfigJWTSecretInsertInput{}
	}
	return o.AllowedSkew
}

func (o *ConfigJWTSecretInsertInput) GetHeader() *string {
	if o == nil {
		o = &ConfigJWTSecretInsertInput{}
	}
	return o.Header
}

func (o *ConfigJWTSecretInsertInput) GetClaimsMap() []*ConfigClaimMapInsertInput {
	if o == nil {
		o = &ConfigJWTSecretInsertInput{}
	}
	return o.ClaimsMap
}

func (o *ConfigJWTSecretInsertInput) GetClaimsNamespace() *string {
	if o == nil {
		o = &ConfigJWTSecretInsertInput{}
	}
	return o.ClaimsNamespace
}

func (o *ConfigJWTSecretInsertInput) GetClaimsNamespacePath() *string {
	if o == nil {
		o = &ConfigJWTSecretInsertInput{}
	}
	return o.ClaimsNamespacePath
}

func (s *ConfigJWTSecret) Insert(v *ConfigJWTSecretInsertInput) {
	s.Type = v.Type
	s.Key = v.Key
	s.SigningKey = v.SigningKey
	s.Kid = v.Kid
	s.JwkUrl = v.JwkUrl
	s.ClaimsFormat = v.ClaimsFormat
	s.Audience = v.Audience
	s.Issuer = v.Issuer
	s.AllowedSkew = v.AllowedSkew
	s.Header = v.Header
	if v.ClaimsMap != nil {
		s.ClaimsMap = make([]*ConfigClaimMap, len(v.ClaimsMap))
		for i, e := range v.ClaimsMap {
			v := &ConfigClaimMap{}
			v.Insert(e)
			s.ClaimsMap[i] = v
		}
	}
	s.ClaimsNamespace = v.ClaimsNamespace
	s.ClaimsNamespacePath = v.ClaimsNamespacePath
}

func (s *ConfigJWTSecret) Clone() *ConfigJWTSecret {
	if s == nil {
		return nil
	}

	v := &ConfigJWTSecret{}
	v.Type = s.Type
	v.Key = s.Key
	v.SigningKey = s.SigningKey
	v.Kid = s.Kid
	v.JwkUrl = s.JwkUrl
	v.ClaimsFormat = s.ClaimsFormat
	v.Audience = s.Audience
	v.Issuer = s.Issuer
	v.AllowedSkew = s.AllowedSkew
	v.Header = s.Header
	if s.ClaimsMap != nil {
		v.ClaimsMap = make([]*ConfigClaimMap, len(s.ClaimsMap))
		for i, e := range s.ClaimsMap {
			v.ClaimsMap[i] = e.Clone()
		}
	}
	v.ClaimsNamespace = s.ClaimsNamespace
	v.ClaimsNamespacePath = s.ClaimsNamespacePath
	return v
}

type ConfigJWTSecretComparisonExp struct {
	And                 []*ConfigJWTSecretComparisonExp `json:"_and,omitempty"`
	Not                 *ConfigJWTSecretComparisonExp   `json:"_not,omitempty"`
	Or                  []*ConfigJWTSecretComparisonExp `json:"_or,omitempty"`
	Type                *ConfigStringComparisonExp      `json:"type,omitempty"`
	Key                 *ConfigStringComparisonExp      `json:"key,omitempty"`
	SigningKey          *ConfigStringComparisonExp      `json:"signingKey,omitempty"`
	Kid                 *ConfigStringComparisonExp      `json:"kid,omitempty"`
	JwkUrl              *ConfigUrlComparisonExp         `json:"jwk_url,omitempty"`
	ClaimsFormat        *ConfigStringComparisonExp      `json:"claims_format,omitempty"`
	Audience            *ConfigStringComparisonExp      `json:"audience,omitempty"`
	Issuer              *ConfigStringComparisonExp      `json:"issuer,omitempty"`
	AllowedSkew         *ConfigUint32ComparisonExp      `json:"allowed_skew,omitempty"`
	Header              *ConfigStringComparisonExp      `json:"header,omitempty"`
	ClaimsMap           *ConfigClaimMapComparisonExp    `json:"claims_map,omitempty"`
	ClaimsNamespace     *ConfigStringComparisonExp      `json:"claims_namespace,omitempty"`
	ClaimsNamespacePath *ConfigStringComparisonExp      `json:"claims_namespace_path,omitempty"`
}

func (exp *ConfigJWTSecretComparisonExp) Matches(o *ConfigJWTSecret) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigJWTSecret{
			ClaimsMap: []*ConfigClaimMap{},
		}
	}
	if o.Type != nil && !exp.Type.Matches(*o.Type) {
		return false
	}
	if o.Key != nil && !exp.Key.Matches(*o.Key) {
		return false
	}
	if o.SigningKey != nil && !exp.SigningKey.Matches(*o.SigningKey) {
		return false
	}
	if o.Kid != nil && !exp.Kid.Matches(*o.Kid) {
		return false
	}
	if o.JwkUrl != nil && !exp.JwkUrl.Matches(*o.JwkUrl) {
		return false
	}
	if o.ClaimsFormat != nil && !exp.ClaimsFormat.Matches(*o.ClaimsFormat) {
		return false
	}
	if o.Audience != nil && !exp.Audience.Matches(*o.Audience) {
		return false
	}
	if o.Issuer != nil && !exp.Issuer.Matches(*o.Issuer) {
		return false
	}
	if o.AllowedSkew != nil && !exp.AllowedSkew.Matches(*o.AllowedSkew) {
		return false
	}
	if o.Header != nil && !exp.Header.Matches(*o.Header) {
		return false
	}
	{
		found := false
		for _, o := range o.ClaimsMap {
			if exp.ClaimsMap.Matches(o) {
				found = true
				break
			}
		}
		if !found && exp.ClaimsMap != nil {
			return false
		}
	}
	if o.ClaimsNamespace != nil && !exp.ClaimsNamespace.Matches(*o.ClaimsNamespace) {
		return false
	}
	if o.ClaimsNamespacePath != nil && !exp.ClaimsNamespacePath.Matches(*o.ClaimsNamespacePath) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigLocaleComparisonExp struct {
	Eq  *string  `json:"_eq,omitempty"`
	Neq *string  `json:"_neq,omitempty"`
	In  []string `json:"_in,omitempty"`
	Nin []string `json:"_nin,omitempty"`
}

func (exp *ConfigLocaleComparisonExp) Matches(o string) bool {
	if exp == nil {
		return true
	}

	if exp.Eq != nil && *exp.Eq != o {
		return false
	}

	if exp.Neq != nil && *exp.Neq == o {
		return false
	}

	if exp.In != nil && !contains(exp.In, o) {
		return false
	}

	if exp.Nin != nil && contains(exp.Nin, o) {
		return false
	}

	return true
}

type ConfigNetworking struct {
	Ingresses []*ConfigIngress `json:"ingresses,omitempty" toml:"ingresses,omitempty"`
}

func (o *ConfigNetworking) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Ingresses != nil {
		m["ingresses"] = o.Ingresses
	}
	return json.Marshal(m)
}

func (o *ConfigNetworking) GetIngresses() []*ConfigIngress {
	if o == nil {
		o = &ConfigNetworking{}
	}
	return o.Ingresses
}

type ConfigNetworkingUpdateInput struct {
	Ingresses      []*ConfigIngressUpdateInput `json:"ingresses,omitempty" toml:"ingresses,omitempty"`
	IsSetIngresses bool                        `json:"-"`
}

func (o *ConfigNetworkingUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["ingresses"]; ok {
		if v != nil {
			x, ok := v.([]interface{})
			if !ok {
				return fmt.Errorf("Ingresses must be []interface{}, got %T", v)
			}

			l := make([]*ConfigIngressUpdateInput, len(x))
			for i, vv := range x {
				t := &ConfigIngressUpdateInput{}
				if err := t.UnmarshalGQL(vv); err != nil {
					return err
				}
				l[i] = t
			}
			o.Ingresses = l
		}
		o.IsSetIngresses = true
	}

	return nil
}

func (o *ConfigNetworkingUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigNetworkingUpdateInput) GetIngresses() []*ConfigIngressUpdateInput {
	if o == nil {
		o = &ConfigNetworkingUpdateInput{}
	}
	return o.Ingresses
}

func (s *ConfigNetworking) Update(v *ConfigNetworkingUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetIngresses || v.Ingresses != nil {
		if v.Ingresses == nil {
			s.Ingresses = nil
		} else {
			s.Ingresses = make([]*ConfigIngress, len(v.Ingresses))
			for i, e := range v.Ingresses {
				v := &ConfigIngress{}
				v.Update(e)
				s.Ingresses[i] = v
			}
		}
	}
}

type ConfigNetworkingInsertInput struct {
	Ingresses []*ConfigIngressInsertInput `json:"ingresses,omitempty" toml:"ingresses,omitempty"`
}

func (o *ConfigNetworkingInsertInput) GetIngresses() []*ConfigIngressInsertInput {
	if o == nil {
		o = &ConfigNetworkingInsertInput{}
	}
	return o.Ingresses
}

func (s *ConfigNetworking) Insert(v *ConfigNetworkingInsertInput) {
	if v.Ingresses != nil {
		s.Ingresses = make([]*ConfigIngress, len(v.Ingresses))
		for i, e := range v.Ingresses {
			v := &ConfigIngress{}
			v.Insert(e)
			s.Ingresses[i] = v
		}
	}
}

func (s *ConfigNetworking) Clone() *ConfigNetworking {
	if s == nil {
		return nil
	}

	v := &ConfigNetworking{}
	if s.Ingresses != nil {
		v.Ingresses = make([]*ConfigIngress, len(s.Ingresses))
		for i, e := range s.Ingresses {
			v.Ingresses[i] = e.Clone()
		}
	}
	return v
}

type ConfigNetworkingComparisonExp struct {
	And       []*ConfigNetworkingComparisonExp `json:"_and,omitempty"`
	Not       *ConfigNetworkingComparisonExp   `json:"_not,omitempty"`
	Or        []*ConfigNetworkingComparisonExp `json:"_or,omitempty"`
	Ingresses *ConfigIngressComparisonExp      `json:"ingresses,omitempty"`
}

func (exp *ConfigNetworkingComparisonExp) Matches(o *ConfigNetworking) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigNetworking{
			Ingresses: []*ConfigIngress{},
		}
	}
	{
		found := false
		for _, o := range o.Ingresses {
			if exp.Ingresses.Matches(o) {
				found = true
				break
			}
		}
		if !found && exp.Ingresses != nil {
			return false
		}
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigObservability struct {
	Grafana *ConfigGrafana `json:"grafana,omitempty" toml:"grafana,omitempty"`
}

func (o *ConfigObservability) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Grafana != nil {
		m["grafana"] = o.Grafana
	}
	return json.Marshal(m)
}

func (o *ConfigObservability) GetGrafana() *ConfigGrafana {
	if o == nil {
		return nil
	}
	return o.Grafana
}

type ConfigObservabilityUpdateInput struct {
	Grafana      *ConfigGrafanaUpdateInput `json:"grafana,omitempty" toml:"grafana,omitempty"`
	IsSetGrafana bool                      `json:"-"`
}

func (o *ConfigObservabilityUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if x, ok := m["grafana"]; ok {
		if x != nil {
			t := &ConfigGrafanaUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Grafana = t
		}
		o.IsSetGrafana = true
	}

	return nil
}

func (o *ConfigObservabilityUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigObservabilityUpdateInput) GetGrafana() *ConfigGrafanaUpdateInput {
	if o == nil {
		return nil
	}
	return o.Grafana
}

func (s *ConfigObservability) Update(v *ConfigObservabilityUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetGrafana || v.Grafana != nil {
		if v.Grafana == nil {
			s.Grafana = nil
		} else {
			if s.Grafana == nil {
				s.Grafana = &ConfigGrafana{}
			}
			s.Grafana.Update(v.Grafana)
		}
	}
}

type ConfigObservabilityInsertInput struct {
	Grafana *ConfigGrafanaInsertInput `json:"grafana,omitempty" toml:"grafana,omitempty"`
}

func (o *ConfigObservabilityInsertInput) GetGrafana() *ConfigGrafanaInsertInput {
	if o == nil {
		return nil
	}
	return o.Grafana
}

func (s *ConfigObservability) Insert(v *ConfigObservabilityInsertInput) {
	if v.Grafana != nil {
		if s.Grafana == nil {
			s.Grafana = &ConfigGrafana{}
		}
		s.Grafana.Insert(v.Grafana)
	}
}

func (s *ConfigObservability) Clone() *ConfigObservability {
	if s == nil {
		return nil
	}

	v := &ConfigObservability{}
	v.Grafana = s.Grafana.Clone()
	return v
}

type ConfigObservabilityComparisonExp struct {
	And     []*ConfigObservabilityComparisonExp `json:"_and,omitempty"`
	Not     *ConfigObservabilityComparisonExp   `json:"_not,omitempty"`
	Or      []*ConfigObservabilityComparisonExp `json:"_or,omitempty"`
	Grafana *ConfigGrafanaComparisonExp         `json:"grafana,omitempty"`
}

func (exp *ConfigObservabilityComparisonExp) Matches(o *ConfigObservability) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigObservability{
			Grafana: &ConfigGrafana{},
		}
	}
	if !exp.Grafana.Matches(o.Grafana) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigPortComparisonExp struct {
	Eq  *uint16  `json:"_eq,omitempty"`
	Neq *uint16  `json:"_neq,omitempty"`
	In  []uint16 `json:"_in,omitempty"`
	Nin []uint16 `json:"_nin,omitempty"`
}

func (exp *ConfigPortComparisonExp) Matches(o uint16) bool {
	if exp == nil {
		return true
	}

	if exp.Eq != nil && *exp.Eq != o {
		return false
	}

	if exp.Neq != nil && *exp.Neq == o {
		return false
	}

	if exp.In != nil && !contains(exp.In, o) {
		return false
	}

	if exp.Nin != nil && contains(exp.Nin, o) {
		return false
	}

	return true
}

// Configuration for postgres service
type ConfigPostgres struct {
	// Version of postgres, you can see available versions in the URL below:
	// https://hub.docker.com/r/nhost/postgres/tags
	Version *string `json:"version" toml:"version"`
	// Resources for the service
	Resources *ConfigPostgresResources `json:"resources,omitempty" toml:"resources,omitempty"`

	Settings *ConfigPostgresSettings `json:"settings,omitempty" toml:"settings,omitempty"`
}

func (o *ConfigPostgres) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Version != nil {
		m["version"] = o.Version
	}
	if o.Resources != nil {
		m["resources"] = o.Resources
	}
	if o.Settings != nil {
		m["settings"] = o.Settings
	}
	return json.Marshal(m)
}

func (o *ConfigPostgres) GetVersion() *string {
	if o == nil {
		o = &ConfigPostgres{}
	}
	return o.Version
}

func (o *ConfigPostgres) GetResources() *ConfigPostgresResources {
	if o == nil {
		return nil
	}
	return o.Resources
}

func (o *ConfigPostgres) GetSettings() *ConfigPostgresSettings {
	if o == nil {
		return nil
	}
	return o.Settings
}

type ConfigPostgresUpdateInput struct {
	Version        *string                             `json:"version,omitempty" toml:"version,omitempty"`
	IsSetVersion   bool                                `json:"-"`
	Resources      *ConfigPostgresResourcesUpdateInput `json:"resources,omitempty" toml:"resources,omitempty"`
	IsSetResources bool                                `json:"-"`
	Settings       *ConfigPostgresSettingsUpdateInput  `json:"settings,omitempty" toml:"settings,omitempty"`
	IsSetSettings  bool                                `json:"-"`
}

func (o *ConfigPostgresUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["version"]; ok {
		if v == nil {
			o.Version = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Version = &x
		}
		o.IsSetVersion = true
	}
	if x, ok := m["resources"]; ok {
		if x != nil {
			t := &ConfigPostgresResourcesUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Resources = t
		}
		o.IsSetResources = true
	}
	if x, ok := m["settings"]; ok {
		if x != nil {
			t := &ConfigPostgresSettingsUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Settings = t
		}
		o.IsSetSettings = true
	}

	return nil
}

func (o *ConfigPostgresUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigPostgresUpdateInput) GetVersion() *string {
	if o == nil {
		o = &ConfigPostgresUpdateInput{}
	}
	return o.Version
}

func (o *ConfigPostgresUpdateInput) GetResources() *ConfigPostgresResourcesUpdateInput {
	if o == nil {
		return nil
	}
	return o.Resources
}

func (o *ConfigPostgresUpdateInput) GetSettings() *ConfigPostgresSettingsUpdateInput {
	if o == nil {
		return nil
	}
	return o.Settings
}

func (s *ConfigPostgres) Update(v *ConfigPostgresUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetVersion || v.Version != nil {
		s.Version = v.Version
	}
	if v.IsSetResources || v.Resources != nil {
		if v.Resources == nil {
			s.Resources = nil
		} else {
			if s.Resources == nil {
				s.Resources = &ConfigPostgresResources{}
			}
			s.Resources.Update(v.Resources)
		}
	}
	if v.IsSetSettings || v.Settings != nil {
		if v.Settings == nil {
			s.Settings = nil
		} else {
			if s.Settings == nil {
				s.Settings = &ConfigPostgresSettings{}
			}
			s.Settings.Update(v.Settings)
		}
	}
}

type ConfigPostgresInsertInput struct {
	Version   *string                             `json:"version,omitempty" toml:"version,omitempty"`
	Resources *ConfigPostgresResourcesInsertInput `json:"resources,omitempty" toml:"resources,omitempty"`
	Settings  *ConfigPostgresSettingsInsertInput  `json:"settings,omitempty" toml:"settings,omitempty"`
}

func (o *ConfigPostgresInsertInput) GetVersion() *string {
	if o == nil {
		o = &ConfigPostgresInsertInput{}
	}
	return o.Version
}

func (o *ConfigPostgresInsertInput) GetResources() *ConfigPostgresResourcesInsertInput {
	if o == nil {
		return nil
	}
	return o.Resources
}

func (o *ConfigPostgresInsertInput) GetSettings() *ConfigPostgresSettingsInsertInput {
	if o == nil {
		return nil
	}
	return o.Settings
}

func (s *ConfigPostgres) Insert(v *ConfigPostgresInsertInput) {
	s.Version = v.Version
	if v.Resources != nil {
		if s.Resources == nil {
			s.Resources = &ConfigPostgresResources{}
		}
		s.Resources.Insert(v.Resources)
	}
	if v.Settings != nil {
		if s.Settings == nil {
			s.Settings = &ConfigPostgresSettings{}
		}
		s.Settings.Insert(v.Settings)
	}
}

func (s *ConfigPostgres) Clone() *ConfigPostgres {
	if s == nil {
		return nil
	}

	v := &ConfigPostgres{}
	v.Version = s.Version
	v.Resources = s.Resources.Clone()
	v.Settings = s.Settings.Clone()
	return v
}

type ConfigPostgresComparisonExp struct {
	And       []*ConfigPostgresComparisonExp        `json:"_and,omitempty"`
	Not       *ConfigPostgresComparisonExp          `json:"_not,omitempty"`
	Or        []*ConfigPostgresComparisonExp        `json:"_or,omitempty"`
	Version   *ConfigStringComparisonExp            `json:"version,omitempty"`
	Resources *ConfigPostgresResourcesComparisonExp `json:"resources,omitempty"`
	Settings  *ConfigPostgresSettingsComparisonExp  `json:"settings,omitempty"`
}

func (exp *ConfigPostgresComparisonExp) Matches(o *ConfigPostgres) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigPostgres{
			Resources: &ConfigPostgresResources{},
			Settings:  &ConfigPostgresSettings{},
		}
	}
	if o.Version != nil && !exp.Version.Matches(*o.Version) {
		return false
	}
	if !exp.Resources.Matches(o.Resources) {
		return false
	}
	if !exp.Settings.Matches(o.Settings) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

// Resources for the service
type ConfigPostgresResources struct {
	Compute *ConfigResourcesCompute `json:"compute,omitempty" toml:"compute,omitempty"`
	// Number of replicas for a service
	Replicas *uint8 `json:"replicas" toml:"replicas"`

	Autoscaler *ConfigAutoscaler `json:"autoscaler,omitempty" toml:"autoscaler,omitempty"`

	Networking *ConfigNetworking `json:"networking,omitempty" toml:"networking,omitempty"`

	Storage *ConfigPostgresStorage `json:"storage,omitempty" toml:"storage,omitempty"`

	EnablePublicAccess *bool `json:"enablePublicAccess" toml:"enablePublicAccess"`
}

func (o *ConfigPostgresResources) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Compute != nil {
		m["compute"] = o.Compute
	}
	if o.Replicas != nil {
		m["replicas"] = o.Replicas
	}
	if o.Autoscaler != nil {
		m["autoscaler"] = o.Autoscaler
	}
	if o.Networking != nil {
		m["networking"] = o.Networking
	}
	if o.Storage != nil {
		m["storage"] = o.Storage
	}
	if o.EnablePublicAccess != nil {
		m["enablePublicAccess"] = o.EnablePublicAccess
	}
	return json.Marshal(m)
}

func (o *ConfigPostgresResources) GetCompute() *ConfigResourcesCompute {
	if o == nil {
		return nil
	}
	return o.Compute
}

func (o *ConfigPostgresResources) GetReplicas() *uint8 {
	if o == nil {
		o = &ConfigPostgresResources{}
	}
	return o.Replicas
}

func (o *ConfigPostgresResources) GetAutoscaler() *ConfigAutoscaler {
	if o == nil {
		return nil
	}
	return o.Autoscaler
}

func (o *ConfigPostgresResources) GetNetworking() *ConfigNetworking {
	if o == nil {
		return nil
	}
	return o.Networking
}

func (o *ConfigPostgresResources) GetStorage() *ConfigPostgresStorage {
	if o == nil {
		return nil
	}
	return o.Storage
}

func (o *ConfigPostgresResources) GetEnablePublicAccess() *bool {
	if o == nil {
		o = &ConfigPostgresResources{}
	}
	return o.EnablePublicAccess
}

type ConfigPostgresResourcesUpdateInput struct {
	Compute                 *ConfigResourcesComputeUpdateInput `json:"compute,omitempty" toml:"compute,omitempty"`
	IsSetCompute            bool                               `json:"-"`
	Replicas                *uint8                             `json:"replicas,omitempty" toml:"replicas,omitempty"`
	IsSetReplicas           bool                               `json:"-"`
	Autoscaler              *ConfigAutoscalerUpdateInput       `json:"autoscaler,omitempty" toml:"autoscaler,omitempty"`
	IsSetAutoscaler         bool                               `json:"-"`
	Networking              *ConfigNetworkingUpdateInput       `json:"networking,omitempty" toml:"networking,omitempty"`
	IsSetNetworking         bool                               `json:"-"`
	Storage                 *ConfigPostgresStorageUpdateInput  `json:"storage,omitempty" toml:"storage,omitempty"`
	IsSetStorage            bool                               `json:"-"`
	EnablePublicAccess      *bool                              `json:"enablePublicAccess,omitempty" toml:"enablePublicAccess,omitempty"`
	IsSetEnablePublicAccess bool                               `json:"-"`
}

func (o *ConfigPostgresResourcesUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if x, ok := m["compute"]; ok {
		if x != nil {
			t := &ConfigResourcesComputeUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Compute = t
		}
		o.IsSetCompute = true
	}
	if v, ok := m["replicas"]; ok {
		if v == nil {
			o.Replicas = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x uint8
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Replicas = &x
		}
		o.IsSetReplicas = true
	}
	if x, ok := m["autoscaler"]; ok {
		if x != nil {
			t := &ConfigAutoscalerUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Autoscaler = t
		}
		o.IsSetAutoscaler = true
	}
	if x, ok := m["networking"]; ok {
		if x != nil {
			t := &ConfigNetworkingUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Networking = t
		}
		o.IsSetNetworking = true
	}
	if x, ok := m["storage"]; ok {
		if x != nil {
			t := &ConfigPostgresStorageUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Storage = t
		}
		o.IsSetStorage = true
	}
	if v, ok := m["enablePublicAccess"]; ok {
		if v == nil {
			o.EnablePublicAccess = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x bool
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.EnablePublicAccess = &x
		}
		o.IsSetEnablePublicAccess = true
	}

	return nil
}

func (o *ConfigPostgresResourcesUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigPostgresResourcesUpdateInput) GetCompute() *ConfigResourcesComputeUpdateInput {
	if o == nil {
		return nil
	}
	return o.Compute
}

func (o *ConfigPostgresResourcesUpdateInput) GetReplicas() *uint8 {
	if o == nil {
		o = &ConfigPostgresResourcesUpdateInput{}
	}
	return o.Replicas
}

func (o *ConfigPostgresResourcesUpdateInput) GetAutoscaler() *ConfigAutoscalerUpdateInput {
	if o == nil {
		return nil
	}
	return o.Autoscaler
}

func (o *ConfigPostgresResourcesUpdateInput) GetNetworking() *ConfigNetworkingUpdateInput {
	if o == nil {
		return nil
	}
	return o.Networking
}

func (o *ConfigPostgresResourcesUpdateInput) GetStorage() *ConfigPostgresStorageUpdateInput {
	if o == nil {
		return nil
	}
	return o.Storage
}

func (o *ConfigPostgresResourcesUpdateInput) GetEnablePublicAccess() *bool {
	if o == nil {
		o = &ConfigPostgresResourcesUpdateInput{}
	}
	return o.EnablePublicAccess
}

func (s *ConfigPostgresResources) Update(v *ConfigPostgresResourcesUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetCompute || v.Compute != nil {
		if v.Compute == nil {
			s.Compute = nil
		} else {
			if s.Compute == nil {
				s.Compute = &ConfigResourcesCompute{}
			}
			s.Compute.Update(v.Compute)
		}
	}
	if v.IsSetReplicas || v.Replicas != nil {
		s.Replicas = v.Replicas
	}
	if v.IsSetAutoscaler || v.Autoscaler != nil {
		if v.Autoscaler == nil {
			s.Autoscaler = nil
		} else {
			if s.Autoscaler == nil {
				s.Autoscaler = &ConfigAutoscaler{}
			}
			s.Autoscaler.Update(v.Autoscaler)
		}
	}
	if v.IsSetNetworking || v.Networking != nil {
		if v.Networking == nil {
			s.Networking = nil
		} else {
			if s.Networking == nil {
				s.Networking = &ConfigNetworking{}
			}
			s.Networking.Update(v.Networking)
		}
	}
	if v.IsSetStorage || v.Storage != nil {
		if v.Storage == nil {
			s.Storage = nil
		} else {
			if s.Storage == nil {
				s.Storage = &ConfigPostgresStorage{}
			}
			s.Storage.Update(v.Storage)
		}
	}
	if v.IsSetEnablePublicAccess || v.EnablePublicAccess != nil {
		s.EnablePublicAccess = v.EnablePublicAccess
	}
}

type ConfigPostgresResourcesInsertInput struct {
	Compute            *ConfigResourcesComputeInsertInput `json:"compute,omitempty" toml:"compute,omitempty"`
	Replicas           *uint8                             `json:"replicas,omitempty" toml:"replicas,omitempty"`
	Autoscaler         *ConfigAutoscalerInsertInput       `json:"autoscaler,omitempty" toml:"autoscaler,omitempty"`
	Networking         *ConfigNetworkingInsertInput       `json:"networking,omitempty" toml:"networking,omitempty"`
	Storage            *ConfigPostgresStorageInsertInput  `json:"storage,omitempty" toml:"storage,omitempty"`
	EnablePublicAccess *bool                              `json:"enablePublicAccess,omitempty" toml:"enablePublicAccess,omitempty"`
}

func (o *ConfigPostgresResourcesInsertInput) GetCompute() *ConfigResourcesComputeInsertInput {
	if o == nil {
		return nil
	}
	return o.Compute
}

func (o *ConfigPostgresResourcesInsertInput) GetReplicas() *uint8 {
	if o == nil {
		o = &ConfigPostgresResourcesInsertInput{}
	}
	return o.Replicas
}

func (o *ConfigPostgresResourcesInsertInput) GetAutoscaler() *ConfigAutoscalerInsertInput {
	if o == nil {
		return nil
	}
	return o.Autoscaler
}

func (o *ConfigPostgresResourcesInsertInput) GetNetworking() *ConfigNetworkingInsertInput {
	if o == nil {
		return nil
	}
	return o.Networking
}

func (o *ConfigPostgresResourcesInsertInput) GetStorage() *ConfigPostgresStorageInsertInput {
	if o == nil {
		return nil
	}
	return o.Storage
}

func (o *ConfigPostgresResourcesInsertInput) GetEnablePublicAccess() *bool {
	if o == nil {
		o = &ConfigPostgresResourcesInsertInput{}
	}
	return o.EnablePublicAccess
}

func (s *ConfigPostgresResources) Insert(v *ConfigPostgresResourcesInsertInput) {
	if v.Compute != nil {
		if s.Compute == nil {
			s.Compute = &ConfigResourcesCompute{}
		}
		s.Compute.Insert(v.Compute)
	}
	s.Replicas = v.Replicas
	if v.Autoscaler != nil {
		if s.Autoscaler == nil {
			s.Autoscaler = &ConfigAutoscaler{}
		}
		s.Autoscaler.Insert(v.Autoscaler)
	}
	if v.Networking != nil {
		if s.Networking == nil {
			s.Networking = &ConfigNetworking{}
		}
		s.Networking.Insert(v.Networking)
	}
	if v.Storage != nil {
		if s.Storage == nil {
			s.Storage = &ConfigPostgresStorage{}
		}
		s.Storage.Insert(v.Storage)
	}
	s.EnablePublicAccess = v.EnablePublicAccess
}

func (s *ConfigPostgresResources) Clone() *ConfigPostgresResources {
	if s == nil {
		return nil
	}

	v := &ConfigPostgresResources{}
	v.Compute = s.Compute.Clone()
	v.Replicas = s.Replicas
	v.Autoscaler = s.Autoscaler.Clone()
	v.Networking = s.Networking.Clone()
	v.Storage = s.Storage.Clone()
	v.EnablePublicAccess = s.EnablePublicAccess
	return v
}

type ConfigPostgresResourcesComparisonExp struct {
	And                []*ConfigPostgresResourcesComparisonExp `json:"_and,omitempty"`
	Not                *ConfigPostgresResourcesComparisonExp   `json:"_not,omitempty"`
	Or                 []*ConfigPostgresResourcesComparisonExp `json:"_or,omitempty"`
	Compute            *ConfigResourcesComputeComparisonExp    `json:"compute,omitempty"`
	Replicas           *ConfigUint8ComparisonExp               `json:"replicas,omitempty"`
	Autoscaler         *ConfigAutoscalerComparisonExp          `json:"autoscaler,omitempty"`
	Networking         *ConfigNetworkingComparisonExp          `json:"networking,omitempty"`
	Storage            *ConfigPostgresStorageComparisonExp     `json:"storage,omitempty"`
	EnablePublicAccess *ConfigBooleanComparisonExp             `json:"enablePublicAccess,omitempty"`
}

func (exp *ConfigPostgresResourcesComparisonExp) Matches(o *ConfigPostgresResources) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigPostgresResources{
			Compute:    &ConfigResourcesCompute{},
			Autoscaler: &ConfigAutoscaler{},
			Networking: &ConfigNetworking{},
			Storage:    &ConfigPostgresStorage{},
		}
	}
	if !exp.Compute.Matches(o.Compute) {
		return false
	}
	if o.Replicas != nil && !exp.Replicas.Matches(*o.Replicas) {
		return false
	}
	if !exp.Autoscaler.Matches(o.Autoscaler) {
		return false
	}
	if !exp.Networking.Matches(o.Networking) {
		return false
	}
	if !exp.Storage.Matches(o.Storage) {
		return false
	}
	if o.EnablePublicAccess != nil && !exp.EnablePublicAccess.Matches(*o.EnablePublicAccess) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigPostgresSettings struct {
	Jit *string `json:"jit" toml:"jit"`

	MaxConnections *int32 `json:"maxConnections" toml:"maxConnections"`

	SharedBuffers *string `json:"sharedBuffers" toml:"sharedBuffers"`

	EffectiveCacheSize *string `json:"effectiveCacheSize" toml:"effectiveCacheSize"`

	MaintenanceWorkMem *string `json:"maintenanceWorkMem" toml:"maintenanceWorkMem"`

	CheckpointCompletionTarget *float64 `json:"checkpointCompletionTarget" toml:"checkpointCompletionTarget"`

	WalBuffers *string `json:"walBuffers" toml:"walBuffers"`

	DefaultStatisticsTarget *int32 `json:"defaultStatisticsTarget" toml:"defaultStatisticsTarget"`

	RandomPageCost *float64 `json:"randomPageCost" toml:"randomPageCost"`

	EffectiveIOConcurrency *int32 `json:"effectiveIOConcurrency" toml:"effectiveIOConcurrency"`

	WorkMem *string `json:"workMem" toml:"workMem"`

	HugePages *string `json:"hugePages" toml:"hugePages"`

	MinWalSize *string `json:"minWalSize" toml:"minWalSize"`

	MaxWalSize *string `json:"maxWalSize" toml:"maxWalSize"`

	MaxWorkerProcesses *int32 `json:"maxWorkerProcesses" toml:"maxWorkerProcesses"`

	MaxParallelWorkersPerGather *int32 `json:"maxParallelWorkersPerGather" toml:"maxParallelWorkersPerGather"`

	MaxParallelWorkers *int32 `json:"maxParallelWorkers" toml:"maxParallelWorkers"`

	MaxParallelMaintenanceWorkers *int32 `json:"maxParallelMaintenanceWorkers" toml:"maxParallelMaintenanceWorkers"`

	WalLevel *string `json:"walLevel" toml:"walLevel"`

	MaxWalSenders *int32 `json:"maxWalSenders" toml:"maxWalSenders"`

	MaxReplicationSlots *int32 `json:"maxReplicationSlots" toml:"maxReplicationSlots"`
}

func (o *ConfigPostgresSettings) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Jit != nil {
		m["jit"] = o.Jit
	}
	if o.MaxConnections != nil {
		m["maxConnections"] = o.MaxConnections
	}
	if o.SharedBuffers != nil {
		m["sharedBuffers"] = o.SharedBuffers
	}
	if o.EffectiveCacheSize != nil {
		m["effectiveCacheSize"] = o.EffectiveCacheSize
	}
	if o.MaintenanceWorkMem != nil {
		m["maintenanceWorkMem"] = o.MaintenanceWorkMem
	}
	if o.CheckpointCompletionTarget != nil {
		m["checkpointCompletionTarget"] = o.CheckpointCompletionTarget
	}
	if o.WalBuffers != nil {
		m["walBuffers"] = o.WalBuffers
	}
	if o.DefaultStatisticsTarget != nil {
		m["defaultStatisticsTarget"] = o.DefaultStatisticsTarget
	}
	if o.RandomPageCost != nil {
		m["randomPageCost"] = o.RandomPageCost
	}
	if o.EffectiveIOConcurrency != nil {
		m["effectiveIOConcurrency"] = o.EffectiveIOConcurrency
	}
	if o.WorkMem != nil {
		m["workMem"] = o.WorkMem
	}
	if o.HugePages != nil {
		m["hugePages"] = o.HugePages
	}
	if o.MinWalSize != nil {
		m["minWalSize"] = o.MinWalSize
	}
	if o.MaxWalSize != nil {
		m["maxWalSize"] = o.MaxWalSize
	}
	if o.MaxWorkerProcesses != nil {
		m["maxWorkerProcesses"] = o.MaxWorkerProcesses
	}
	if o.MaxParallelWorkersPerGather != nil {
		m["maxParallelWorkersPerGather"] = o.MaxParallelWorkersPerGather
	}
	if o.MaxParallelWorkers != nil {
		m["maxParallelWorkers"] = o.MaxParallelWorkers
	}
	if o.MaxParallelMaintenanceWorkers != nil {
		m["maxParallelMaintenanceWorkers"] = o.MaxParallelMaintenanceWorkers
	}
	if o.WalLevel != nil {
		m["walLevel"] = o.WalLevel
	}
	if o.MaxWalSenders != nil {
		m["maxWalSenders"] = o.MaxWalSenders
	}
	if o.MaxReplicationSlots != nil {
		m["maxReplicationSlots"] = o.MaxReplicationSlots
	}
	return json.Marshal(m)
}

func (o *ConfigPostgresSettings) GetJit() *string {
	if o == nil {
		o = &ConfigPostgresSettings{}
	}
	return o.Jit
}

func (o *ConfigPostgresSettings) GetMaxConnections() *int32 {
	if o == nil {
		o = &ConfigPostgresSettings{}
	}
	return o.MaxConnections
}

func (o *ConfigPostgresSettings) GetSharedBuffers() *string {
	if o == nil {
		o = &ConfigPostgresSettings{}
	}
	return o.SharedBuffers
}

func (o *ConfigPostgresSettings) GetEffectiveCacheSize() *string {
	if o == nil {
		o = &ConfigPostgresSettings{}
	}
	return o.EffectiveCacheSize
}

func (o *ConfigPostgresSettings) GetMaintenanceWorkMem() *string {
	if o == nil {
		o = &ConfigPostgresSettings{}
	}
	return o.MaintenanceWorkMem
}

func (o *ConfigPostgresSettings) GetCheckpointCompletionTarget() *float64 {
	if o == nil {
		o = &ConfigPostgresSettings{}
	}
	return o.CheckpointCompletionTarget
}

func (o *ConfigPostgresSettings) GetWalBuffers() *string {
	if o == nil {
		o = &ConfigPostgresSettings{}
	}
	return o.WalBuffers
}

func (o *ConfigPostgresSettings) GetDefaultStatisticsTarget() *int32 {
	if o == nil {
		o = &ConfigPostgresSettings{}
	}
	return o.DefaultStatisticsTarget
}

func (o *ConfigPostgresSettings) GetRandomPageCost() *float64 {
	if o == nil {
		o = &ConfigPostgresSettings{}
	}
	return o.RandomPageCost
}

func (o *ConfigPostgresSettings) GetEffectiveIOConcurrency() *int32 {
	if o == nil {
		o = &ConfigPostgresSettings{}
	}
	return o.EffectiveIOConcurrency
}

func (o *ConfigPostgresSettings) GetWorkMem() *string {
	if o == nil {
		o = &ConfigPostgresSettings{}
	}
	return o.WorkMem
}

func (o *ConfigPostgresSettings) GetHugePages() *string {
	if o == nil {
		o = &ConfigPostgresSettings{}
	}
	return o.HugePages
}

func (o *ConfigPostgresSettings) GetMinWalSize() *string {
	if o == nil {
		o = &ConfigPostgresSettings{}
	}
	return o.MinWalSize
}

func (o *ConfigPostgresSettings) GetMaxWalSize() *string {
	if o == nil {
		o = &ConfigPostgresSettings{}
	}
	return o.MaxWalSize
}

func (o *ConfigPostgresSettings) GetMaxWorkerProcesses() *int32 {
	if o == nil {
		o = &ConfigPostgresSettings{}
	}
	return o.MaxWorkerProcesses
}

func (o *ConfigPostgresSettings) GetMaxParallelWorkersPerGather() *int32 {
	if o == nil {
		o = &ConfigPostgresSettings{}
	}
	return o.MaxParallelWorkersPerGather
}

func (o *ConfigPostgresSettings) GetMaxParallelWorkers() *int32 {
	if o == nil {
		o = &ConfigPostgresSettings{}
	}
	return o.MaxParallelWorkers
}

func (o *ConfigPostgresSettings) GetMaxParallelMaintenanceWorkers() *int32 {
	if o == nil {
		o = &ConfigPostgresSettings{}
	}
	return o.MaxParallelMaintenanceWorkers
}

func (o *ConfigPostgresSettings) GetWalLevel() *string {
	if o == nil {
		o = &ConfigPostgresSettings{}
	}
	return o.WalLevel
}

func (o *ConfigPostgresSettings) GetMaxWalSenders() *int32 {
	if o == nil {
		o = &ConfigPostgresSettings{}
	}
	return o.MaxWalSenders
}

func (o *ConfigPostgresSettings) GetMaxReplicationSlots() *int32 {
	if o == nil {
		o = &ConfigPostgresSettings{}
	}
	return o.MaxReplicationSlots
}

type ConfigPostgresSettingsUpdateInput struct {
	Jit                                *string  `json:"jit,omitempty" toml:"jit,omitempty"`
	IsSetJit                           bool     `json:"-"`
	MaxConnections                     *int32   `json:"maxConnections,omitempty" toml:"maxConnections,omitempty"`
	IsSetMaxConnections                bool     `json:"-"`
	SharedBuffers                      *string  `json:"sharedBuffers,omitempty" toml:"sharedBuffers,omitempty"`
	IsSetSharedBuffers                 bool     `json:"-"`
	EffectiveCacheSize                 *string  `json:"effectiveCacheSize,omitempty" toml:"effectiveCacheSize,omitempty"`
	IsSetEffectiveCacheSize            bool     `json:"-"`
	MaintenanceWorkMem                 *string  `json:"maintenanceWorkMem,omitempty" toml:"maintenanceWorkMem,omitempty"`
	IsSetMaintenanceWorkMem            bool     `json:"-"`
	CheckpointCompletionTarget         *float64 `json:"checkpointCompletionTarget,omitempty" toml:"checkpointCompletionTarget,omitempty"`
	IsSetCheckpointCompletionTarget    bool     `json:"-"`
	WalBuffers                         *string  `json:"walBuffers,omitempty" toml:"walBuffers,omitempty"`
	IsSetWalBuffers                    bool     `json:"-"`
	DefaultStatisticsTarget            *int32   `json:"defaultStatisticsTarget,omitempty" toml:"defaultStatisticsTarget,omitempty"`
	IsSetDefaultStatisticsTarget       bool     `json:"-"`
	RandomPageCost                     *float64 `json:"randomPageCost,omitempty" toml:"randomPageCost,omitempty"`
	IsSetRandomPageCost                bool     `json:"-"`
	EffectiveIOConcurrency             *int32   `json:"effectiveIOConcurrency,omitempty" toml:"effectiveIOConcurrency,omitempty"`
	IsSetEffectiveIOConcurrency        bool     `json:"-"`
	WorkMem                            *string  `json:"workMem,omitempty" toml:"workMem,omitempty"`
	IsSetWorkMem                       bool     `json:"-"`
	HugePages                          *string  `json:"hugePages,omitempty" toml:"hugePages,omitempty"`
	IsSetHugePages                     bool     `json:"-"`
	MinWalSize                         *string  `json:"minWalSize,omitempty" toml:"minWalSize,omitempty"`
	IsSetMinWalSize                    bool     `json:"-"`
	MaxWalSize                         *string  `json:"maxWalSize,omitempty" toml:"maxWalSize,omitempty"`
	IsSetMaxWalSize                    bool     `json:"-"`
	MaxWorkerProcesses                 *int32   `json:"maxWorkerProcesses,omitempty" toml:"maxWorkerProcesses,omitempty"`
	IsSetMaxWorkerProcesses            bool     `json:"-"`
	MaxParallelWorkersPerGather        *int32   `json:"maxParallelWorkersPerGather,omitempty" toml:"maxParallelWorkersPerGather,omitempty"`
	IsSetMaxParallelWorkersPerGather   bool     `json:"-"`
	MaxParallelWorkers                 *int32   `json:"maxParallelWorkers,omitempty" toml:"maxParallelWorkers,omitempty"`
	IsSetMaxParallelWorkers            bool     `json:"-"`
	MaxParallelMaintenanceWorkers      *int32   `json:"maxParallelMaintenanceWorkers,omitempty" toml:"maxParallelMaintenanceWorkers,omitempty"`
	IsSetMaxParallelMaintenanceWorkers bool     `json:"-"`
	WalLevel                           *string  `json:"walLevel,omitempty" toml:"walLevel,omitempty"`
	IsSetWalLevel                      bool     `json:"-"`
	MaxWalSenders                      *int32   `json:"maxWalSenders,omitempty" toml:"maxWalSenders,omitempty"`
	IsSetMaxWalSenders                 bool     `json:"-"`
	MaxReplicationSlots                *int32   `json:"maxReplicationSlots,omitempty" toml:"maxReplicationSlots,omitempty"`
	IsSetMaxReplicationSlots           bool     `json:"-"`
}

func (o *ConfigPostgresSettingsUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["jit"]; ok {
		if v == nil {
			o.Jit = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Jit = &x
		}
		o.IsSetJit = true
	}
	if v, ok := m["maxConnections"]; ok {
		if v == nil {
			o.MaxConnections = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x int32
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.MaxConnections = &x
		}
		o.IsSetMaxConnections = true
	}
	if v, ok := m["sharedBuffers"]; ok {
		if v == nil {
			o.SharedBuffers = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.SharedBuffers = &x
		}
		o.IsSetSharedBuffers = true
	}
	if v, ok := m["effectiveCacheSize"]; ok {
		if v == nil {
			o.EffectiveCacheSize = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.EffectiveCacheSize = &x
		}
		o.IsSetEffectiveCacheSize = true
	}
	if v, ok := m["maintenanceWorkMem"]; ok {
		if v == nil {
			o.MaintenanceWorkMem = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.MaintenanceWorkMem = &x
		}
		o.IsSetMaintenanceWorkMem = true
	}
	if v, ok := m["checkpointCompletionTarget"]; ok {
		if v == nil {
			o.CheckpointCompletionTarget = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x float64
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.CheckpointCompletionTarget = &x
		}
		o.IsSetCheckpointCompletionTarget = true
	}
	if v, ok := m["walBuffers"]; ok {
		if v == nil {
			o.WalBuffers = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.WalBuffers = &x
		}
		o.IsSetWalBuffers = true
	}
	if v, ok := m["defaultStatisticsTarget"]; ok {
		if v == nil {
			o.DefaultStatisticsTarget = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x int32
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.DefaultStatisticsTarget = &x
		}
		o.IsSetDefaultStatisticsTarget = true
	}
	if v, ok := m["randomPageCost"]; ok {
		if v == nil {
			o.RandomPageCost = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x float64
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.RandomPageCost = &x
		}
		o.IsSetRandomPageCost = true
	}
	if v, ok := m["effectiveIOConcurrency"]; ok {
		if v == nil {
			o.EffectiveIOConcurrency = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x int32
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.EffectiveIOConcurrency = &x
		}
		o.IsSetEffectiveIOConcurrency = true
	}
	if v, ok := m["workMem"]; ok {
		if v == nil {
			o.WorkMem = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.WorkMem = &x
		}
		o.IsSetWorkMem = true
	}
	if v, ok := m["hugePages"]; ok {
		if v == nil {
			o.HugePages = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.HugePages = &x
		}
		o.IsSetHugePages = true
	}
	if v, ok := m["minWalSize"]; ok {
		if v == nil {
			o.MinWalSize = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.MinWalSize = &x
		}
		o.IsSetMinWalSize = true
	}
	if v, ok := m["maxWalSize"]; ok {
		if v == nil {
			o.MaxWalSize = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.MaxWalSize = &x
		}
		o.IsSetMaxWalSize = true
	}
	if v, ok := m["maxWorkerProcesses"]; ok {
		if v == nil {
			o.MaxWorkerProcesses = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x int32
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.MaxWorkerProcesses = &x
		}
		o.IsSetMaxWorkerProcesses = true
	}
	if v, ok := m["maxParallelWorkersPerGather"]; ok {
		if v == nil {
			o.MaxParallelWorkersPerGather = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x int32
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.MaxParallelWorkersPerGather = &x
		}
		o.IsSetMaxParallelWorkersPerGather = true
	}
	if v, ok := m["maxParallelWorkers"]; ok {
		if v == nil {
			o.MaxParallelWorkers = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x int32
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.MaxParallelWorkers = &x
		}
		o.IsSetMaxParallelWorkers = true
	}
	if v, ok := m["maxParallelMaintenanceWorkers"]; ok {
		if v == nil {
			o.MaxParallelMaintenanceWorkers = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x int32
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.MaxParallelMaintenanceWorkers = &x
		}
		o.IsSetMaxParallelMaintenanceWorkers = true
	}
	if v, ok := m["walLevel"]; ok {
		if v == nil {
			o.WalLevel = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.WalLevel = &x
		}
		o.IsSetWalLevel = true
	}
	if v, ok := m["maxWalSenders"]; ok {
		if v == nil {
			o.MaxWalSenders = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x int32
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.MaxWalSenders = &x
		}
		o.IsSetMaxWalSenders = true
	}
	if v, ok := m["maxReplicationSlots"]; ok {
		if v == nil {
			o.MaxReplicationSlots = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x int32
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.MaxReplicationSlots = &x
		}
		o.IsSetMaxReplicationSlots = true
	}

	return nil
}

func (o *ConfigPostgresSettingsUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigPostgresSettingsUpdateInput) GetJit() *string {
	if o == nil {
		o = &ConfigPostgresSettingsUpdateInput{}
	}
	return o.Jit
}

func (o *ConfigPostgresSettingsUpdateInput) GetMaxConnections() *int32 {
	if o == nil {
		o = &ConfigPostgresSettingsUpdateInput{}
	}
	return o.MaxConnections
}

func (o *ConfigPostgresSettingsUpdateInput) GetSharedBuffers() *string {
	if o == nil {
		o = &ConfigPostgresSettingsUpdateInput{}
	}
	return o.SharedBuffers
}

func (o *ConfigPostgresSettingsUpdateInput) GetEffectiveCacheSize() *string {
	if o == nil {
		o = &ConfigPostgresSettingsUpdateInput{}
	}
	return o.EffectiveCacheSize
}

func (o *ConfigPostgresSettingsUpdateInput) GetMaintenanceWorkMem() *string {
	if o == nil {
		o = &ConfigPostgresSettingsUpdateInput{}
	}
	return o.MaintenanceWorkMem
}

func (o *ConfigPostgresSettingsUpdateInput) GetCheckpointCompletionTarget() *float64 {
	if o == nil {
		o = &ConfigPostgresSettingsUpdateInput{}
	}
	return o.CheckpointCompletionTarget
}

func (o *ConfigPostgresSettingsUpdateInput) GetWalBuffers() *string {
	if o == nil {
		o = &ConfigPostgresSettingsUpdateInput{}
	}
	return o.WalBuffers
}

func (o *ConfigPostgresSettingsUpdateInput) GetDefaultStatisticsTarget() *int32 {
	if o == nil {
		o = &ConfigPostgresSettingsUpdateInput{}
	}
	return o.DefaultStatisticsTarget
}

func (o *ConfigPostgresSettingsUpdateInput) GetRandomPageCost() *float64 {
	if o == nil {
		o = &ConfigPostgresSettingsUpdateInput{}
	}
	return o.RandomPageCost
}

func (o *ConfigPostgresSettingsUpdateInput) GetEffectiveIOConcurrency() *int32 {
	if o == nil {
		o = &ConfigPostgresSettingsUpdateInput{}
	}
	return o.EffectiveIOConcurrency
}

func (o *ConfigPostgresSettingsUpdateInput) GetWorkMem() *string {
	if o == nil {
		o = &ConfigPostgresSettingsUpdateInput{}
	}
	return o.WorkMem
}

func (o *ConfigPostgresSettingsUpdateInput) GetHugePages() *string {
	if o == nil {
		o = &ConfigPostgresSettingsUpdateInput{}
	}
	return o.HugePages
}

func (o *ConfigPostgresSettingsUpdateInput) GetMinWalSize() *string {
	if o == nil {
		o = &ConfigPostgresSettingsUpdateInput{}
	}
	return o.MinWalSize
}

func (o *ConfigPostgresSettingsUpdateInput) GetMaxWalSize() *string {
	if o == nil {
		o = &ConfigPostgresSettingsUpdateInput{}
	}
	return o.MaxWalSize
}

func (o *ConfigPostgresSettingsUpdateInput) GetMaxWorkerProcesses() *int32 {
	if o == nil {
		o = &ConfigPostgresSettingsUpdateInput{}
	}
	return o.MaxWorkerProcesses
}

func (o *ConfigPostgresSettingsUpdateInput) GetMaxParallelWorkersPerGather() *int32 {
	if o == nil {
		o = &ConfigPostgresSettingsUpdateInput{}
	}
	return o.MaxParallelWorkersPerGather
}

func (o *ConfigPostgresSettingsUpdateInput) GetMaxParallelWorkers() *int32 {
	if o == nil {
		o = &ConfigPostgresSettingsUpdateInput{}
	}
	return o.MaxParallelWorkers
}

func (o *ConfigPostgresSettingsUpdateInput) GetMaxParallelMaintenanceWorkers() *int32 {
	if o == nil {
		o = &ConfigPostgresSettingsUpdateInput{}
	}
	return o.MaxParallelMaintenanceWorkers
}

func (o *ConfigPostgresSettingsUpdateInput) GetWalLevel() *string {
	if o == nil {
		o = &ConfigPostgresSettingsUpdateInput{}
	}
	return o.WalLevel
}

func (o *ConfigPostgresSettingsUpdateInput) GetMaxWalSenders() *int32 {
	if o == nil {
		o = &ConfigPostgresSettingsUpdateInput{}
	}
	return o.MaxWalSenders
}

func (o *ConfigPostgresSettingsUpdateInput) GetMaxReplicationSlots() *int32 {
	if o == nil {
		o = &ConfigPostgresSettingsUpdateInput{}
	}
	return o.MaxReplicationSlots
}

func (s *ConfigPostgresSettings) Update(v *ConfigPostgresSettingsUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetJit || v.Jit != nil {
		s.Jit = v.Jit
	}
	if v.IsSetMaxConnections || v.MaxConnections != nil {
		s.MaxConnections = v.MaxConnections
	}
	if v.IsSetSharedBuffers || v.SharedBuffers != nil {
		s.SharedBuffers = v.SharedBuffers
	}
	if v.IsSetEffectiveCacheSize || v.EffectiveCacheSize != nil {
		s.EffectiveCacheSize = v.EffectiveCacheSize
	}
	if v.IsSetMaintenanceWorkMem || v.MaintenanceWorkMem != nil {
		s.MaintenanceWorkMem = v.MaintenanceWorkMem
	}
	if v.IsSetCheckpointCompletionTarget || v.CheckpointCompletionTarget != nil {
		s.CheckpointCompletionTarget = v.CheckpointCompletionTarget
	}
	if v.IsSetWalBuffers || v.WalBuffers != nil {
		s.WalBuffers = v.WalBuffers
	}
	if v.IsSetDefaultStatisticsTarget || v.DefaultStatisticsTarget != nil {
		s.DefaultStatisticsTarget = v.DefaultStatisticsTarget
	}
	if v.IsSetRandomPageCost || v.RandomPageCost != nil {
		s.RandomPageCost = v.RandomPageCost
	}
	if v.IsSetEffectiveIOConcurrency || v.EffectiveIOConcurrency != nil {
		s.EffectiveIOConcurrency = v.EffectiveIOConcurrency
	}
	if v.IsSetWorkMem || v.WorkMem != nil {
		s.WorkMem = v.WorkMem
	}
	if v.IsSetHugePages || v.HugePages != nil {
		s.HugePages = v.HugePages
	}
	if v.IsSetMinWalSize || v.MinWalSize != nil {
		s.MinWalSize = v.MinWalSize
	}
	if v.IsSetMaxWalSize || v.MaxWalSize != nil {
		s.MaxWalSize = v.MaxWalSize
	}
	if v.IsSetMaxWorkerProcesses || v.MaxWorkerProcesses != nil {
		s.MaxWorkerProcesses = v.MaxWorkerProcesses
	}
	if v.IsSetMaxParallelWorkersPerGather || v.MaxParallelWorkersPerGather != nil {
		s.MaxParallelWorkersPerGather = v.MaxParallelWorkersPerGather
	}
	if v.IsSetMaxParallelWorkers || v.MaxParallelWorkers != nil {
		s.MaxParallelWorkers = v.MaxParallelWorkers
	}
	if v.IsSetMaxParallelMaintenanceWorkers || v.MaxParallelMaintenanceWorkers != nil {
		s.MaxParallelMaintenanceWorkers = v.MaxParallelMaintenanceWorkers
	}
	if v.IsSetWalLevel || v.WalLevel != nil {
		s.WalLevel = v.WalLevel
	}
	if v.IsSetMaxWalSenders || v.MaxWalSenders != nil {
		s.MaxWalSenders = v.MaxWalSenders
	}
	if v.IsSetMaxReplicationSlots || v.MaxReplicationSlots != nil {
		s.MaxReplicationSlots = v.MaxReplicationSlots
	}
}

type ConfigPostgresSettingsInsertInput struct {
	Jit                           *string  `json:"jit,omitempty" toml:"jit,omitempty"`
	MaxConnections                *int32   `json:"maxConnections,omitempty" toml:"maxConnections,omitempty"`
	SharedBuffers                 *string  `json:"sharedBuffers,omitempty" toml:"sharedBuffers,omitempty"`
	EffectiveCacheSize            *string  `json:"effectiveCacheSize,omitempty" toml:"effectiveCacheSize,omitempty"`
	MaintenanceWorkMem            *string  `json:"maintenanceWorkMem,omitempty" toml:"maintenanceWorkMem,omitempty"`
	CheckpointCompletionTarget    *float64 `json:"checkpointCompletionTarget,omitempty" toml:"checkpointCompletionTarget,omitempty"`
	WalBuffers                    *string  `json:"walBuffers,omitempty" toml:"walBuffers,omitempty"`
	DefaultStatisticsTarget       *int32   `json:"defaultStatisticsTarget,omitempty" toml:"defaultStatisticsTarget,omitempty"`
	RandomPageCost                *float64 `json:"randomPageCost,omitempty" toml:"randomPageCost,omitempty"`
	EffectiveIOConcurrency        *int32   `json:"effectiveIOConcurrency,omitempty" toml:"effectiveIOConcurrency,omitempty"`
	WorkMem                       *string  `json:"workMem,omitempty" toml:"workMem,omitempty"`
	HugePages                     *string  `json:"hugePages,omitempty" toml:"hugePages,omitempty"`
	MinWalSize                    *string  `json:"minWalSize,omitempty" toml:"minWalSize,omitempty"`
	MaxWalSize                    *string  `json:"maxWalSize,omitempty" toml:"maxWalSize,omitempty"`
	MaxWorkerProcesses            *int32   `json:"maxWorkerProcesses,omitempty" toml:"maxWorkerProcesses,omitempty"`
	MaxParallelWorkersPerGather   *int32   `json:"maxParallelWorkersPerGather,omitempty" toml:"maxParallelWorkersPerGather,omitempty"`
	MaxParallelWorkers            *int32   `json:"maxParallelWorkers,omitempty" toml:"maxParallelWorkers,omitempty"`
	MaxParallelMaintenanceWorkers *int32   `json:"maxParallelMaintenanceWorkers,omitempty" toml:"maxParallelMaintenanceWorkers,omitempty"`
	WalLevel                      *string  `json:"walLevel,omitempty" toml:"walLevel,omitempty"`
	MaxWalSenders                 *int32   `json:"maxWalSenders,omitempty" toml:"maxWalSenders,omitempty"`
	MaxReplicationSlots           *int32   `json:"maxReplicationSlots,omitempty" toml:"maxReplicationSlots,omitempty"`
}

func (o *ConfigPostgresSettingsInsertInput) GetJit() *string {
	if o == nil {
		o = &ConfigPostgresSettingsInsertInput{}
	}
	return o.Jit
}

func (o *ConfigPostgresSettingsInsertInput) GetMaxConnections() *int32 {
	if o == nil {
		o = &ConfigPostgresSettingsInsertInput{}
	}
	return o.MaxConnections
}

func (o *ConfigPostgresSettingsInsertInput) GetSharedBuffers() *string {
	if o == nil {
		o = &ConfigPostgresSettingsInsertInput{}
	}
	return o.SharedBuffers
}

func (o *ConfigPostgresSettingsInsertInput) GetEffectiveCacheSize() *string {
	if o == nil {
		o = &ConfigPostgresSettingsInsertInput{}
	}
	return o.EffectiveCacheSize
}

func (o *ConfigPostgresSettingsInsertInput) GetMaintenanceWorkMem() *string {
	if o == nil {
		o = &ConfigPostgresSettingsInsertInput{}
	}
	return o.MaintenanceWorkMem
}

func (o *ConfigPostgresSettingsInsertInput) GetCheckpointCompletionTarget() *float64 {
	if o == nil {
		o = &ConfigPostgresSettingsInsertInput{}
	}
	return o.CheckpointCompletionTarget
}

func (o *ConfigPostgresSettingsInsertInput) GetWalBuffers() *string {
	if o == nil {
		o = &ConfigPostgresSettingsInsertInput{}
	}
	return o.WalBuffers
}

func (o *ConfigPostgresSettingsInsertInput) GetDefaultStatisticsTarget() *int32 {
	if o == nil {
		o = &ConfigPostgresSettingsInsertInput{}
	}
	return o.DefaultStatisticsTarget
}

func (o *ConfigPostgresSettingsInsertInput) GetRandomPageCost() *float64 {
	if o == nil {
		o = &ConfigPostgresSettingsInsertInput{}
	}
	return o.RandomPageCost
}

func (o *ConfigPostgresSettingsInsertInput) GetEffectiveIOConcurrency() *int32 {
	if o == nil {
		o = &ConfigPostgresSettingsInsertInput{}
	}
	return o.EffectiveIOConcurrency
}

func (o *ConfigPostgresSettingsInsertInput) GetWorkMem() *string {
	if o == nil {
		o = &ConfigPostgresSettingsInsertInput{}
	}
	return o.WorkMem
}

func (o *ConfigPostgresSettingsInsertInput) GetHugePages() *string {
	if o == nil {
		o = &ConfigPostgresSettingsInsertInput{}
	}
	return o.HugePages
}

func (o *ConfigPostgresSettingsInsertInput) GetMinWalSize() *string {
	if o == nil {
		o = &ConfigPostgresSettingsInsertInput{}
	}
	return o.MinWalSize
}

func (o *ConfigPostgresSettingsInsertInput) GetMaxWalSize() *string {
	if o == nil {
		o = &ConfigPostgresSettingsInsertInput{}
	}
	return o.MaxWalSize
}

func (o *ConfigPostgresSettingsInsertInput) GetMaxWorkerProcesses() *int32 {
	if o == nil {
		o = &ConfigPostgresSettingsInsertInput{}
	}
	return o.MaxWorkerProcesses
}

func (o *ConfigPostgresSettingsInsertInput) GetMaxParallelWorkersPerGather() *int32 {
	if o == nil {
		o = &ConfigPostgresSettingsInsertInput{}
	}
	return o.MaxParallelWorkersPerGather
}

func (o *ConfigPostgresSettingsInsertInput) GetMaxParallelWorkers() *int32 {
	if o == nil {
		o = &ConfigPostgresSettingsInsertInput{}
	}
	return o.MaxParallelWorkers
}

func (o *ConfigPostgresSettingsInsertInput) GetMaxParallelMaintenanceWorkers() *int32 {
	if o == nil {
		o = &ConfigPostgresSettingsInsertInput{}
	}
	return o.MaxParallelMaintenanceWorkers
}

func (o *ConfigPostgresSettingsInsertInput) GetWalLevel() *string {
	if o == nil {
		o = &ConfigPostgresSettingsInsertInput{}
	}
	return o.WalLevel
}

func (o *ConfigPostgresSettingsInsertInput) GetMaxWalSenders() *int32 {
	if o == nil {
		o = &ConfigPostgresSettingsInsertInput{}
	}
	return o.MaxWalSenders
}

func (o *ConfigPostgresSettingsInsertInput) GetMaxReplicationSlots() *int32 {
	if o == nil {
		o = &ConfigPostgresSettingsInsertInput{}
	}
	return o.MaxReplicationSlots
}

func (s *ConfigPostgresSettings) Insert(v *ConfigPostgresSettingsInsertInput) {
	s.Jit = v.Jit
	s.MaxConnections = v.MaxConnections
	s.SharedBuffers = v.SharedBuffers
	s.EffectiveCacheSize = v.EffectiveCacheSize
	s.MaintenanceWorkMem = v.MaintenanceWorkMem
	s.CheckpointCompletionTarget = v.CheckpointCompletionTarget
	s.WalBuffers = v.WalBuffers
	s.DefaultStatisticsTarget = v.DefaultStatisticsTarget
	s.RandomPageCost = v.RandomPageCost
	s.EffectiveIOConcurrency = v.EffectiveIOConcurrency
	s.WorkMem = v.WorkMem
	s.HugePages = v.HugePages
	s.MinWalSize = v.MinWalSize
	s.MaxWalSize = v.MaxWalSize
	s.MaxWorkerProcesses = v.MaxWorkerProcesses
	s.MaxParallelWorkersPerGather = v.MaxParallelWorkersPerGather
	s.MaxParallelWorkers = v.MaxParallelWorkers
	s.MaxParallelMaintenanceWorkers = v.MaxParallelMaintenanceWorkers
	s.WalLevel = v.WalLevel
	s.MaxWalSenders = v.MaxWalSenders
	s.MaxReplicationSlots = v.MaxReplicationSlots
}

func (s *ConfigPostgresSettings) Clone() *ConfigPostgresSettings {
	if s == nil {
		return nil
	}

	v := &ConfigPostgresSettings{}
	v.Jit = s.Jit
	v.MaxConnections = s.MaxConnections
	v.SharedBuffers = s.SharedBuffers
	v.EffectiveCacheSize = s.EffectiveCacheSize
	v.MaintenanceWorkMem = s.MaintenanceWorkMem
	v.CheckpointCompletionTarget = s.CheckpointCompletionTarget
	v.WalBuffers = s.WalBuffers
	v.DefaultStatisticsTarget = s.DefaultStatisticsTarget
	v.RandomPageCost = s.RandomPageCost
	v.EffectiveIOConcurrency = s.EffectiveIOConcurrency
	v.WorkMem = s.WorkMem
	v.HugePages = s.HugePages
	v.MinWalSize = s.MinWalSize
	v.MaxWalSize = s.MaxWalSize
	v.MaxWorkerProcesses = s.MaxWorkerProcesses
	v.MaxParallelWorkersPerGather = s.MaxParallelWorkersPerGather
	v.MaxParallelWorkers = s.MaxParallelWorkers
	v.MaxParallelMaintenanceWorkers = s.MaxParallelMaintenanceWorkers
	v.WalLevel = s.WalLevel
	v.MaxWalSenders = s.MaxWalSenders
	v.MaxReplicationSlots = s.MaxReplicationSlots
	return v
}

type ConfigPostgresSettingsComparisonExp struct {
	And                           []*ConfigPostgresSettingsComparisonExp `json:"_and,omitempty"`
	Not                           *ConfigPostgresSettingsComparisonExp   `json:"_not,omitempty"`
	Or                            []*ConfigPostgresSettingsComparisonExp `json:"_or,omitempty"`
	Jit                           *ConfigStringComparisonExp             `json:"jit,omitempty"`
	MaxConnections                *ConfigInt32ComparisonExp              `json:"maxConnections,omitempty"`
	SharedBuffers                 *ConfigStringComparisonExp             `json:"sharedBuffers,omitempty"`
	EffectiveCacheSize            *ConfigStringComparisonExp             `json:"effectiveCacheSize,omitempty"`
	MaintenanceWorkMem            *ConfigStringComparisonExp             `json:"maintenanceWorkMem,omitempty"`
	CheckpointCompletionTarget    *ConfigFloatComparisonExp              `json:"checkpointCompletionTarget,omitempty"`
	WalBuffers                    *ConfigStringComparisonExp             `json:"walBuffers,omitempty"`
	DefaultStatisticsTarget       *ConfigInt32ComparisonExp              `json:"defaultStatisticsTarget,omitempty"`
	RandomPageCost                *ConfigFloatComparisonExp              `json:"randomPageCost,omitempty"`
	EffectiveIOConcurrency        *ConfigInt32ComparisonExp              `json:"effectiveIOConcurrency,omitempty"`
	WorkMem                       *ConfigStringComparisonExp             `json:"workMem,omitempty"`
	HugePages                     *ConfigStringComparisonExp             `json:"hugePages,omitempty"`
	MinWalSize                    *ConfigStringComparisonExp             `json:"minWalSize,omitempty"`
	MaxWalSize                    *ConfigStringComparisonExp             `json:"maxWalSize,omitempty"`
	MaxWorkerProcesses            *ConfigInt32ComparisonExp              `json:"maxWorkerProcesses,omitempty"`
	MaxParallelWorkersPerGather   *ConfigInt32ComparisonExp              `json:"maxParallelWorkersPerGather,omitempty"`
	MaxParallelWorkers            *ConfigInt32ComparisonExp              `json:"maxParallelWorkers,omitempty"`
	MaxParallelMaintenanceWorkers *ConfigInt32ComparisonExp              `json:"maxParallelMaintenanceWorkers,omitempty"`
	WalLevel                      *ConfigStringComparisonExp             `json:"walLevel,omitempty"`
	MaxWalSenders                 *ConfigInt32ComparisonExp              `json:"maxWalSenders,omitempty"`
	MaxReplicationSlots           *ConfigInt32ComparisonExp              `json:"maxReplicationSlots,omitempty"`
}

func (exp *ConfigPostgresSettingsComparisonExp) Matches(o *ConfigPostgresSettings) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigPostgresSettings{}
	}
	if o.Jit != nil && !exp.Jit.Matches(*o.Jit) {
		return false
	}
	if o.MaxConnections != nil && !exp.MaxConnections.Matches(*o.MaxConnections) {
		return false
	}
	if o.SharedBuffers != nil && !exp.SharedBuffers.Matches(*o.SharedBuffers) {
		return false
	}
	if o.EffectiveCacheSize != nil && !exp.EffectiveCacheSize.Matches(*o.EffectiveCacheSize) {
		return false
	}
	if o.MaintenanceWorkMem != nil && !exp.MaintenanceWorkMem.Matches(*o.MaintenanceWorkMem) {
		return false
	}
	if o.CheckpointCompletionTarget != nil && !exp.CheckpointCompletionTarget.Matches(*o.CheckpointCompletionTarget) {
		return false
	}
	if o.WalBuffers != nil && !exp.WalBuffers.Matches(*o.WalBuffers) {
		return false
	}
	if o.DefaultStatisticsTarget != nil && !exp.DefaultStatisticsTarget.Matches(*o.DefaultStatisticsTarget) {
		return false
	}
	if o.RandomPageCost != nil && !exp.RandomPageCost.Matches(*o.RandomPageCost) {
		return false
	}
	if o.EffectiveIOConcurrency != nil && !exp.EffectiveIOConcurrency.Matches(*o.EffectiveIOConcurrency) {
		return false
	}
	if o.WorkMem != nil && !exp.WorkMem.Matches(*o.WorkMem) {
		return false
	}
	if o.HugePages != nil && !exp.HugePages.Matches(*o.HugePages) {
		return false
	}
	if o.MinWalSize != nil && !exp.MinWalSize.Matches(*o.MinWalSize) {
		return false
	}
	if o.MaxWalSize != nil && !exp.MaxWalSize.Matches(*o.MaxWalSize) {
		return false
	}
	if o.MaxWorkerProcesses != nil && !exp.MaxWorkerProcesses.Matches(*o.MaxWorkerProcesses) {
		return false
	}
	if o.MaxParallelWorkersPerGather != nil && !exp.MaxParallelWorkersPerGather.Matches(*o.MaxParallelWorkersPerGather) {
		return false
	}
	if o.MaxParallelWorkers != nil && !exp.MaxParallelWorkers.Matches(*o.MaxParallelWorkers) {
		return false
	}
	if o.MaxParallelMaintenanceWorkers != nil && !exp.MaxParallelMaintenanceWorkers.Matches(*o.MaxParallelMaintenanceWorkers) {
		return false
	}
	if o.WalLevel != nil && !exp.WalLevel.Matches(*o.WalLevel) {
		return false
	}
	if o.MaxWalSenders != nil && !exp.MaxWalSenders.Matches(*o.MaxWalSenders) {
		return false
	}
	if o.MaxReplicationSlots != nil && !exp.MaxReplicationSlots.Matches(*o.MaxReplicationSlots) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigPostgresStorage struct {
	// GiB
	Capacity uint32 `json:"capacity" toml:"capacity"`
}

func (o *ConfigPostgresStorage) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	m["capacity"] = o.Capacity
	return json.Marshal(m)
}

func (o *ConfigPostgresStorage) GetCapacity() uint32 {
	if o == nil {
		o = &ConfigPostgresStorage{}
	}
	return o.Capacity
}

type ConfigPostgresStorageUpdateInput struct {
	Capacity      *uint32 `json:"capacity,omitempty" toml:"capacity,omitempty"`
	IsSetCapacity bool    `json:"-"`
}

func (o *ConfigPostgresStorageUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["capacity"]; ok {
		if v == nil {
			o.Capacity = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x uint32
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Capacity = &x
		}
		o.IsSetCapacity = true
	}

	return nil
}

func (o *ConfigPostgresStorageUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigPostgresStorageUpdateInput) GetCapacity() *uint32 {
	if o == nil {
		o = &ConfigPostgresStorageUpdateInput{}
	}
	return o.Capacity
}

func (s *ConfigPostgresStorage) Update(v *ConfigPostgresStorageUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetCapacity || v.Capacity != nil {
		if v.Capacity != nil {
			s.Capacity = *v.Capacity
		}
	}
}

type ConfigPostgresStorageInsertInput struct {
	Capacity uint32 `json:"capacity,omitempty" toml:"capacity,omitempty"`
}

func (o *ConfigPostgresStorageInsertInput) GetCapacity() uint32 {
	if o == nil {
		o = &ConfigPostgresStorageInsertInput{}
	}
	return o.Capacity
}

func (s *ConfigPostgresStorage) Insert(v *ConfigPostgresStorageInsertInput) {
	s.Capacity = v.Capacity
}

func (s *ConfigPostgresStorage) Clone() *ConfigPostgresStorage {
	if s == nil {
		return nil
	}

	v := &ConfigPostgresStorage{}
	v.Capacity = s.Capacity
	return v
}

type ConfigPostgresStorageComparisonExp struct {
	And      []*ConfigPostgresStorageComparisonExp `json:"_and,omitempty"`
	Not      *ConfigPostgresStorageComparisonExp   `json:"_not,omitempty"`
	Or       []*ConfigPostgresStorageComparisonExp `json:"_or,omitempty"`
	Capacity *ConfigUint32ComparisonExp            `json:"capacity,omitempty"`
}

func (exp *ConfigPostgresStorageComparisonExp) Matches(o *ConfigPostgresStorage) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigPostgresStorage{}
	}
	if !exp.Capacity.Matches(o.Capacity) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigProvider struct {
	Smtp *ConfigSmtp `json:"smtp,omitempty" toml:"smtp,omitempty"`

	Sms *ConfigSms `json:"sms,omitempty" toml:"sms,omitempty"`
}

func (o *ConfigProvider) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Smtp != nil {
		m["smtp"] = o.Smtp
	}
	if o.Sms != nil {
		m["sms"] = o.Sms
	}
	return json.Marshal(m)
}

func (o *ConfigProvider) GetSmtp() *ConfigSmtp {
	if o == nil {
		return nil
	}
	return o.Smtp
}

func (o *ConfigProvider) GetSms() *ConfigSms {
	if o == nil {
		return nil
	}
	return o.Sms
}

type ConfigProviderUpdateInput struct {
	Smtp      *ConfigSmtpUpdateInput `json:"smtp,omitempty" toml:"smtp,omitempty"`
	IsSetSmtp bool                   `json:"-"`
	Sms       *ConfigSmsUpdateInput  `json:"sms,omitempty" toml:"sms,omitempty"`
	IsSetSms  bool                   `json:"-"`
}

func (o *ConfigProviderUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if x, ok := m["smtp"]; ok {
		if x != nil {
			t := &ConfigSmtpUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Smtp = t
		}
		o.IsSetSmtp = true
	}
	if x, ok := m["sms"]; ok {
		if x != nil {
			t := &ConfigSmsUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Sms = t
		}
		o.IsSetSms = true
	}

	return nil
}

func (o *ConfigProviderUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigProviderUpdateInput) GetSmtp() *ConfigSmtpUpdateInput {
	if o == nil {
		return nil
	}
	return o.Smtp
}

func (o *ConfigProviderUpdateInput) GetSms() *ConfigSmsUpdateInput {
	if o == nil {
		return nil
	}
	return o.Sms
}

func (s *ConfigProvider) Update(v *ConfigProviderUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetSmtp || v.Smtp != nil {
		if v.Smtp == nil {
			s.Smtp = nil
		} else {
			if s.Smtp == nil {
				s.Smtp = &ConfigSmtp{}
			}
			s.Smtp.Update(v.Smtp)
		}
	}
	if v.IsSetSms || v.Sms != nil {
		if v.Sms == nil {
			s.Sms = nil
		} else {
			if s.Sms == nil {
				s.Sms = &ConfigSms{}
			}
			s.Sms.Update(v.Sms)
		}
	}
}

type ConfigProviderInsertInput struct {
	Smtp *ConfigSmtpInsertInput `json:"smtp,omitempty" toml:"smtp,omitempty"`
	Sms  *ConfigSmsInsertInput  `json:"sms,omitempty" toml:"sms,omitempty"`
}

func (o *ConfigProviderInsertInput) GetSmtp() *ConfigSmtpInsertInput {
	if o == nil {
		return nil
	}
	return o.Smtp
}

func (o *ConfigProviderInsertInput) GetSms() *ConfigSmsInsertInput {
	if o == nil {
		return nil
	}
	return o.Sms
}

func (s *ConfigProvider) Insert(v *ConfigProviderInsertInput) {
	if v.Smtp != nil {
		if s.Smtp == nil {
			s.Smtp = &ConfigSmtp{}
		}
		s.Smtp.Insert(v.Smtp)
	}
	if v.Sms != nil {
		if s.Sms == nil {
			s.Sms = &ConfigSms{}
		}
		s.Sms.Insert(v.Sms)
	}
}

func (s *ConfigProvider) Clone() *ConfigProvider {
	if s == nil {
		return nil
	}

	v := &ConfigProvider{}
	v.Smtp = s.Smtp.Clone()
	v.Sms = s.Sms.Clone()
	return v
}

type ConfigProviderComparisonExp struct {
	And  []*ConfigProviderComparisonExp `json:"_and,omitempty"`
	Not  *ConfigProviderComparisonExp   `json:"_not,omitempty"`
	Or   []*ConfigProviderComparisonExp `json:"_or,omitempty"`
	Smtp *ConfigSmtpComparisonExp       `json:"smtp,omitempty"`
	Sms  *ConfigSmsComparisonExp        `json:"sms,omitempty"`
}

func (exp *ConfigProviderComparisonExp) Matches(o *ConfigProvider) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigProvider{
			Smtp: &ConfigSmtp{},
			Sms:  &ConfigSms{},
		}
	}
	if !exp.Smtp.Matches(o.Smtp) {
		return false
	}
	if !exp.Sms.Matches(o.Sms) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigRateLimit struct {
	Limit uint32 `json:"limit" toml:"limit"`

	Interval string `json:"interval" toml:"interval"`
}

func (o *ConfigRateLimit) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	m["limit"] = o.Limit
	m["interval"] = o.Interval
	return json.Marshal(m)
}

func (o *ConfigRateLimit) GetLimit() uint32 {
	if o == nil {
		o = &ConfigRateLimit{}
	}
	return o.Limit
}

func (o *ConfigRateLimit) GetInterval() string {
	if o == nil {
		o = &ConfigRateLimit{}
	}
	return o.Interval
}

type ConfigRateLimitUpdateInput struct {
	Limit         *uint32 `json:"limit,omitempty" toml:"limit,omitempty"`
	IsSetLimit    bool    `json:"-"`
	Interval      *string `json:"interval,omitempty" toml:"interval,omitempty"`
	IsSetInterval bool    `json:"-"`
}

func (o *ConfigRateLimitUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["limit"]; ok {
		if v == nil {
			o.Limit = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x uint32
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Limit = &x
		}
		o.IsSetLimit = true
	}
	if v, ok := m["interval"]; ok {
		if v == nil {
			o.Interval = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Interval = &x
		}
		o.IsSetInterval = true
	}

	return nil
}

func (o *ConfigRateLimitUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigRateLimitUpdateInput) GetLimit() *uint32 {
	if o == nil {
		o = &ConfigRateLimitUpdateInput{}
	}
	return o.Limit
}

func (o *ConfigRateLimitUpdateInput) GetInterval() *string {
	if o == nil {
		o = &ConfigRateLimitUpdateInput{}
	}
	return o.Interval
}

func (s *ConfigRateLimit) Update(v *ConfigRateLimitUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetLimit || v.Limit != nil {
		if v.Limit != nil {
			s.Limit = *v.Limit
		}
	}
	if v.IsSetInterval || v.Interval != nil {
		if v.Interval != nil {
			s.Interval = *v.Interval
		}
	}
}

type ConfigRateLimitInsertInput struct {
	Limit    uint32 `json:"limit,omitempty" toml:"limit,omitempty"`
	Interval string `json:"interval,omitempty" toml:"interval,omitempty"`
}

func (o *ConfigRateLimitInsertInput) GetLimit() uint32 {
	if o == nil {
		o = &ConfigRateLimitInsertInput{}
	}
	return o.Limit
}

func (o *ConfigRateLimitInsertInput) GetInterval() string {
	if o == nil {
		o = &ConfigRateLimitInsertInput{}
	}
	return o.Interval
}

func (s *ConfigRateLimit) Insert(v *ConfigRateLimitInsertInput) {
	s.Limit = v.Limit
	s.Interval = v.Interval
}

func (s *ConfigRateLimit) Clone() *ConfigRateLimit {
	if s == nil {
		return nil
	}

	v := &ConfigRateLimit{}
	v.Limit = s.Limit
	v.Interval = s.Interval
	return v
}

type ConfigRateLimitComparisonExp struct {
	And      []*ConfigRateLimitComparisonExp `json:"_and,omitempty"`
	Not      *ConfigRateLimitComparisonExp   `json:"_not,omitempty"`
	Or       []*ConfigRateLimitComparisonExp `json:"_or,omitempty"`
	Limit    *ConfigUint32ComparisonExp      `json:"limit,omitempty"`
	Interval *ConfigStringComparisonExp      `json:"interval,omitempty"`
}

func (exp *ConfigRateLimitComparisonExp) Matches(o *ConfigRateLimit) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigRateLimit{}
	}
	if !exp.Limit.Matches(o.Limit) {
		return false
	}
	if !exp.Interval.Matches(o.Interval) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

// Resource configuration for a service
type ConfigResources struct {
	Compute *ConfigResourcesCompute `json:"compute,omitempty" toml:"compute,omitempty"`
	// Number of replicas for a service
	Replicas *uint8 `json:"replicas" toml:"replicas"`

	Autoscaler *ConfigAutoscaler `json:"autoscaler,omitempty" toml:"autoscaler,omitempty"`

	Networking *ConfigNetworking `json:"networking,omitempty" toml:"networking,omitempty"`
}

func (o *ConfigResources) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Compute != nil {
		m["compute"] = o.Compute
	}
	if o.Replicas != nil {
		m["replicas"] = o.Replicas
	}
	if o.Autoscaler != nil {
		m["autoscaler"] = o.Autoscaler
	}
	if o.Networking != nil {
		m["networking"] = o.Networking
	}
	return json.Marshal(m)
}

func (o *ConfigResources) GetCompute() *ConfigResourcesCompute {
	if o == nil {
		return nil
	}
	return o.Compute
}

func (o *ConfigResources) GetReplicas() *uint8 {
	if o == nil {
		o = &ConfigResources{}
	}
	return o.Replicas
}

func (o *ConfigResources) GetAutoscaler() *ConfigAutoscaler {
	if o == nil {
		return nil
	}
	return o.Autoscaler
}

func (o *ConfigResources) GetNetworking() *ConfigNetworking {
	if o == nil {
		return nil
	}
	return o.Networking
}

type ConfigResourcesUpdateInput struct {
	Compute         *ConfigResourcesComputeUpdateInput `json:"compute,omitempty" toml:"compute,omitempty"`
	IsSetCompute    bool                               `json:"-"`
	Replicas        *uint8                             `json:"replicas,omitempty" toml:"replicas,omitempty"`
	IsSetReplicas   bool                               `json:"-"`
	Autoscaler      *ConfigAutoscalerUpdateInput       `json:"autoscaler,omitempty" toml:"autoscaler,omitempty"`
	IsSetAutoscaler bool                               `json:"-"`
	Networking      *ConfigNetworkingUpdateInput       `json:"networking,omitempty" toml:"networking,omitempty"`
	IsSetNetworking bool                               `json:"-"`
}

func (o *ConfigResourcesUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if x, ok := m["compute"]; ok {
		if x != nil {
			t := &ConfigResourcesComputeUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Compute = t
		}
		o.IsSetCompute = true
	}
	if v, ok := m["replicas"]; ok {
		if v == nil {
			o.Replicas = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x uint8
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Replicas = &x
		}
		o.IsSetReplicas = true
	}
	if x, ok := m["autoscaler"]; ok {
		if x != nil {
			t := &ConfigAutoscalerUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Autoscaler = t
		}
		o.IsSetAutoscaler = true
	}
	if x, ok := m["networking"]; ok {
		if x != nil {
			t := &ConfigNetworkingUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Networking = t
		}
		o.IsSetNetworking = true
	}

	return nil
}

func (o *ConfigResourcesUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigResourcesUpdateInput) GetCompute() *ConfigResourcesComputeUpdateInput {
	if o == nil {
		return nil
	}
	return o.Compute
}

func (o *ConfigResourcesUpdateInput) GetReplicas() *uint8 {
	if o == nil {
		o = &ConfigResourcesUpdateInput{}
	}
	return o.Replicas
}

func (o *ConfigResourcesUpdateInput) GetAutoscaler() *ConfigAutoscalerUpdateInput {
	if o == nil {
		return nil
	}
	return o.Autoscaler
}

func (o *ConfigResourcesUpdateInput) GetNetworking() *ConfigNetworkingUpdateInput {
	if o == nil {
		return nil
	}
	return o.Networking
}

func (s *ConfigResources) Update(v *ConfigResourcesUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetCompute || v.Compute != nil {
		if v.Compute == nil {
			s.Compute = nil
		} else {
			if s.Compute == nil {
				s.Compute = &ConfigResourcesCompute{}
			}
			s.Compute.Update(v.Compute)
		}
	}
	if v.IsSetReplicas || v.Replicas != nil {
		s.Replicas = v.Replicas
	}
	if v.IsSetAutoscaler || v.Autoscaler != nil {
		if v.Autoscaler == nil {
			s.Autoscaler = nil
		} else {
			if s.Autoscaler == nil {
				s.Autoscaler = &ConfigAutoscaler{}
			}
			s.Autoscaler.Update(v.Autoscaler)
		}
	}
	if v.IsSetNetworking || v.Networking != nil {
		if v.Networking == nil {
			s.Networking = nil
		} else {
			if s.Networking == nil {
				s.Networking = &ConfigNetworking{}
			}
			s.Networking.Update(v.Networking)
		}
	}
}

type ConfigResourcesInsertInput struct {
	Compute    *ConfigResourcesComputeInsertInput `json:"compute,omitempty" toml:"compute,omitempty"`
	Replicas   *uint8                             `json:"replicas,omitempty" toml:"replicas,omitempty"`
	Autoscaler *ConfigAutoscalerInsertInput       `json:"autoscaler,omitempty" toml:"autoscaler,omitempty"`
	Networking *ConfigNetworkingInsertInput       `json:"networking,omitempty" toml:"networking,omitempty"`
}

func (o *ConfigResourcesInsertInput) GetCompute() *ConfigResourcesComputeInsertInput {
	if o == nil {
		return nil
	}
	return o.Compute
}

func (o *ConfigResourcesInsertInput) GetReplicas() *uint8 {
	if o == nil {
		o = &ConfigResourcesInsertInput{}
	}
	return o.Replicas
}

func (o *ConfigResourcesInsertInput) GetAutoscaler() *ConfigAutoscalerInsertInput {
	if o == nil {
		return nil
	}
	return o.Autoscaler
}

func (o *ConfigResourcesInsertInput) GetNetworking() *ConfigNetworkingInsertInput {
	if o == nil {
		return nil
	}
	return o.Networking
}

func (s *ConfigResources) Insert(v *ConfigResourcesInsertInput) {
	if v.Compute != nil {
		if s.Compute == nil {
			s.Compute = &ConfigResourcesCompute{}
		}
		s.Compute.Insert(v.Compute)
	}
	s.Replicas = v.Replicas
	if v.Autoscaler != nil {
		if s.Autoscaler == nil {
			s.Autoscaler = &ConfigAutoscaler{}
		}
		s.Autoscaler.Insert(v.Autoscaler)
	}
	if v.Networking != nil {
		if s.Networking == nil {
			s.Networking = &ConfigNetworking{}
		}
		s.Networking.Insert(v.Networking)
	}
}

func (s *ConfigResources) Clone() *ConfigResources {
	if s == nil {
		return nil
	}

	v := &ConfigResources{}
	v.Compute = s.Compute.Clone()
	v.Replicas = s.Replicas
	v.Autoscaler = s.Autoscaler.Clone()
	v.Networking = s.Networking.Clone()
	return v
}

type ConfigResourcesComparisonExp struct {
	And        []*ConfigResourcesComparisonExp      `json:"_and,omitempty"`
	Not        *ConfigResourcesComparisonExp        `json:"_not,omitempty"`
	Or         []*ConfigResourcesComparisonExp      `json:"_or,omitempty"`
	Compute    *ConfigResourcesComputeComparisonExp `json:"compute,omitempty"`
	Replicas   *ConfigUint8ComparisonExp            `json:"replicas,omitempty"`
	Autoscaler *ConfigAutoscalerComparisonExp       `json:"autoscaler,omitempty"`
	Networking *ConfigNetworkingComparisonExp       `json:"networking,omitempty"`
}

func (exp *ConfigResourcesComparisonExp) Matches(o *ConfigResources) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigResources{
			Compute:    &ConfigResourcesCompute{},
			Autoscaler: &ConfigAutoscaler{},
			Networking: &ConfigNetworking{},
		}
	}
	if !exp.Compute.Matches(o.Compute) {
		return false
	}
	if o.Replicas != nil && !exp.Replicas.Matches(*o.Replicas) {
		return false
	}
	if !exp.Autoscaler.Matches(o.Autoscaler) {
		return false
	}
	if !exp.Networking.Matches(o.Networking) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigResourcesCompute struct {
	// milicpus, 1000 milicpus = 1 cpu
	Cpu uint32 `json:"cpu" toml:"cpu"`
	// MiB: 128MiB to 30GiB
	Memory uint32 `json:"memory" toml:"memory"`
}

func (o *ConfigResourcesCompute) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	m["cpu"] = o.Cpu
	m["memory"] = o.Memory
	return json.Marshal(m)
}

func (o *ConfigResourcesCompute) GetCpu() uint32 {
	if o == nil {
		o = &ConfigResourcesCompute{}
	}
	return o.Cpu
}

func (o *ConfigResourcesCompute) GetMemory() uint32 {
	if o == nil {
		o = &ConfigResourcesCompute{}
	}
	return o.Memory
}

type ConfigResourcesComputeUpdateInput struct {
	Cpu         *uint32 `json:"cpu,omitempty" toml:"cpu,omitempty"`
	IsSetCpu    bool    `json:"-"`
	Memory      *uint32 `json:"memory,omitempty" toml:"memory,omitempty"`
	IsSetMemory bool    `json:"-"`
}

func (o *ConfigResourcesComputeUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["cpu"]; ok {
		if v == nil {
			o.Cpu = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x uint32
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Cpu = &x
		}
		o.IsSetCpu = true
	}
	if v, ok := m["memory"]; ok {
		if v == nil {
			o.Memory = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x uint32
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Memory = &x
		}
		o.IsSetMemory = true
	}

	return nil
}

func (o *ConfigResourcesComputeUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigResourcesComputeUpdateInput) GetCpu() *uint32 {
	if o == nil {
		o = &ConfigResourcesComputeUpdateInput{}
	}
	return o.Cpu
}

func (o *ConfigResourcesComputeUpdateInput) GetMemory() *uint32 {
	if o == nil {
		o = &ConfigResourcesComputeUpdateInput{}
	}
	return o.Memory
}

func (s *ConfigResourcesCompute) Update(v *ConfigResourcesComputeUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetCpu || v.Cpu != nil {
		if v.Cpu != nil {
			s.Cpu = *v.Cpu
		}
	}
	if v.IsSetMemory || v.Memory != nil {
		if v.Memory != nil {
			s.Memory = *v.Memory
		}
	}
}

type ConfigResourcesComputeInsertInput struct {
	Cpu    uint32 `json:"cpu,omitempty" toml:"cpu,omitempty"`
	Memory uint32 `json:"memory,omitempty" toml:"memory,omitempty"`
}

func (o *ConfigResourcesComputeInsertInput) GetCpu() uint32 {
	if o == nil {
		o = &ConfigResourcesComputeInsertInput{}
	}
	return o.Cpu
}

func (o *ConfigResourcesComputeInsertInput) GetMemory() uint32 {
	if o == nil {
		o = &ConfigResourcesComputeInsertInput{}
	}
	return o.Memory
}

func (s *ConfigResourcesCompute) Insert(v *ConfigResourcesComputeInsertInput) {
	s.Cpu = v.Cpu
	s.Memory = v.Memory
}

func (s *ConfigResourcesCompute) Clone() *ConfigResourcesCompute {
	if s == nil {
		return nil
	}

	v := &ConfigResourcesCompute{}
	v.Cpu = s.Cpu
	v.Memory = s.Memory
	return v
}

type ConfigResourcesComputeComparisonExp struct {
	And    []*ConfigResourcesComputeComparisonExp `json:"_and,omitempty"`
	Not    *ConfigResourcesComputeComparisonExp   `json:"_not,omitempty"`
	Or     []*ConfigResourcesComputeComparisonExp `json:"_or,omitempty"`
	Cpu    *ConfigUint32ComparisonExp             `json:"cpu,omitempty"`
	Memory *ConfigUint32ComparisonExp             `json:"memory,omitempty"`
}

func (exp *ConfigResourcesComputeComparisonExp) Matches(o *ConfigResourcesCompute) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigResourcesCompute{}
	}
	if !exp.Cpu.Matches(o.Cpu) {
		return false
	}
	if !exp.Memory.Matches(o.Memory) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigRunServiceConfig struct {
	Name string `json:"name" toml:"name"`

	Image *ConfigRunServiceImage `json:"image,omitempty" toml:"image,omitempty"`

	Command []string `json:"command,omitempty" toml:"command,omitempty"`

	Environment []*ConfigEnvironmentVariable `json:"environment,omitempty" toml:"environment,omitempty"`

	Ports []*ConfigRunServicePort `json:"ports,omitempty" toml:"ports,omitempty"`

	Resources *ConfigRunServiceResources `json:"resources,omitempty" toml:"resources,omitempty"`

	HealthCheck *ConfigHealthCheck `json:"healthCheck,omitempty" toml:"healthCheck,omitempty"`
}

func (o *ConfigRunServiceConfig) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	m["name"] = o.Name
	if o.Image != nil {
		m["image"] = o.Image
	}
	if o.Command != nil {
		m["command"] = o.Command
	}
	if o.Environment != nil {
		m["environment"] = o.Environment
	}
	if o.Ports != nil {
		m["ports"] = o.Ports
	}
	if o.Resources != nil {
		m["resources"] = o.Resources
	}
	if o.HealthCheck != nil {
		m["healthCheck"] = o.HealthCheck
	}
	return json.Marshal(m)
}

func (o *ConfigRunServiceConfig) GetName() string {
	if o == nil {
		o = &ConfigRunServiceConfig{}
	}
	return o.Name
}

func (o *ConfigRunServiceConfig) GetImage() *ConfigRunServiceImage {
	if o == nil {
		return nil
	}
	return o.Image
}

func (o *ConfigRunServiceConfig) GetCommand() []string {
	if o == nil {
		o = &ConfigRunServiceConfig{}
	}
	return o.Command
}

func (o *ConfigRunServiceConfig) GetEnvironment() []*ConfigEnvironmentVariable {
	if o == nil {
		o = &ConfigRunServiceConfig{}
	}
	return o.Environment
}

func (o *ConfigRunServiceConfig) GetPorts() []*ConfigRunServicePort {
	if o == nil {
		o = &ConfigRunServiceConfig{}
	}
	return o.Ports
}

func (o *ConfigRunServiceConfig) GetResources() *ConfigRunServiceResources {
	if o == nil {
		return nil
	}
	return o.Resources
}

func (o *ConfigRunServiceConfig) GetHealthCheck() *ConfigHealthCheck {
	if o == nil {
		return nil
	}
	return o.HealthCheck
}

type ConfigRunServiceConfigUpdateInput struct {
	Name             *string                                 `json:"name,omitempty" toml:"name,omitempty"`
	IsSetName        bool                                    `json:"-"`
	Image            *ConfigRunServiceImageUpdateInput       `json:"image,omitempty" toml:"image,omitempty"`
	IsSetImage       bool                                    `json:"-"`
	Command          []string                                `json:"command,omitempty" toml:"command,omitempty"`
	IsSetCommand     bool                                    `json:"-"`
	Environment      []*ConfigEnvironmentVariableUpdateInput `json:"environment,omitempty" toml:"environment,omitempty"`
	IsSetEnvironment bool                                    `json:"-"`
	Ports            []*ConfigRunServicePortUpdateInput      `json:"ports,omitempty" toml:"ports,omitempty"`
	IsSetPorts       bool                                    `json:"-"`
	Resources        *ConfigRunServiceResourcesUpdateInput   `json:"resources,omitempty" toml:"resources,omitempty"`
	IsSetResources   bool                                    `json:"-"`
	HealthCheck      *ConfigHealthCheckUpdateInput           `json:"healthCheck,omitempty" toml:"healthCheck,omitempty"`
	IsSetHealthCheck bool                                    `json:"-"`
}

func (o *ConfigRunServiceConfigUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["name"]; ok {
		if v == nil {
			o.Name = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Name = &x
		}
		o.IsSetName = true
	}
	if x, ok := m["image"]; ok {
		if x != nil {
			t := &ConfigRunServiceImageUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Image = t
		}
		o.IsSetImage = true
	}
	if v, ok := m["command"]; ok {
		if v != nil {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var l []string
			if err := json.Unmarshal(b, &l); err != nil {
				return err
			}
			o.Command = l
		}
		o.IsSetCommand = true
	}
	if v, ok := m["environment"]; ok {
		if v != nil {
			x, ok := v.([]interface{})
			if !ok {
				return fmt.Errorf("Environment must be []interface{}, got %T", v)
			}

			l := make([]*ConfigEnvironmentVariableUpdateInput, len(x))
			for i, vv := range x {
				t := &ConfigEnvironmentVariableUpdateInput{}
				if err := t.UnmarshalGQL(vv); err != nil {
					return err
				}
				l[i] = t
			}
			o.Environment = l
		}
		o.IsSetEnvironment = true
	}
	if v, ok := m["ports"]; ok {
		if v != nil {
			x, ok := v.([]interface{})
			if !ok {
				return fmt.Errorf("Ports must be []interface{}, got %T", v)
			}

			l := make([]*ConfigRunServicePortUpdateInput, len(x))
			for i, vv := range x {
				t := &ConfigRunServicePortUpdateInput{}
				if err := t.UnmarshalGQL(vv); err != nil {
					return err
				}
				l[i] = t
			}
			o.Ports = l
		}
		o.IsSetPorts = true
	}
	if x, ok := m["resources"]; ok {
		if x != nil {
			t := &ConfigRunServiceResourcesUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Resources = t
		}
		o.IsSetResources = true
	}
	if x, ok := m["healthCheck"]; ok {
		if x != nil {
			t := &ConfigHealthCheckUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.HealthCheck = t
		}
		o.IsSetHealthCheck = true
	}

	return nil
}

func (o *ConfigRunServiceConfigUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigRunServiceConfigUpdateInput) GetName() *string {
	if o == nil {
		o = &ConfigRunServiceConfigUpdateInput{}
	}
	return o.Name
}

func (o *ConfigRunServiceConfigUpdateInput) GetImage() *ConfigRunServiceImageUpdateInput {
	if o == nil {
		return nil
	}
	return o.Image
}

func (o *ConfigRunServiceConfigUpdateInput) GetCommand() []string {
	if o == nil {
		o = &ConfigRunServiceConfigUpdateInput{}
	}
	return o.Command
}

func (o *ConfigRunServiceConfigUpdateInput) GetEnvironment() []*ConfigEnvironmentVariableUpdateInput {
	if o == nil {
		o = &ConfigRunServiceConfigUpdateInput{}
	}
	return o.Environment
}

func (o *ConfigRunServiceConfigUpdateInput) GetPorts() []*ConfigRunServicePortUpdateInput {
	if o == nil {
		o = &ConfigRunServiceConfigUpdateInput{}
	}
	return o.Ports
}

func (o *ConfigRunServiceConfigUpdateInput) GetResources() *ConfigRunServiceResourcesUpdateInput {
	if o == nil {
		return nil
	}
	return o.Resources
}

func (o *ConfigRunServiceConfigUpdateInput) GetHealthCheck() *ConfigHealthCheckUpdateInput {
	if o == nil {
		return nil
	}
	return o.HealthCheck
}

func (s *ConfigRunServiceConfig) Update(v *ConfigRunServiceConfigUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetName || v.Name != nil {
		if v.Name != nil {
			s.Name = *v.Name
		}
	}
	if v.IsSetImage || v.Image != nil {
		if v.Image == nil {
			s.Image = nil
		} else {
			if s.Image == nil {
				s.Image = &ConfigRunServiceImage{}
			}
			s.Image.Update(v.Image)
		}
	}
	if v.IsSetCommand || v.Command != nil {
		if v.Command == nil {
			s.Command = nil
		} else {
			s.Command = make([]string, len(v.Command))
			for i, e := range v.Command {
				s.Command[i] = e
			}
		}
	}
	if v.IsSetEnvironment || v.Environment != nil {
		if v.Environment == nil {
			s.Environment = nil
		} else {
			s.Environment = make([]*ConfigEnvironmentVariable, len(v.Environment))
			for i, e := range v.Environment {
				v := &ConfigEnvironmentVariable{}
				v.Update(e)
				s.Environment[i] = v
			}
		}
	}
	if v.IsSetPorts || v.Ports != nil {
		if v.Ports == nil {
			s.Ports = nil
		} else {
			s.Ports = make([]*ConfigRunServicePort, len(v.Ports))
			for i, e := range v.Ports {
				v := &ConfigRunServicePort{}
				v.Update(e)
				s.Ports[i] = v
			}
		}
	}
	if v.IsSetResources || v.Resources != nil {
		if v.Resources == nil {
			s.Resources = nil
		} else {
			if s.Resources == nil {
				s.Resources = &ConfigRunServiceResources{}
			}
			s.Resources.Update(v.Resources)
		}
	}
	if v.IsSetHealthCheck || v.HealthCheck != nil {
		if v.HealthCheck == nil {
			s.HealthCheck = nil
		} else {
			if s.HealthCheck == nil {
				s.HealthCheck = &ConfigHealthCheck{}
			}
			s.HealthCheck.Update(v.HealthCheck)
		}
	}
}

type ConfigRunServiceConfigInsertInput struct {
	Name        string                                  `json:"name,omitempty" toml:"name,omitempty"`
	Image       *ConfigRunServiceImageInsertInput       `json:"image,omitempty" toml:"image,omitempty"`
	Command     []string                                `json:"command,omitempty" toml:"command,omitempty"`
	Environment []*ConfigEnvironmentVariableInsertInput `json:"environment,omitempty" toml:"environment,omitempty"`
	Ports       []*ConfigRunServicePortInsertInput      `json:"ports,omitempty" toml:"ports,omitempty"`
	Resources   *ConfigRunServiceResourcesInsertInput   `json:"resources,omitempty" toml:"resources,omitempty"`
	HealthCheck *ConfigHealthCheckInsertInput           `json:"healthCheck,omitempty" toml:"healthCheck,omitempty"`
}

func (o *ConfigRunServiceConfigInsertInput) GetName() string {
	if o == nil {
		o = &ConfigRunServiceConfigInsertInput{}
	}
	return o.Name
}

func (o *ConfigRunServiceConfigInsertInput) GetImage() *ConfigRunServiceImageInsertInput {
	if o == nil {
		return nil
	}
	return o.Image
}

func (o *ConfigRunServiceConfigInsertInput) GetCommand() []string {
	if o == nil {
		o = &ConfigRunServiceConfigInsertInput{}
	}
	return o.Command
}

func (o *ConfigRunServiceConfigInsertInput) GetEnvironment() []*ConfigEnvironmentVariableInsertInput {
	if o == nil {
		o = &ConfigRunServiceConfigInsertInput{}
	}
	return o.Environment
}

func (o *ConfigRunServiceConfigInsertInput) GetPorts() []*ConfigRunServicePortInsertInput {
	if o == nil {
		o = &ConfigRunServiceConfigInsertInput{}
	}
	return o.Ports
}

func (o *ConfigRunServiceConfigInsertInput) GetResources() *ConfigRunServiceResourcesInsertInput {
	if o == nil {
		return nil
	}
	return o.Resources
}

func (o *ConfigRunServiceConfigInsertInput) GetHealthCheck() *ConfigHealthCheckInsertInput {
	if o == nil {
		return nil
	}
	return o.HealthCheck
}

func (s *ConfigRunServiceConfig) Insert(v *ConfigRunServiceConfigInsertInput) {
	s.Name = v.Name
	if v.Image != nil {
		if s.Image == nil {
			s.Image = &ConfigRunServiceImage{}
		}
		s.Image.Insert(v.Image)
	}
	if v.Command != nil {
		s.Command = make([]string, len(v.Command))
		for i, e := range v.Command {
			s.Command[i] = e
		}
	}
	if v.Environment != nil {
		s.Environment = make([]*ConfigEnvironmentVariable, len(v.Environment))
		for i, e := range v.Environment {
			v := &ConfigEnvironmentVariable{}
			v.Insert(e)
			s.Environment[i] = v
		}
	}
	if v.Ports != nil {
		s.Ports = make([]*ConfigRunServicePort, len(v.Ports))
		for i, e := range v.Ports {
			v := &ConfigRunServicePort{}
			v.Insert(e)
			s.Ports[i] = v
		}
	}
	if v.Resources != nil {
		if s.Resources == nil {
			s.Resources = &ConfigRunServiceResources{}
		}
		s.Resources.Insert(v.Resources)
	}
	if v.HealthCheck != nil {
		if s.HealthCheck == nil {
			s.HealthCheck = &ConfigHealthCheck{}
		}
		s.HealthCheck.Insert(v.HealthCheck)
	}
}

func (s *ConfigRunServiceConfig) Clone() *ConfigRunServiceConfig {
	if s == nil {
		return nil
	}

	v := &ConfigRunServiceConfig{}
	v.Name = s.Name
	v.Image = s.Image.Clone()
	if s.Command != nil {
		v.Command = make([]string, len(s.Command))
		copy(v.Command, s.Command)
	}
	if s.Environment != nil {
		v.Environment = make([]*ConfigEnvironmentVariable, len(s.Environment))
		for i, e := range s.Environment {
			v.Environment[i] = e.Clone()
		}
	}
	if s.Ports != nil {
		v.Ports = make([]*ConfigRunServicePort, len(s.Ports))
		for i, e := range s.Ports {
			v.Ports[i] = e.Clone()
		}
	}
	v.Resources = s.Resources.Clone()
	v.HealthCheck = s.HealthCheck.Clone()
	return v
}

type ConfigRunServiceConfigComparisonExp struct {
	And         []*ConfigRunServiceConfigComparisonExp  `json:"_and,omitempty"`
	Not         *ConfigRunServiceConfigComparisonExp    `json:"_not,omitempty"`
	Or          []*ConfigRunServiceConfigComparisonExp  `json:"_or,omitempty"`
	Name        *ConfigRunServiceNameComparisonExp      `json:"name,omitempty"`
	Image       *ConfigRunServiceImageComparisonExp     `json:"image,omitempty"`
	Command     *ConfigStringComparisonExp              `json:"command,omitempty"`
	Environment *ConfigEnvironmentVariableComparisonExp `json:"environment,omitempty"`
	Ports       *ConfigRunServicePortComparisonExp      `json:"ports,omitempty"`
	Resources   *ConfigRunServiceResourcesComparisonExp `json:"resources,omitempty"`
	HealthCheck *ConfigHealthCheckComparisonExp         `json:"healthCheck,omitempty"`
}

func (exp *ConfigRunServiceConfigComparisonExp) Matches(o *ConfigRunServiceConfig) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigRunServiceConfig{
			Image:       &ConfigRunServiceImage{},
			Command:     []string{},
			Environment: []*ConfigEnvironmentVariable{},
			Ports:       []*ConfigRunServicePort{},
			Resources:   &ConfigRunServiceResources{},
			HealthCheck: &ConfigHealthCheck{},
		}
	}
	if !exp.Name.Matches(o.Name) {
		return false
	}
	if !exp.Image.Matches(o.Image) {
		return false
	}
	{
		found := false
		for _, o := range o.Command {
			if exp.Command.Matches(o) {
				found = true
				break
			}
		}
		if !found && exp.Command != nil {
			return false
		}
	}
	{
		found := false
		for _, o := range o.Environment {
			if exp.Environment.Matches(o) {
				found = true
				break
			}
		}
		if !found && exp.Environment != nil {
			return false
		}
	}
	{
		found := false
		for _, o := range o.Ports {
			if exp.Ports.Matches(o) {
				found = true
				break
			}
		}
		if !found && exp.Ports != nil {
			return false
		}
	}
	if !exp.Resources.Matches(o.Resources) {
		return false
	}
	if !exp.HealthCheck.Matches(o.HealthCheck) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigRunServiceImage struct {
	Image string `json:"image" toml:"image"`
	// content of "auths", i.e., { "auths": $THIS }
	PullCredentials *string `json:"pullCredentials" toml:"pullCredentials"`
}

func (o *ConfigRunServiceImage) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	m["image"] = o.Image
	if o.PullCredentials != nil {
		m["pullCredentials"] = o.PullCredentials
	}
	return json.Marshal(m)
}

func (o *ConfigRunServiceImage) GetImage() string {
	if o == nil {
		o = &ConfigRunServiceImage{}
	}
	return o.Image
}

func (o *ConfigRunServiceImage) GetPullCredentials() *string {
	if o == nil {
		o = &ConfigRunServiceImage{}
	}
	return o.PullCredentials
}

type ConfigRunServiceImageUpdateInput struct {
	Image                *string `json:"image,omitempty" toml:"image,omitempty"`
	IsSetImage           bool    `json:"-"`
	PullCredentials      *string `json:"pullCredentials,omitempty" toml:"pullCredentials,omitempty"`
	IsSetPullCredentials bool    `json:"-"`
}

func (o *ConfigRunServiceImageUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["image"]; ok {
		if v == nil {
			o.Image = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Image = &x
		}
		o.IsSetImage = true
	}
	if v, ok := m["pullCredentials"]; ok {
		if v == nil {
			o.PullCredentials = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.PullCredentials = &x
		}
		o.IsSetPullCredentials = true
	}

	return nil
}

func (o *ConfigRunServiceImageUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigRunServiceImageUpdateInput) GetImage() *string {
	if o == nil {
		o = &ConfigRunServiceImageUpdateInput{}
	}
	return o.Image
}

func (o *ConfigRunServiceImageUpdateInput) GetPullCredentials() *string {
	if o == nil {
		o = &ConfigRunServiceImageUpdateInput{}
	}
	return o.PullCredentials
}

func (s *ConfigRunServiceImage) Update(v *ConfigRunServiceImageUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetImage || v.Image != nil {
		if v.Image != nil {
			s.Image = *v.Image
		}
	}
	if v.IsSetPullCredentials || v.PullCredentials != nil {
		s.PullCredentials = v.PullCredentials
	}
}

type ConfigRunServiceImageInsertInput struct {
	Image           string  `json:"image,omitempty" toml:"image,omitempty"`
	PullCredentials *string `json:"pullCredentials,omitempty" toml:"pullCredentials,omitempty"`
}

func (o *ConfigRunServiceImageInsertInput) GetImage() string {
	if o == nil {
		o = &ConfigRunServiceImageInsertInput{}
	}
	return o.Image
}

func (o *ConfigRunServiceImageInsertInput) GetPullCredentials() *string {
	if o == nil {
		o = &ConfigRunServiceImageInsertInput{}
	}
	return o.PullCredentials
}

func (s *ConfigRunServiceImage) Insert(v *ConfigRunServiceImageInsertInput) {
	s.Image = v.Image
	s.PullCredentials = v.PullCredentials
}

func (s *ConfigRunServiceImage) Clone() *ConfigRunServiceImage {
	if s == nil {
		return nil
	}

	v := &ConfigRunServiceImage{}
	v.Image = s.Image
	v.PullCredentials = s.PullCredentials
	return v
}

type ConfigRunServiceImageComparisonExp struct {
	And             []*ConfigRunServiceImageComparisonExp `json:"_and,omitempty"`
	Not             *ConfigRunServiceImageComparisonExp   `json:"_not,omitempty"`
	Or              []*ConfigRunServiceImageComparisonExp `json:"_or,omitempty"`
	Image           *ConfigStringComparisonExp            `json:"image,omitempty"`
	PullCredentials *ConfigStringComparisonExp            `json:"pullCredentials,omitempty"`
}

func (exp *ConfigRunServiceImageComparisonExp) Matches(o *ConfigRunServiceImage) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigRunServiceImage{}
	}
	if !exp.Image.Matches(o.Image) {
		return false
	}
	if o.PullCredentials != nil && !exp.PullCredentials.Matches(*o.PullCredentials) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigRunServiceNameComparisonExp struct {
	Eq  *string  `json:"_eq,omitempty"`
	Neq *string  `json:"_neq,omitempty"`
	In  []string `json:"_in,omitempty"`
	Nin []string `json:"_nin,omitempty"`
}

func (exp *ConfigRunServiceNameComparisonExp) Matches(o string) bool {
	if exp == nil {
		return true
	}

	if exp.Eq != nil && *exp.Eq != o {
		return false
	}

	if exp.Neq != nil && *exp.Neq == o {
		return false
	}

	if exp.In != nil && !contains(exp.In, o) {
		return false
	}

	if exp.Nin != nil && contains(exp.Nin, o) {
		return false
	}

	return true
}

type ConfigRunServicePort struct {
	Port uint16 `json:"port" toml:"port"`

	Type string `json:"type" toml:"type"`

	Publish *bool `json:"publish" toml:"publish"`

	Ingresses []*ConfigIngress `json:"ingresses,omitempty" toml:"ingresses,omitempty"`

	RateLimit *ConfigRateLimit `json:"rateLimit,omitempty" toml:"rateLimit,omitempty"`
}

func (o *ConfigRunServicePort) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	m["port"] = o.Port
	m["type"] = o.Type
	if o.Publish != nil {
		m["publish"] = o.Publish
	}
	if o.Ingresses != nil {
		m["ingresses"] = o.Ingresses
	}
	if o.RateLimit != nil {
		m["rateLimit"] = o.RateLimit
	}
	return json.Marshal(m)
}

func (o *ConfigRunServicePort) GetPort() uint16 {
	if o == nil {
		o = &ConfigRunServicePort{}
	}
	return o.Port
}

func (o *ConfigRunServicePort) GetType() string {
	if o == nil {
		o = &ConfigRunServicePort{}
	}
	return o.Type
}

func (o *ConfigRunServicePort) GetPublish() *bool {
	if o == nil {
		o = &ConfigRunServicePort{}
	}
	return o.Publish
}

func (o *ConfigRunServicePort) GetIngresses() []*ConfigIngress {
	if o == nil {
		o = &ConfigRunServicePort{}
	}
	return o.Ingresses
}

func (o *ConfigRunServicePort) GetRateLimit() *ConfigRateLimit {
	if o == nil {
		return nil
	}
	return o.RateLimit
}

type ConfigRunServicePortUpdateInput struct {
	Port           *uint16                     `json:"port,omitempty" toml:"port,omitempty"`
	IsSetPort      bool                        `json:"-"`
	Type           *string                     `json:"type,omitempty" toml:"type,omitempty"`
	IsSetType      bool                        `json:"-"`
	Publish        *bool                       `json:"publish,omitempty" toml:"publish,omitempty"`
	IsSetPublish   bool                        `json:"-"`
	Ingresses      []*ConfigIngressUpdateInput `json:"ingresses,omitempty" toml:"ingresses,omitempty"`
	IsSetIngresses bool                        `json:"-"`
	RateLimit      *ConfigRateLimitUpdateInput `json:"rateLimit,omitempty" toml:"rateLimit,omitempty"`
	IsSetRateLimit bool                        `json:"-"`
}

func (o *ConfigRunServicePortUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["port"]; ok {
		if v == nil {
			o.Port = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x uint16
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Port = &x
		}
		o.IsSetPort = true
	}
	if v, ok := m["type"]; ok {
		if v == nil {
			o.Type = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Type = &x
		}
		o.IsSetType = true
	}
	if v, ok := m["publish"]; ok {
		if v == nil {
			o.Publish = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x bool
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Publish = &x
		}
		o.IsSetPublish = true
	}
	if v, ok := m["ingresses"]; ok {
		if v != nil {
			x, ok := v.([]interface{})
			if !ok {
				return fmt.Errorf("Ingresses must be []interface{}, got %T", v)
			}

			l := make([]*ConfigIngressUpdateInput, len(x))
			for i, vv := range x {
				t := &ConfigIngressUpdateInput{}
				if err := t.UnmarshalGQL(vv); err != nil {
					return err
				}
				l[i] = t
			}
			o.Ingresses = l
		}
		o.IsSetIngresses = true
	}
	if x, ok := m["rateLimit"]; ok {
		if x != nil {
			t := &ConfigRateLimitUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.RateLimit = t
		}
		o.IsSetRateLimit = true
	}

	return nil
}

func (o *ConfigRunServicePortUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigRunServicePortUpdateInput) GetPort() *uint16 {
	if o == nil {
		o = &ConfigRunServicePortUpdateInput{}
	}
	return o.Port
}

func (o *ConfigRunServicePortUpdateInput) GetType() *string {
	if o == nil {
		o = &ConfigRunServicePortUpdateInput{}
	}
	return o.Type
}

func (o *ConfigRunServicePortUpdateInput) GetPublish() *bool {
	if o == nil {
		o = &ConfigRunServicePortUpdateInput{}
	}
	return o.Publish
}

func (o *ConfigRunServicePortUpdateInput) GetIngresses() []*ConfigIngressUpdateInput {
	if o == nil {
		o = &ConfigRunServicePortUpdateInput{}
	}
	return o.Ingresses
}

func (o *ConfigRunServicePortUpdateInput) GetRateLimit() *ConfigRateLimitUpdateInput {
	if o == nil {
		return nil
	}
	return o.RateLimit
}

func (s *ConfigRunServicePort) Update(v *ConfigRunServicePortUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetPort || v.Port != nil {
		if v.Port != nil {
			s.Port = *v.Port
		}
	}
	if v.IsSetType || v.Type != nil {
		if v.Type != nil {
			s.Type = *v.Type
		}
	}
	if v.IsSetPublish || v.Publish != nil {
		s.Publish = v.Publish
	}
	if v.IsSetIngresses || v.Ingresses != nil {
		if v.Ingresses == nil {
			s.Ingresses = nil
		} else {
			s.Ingresses = make([]*ConfigIngress, len(v.Ingresses))
			for i, e := range v.Ingresses {
				v := &ConfigIngress{}
				v.Update(e)
				s.Ingresses[i] = v
			}
		}
	}
	if v.IsSetRateLimit || v.RateLimit != nil {
		if v.RateLimit == nil {
			s.RateLimit = nil
		} else {
			if s.RateLimit == nil {
				s.RateLimit = &ConfigRateLimit{}
			}
			s.RateLimit.Update(v.RateLimit)
		}
	}
}

type ConfigRunServicePortInsertInput struct {
	Port      uint16                      `json:"port,omitempty" toml:"port,omitempty"`
	Type      string                      `json:"type,omitempty" toml:"type,omitempty"`
	Publish   *bool                       `json:"publish,omitempty" toml:"publish,omitempty"`
	Ingresses []*ConfigIngressInsertInput `json:"ingresses,omitempty" toml:"ingresses,omitempty"`
	RateLimit *ConfigRateLimitInsertInput `json:"rateLimit,omitempty" toml:"rateLimit,omitempty"`
}

func (o *ConfigRunServicePortInsertInput) GetPort() uint16 {
	if o == nil {
		o = &ConfigRunServicePortInsertInput{}
	}
	return o.Port
}

func (o *ConfigRunServicePortInsertInput) GetType() string {
	if o == nil {
		o = &ConfigRunServicePortInsertInput{}
	}
	return o.Type
}

func (o *ConfigRunServicePortInsertInput) GetPublish() *bool {
	if o == nil {
		o = &ConfigRunServicePortInsertInput{}
	}
	return o.Publish
}

func (o *ConfigRunServicePortInsertInput) GetIngresses() []*ConfigIngressInsertInput {
	if o == nil {
		o = &ConfigRunServicePortInsertInput{}
	}
	return o.Ingresses
}

func (o *ConfigRunServicePortInsertInput) GetRateLimit() *ConfigRateLimitInsertInput {
	if o == nil {
		return nil
	}
	return o.RateLimit
}

func (s *ConfigRunServicePort) Insert(v *ConfigRunServicePortInsertInput) {
	s.Port = v.Port
	s.Type = v.Type
	s.Publish = v.Publish
	if v.Ingresses != nil {
		s.Ingresses = make([]*ConfigIngress, len(v.Ingresses))
		for i, e := range v.Ingresses {
			v := &ConfigIngress{}
			v.Insert(e)
			s.Ingresses[i] = v
		}
	}
	if v.RateLimit != nil {
		if s.RateLimit == nil {
			s.RateLimit = &ConfigRateLimit{}
		}
		s.RateLimit.Insert(v.RateLimit)
	}
}

func (s *ConfigRunServicePort) Clone() *ConfigRunServicePort {
	if s == nil {
		return nil
	}

	v := &ConfigRunServicePort{}
	v.Port = s.Port
	v.Type = s.Type
	v.Publish = s.Publish
	if s.Ingresses != nil {
		v.Ingresses = make([]*ConfigIngress, len(s.Ingresses))
		for i, e := range s.Ingresses {
			v.Ingresses[i] = e.Clone()
		}
	}
	v.RateLimit = s.RateLimit.Clone()
	return v
}

type ConfigRunServicePortComparisonExp struct {
	And       []*ConfigRunServicePortComparisonExp `json:"_and,omitempty"`
	Not       *ConfigRunServicePortComparisonExp   `json:"_not,omitempty"`
	Or        []*ConfigRunServicePortComparisonExp `json:"_or,omitempty"`
	Port      *ConfigPortComparisonExp             `json:"port,omitempty"`
	Type      *ConfigStringComparisonExp           `json:"type,omitempty"`
	Publish   *ConfigBooleanComparisonExp          `json:"publish,omitempty"`
	Ingresses *ConfigIngressComparisonExp          `json:"ingresses,omitempty"`
	RateLimit *ConfigRateLimitComparisonExp        `json:"rateLimit,omitempty"`
}

func (exp *ConfigRunServicePortComparisonExp) Matches(o *ConfigRunServicePort) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigRunServicePort{
			Ingresses: []*ConfigIngress{},
			RateLimit: &ConfigRateLimit{},
		}
	}
	if !exp.Port.Matches(o.Port) {
		return false
	}
	if !exp.Type.Matches(o.Type) {
		return false
	}
	if o.Publish != nil && !exp.Publish.Matches(*o.Publish) {
		return false
	}
	{
		found := false
		for _, o := range o.Ingresses {
			if exp.Ingresses.Matches(o) {
				found = true
				break
			}
		}
		if !found && exp.Ingresses != nil {
			return false
		}
	}
	if !exp.RateLimit.Matches(o.RateLimit) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

// Resource configuration for a service
type ConfigRunServiceResources struct {
	Compute *ConfigComputeResources `json:"compute,omitempty" toml:"compute,omitempty"`

	Storage []*ConfigRunServiceResourcesStorage `json:"storage,omitempty" toml:"storage,omitempty"`
	// Number of replicas for a service
	Replicas uint8 `json:"replicas" toml:"replicas"`

	Autoscaler *ConfigAutoscaler `json:"autoscaler,omitempty" toml:"autoscaler,omitempty"`
}

func (o *ConfigRunServiceResources) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Compute != nil {
		m["compute"] = o.Compute
	}
	if o.Storage != nil {
		m["storage"] = o.Storage
	}
	m["replicas"] = o.Replicas
	if o.Autoscaler != nil {
		m["autoscaler"] = o.Autoscaler
	}
	return json.Marshal(m)
}

func (o *ConfigRunServiceResources) GetCompute() *ConfigComputeResources {
	if o == nil {
		return nil
	}
	return o.Compute
}

func (o *ConfigRunServiceResources) GetStorage() []*ConfigRunServiceResourcesStorage {
	if o == nil {
		o = &ConfigRunServiceResources{}
	}
	return o.Storage
}

func (o *ConfigRunServiceResources) GetReplicas() uint8 {
	if o == nil {
		o = &ConfigRunServiceResources{}
	}
	return o.Replicas
}

func (o *ConfigRunServiceResources) GetAutoscaler() *ConfigAutoscaler {
	if o == nil {
		return nil
	}
	return o.Autoscaler
}

type ConfigRunServiceResourcesUpdateInput struct {
	Compute         *ConfigComputeResourcesUpdateInput             `json:"compute,omitempty" toml:"compute,omitempty"`
	IsSetCompute    bool                                           `json:"-"`
	Storage         []*ConfigRunServiceResourcesStorageUpdateInput `json:"storage,omitempty" toml:"storage,omitempty"`
	IsSetStorage    bool                                           `json:"-"`
	Replicas        *uint8                                         `json:"replicas,omitempty" toml:"replicas,omitempty"`
	IsSetReplicas   bool                                           `json:"-"`
	Autoscaler      *ConfigAutoscalerUpdateInput                   `json:"autoscaler,omitempty" toml:"autoscaler,omitempty"`
	IsSetAutoscaler bool                                           `json:"-"`
}

func (o *ConfigRunServiceResourcesUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if x, ok := m["compute"]; ok {
		if x != nil {
			t := &ConfigComputeResourcesUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Compute = t
		}
		o.IsSetCompute = true
	}
	if v, ok := m["storage"]; ok {
		if v != nil {
			x, ok := v.([]interface{})
			if !ok {
				return fmt.Errorf("Storage must be []interface{}, got %T", v)
			}

			l := make([]*ConfigRunServiceResourcesStorageUpdateInput, len(x))
			for i, vv := range x {
				t := &ConfigRunServiceResourcesStorageUpdateInput{}
				if err := t.UnmarshalGQL(vv); err != nil {
					return err
				}
				l[i] = t
			}
			o.Storage = l
		}
		o.IsSetStorage = true
	}
	if v, ok := m["replicas"]; ok {
		if v == nil {
			o.Replicas = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x uint8
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Replicas = &x
		}
		o.IsSetReplicas = true
	}
	if x, ok := m["autoscaler"]; ok {
		if x != nil {
			t := &ConfigAutoscalerUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Autoscaler = t
		}
		o.IsSetAutoscaler = true
	}

	return nil
}

func (o *ConfigRunServiceResourcesUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigRunServiceResourcesUpdateInput) GetCompute() *ConfigComputeResourcesUpdateInput {
	if o == nil {
		return nil
	}
	return o.Compute
}

func (o *ConfigRunServiceResourcesUpdateInput) GetStorage() []*ConfigRunServiceResourcesStorageUpdateInput {
	if o == nil {
		o = &ConfigRunServiceResourcesUpdateInput{}
	}
	return o.Storage
}

func (o *ConfigRunServiceResourcesUpdateInput) GetReplicas() *uint8 {
	if o == nil {
		o = &ConfigRunServiceResourcesUpdateInput{}
	}
	return o.Replicas
}

func (o *ConfigRunServiceResourcesUpdateInput) GetAutoscaler() *ConfigAutoscalerUpdateInput {
	if o == nil {
		return nil
	}
	return o.Autoscaler
}

func (s *ConfigRunServiceResources) Update(v *ConfigRunServiceResourcesUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetCompute || v.Compute != nil {
		if v.Compute == nil {
			s.Compute = nil
		} else {
			if s.Compute == nil {
				s.Compute = &ConfigComputeResources{}
			}
			s.Compute.Update(v.Compute)
		}
	}
	if v.IsSetStorage || v.Storage != nil {
		if v.Storage == nil {
			s.Storage = nil
		} else {
			s.Storage = make([]*ConfigRunServiceResourcesStorage, len(v.Storage))
			for i, e := range v.Storage {
				v := &ConfigRunServiceResourcesStorage{}
				v.Update(e)
				s.Storage[i] = v
			}
		}
	}
	if v.IsSetReplicas || v.Replicas != nil {
		if v.Replicas != nil {
			s.Replicas = *v.Replicas
		}
	}
	if v.IsSetAutoscaler || v.Autoscaler != nil {
		if v.Autoscaler == nil {
			s.Autoscaler = nil
		} else {
			if s.Autoscaler == nil {
				s.Autoscaler = &ConfigAutoscaler{}
			}
			s.Autoscaler.Update(v.Autoscaler)
		}
	}
}

type ConfigRunServiceResourcesInsertInput struct {
	Compute    *ConfigComputeResourcesInsertInput             `json:"compute,omitempty" toml:"compute,omitempty"`
	Storage    []*ConfigRunServiceResourcesStorageInsertInput `json:"storage,omitempty" toml:"storage,omitempty"`
	Replicas   uint8                                          `json:"replicas,omitempty" toml:"replicas,omitempty"`
	Autoscaler *ConfigAutoscalerInsertInput                   `json:"autoscaler,omitempty" toml:"autoscaler,omitempty"`
}

func (o *ConfigRunServiceResourcesInsertInput) GetCompute() *ConfigComputeResourcesInsertInput {
	if o == nil {
		return nil
	}
	return o.Compute
}

func (o *ConfigRunServiceResourcesInsertInput) GetStorage() []*ConfigRunServiceResourcesStorageInsertInput {
	if o == nil {
		o = &ConfigRunServiceResourcesInsertInput{}
	}
	return o.Storage
}

func (o *ConfigRunServiceResourcesInsertInput) GetReplicas() uint8 {
	if o == nil {
		o = &ConfigRunServiceResourcesInsertInput{}
	}
	return o.Replicas
}

func (o *ConfigRunServiceResourcesInsertInput) GetAutoscaler() *ConfigAutoscalerInsertInput {
	if o == nil {
		return nil
	}
	return o.Autoscaler
}

func (s *ConfigRunServiceResources) Insert(v *ConfigRunServiceResourcesInsertInput) {
	if v.Compute != nil {
		if s.Compute == nil {
			s.Compute = &ConfigComputeResources{}
		}
		s.Compute.Insert(v.Compute)
	}
	if v.Storage != nil {
		s.Storage = make([]*ConfigRunServiceResourcesStorage, len(v.Storage))
		for i, e := range v.Storage {
			v := &ConfigRunServiceResourcesStorage{}
			v.Insert(e)
			s.Storage[i] = v
		}
	}
	s.Replicas = v.Replicas
	if v.Autoscaler != nil {
		if s.Autoscaler == nil {
			s.Autoscaler = &ConfigAutoscaler{}
		}
		s.Autoscaler.Insert(v.Autoscaler)
	}
}

func (s *ConfigRunServiceResources) Clone() *ConfigRunServiceResources {
	if s == nil {
		return nil
	}

	v := &ConfigRunServiceResources{}
	v.Compute = s.Compute.Clone()
	if s.Storage != nil {
		v.Storage = make([]*ConfigRunServiceResourcesStorage, len(s.Storage))
		for i, e := range s.Storage {
			v.Storage[i] = e.Clone()
		}
	}
	v.Replicas = s.Replicas
	v.Autoscaler = s.Autoscaler.Clone()
	return v
}

type ConfigRunServiceResourcesComparisonExp struct {
	And        []*ConfigRunServiceResourcesComparisonExp      `json:"_and,omitempty"`
	Not        *ConfigRunServiceResourcesComparisonExp        `json:"_not,omitempty"`
	Or         []*ConfigRunServiceResourcesComparisonExp      `json:"_or,omitempty"`
	Compute    *ConfigComputeResourcesComparisonExp           `json:"compute,omitempty"`
	Storage    *ConfigRunServiceResourcesStorageComparisonExp `json:"storage,omitempty"`
	Replicas   *ConfigUint8ComparisonExp                      `json:"replicas,omitempty"`
	Autoscaler *ConfigAutoscalerComparisonExp                 `json:"autoscaler,omitempty"`
}

func (exp *ConfigRunServiceResourcesComparisonExp) Matches(o *ConfigRunServiceResources) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigRunServiceResources{
			Compute:    &ConfigComputeResources{},
			Storage:    []*ConfigRunServiceResourcesStorage{},
			Autoscaler: &ConfigAutoscaler{},
		}
	}
	if !exp.Compute.Matches(o.Compute) {
		return false
	}
	{
		found := false
		for _, o := range o.Storage {
			if exp.Storage.Matches(o) {
				found = true
				break
			}
		}
		if !found && exp.Storage != nil {
			return false
		}
	}
	if !exp.Replicas.Matches(o.Replicas) {
		return false
	}
	if !exp.Autoscaler.Matches(o.Autoscaler) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigRunServiceResourcesStorage struct {
	// name of the volume, changing it will cause data loss
	Name string `json:"name" toml:"name"`
	// GiB
	Capacity uint32 `json:"capacity" toml:"capacity"`

	Path string `json:"path" toml:"path"`
}

func (o *ConfigRunServiceResourcesStorage) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	m["name"] = o.Name
	m["capacity"] = o.Capacity
	m["path"] = o.Path
	return json.Marshal(m)
}

func (o *ConfigRunServiceResourcesStorage) GetName() string {
	if o == nil {
		o = &ConfigRunServiceResourcesStorage{}
	}
	return o.Name
}

func (o *ConfigRunServiceResourcesStorage) GetCapacity() uint32 {
	if o == nil {
		o = &ConfigRunServiceResourcesStorage{}
	}
	return o.Capacity
}

func (o *ConfigRunServiceResourcesStorage) GetPath() string {
	if o == nil {
		o = &ConfigRunServiceResourcesStorage{}
	}
	return o.Path
}

type ConfigRunServiceResourcesStorageUpdateInput struct {
	Name          *string `json:"name,omitempty" toml:"name,omitempty"`
	IsSetName     bool    `json:"-"`
	Capacity      *uint32 `json:"capacity,omitempty" toml:"capacity,omitempty"`
	IsSetCapacity bool    `json:"-"`
	Path          *string `json:"path,omitempty" toml:"path,omitempty"`
	IsSetPath     bool    `json:"-"`
}

func (o *ConfigRunServiceResourcesStorageUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["name"]; ok {
		if v == nil {
			o.Name = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Name = &x
		}
		o.IsSetName = true
	}
	if v, ok := m["capacity"]; ok {
		if v == nil {
			o.Capacity = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x uint32
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Capacity = &x
		}
		o.IsSetCapacity = true
	}
	if v, ok := m["path"]; ok {
		if v == nil {
			o.Path = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Path = &x
		}
		o.IsSetPath = true
	}

	return nil
}

func (o *ConfigRunServiceResourcesStorageUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigRunServiceResourcesStorageUpdateInput) GetName() *string {
	if o == nil {
		o = &ConfigRunServiceResourcesStorageUpdateInput{}
	}
	return o.Name
}

func (o *ConfigRunServiceResourcesStorageUpdateInput) GetCapacity() *uint32 {
	if o == nil {
		o = &ConfigRunServiceResourcesStorageUpdateInput{}
	}
	return o.Capacity
}

func (o *ConfigRunServiceResourcesStorageUpdateInput) GetPath() *string {
	if o == nil {
		o = &ConfigRunServiceResourcesStorageUpdateInput{}
	}
	return o.Path
}

func (s *ConfigRunServiceResourcesStorage) Update(v *ConfigRunServiceResourcesStorageUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetName || v.Name != nil {
		if v.Name != nil {
			s.Name = *v.Name
		}
	}
	if v.IsSetCapacity || v.Capacity != nil {
		if v.Capacity != nil {
			s.Capacity = *v.Capacity
		}
	}
	if v.IsSetPath || v.Path != nil {
		if v.Path != nil {
			s.Path = *v.Path
		}
	}
}

type ConfigRunServiceResourcesStorageInsertInput struct {
	Name     string `json:"name,omitempty" toml:"name,omitempty"`
	Capacity uint32 `json:"capacity,omitempty" toml:"capacity,omitempty"`
	Path     string `json:"path,omitempty" toml:"path,omitempty"`
}

func (o *ConfigRunServiceResourcesStorageInsertInput) GetName() string {
	if o == nil {
		o = &ConfigRunServiceResourcesStorageInsertInput{}
	}
	return o.Name
}

func (o *ConfigRunServiceResourcesStorageInsertInput) GetCapacity() uint32 {
	if o == nil {
		o = &ConfigRunServiceResourcesStorageInsertInput{}
	}
	return o.Capacity
}

func (o *ConfigRunServiceResourcesStorageInsertInput) GetPath() string {
	if o == nil {
		o = &ConfigRunServiceResourcesStorageInsertInput{}
	}
	return o.Path
}

func (s *ConfigRunServiceResourcesStorage) Insert(v *ConfigRunServiceResourcesStorageInsertInput) {
	s.Name = v.Name
	s.Capacity = v.Capacity
	s.Path = v.Path
}

func (s *ConfigRunServiceResourcesStorage) Clone() *ConfigRunServiceResourcesStorage {
	if s == nil {
		return nil
	}

	v := &ConfigRunServiceResourcesStorage{}
	v.Name = s.Name
	v.Capacity = s.Capacity
	v.Path = s.Path
	return v
}

type ConfigRunServiceResourcesStorageComparisonExp struct {
	And      []*ConfigRunServiceResourcesStorageComparisonExp `json:"_and,omitempty"`
	Not      *ConfigRunServiceResourcesStorageComparisonExp   `json:"_not,omitempty"`
	Or       []*ConfigRunServiceResourcesStorageComparisonExp `json:"_or,omitempty"`
	Name     *ConfigRunServiceNameComparisonExp               `json:"name,omitempty"`
	Capacity *ConfigUint32ComparisonExp                       `json:"capacity,omitempty"`
	Path     *ConfigStringComparisonExp                       `json:"path,omitempty"`
}

func (exp *ConfigRunServiceResourcesStorageComparisonExp) Matches(o *ConfigRunServiceResourcesStorage) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigRunServiceResourcesStorage{}
	}
	if !exp.Name.Matches(o.Name) {
		return false
	}
	if !exp.Capacity.Matches(o.Capacity) {
		return false
	}
	if !exp.Path.Matches(o.Path) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigSms struct {
	Provider *string `json:"provider" toml:"provider"`

	AccountSid string `json:"accountSid" toml:"accountSid"`

	AuthToken string `json:"authToken" toml:"authToken"`

	MessagingServiceId string `json:"messagingServiceId" toml:"messagingServiceId"`
}

func (o *ConfigSms) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Provider != nil {
		m["provider"] = o.Provider
	}
	m["accountSid"] = o.AccountSid
	m["authToken"] = o.AuthToken
	m["messagingServiceId"] = o.MessagingServiceId
	return json.Marshal(m)
}

func (o *ConfigSms) GetProvider() *string {
	if o == nil {
		o = &ConfigSms{}
	}
	return o.Provider
}

func (o *ConfigSms) GetAccountSid() string {
	if o == nil {
		o = &ConfigSms{}
	}
	return o.AccountSid
}

func (o *ConfigSms) GetAuthToken() string {
	if o == nil {
		o = &ConfigSms{}
	}
	return o.AuthToken
}

func (o *ConfigSms) GetMessagingServiceId() string {
	if o == nil {
		o = &ConfigSms{}
	}
	return o.MessagingServiceId
}

type ConfigSmsUpdateInput struct {
	Provider                *string `json:"provider,omitempty" toml:"provider,omitempty"`
	IsSetProvider           bool    `json:"-"`
	AccountSid              *string `json:"accountSid,omitempty" toml:"accountSid,omitempty"`
	IsSetAccountSid         bool    `json:"-"`
	AuthToken               *string `json:"authToken,omitempty" toml:"authToken,omitempty"`
	IsSetAuthToken          bool    `json:"-"`
	MessagingServiceId      *string `json:"messagingServiceId,omitempty" toml:"messagingServiceId,omitempty"`
	IsSetMessagingServiceId bool    `json:"-"`
}

func (o *ConfigSmsUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["provider"]; ok {
		if v == nil {
			o.Provider = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Provider = &x
		}
		o.IsSetProvider = true
	}
	if v, ok := m["accountSid"]; ok {
		if v == nil {
			o.AccountSid = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.AccountSid = &x
		}
		o.IsSetAccountSid = true
	}
	if v, ok := m["authToken"]; ok {
		if v == nil {
			o.AuthToken = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.AuthToken = &x
		}
		o.IsSetAuthToken = true
	}
	if v, ok := m["messagingServiceId"]; ok {
		if v == nil {
			o.MessagingServiceId = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.MessagingServiceId = &x
		}
		o.IsSetMessagingServiceId = true
	}

	return nil
}

func (o *ConfigSmsUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigSmsUpdateInput) GetProvider() *string {
	if o == nil {
		o = &ConfigSmsUpdateInput{}
	}
	return o.Provider
}

func (o *ConfigSmsUpdateInput) GetAccountSid() *string {
	if o == nil {
		o = &ConfigSmsUpdateInput{}
	}
	return o.AccountSid
}

func (o *ConfigSmsUpdateInput) GetAuthToken() *string {
	if o == nil {
		o = &ConfigSmsUpdateInput{}
	}
	return o.AuthToken
}

func (o *ConfigSmsUpdateInput) GetMessagingServiceId() *string {
	if o == nil {
		o = &ConfigSmsUpdateInput{}
	}
	return o.MessagingServiceId
}

func (s *ConfigSms) Update(v *ConfigSmsUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetProvider || v.Provider != nil {
		s.Provider = v.Provider
	}
	if v.IsSetAccountSid || v.AccountSid != nil {
		if v.AccountSid != nil {
			s.AccountSid = *v.AccountSid
		}
	}
	if v.IsSetAuthToken || v.AuthToken != nil {
		if v.AuthToken != nil {
			s.AuthToken = *v.AuthToken
		}
	}
	if v.IsSetMessagingServiceId || v.MessagingServiceId != nil {
		if v.MessagingServiceId != nil {
			s.MessagingServiceId = *v.MessagingServiceId
		}
	}
}

type ConfigSmsInsertInput struct {
	Provider           *string `json:"provider,omitempty" toml:"provider,omitempty"`
	AccountSid         string  `json:"accountSid,omitempty" toml:"accountSid,omitempty"`
	AuthToken          string  `json:"authToken,omitempty" toml:"authToken,omitempty"`
	MessagingServiceId string  `json:"messagingServiceId,omitempty" toml:"messagingServiceId,omitempty"`
}

func (o *ConfigSmsInsertInput) GetProvider() *string {
	if o == nil {
		o = &ConfigSmsInsertInput{}
	}
	return o.Provider
}

func (o *ConfigSmsInsertInput) GetAccountSid() string {
	if o == nil {
		o = &ConfigSmsInsertInput{}
	}
	return o.AccountSid
}

func (o *ConfigSmsInsertInput) GetAuthToken() string {
	if o == nil {
		o = &ConfigSmsInsertInput{}
	}
	return o.AuthToken
}

func (o *ConfigSmsInsertInput) GetMessagingServiceId() string {
	if o == nil {
		o = &ConfigSmsInsertInput{}
	}
	return o.MessagingServiceId
}

func (s *ConfigSms) Insert(v *ConfigSmsInsertInput) {
	s.Provider = v.Provider
	s.AccountSid = v.AccountSid
	s.AuthToken = v.AuthToken
	s.MessagingServiceId = v.MessagingServiceId
}

func (s *ConfigSms) Clone() *ConfigSms {
	if s == nil {
		return nil
	}

	v := &ConfigSms{}
	v.Provider = s.Provider
	v.AccountSid = s.AccountSid
	v.AuthToken = s.AuthToken
	v.MessagingServiceId = s.MessagingServiceId
	return v
}

type ConfigSmsComparisonExp struct {
	And                []*ConfigSmsComparisonExp  `json:"_and,omitempty"`
	Not                *ConfigSmsComparisonExp    `json:"_not,omitempty"`
	Or                 []*ConfigSmsComparisonExp  `json:"_or,omitempty"`
	Provider           *ConfigStringComparisonExp `json:"provider,omitempty"`
	AccountSid         *ConfigStringComparisonExp `json:"accountSid,omitempty"`
	AuthToken          *ConfigStringComparisonExp `json:"authToken,omitempty"`
	MessagingServiceId *ConfigStringComparisonExp `json:"messagingServiceId,omitempty"`
}

func (exp *ConfigSmsComparisonExp) Matches(o *ConfigSms) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigSms{}
	}
	if o.Provider != nil && !exp.Provider.Matches(*o.Provider) {
		return false
	}
	if !exp.AccountSid.Matches(o.AccountSid) {
		return false
	}
	if !exp.AuthToken.Matches(o.AuthToken) {
		return false
	}
	if !exp.MessagingServiceId.Matches(o.MessagingServiceId) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigSmtp struct {
	User string `json:"user" toml:"user"`

	Password string `json:"password" toml:"password"`

	Sender string `json:"sender" toml:"sender"`

	Host string `json:"host" toml:"host"`

	Port uint16 `json:"port" toml:"port"`

	Secure bool `json:"secure" toml:"secure"`

	Method string `json:"method" toml:"method"`
}

func (o *ConfigSmtp) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	m["user"] = o.User
	m["password"] = o.Password
	m["sender"] = o.Sender
	m["host"] = o.Host
	m["port"] = o.Port
	m["secure"] = o.Secure
	m["method"] = o.Method
	return json.Marshal(m)
}

func (o *ConfigSmtp) GetUser() string {
	if o == nil {
		o = &ConfigSmtp{}
	}
	return o.User
}

func (o *ConfigSmtp) GetPassword() string {
	if o == nil {
		o = &ConfigSmtp{}
	}
	return o.Password
}

func (o *ConfigSmtp) GetSender() string {
	if o == nil {
		o = &ConfigSmtp{}
	}
	return o.Sender
}

func (o *ConfigSmtp) GetHost() string {
	if o == nil {
		o = &ConfigSmtp{}
	}
	return o.Host
}

func (o *ConfigSmtp) GetPort() uint16 {
	if o == nil {
		o = &ConfigSmtp{}
	}
	return o.Port
}

func (o *ConfigSmtp) GetSecure() bool {
	if o == nil {
		o = &ConfigSmtp{}
	}
	return o.Secure
}

func (o *ConfigSmtp) GetMethod() string {
	if o == nil {
		o = &ConfigSmtp{}
	}
	return o.Method
}

type ConfigSmtpUpdateInput struct {
	User          *string `json:"user,omitempty" toml:"user,omitempty"`
	IsSetUser     bool    `json:"-"`
	Password      *string `json:"password,omitempty" toml:"password,omitempty"`
	IsSetPassword bool    `json:"-"`
	Sender        *string `json:"sender,omitempty" toml:"sender,omitempty"`
	IsSetSender   bool    `json:"-"`
	Host          *string `json:"host,omitempty" toml:"host,omitempty"`
	IsSetHost     bool    `json:"-"`
	Port          *uint16 `json:"port,omitempty" toml:"port,omitempty"`
	IsSetPort     bool    `json:"-"`
	Secure        *bool   `json:"secure,omitempty" toml:"secure,omitempty"`
	IsSetSecure   bool    `json:"-"`
	Method        *string `json:"method,omitempty" toml:"method,omitempty"`
	IsSetMethod   bool    `json:"-"`
}

func (o *ConfigSmtpUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["user"]; ok {
		if v == nil {
			o.User = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.User = &x
		}
		o.IsSetUser = true
	}
	if v, ok := m["password"]; ok {
		if v == nil {
			o.Password = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Password = &x
		}
		o.IsSetPassword = true
	}
	if v, ok := m["sender"]; ok {
		if v == nil {
			o.Sender = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Sender = &x
		}
		o.IsSetSender = true
	}
	if v, ok := m["host"]; ok {
		if v == nil {
			o.Host = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Host = &x
		}
		o.IsSetHost = true
	}
	if v, ok := m["port"]; ok {
		if v == nil {
			o.Port = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x uint16
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Port = &x
		}
		o.IsSetPort = true
	}
	if v, ok := m["secure"]; ok {
		if v == nil {
			o.Secure = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x bool
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Secure = &x
		}
		o.IsSetSecure = true
	}
	if v, ok := m["method"]; ok {
		if v == nil {
			o.Method = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Method = &x
		}
		o.IsSetMethod = true
	}

	return nil
}

func (o *ConfigSmtpUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigSmtpUpdateInput) GetUser() *string {
	if o == nil {
		o = &ConfigSmtpUpdateInput{}
	}
	return o.User
}

func (o *ConfigSmtpUpdateInput) GetPassword() *string {
	if o == nil {
		o = &ConfigSmtpUpdateInput{}
	}
	return o.Password
}

func (o *ConfigSmtpUpdateInput) GetSender() *string {
	if o == nil {
		o = &ConfigSmtpUpdateInput{}
	}
	return o.Sender
}

func (o *ConfigSmtpUpdateInput) GetHost() *string {
	if o == nil {
		o = &ConfigSmtpUpdateInput{}
	}
	return o.Host
}

func (o *ConfigSmtpUpdateInput) GetPort() *uint16 {
	if o == nil {
		o = &ConfigSmtpUpdateInput{}
	}
	return o.Port
}

func (o *ConfigSmtpUpdateInput) GetSecure() *bool {
	if o == nil {
		o = &ConfigSmtpUpdateInput{}
	}
	return o.Secure
}

func (o *ConfigSmtpUpdateInput) GetMethod() *string {
	if o == nil {
		o = &ConfigSmtpUpdateInput{}
	}
	return o.Method
}

func (s *ConfigSmtp) Update(v *ConfigSmtpUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetUser || v.User != nil {
		if v.User != nil {
			s.User = *v.User
		}
	}
	if v.IsSetPassword || v.Password != nil {
		if v.Password != nil {
			s.Password = *v.Password
		}
	}
	if v.IsSetSender || v.Sender != nil {
		if v.Sender != nil {
			s.Sender = *v.Sender
		}
	}
	if v.IsSetHost || v.Host != nil {
		if v.Host != nil {
			s.Host = *v.Host
		}
	}
	if v.IsSetPort || v.Port != nil {
		if v.Port != nil {
			s.Port = *v.Port
		}
	}
	if v.IsSetSecure || v.Secure != nil {
		if v.Secure != nil {
			s.Secure = *v.Secure
		}
	}
	if v.IsSetMethod || v.Method != nil {
		if v.Method != nil {
			s.Method = *v.Method
		}
	}
}

type ConfigSmtpInsertInput struct {
	User     string `json:"user,omitempty" toml:"user,omitempty"`
	Password string `json:"password,omitempty" toml:"password,omitempty"`
	Sender   string `json:"sender,omitempty" toml:"sender,omitempty"`
	Host     string `json:"host,omitempty" toml:"host,omitempty"`
	Port     uint16 `json:"port,omitempty" toml:"port,omitempty"`
	Secure   bool   `json:"secure,omitempty" toml:"secure,omitempty"`
	Method   string `json:"method,omitempty" toml:"method,omitempty"`
}

func (o *ConfigSmtpInsertInput) GetUser() string {
	if o == nil {
		o = &ConfigSmtpInsertInput{}
	}
	return o.User
}

func (o *ConfigSmtpInsertInput) GetPassword() string {
	if o == nil {
		o = &ConfigSmtpInsertInput{}
	}
	return o.Password
}

func (o *ConfigSmtpInsertInput) GetSender() string {
	if o == nil {
		o = &ConfigSmtpInsertInput{}
	}
	return o.Sender
}

func (o *ConfigSmtpInsertInput) GetHost() string {
	if o == nil {
		o = &ConfigSmtpInsertInput{}
	}
	return o.Host
}

func (o *ConfigSmtpInsertInput) GetPort() uint16 {
	if o == nil {
		o = &ConfigSmtpInsertInput{}
	}
	return o.Port
}

func (o *ConfigSmtpInsertInput) GetSecure() bool {
	if o == nil {
		o = &ConfigSmtpInsertInput{}
	}
	return o.Secure
}

func (o *ConfigSmtpInsertInput) GetMethod() string {
	if o == nil {
		o = &ConfigSmtpInsertInput{}
	}
	return o.Method
}

func (s *ConfigSmtp) Insert(v *ConfigSmtpInsertInput) {
	s.User = v.User
	s.Password = v.Password
	s.Sender = v.Sender
	s.Host = v.Host
	s.Port = v.Port
	s.Secure = v.Secure
	s.Method = v.Method
}

func (s *ConfigSmtp) Clone() *ConfigSmtp {
	if s == nil {
		return nil
	}

	v := &ConfigSmtp{}
	v.User = s.User
	v.Password = s.Password
	v.Sender = s.Sender
	v.Host = s.Host
	v.Port = s.Port
	v.Secure = s.Secure
	v.Method = s.Method
	return v
}

type ConfigSmtpComparisonExp struct {
	And      []*ConfigSmtpComparisonExp  `json:"_and,omitempty"`
	Not      *ConfigSmtpComparisonExp    `json:"_not,omitempty"`
	Or       []*ConfigSmtpComparisonExp  `json:"_or,omitempty"`
	User     *ConfigStringComparisonExp  `json:"user,omitempty"`
	Password *ConfigStringComparisonExp  `json:"password,omitempty"`
	Sender   *ConfigStringComparisonExp  `json:"sender,omitempty"`
	Host     *ConfigStringComparisonExp  `json:"host,omitempty"`
	Port     *ConfigPortComparisonExp    `json:"port,omitempty"`
	Secure   *ConfigBooleanComparisonExp `json:"secure,omitempty"`
	Method   *ConfigStringComparisonExp  `json:"method,omitempty"`
}

func (exp *ConfigSmtpComparisonExp) Matches(o *ConfigSmtp) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigSmtp{}
	}
	if !exp.User.Matches(o.User) {
		return false
	}
	if !exp.Password.Matches(o.Password) {
		return false
	}
	if !exp.Sender.Matches(o.Sender) {
		return false
	}
	if !exp.Host.Matches(o.Host) {
		return false
	}
	if !exp.Port.Matches(o.Port) {
		return false
	}
	if !exp.Secure.Matches(o.Secure) {
		return false
	}
	if !exp.Method.Matches(o.Method) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigStandardOauthProvider struct {
	Enabled *bool `json:"enabled" toml:"enabled"`

	ClientId *string `json:"clientId" toml:"clientId"`

	ClientSecret *string `json:"clientSecret" toml:"clientSecret"`
}

func (o *ConfigStandardOauthProvider) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Enabled != nil {
		m["enabled"] = o.Enabled
	}
	if o.ClientId != nil {
		m["clientId"] = o.ClientId
	}
	if o.ClientSecret != nil {
		m["clientSecret"] = o.ClientSecret
	}
	return json.Marshal(m)
}

func (o *ConfigStandardOauthProvider) GetEnabled() *bool {
	if o == nil {
		o = &ConfigStandardOauthProvider{}
	}
	return o.Enabled
}

func (o *ConfigStandardOauthProvider) GetClientId() *string {
	if o == nil {
		o = &ConfigStandardOauthProvider{}
	}
	return o.ClientId
}

func (o *ConfigStandardOauthProvider) GetClientSecret() *string {
	if o == nil {
		o = &ConfigStandardOauthProvider{}
	}
	return o.ClientSecret
}

type ConfigStandardOauthProviderUpdateInput struct {
	Enabled           *bool   `json:"enabled,omitempty" toml:"enabled,omitempty"`
	IsSetEnabled      bool    `json:"-"`
	ClientId          *string `json:"clientId,omitempty" toml:"clientId,omitempty"`
	IsSetClientId     bool    `json:"-"`
	ClientSecret      *string `json:"clientSecret,omitempty" toml:"clientSecret,omitempty"`
	IsSetClientSecret bool    `json:"-"`
}

func (o *ConfigStandardOauthProviderUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["enabled"]; ok {
		if v == nil {
			o.Enabled = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x bool
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Enabled = &x
		}
		o.IsSetEnabled = true
	}
	if v, ok := m["clientId"]; ok {
		if v == nil {
			o.ClientId = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.ClientId = &x
		}
		o.IsSetClientId = true
	}
	if v, ok := m["clientSecret"]; ok {
		if v == nil {
			o.ClientSecret = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.ClientSecret = &x
		}
		o.IsSetClientSecret = true
	}

	return nil
}

func (o *ConfigStandardOauthProviderUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigStandardOauthProviderUpdateInput) GetEnabled() *bool {
	if o == nil {
		o = &ConfigStandardOauthProviderUpdateInput{}
	}
	return o.Enabled
}

func (o *ConfigStandardOauthProviderUpdateInput) GetClientId() *string {
	if o == nil {
		o = &ConfigStandardOauthProviderUpdateInput{}
	}
	return o.ClientId
}

func (o *ConfigStandardOauthProviderUpdateInput) GetClientSecret() *string {
	if o == nil {
		o = &ConfigStandardOauthProviderUpdateInput{}
	}
	return o.ClientSecret
}

func (s *ConfigStandardOauthProvider) Update(v *ConfigStandardOauthProviderUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetEnabled || v.Enabled != nil {
		s.Enabled = v.Enabled
	}
	if v.IsSetClientId || v.ClientId != nil {
		s.ClientId = v.ClientId
	}
	if v.IsSetClientSecret || v.ClientSecret != nil {
		s.ClientSecret = v.ClientSecret
	}
}

type ConfigStandardOauthProviderInsertInput struct {
	Enabled      *bool   `json:"enabled,omitempty" toml:"enabled,omitempty"`
	ClientId     *string `json:"clientId,omitempty" toml:"clientId,omitempty"`
	ClientSecret *string `json:"clientSecret,omitempty" toml:"clientSecret,omitempty"`
}

func (o *ConfigStandardOauthProviderInsertInput) GetEnabled() *bool {
	if o == nil {
		o = &ConfigStandardOauthProviderInsertInput{}
	}
	return o.Enabled
}

func (o *ConfigStandardOauthProviderInsertInput) GetClientId() *string {
	if o == nil {
		o = &ConfigStandardOauthProviderInsertInput{}
	}
	return o.ClientId
}

func (o *ConfigStandardOauthProviderInsertInput) GetClientSecret() *string {
	if o == nil {
		o = &ConfigStandardOauthProviderInsertInput{}
	}
	return o.ClientSecret
}

func (s *ConfigStandardOauthProvider) Insert(v *ConfigStandardOauthProviderInsertInput) {
	s.Enabled = v.Enabled
	s.ClientId = v.ClientId
	s.ClientSecret = v.ClientSecret
}

func (s *ConfigStandardOauthProvider) Clone() *ConfigStandardOauthProvider {
	if s == nil {
		return nil
	}

	v := &ConfigStandardOauthProvider{}
	v.Enabled = s.Enabled
	v.ClientId = s.ClientId
	v.ClientSecret = s.ClientSecret
	return v
}

type ConfigStandardOauthProviderComparisonExp struct {
	And          []*ConfigStandardOauthProviderComparisonExp `json:"_and,omitempty"`
	Not          *ConfigStandardOauthProviderComparisonExp   `json:"_not,omitempty"`
	Or           []*ConfigStandardOauthProviderComparisonExp `json:"_or,omitempty"`
	Enabled      *ConfigBooleanComparisonExp                 `json:"enabled,omitempty"`
	ClientId     *ConfigStringComparisonExp                  `json:"clientId,omitempty"`
	ClientSecret *ConfigStringComparisonExp                  `json:"clientSecret,omitempty"`
}

func (exp *ConfigStandardOauthProviderComparisonExp) Matches(o *ConfigStandardOauthProvider) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigStandardOauthProvider{}
	}
	if o.Enabled != nil && !exp.Enabled.Matches(*o.Enabled) {
		return false
	}
	if o.ClientId != nil && !exp.ClientId.Matches(*o.ClientId) {
		return false
	}
	if o.ClientSecret != nil && !exp.ClientSecret.Matches(*o.ClientSecret) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigStandardOauthProviderWithScope struct {
	Enabled *bool `json:"enabled" toml:"enabled"`

	Audience *string `json:"audience" toml:"audience"`

	ClientId *string `json:"clientId" toml:"clientId"`

	Scope []string `json:"scope,omitempty" toml:"scope,omitempty"`

	ClientSecret *string `json:"clientSecret" toml:"clientSecret"`
}

func (o *ConfigStandardOauthProviderWithScope) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Enabled != nil {
		m["enabled"] = o.Enabled
	}
	if o.Audience != nil {
		m["audience"] = o.Audience
	}
	if o.ClientId != nil {
		m["clientId"] = o.ClientId
	}
	if o.Scope != nil {
		m["scope"] = o.Scope
	}
	if o.ClientSecret != nil {
		m["clientSecret"] = o.ClientSecret
	}
	return json.Marshal(m)
}

func (o *ConfigStandardOauthProviderWithScope) GetEnabled() *bool {
	if o == nil {
		o = &ConfigStandardOauthProviderWithScope{}
	}
	return o.Enabled
}

func (o *ConfigStandardOauthProviderWithScope) GetAudience() *string {
	if o == nil {
		o = &ConfigStandardOauthProviderWithScope{}
	}
	return o.Audience
}

func (o *ConfigStandardOauthProviderWithScope) GetClientId() *string {
	if o == nil {
		o = &ConfigStandardOauthProviderWithScope{}
	}
	return o.ClientId
}

func (o *ConfigStandardOauthProviderWithScope) GetScope() []string {
	if o == nil {
		o = &ConfigStandardOauthProviderWithScope{}
	}
	return o.Scope
}

func (o *ConfigStandardOauthProviderWithScope) GetClientSecret() *string {
	if o == nil {
		o = &ConfigStandardOauthProviderWithScope{}
	}
	return o.ClientSecret
}

type ConfigStandardOauthProviderWithScopeUpdateInput struct {
	Enabled           *bool    `json:"enabled,omitempty" toml:"enabled,omitempty"`
	IsSetEnabled      bool     `json:"-"`
	Audience          *string  `json:"audience,omitempty" toml:"audience,omitempty"`
	IsSetAudience     bool     `json:"-"`
	ClientId          *string  `json:"clientId,omitempty" toml:"clientId,omitempty"`
	IsSetClientId     bool     `json:"-"`
	Scope             []string `json:"scope,omitempty" toml:"scope,omitempty"`
	IsSetScope        bool     `json:"-"`
	ClientSecret      *string  `json:"clientSecret,omitempty" toml:"clientSecret,omitempty"`
	IsSetClientSecret bool     `json:"-"`
}

func (o *ConfigStandardOauthProviderWithScopeUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["enabled"]; ok {
		if v == nil {
			o.Enabled = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x bool
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Enabled = &x
		}
		o.IsSetEnabled = true
	}
	if v, ok := m["audience"]; ok {
		if v == nil {
			o.Audience = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Audience = &x
		}
		o.IsSetAudience = true
	}
	if v, ok := m["clientId"]; ok {
		if v == nil {
			o.ClientId = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.ClientId = &x
		}
		o.IsSetClientId = true
	}
	if v, ok := m["scope"]; ok {
		if v != nil {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var l []string
			if err := json.Unmarshal(b, &l); err != nil {
				return err
			}
			o.Scope = l
		}
		o.IsSetScope = true
	}
	if v, ok := m["clientSecret"]; ok {
		if v == nil {
			o.ClientSecret = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.ClientSecret = &x
		}
		o.IsSetClientSecret = true
	}

	return nil
}

func (o *ConfigStandardOauthProviderWithScopeUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigStandardOauthProviderWithScopeUpdateInput) GetEnabled() *bool {
	if o == nil {
		o = &ConfigStandardOauthProviderWithScopeUpdateInput{}
	}
	return o.Enabled
}

func (o *ConfigStandardOauthProviderWithScopeUpdateInput) GetAudience() *string {
	if o == nil {
		o = &ConfigStandardOauthProviderWithScopeUpdateInput{}
	}
	return o.Audience
}

func (o *ConfigStandardOauthProviderWithScopeUpdateInput) GetClientId() *string {
	if o == nil {
		o = &ConfigStandardOauthProviderWithScopeUpdateInput{}
	}
	return o.ClientId
}

func (o *ConfigStandardOauthProviderWithScopeUpdateInput) GetScope() []string {
	if o == nil {
		o = &ConfigStandardOauthProviderWithScopeUpdateInput{}
	}
	return o.Scope
}

func (o *ConfigStandardOauthProviderWithScopeUpdateInput) GetClientSecret() *string {
	if o == nil {
		o = &ConfigStandardOauthProviderWithScopeUpdateInput{}
	}
	return o.ClientSecret
}

func (s *ConfigStandardOauthProviderWithScope) Update(v *ConfigStandardOauthProviderWithScopeUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetEnabled || v.Enabled != nil {
		s.Enabled = v.Enabled
	}
	if v.IsSetAudience || v.Audience != nil {
		s.Audience = v.Audience
	}
	if v.IsSetClientId || v.ClientId != nil {
		s.ClientId = v.ClientId
	}
	if v.IsSetScope || v.Scope != nil {
		if v.Scope == nil {
			s.Scope = nil
		} else {
			s.Scope = make([]string, len(v.Scope))
			for i, e := range v.Scope {
				s.Scope[i] = e
			}
		}
	}
	if v.IsSetClientSecret || v.ClientSecret != nil {
		s.ClientSecret = v.ClientSecret
	}
}

type ConfigStandardOauthProviderWithScopeInsertInput struct {
	Enabled      *bool    `json:"enabled,omitempty" toml:"enabled,omitempty"`
	Audience     *string  `json:"audience,omitempty" toml:"audience,omitempty"`
	ClientId     *string  `json:"clientId,omitempty" toml:"clientId,omitempty"`
	Scope        []string `json:"scope,omitempty" toml:"scope,omitempty"`
	ClientSecret *string  `json:"clientSecret,omitempty" toml:"clientSecret,omitempty"`
}

func (o *ConfigStandardOauthProviderWithScopeInsertInput) GetEnabled() *bool {
	if o == nil {
		o = &ConfigStandardOauthProviderWithScopeInsertInput{}
	}
	return o.Enabled
}

func (o *ConfigStandardOauthProviderWithScopeInsertInput) GetAudience() *string {
	if o == nil {
		o = &ConfigStandardOauthProviderWithScopeInsertInput{}
	}
	return o.Audience
}

func (o *ConfigStandardOauthProviderWithScopeInsertInput) GetClientId() *string {
	if o == nil {
		o = &ConfigStandardOauthProviderWithScopeInsertInput{}
	}
	return o.ClientId
}

func (o *ConfigStandardOauthProviderWithScopeInsertInput) GetScope() []string {
	if o == nil {
		o = &ConfigStandardOauthProviderWithScopeInsertInput{}
	}
	return o.Scope
}

func (o *ConfigStandardOauthProviderWithScopeInsertInput) GetClientSecret() *string {
	if o == nil {
		o = &ConfigStandardOauthProviderWithScopeInsertInput{}
	}
	return o.ClientSecret
}

func (s *ConfigStandardOauthProviderWithScope) Insert(v *ConfigStandardOauthProviderWithScopeInsertInput) {
	s.Enabled = v.Enabled
	s.Audience = v.Audience
	s.ClientId = v.ClientId
	if v.Scope != nil {
		s.Scope = make([]string, len(v.Scope))
		for i, e := range v.Scope {
			s.Scope[i] = e
		}
	}
	s.ClientSecret = v.ClientSecret
}

func (s *ConfigStandardOauthProviderWithScope) Clone() *ConfigStandardOauthProviderWithScope {
	if s == nil {
		return nil
	}

	v := &ConfigStandardOauthProviderWithScope{}
	v.Enabled = s.Enabled
	v.Audience = s.Audience
	v.ClientId = s.ClientId
	if s.Scope != nil {
		v.Scope = make([]string, len(s.Scope))
		copy(v.Scope, s.Scope)
	}
	v.ClientSecret = s.ClientSecret
	return v
}

type ConfigStandardOauthProviderWithScopeComparisonExp struct {
	And          []*ConfigStandardOauthProviderWithScopeComparisonExp `json:"_and,omitempty"`
	Not          *ConfigStandardOauthProviderWithScopeComparisonExp   `json:"_not,omitempty"`
	Or           []*ConfigStandardOauthProviderWithScopeComparisonExp `json:"_or,omitempty"`
	Enabled      *ConfigBooleanComparisonExp                          `json:"enabled,omitempty"`
	Audience     *ConfigStringComparisonExp                           `json:"audience,omitempty"`
	ClientId     *ConfigStringComparisonExp                           `json:"clientId,omitempty"`
	Scope        *ConfigStringComparisonExp                           `json:"scope,omitempty"`
	ClientSecret *ConfigStringComparisonExp                           `json:"clientSecret,omitempty"`
}

func (exp *ConfigStandardOauthProviderWithScopeComparisonExp) Matches(o *ConfigStandardOauthProviderWithScope) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigStandardOauthProviderWithScope{
			Scope: []string{},
		}
	}
	if o.Enabled != nil && !exp.Enabled.Matches(*o.Enabled) {
		return false
	}
	if o.Audience != nil && !exp.Audience.Matches(*o.Audience) {
		return false
	}
	if o.ClientId != nil && !exp.ClientId.Matches(*o.ClientId) {
		return false
	}
	{
		found := false
		for _, o := range o.Scope {
			if exp.Scope.Matches(o) {
				found = true
				break
			}
		}
		if !found && exp.Scope != nil {
			return false
		}
	}
	if o.ClientSecret != nil && !exp.ClientSecret.Matches(*o.ClientSecret) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

// Configuration for storage service
type ConfigStorage struct {
	// Version of storage service, you can see available versions in the URL below:
	// https://hub.docker.com/r/nhost/hasura-storage/tags
	//
	// Releases:
	//
	// https://github.com/nhost/hasura-storage/releases
	Version *string `json:"version" toml:"version"`
	// Networking (custom domains at the moment) are not allowed as we need to do further
	// configurations in the CDN. We will enable it again in the future.
	Resources *ConfigResources `json:"resources,omitempty" toml:"resources,omitempty"`

	Antivirus *ConfigStorageAntivirus `json:"antivirus,omitempty" toml:"antivirus,omitempty"`

	RateLimit *ConfigRateLimit `json:"rateLimit,omitempty" toml:"rateLimit,omitempty"`
}

func (o *ConfigStorage) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Version != nil {
		m["version"] = o.Version
	}
	if o.Resources != nil {
		m["resources"] = o.Resources
	}
	if o.Antivirus != nil {
		m["antivirus"] = o.Antivirus
	}
	if o.RateLimit != nil {
		m["rateLimit"] = o.RateLimit
	}
	return json.Marshal(m)
}

func (o *ConfigStorage) GetVersion() *string {
	if o == nil {
		o = &ConfigStorage{}
	}
	return o.Version
}

func (o *ConfigStorage) GetResources() *ConfigResources {
	if o == nil {
		return nil
	}
	return o.Resources
}

func (o *ConfigStorage) GetAntivirus() *ConfigStorageAntivirus {
	if o == nil {
		return nil
	}
	return o.Antivirus
}

func (o *ConfigStorage) GetRateLimit() *ConfigRateLimit {
	if o == nil {
		return nil
	}
	return o.RateLimit
}

type ConfigStorageUpdateInput struct {
	Version        *string                            `json:"version,omitempty" toml:"version,omitempty"`
	IsSetVersion   bool                               `json:"-"`
	Resources      *ConfigResourcesUpdateInput        `json:"resources,omitempty" toml:"resources,omitempty"`
	IsSetResources bool                               `json:"-"`
	Antivirus      *ConfigStorageAntivirusUpdateInput `json:"antivirus,omitempty" toml:"antivirus,omitempty"`
	IsSetAntivirus bool                               `json:"-"`
	RateLimit      *ConfigRateLimitUpdateInput        `json:"rateLimit,omitempty" toml:"rateLimit,omitempty"`
	IsSetRateLimit bool                               `json:"-"`
}

func (o *ConfigStorageUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["version"]; ok {
		if v == nil {
			o.Version = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Version = &x
		}
		o.IsSetVersion = true
	}
	if x, ok := m["resources"]; ok {
		if x != nil {
			t := &ConfigResourcesUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Resources = t
		}
		o.IsSetResources = true
	}
	if x, ok := m["antivirus"]; ok {
		if x != nil {
			t := &ConfigStorageAntivirusUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Antivirus = t
		}
		o.IsSetAntivirus = true
	}
	if x, ok := m["rateLimit"]; ok {
		if x != nil {
			t := &ConfigRateLimitUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.RateLimit = t
		}
		o.IsSetRateLimit = true
	}

	return nil
}

func (o *ConfigStorageUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigStorageUpdateInput) GetVersion() *string {
	if o == nil {
		o = &ConfigStorageUpdateInput{}
	}
	return o.Version
}

func (o *ConfigStorageUpdateInput) GetResources() *ConfigResourcesUpdateInput {
	if o == nil {
		return nil
	}
	return o.Resources
}

func (o *ConfigStorageUpdateInput) GetAntivirus() *ConfigStorageAntivirusUpdateInput {
	if o == nil {
		return nil
	}
	return o.Antivirus
}

func (o *ConfigStorageUpdateInput) GetRateLimit() *ConfigRateLimitUpdateInput {
	if o == nil {
		return nil
	}
	return o.RateLimit
}

func (s *ConfigStorage) Update(v *ConfigStorageUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetVersion || v.Version != nil {
		s.Version = v.Version
	}
	if v.IsSetResources || v.Resources != nil {
		if v.Resources == nil {
			s.Resources = nil
		} else {
			if s.Resources == nil {
				s.Resources = &ConfigResources{}
			}
			s.Resources.Update(v.Resources)
		}
	}
	if v.IsSetAntivirus || v.Antivirus != nil {
		if v.Antivirus == nil {
			s.Antivirus = nil
		} else {
			if s.Antivirus == nil {
				s.Antivirus = &ConfigStorageAntivirus{}
			}
			s.Antivirus.Update(v.Antivirus)
		}
	}
	if v.IsSetRateLimit || v.RateLimit != nil {
		if v.RateLimit == nil {
			s.RateLimit = nil
		} else {
			if s.RateLimit == nil {
				s.RateLimit = &ConfigRateLimit{}
			}
			s.RateLimit.Update(v.RateLimit)
		}
	}
}

type ConfigStorageInsertInput struct {
	Version   *string                            `json:"version,omitempty" toml:"version,omitempty"`
	Resources *ConfigResourcesInsertInput        `json:"resources,omitempty" toml:"resources,omitempty"`
	Antivirus *ConfigStorageAntivirusInsertInput `json:"antivirus,omitempty" toml:"antivirus,omitempty"`
	RateLimit *ConfigRateLimitInsertInput        `json:"rateLimit,omitempty" toml:"rateLimit,omitempty"`
}

func (o *ConfigStorageInsertInput) GetVersion() *string {
	if o == nil {
		o = &ConfigStorageInsertInput{}
	}
	return o.Version
}

func (o *ConfigStorageInsertInput) GetResources() *ConfigResourcesInsertInput {
	if o == nil {
		return nil
	}
	return o.Resources
}

func (o *ConfigStorageInsertInput) GetAntivirus() *ConfigStorageAntivirusInsertInput {
	if o == nil {
		return nil
	}
	return o.Antivirus
}

func (o *ConfigStorageInsertInput) GetRateLimit() *ConfigRateLimitInsertInput {
	if o == nil {
		return nil
	}
	return o.RateLimit
}

func (s *ConfigStorage) Insert(v *ConfigStorageInsertInput) {
	s.Version = v.Version
	if v.Resources != nil {
		if s.Resources == nil {
			s.Resources = &ConfigResources{}
		}
		s.Resources.Insert(v.Resources)
	}
	if v.Antivirus != nil {
		if s.Antivirus == nil {
			s.Antivirus = &ConfigStorageAntivirus{}
		}
		s.Antivirus.Insert(v.Antivirus)
	}
	if v.RateLimit != nil {
		if s.RateLimit == nil {
			s.RateLimit = &ConfigRateLimit{}
		}
		s.RateLimit.Insert(v.RateLimit)
	}
}

func (s *ConfigStorage) Clone() *ConfigStorage {
	if s == nil {
		return nil
	}

	v := &ConfigStorage{}
	v.Version = s.Version
	v.Resources = s.Resources.Clone()
	v.Antivirus = s.Antivirus.Clone()
	v.RateLimit = s.RateLimit.Clone()
	return v
}

type ConfigStorageComparisonExp struct {
	And       []*ConfigStorageComparisonExp        `json:"_and,omitempty"`
	Not       *ConfigStorageComparisonExp          `json:"_not,omitempty"`
	Or        []*ConfigStorageComparisonExp        `json:"_or,omitempty"`
	Version   *ConfigStringComparisonExp           `json:"version,omitempty"`
	Resources *ConfigResourcesComparisonExp        `json:"resources,omitempty"`
	Antivirus *ConfigStorageAntivirusComparisonExp `json:"antivirus,omitempty"`
	RateLimit *ConfigRateLimitComparisonExp        `json:"rateLimit,omitempty"`
}

func (exp *ConfigStorageComparisonExp) Matches(o *ConfigStorage) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigStorage{
			Resources: &ConfigResources{},
			Antivirus: &ConfigStorageAntivirus{},
			RateLimit: &ConfigRateLimit{},
		}
	}
	if o.Version != nil && !exp.Version.Matches(*o.Version) {
		return false
	}
	if !exp.Resources.Matches(o.Resources) {
		return false
	}
	if !exp.Antivirus.Matches(o.Antivirus) {
		return false
	}
	if !exp.RateLimit.Matches(o.RateLimit) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigStorageAntivirus struct {
	Server *string `json:"server" toml:"server"`
}

func (o *ConfigStorageAntivirus) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Server != nil {
		m["server"] = o.Server
	}
	return json.Marshal(m)
}

func (o *ConfigStorageAntivirus) GetServer() *string {
	if o == nil {
		o = &ConfigStorageAntivirus{}
	}
	return o.Server
}

type ConfigStorageAntivirusUpdateInput struct {
	Server      *string `json:"server,omitempty" toml:"server,omitempty"`
	IsSetServer bool    `json:"-"`
}

func (o *ConfigStorageAntivirusUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["server"]; ok {
		if v == nil {
			o.Server = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Server = &x
		}
		o.IsSetServer = true
	}

	return nil
}

func (o *ConfigStorageAntivirusUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigStorageAntivirusUpdateInput) GetServer() *string {
	if o == nil {
		o = &ConfigStorageAntivirusUpdateInput{}
	}
	return o.Server
}

func (s *ConfigStorageAntivirus) Update(v *ConfigStorageAntivirusUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetServer || v.Server != nil {
		s.Server = v.Server
	}
}

type ConfigStorageAntivirusInsertInput struct {
	Server *string `json:"server,omitempty" toml:"server,omitempty"`
}

func (o *ConfigStorageAntivirusInsertInput) GetServer() *string {
	if o == nil {
		o = &ConfigStorageAntivirusInsertInput{}
	}
	return o.Server
}

func (s *ConfigStorageAntivirus) Insert(v *ConfigStorageAntivirusInsertInput) {
	s.Server = v.Server
}

func (s *ConfigStorageAntivirus) Clone() *ConfigStorageAntivirus {
	if s == nil {
		return nil
	}

	v := &ConfigStorageAntivirus{}
	v.Server = s.Server
	return v
}

type ConfigStorageAntivirusComparisonExp struct {
	And    []*ConfigStorageAntivirusComparisonExp `json:"_and,omitempty"`
	Not    *ConfigStorageAntivirusComparisonExp   `json:"_not,omitempty"`
	Or     []*ConfigStorageAntivirusComparisonExp `json:"_or,omitempty"`
	Server *ConfigStringComparisonExp             `json:"server,omitempty"`
}

func (exp *ConfigStorageAntivirusComparisonExp) Matches(o *ConfigStorageAntivirus) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigStorageAntivirus{}
	}
	if o.Server != nil && !exp.Server.Matches(*o.Server) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigSystemConfig struct {
	Auth *ConfigSystemConfigAuth `json:"auth,omitempty" toml:"auth,omitempty"`

	Graphql *ConfigSystemConfigGraphql `json:"graphql,omitempty" toml:"graphql,omitempty"`

	Postgres *ConfigSystemConfigPostgres `json:"postgres,omitempty" toml:"postgres,omitempty"`

	PersistentVolumesEncrypted *bool `json:"persistentVolumesEncrypted" toml:"persistentVolumesEncrypted"`
}

func (o *ConfigSystemConfig) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Auth != nil {
		m["auth"] = o.Auth
	}
	if o.Graphql != nil {
		m["graphql"] = o.Graphql
	}
	if o.Postgres != nil {
		m["postgres"] = o.Postgres
	}
	if o.PersistentVolumesEncrypted != nil {
		m["persistentVolumesEncrypted"] = o.PersistentVolumesEncrypted
	}
	return json.Marshal(m)
}

func (o *ConfigSystemConfig) GetAuth() *ConfigSystemConfigAuth {
	if o == nil {
		return nil
	}
	return o.Auth
}

func (o *ConfigSystemConfig) GetGraphql() *ConfigSystemConfigGraphql {
	if o == nil {
		return nil
	}
	return o.Graphql
}

func (o *ConfigSystemConfig) GetPostgres() *ConfigSystemConfigPostgres {
	if o == nil {
		return nil
	}
	return o.Postgres
}

func (o *ConfigSystemConfig) GetPersistentVolumesEncrypted() *bool {
	if o == nil {
		o = &ConfigSystemConfig{}
	}
	return o.PersistentVolumesEncrypted
}

type ConfigSystemConfigUpdateInput struct {
	Auth                            *ConfigSystemConfigAuthUpdateInput     `json:"auth,omitempty" toml:"auth,omitempty"`
	IsSetAuth                       bool                                   `json:"-"`
	Graphql                         *ConfigSystemConfigGraphqlUpdateInput  `json:"graphql,omitempty" toml:"graphql,omitempty"`
	IsSetGraphql                    bool                                   `json:"-"`
	Postgres                        *ConfigSystemConfigPostgresUpdateInput `json:"postgres,omitempty" toml:"postgres,omitempty"`
	IsSetPostgres                   bool                                   `json:"-"`
	PersistentVolumesEncrypted      *bool                                  `json:"persistentVolumesEncrypted,omitempty" toml:"persistentVolumesEncrypted,omitempty"`
	IsSetPersistentVolumesEncrypted bool                                   `json:"-"`
}

func (o *ConfigSystemConfigUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if x, ok := m["auth"]; ok {
		if x != nil {
			t := &ConfigSystemConfigAuthUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Auth = t
		}
		o.IsSetAuth = true
	}
	if x, ok := m["graphql"]; ok {
		if x != nil {
			t := &ConfigSystemConfigGraphqlUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Graphql = t
		}
		o.IsSetGraphql = true
	}
	if x, ok := m["postgres"]; ok {
		if x != nil {
			t := &ConfigSystemConfigPostgresUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Postgres = t
		}
		o.IsSetPostgres = true
	}
	if v, ok := m["persistentVolumesEncrypted"]; ok {
		if v == nil {
			o.PersistentVolumesEncrypted = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x bool
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.PersistentVolumesEncrypted = &x
		}
		o.IsSetPersistentVolumesEncrypted = true
	}

	return nil
}

func (o *ConfigSystemConfigUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigSystemConfigUpdateInput) GetAuth() *ConfigSystemConfigAuthUpdateInput {
	if o == nil {
		return nil
	}
	return o.Auth
}

func (o *ConfigSystemConfigUpdateInput) GetGraphql() *ConfigSystemConfigGraphqlUpdateInput {
	if o == nil {
		return nil
	}
	return o.Graphql
}

func (o *ConfigSystemConfigUpdateInput) GetPostgres() *ConfigSystemConfigPostgresUpdateInput {
	if o == nil {
		return nil
	}
	return o.Postgres
}

func (o *ConfigSystemConfigUpdateInput) GetPersistentVolumesEncrypted() *bool {
	if o == nil {
		o = &ConfigSystemConfigUpdateInput{}
	}
	return o.PersistentVolumesEncrypted
}

func (s *ConfigSystemConfig) Update(v *ConfigSystemConfigUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetAuth || v.Auth != nil {
		if v.Auth == nil {
			s.Auth = nil
		} else {
			if s.Auth == nil {
				s.Auth = &ConfigSystemConfigAuth{}
			}
			s.Auth.Update(v.Auth)
		}
	}
	if v.IsSetGraphql || v.Graphql != nil {
		if v.Graphql == nil {
			s.Graphql = nil
		} else {
			if s.Graphql == nil {
				s.Graphql = &ConfigSystemConfigGraphql{}
			}
			s.Graphql.Update(v.Graphql)
		}
	}
	if v.IsSetPostgres || v.Postgres != nil {
		if v.Postgres == nil {
			s.Postgres = nil
		} else {
			if s.Postgres == nil {
				s.Postgres = &ConfigSystemConfigPostgres{}
			}
			s.Postgres.Update(v.Postgres)
		}
	}
	if v.IsSetPersistentVolumesEncrypted || v.PersistentVolumesEncrypted != nil {
		s.PersistentVolumesEncrypted = v.PersistentVolumesEncrypted
	}
}

type ConfigSystemConfigInsertInput struct {
	Auth                       *ConfigSystemConfigAuthInsertInput     `json:"auth,omitempty" toml:"auth,omitempty"`
	Graphql                    *ConfigSystemConfigGraphqlInsertInput  `json:"graphql,omitempty" toml:"graphql,omitempty"`
	Postgres                   *ConfigSystemConfigPostgresInsertInput `json:"postgres,omitempty" toml:"postgres,omitempty"`
	PersistentVolumesEncrypted *bool                                  `json:"persistentVolumesEncrypted,omitempty" toml:"persistentVolumesEncrypted,omitempty"`
}

func (o *ConfigSystemConfigInsertInput) GetAuth() *ConfigSystemConfigAuthInsertInput {
	if o == nil {
		return nil
	}
	return o.Auth
}

func (o *ConfigSystemConfigInsertInput) GetGraphql() *ConfigSystemConfigGraphqlInsertInput {
	if o == nil {
		return nil
	}
	return o.Graphql
}

func (o *ConfigSystemConfigInsertInput) GetPostgres() *ConfigSystemConfigPostgresInsertInput {
	if o == nil {
		return nil
	}
	return o.Postgres
}

func (o *ConfigSystemConfigInsertInput) GetPersistentVolumesEncrypted() *bool {
	if o == nil {
		o = &ConfigSystemConfigInsertInput{}
	}
	return o.PersistentVolumesEncrypted
}

func (s *ConfigSystemConfig) Insert(v *ConfigSystemConfigInsertInput) {
	if v.Auth != nil {
		if s.Auth == nil {
			s.Auth = &ConfigSystemConfigAuth{}
		}
		s.Auth.Insert(v.Auth)
	}
	if v.Graphql != nil {
		if s.Graphql == nil {
			s.Graphql = &ConfigSystemConfigGraphql{}
		}
		s.Graphql.Insert(v.Graphql)
	}
	if v.Postgres != nil {
		if s.Postgres == nil {
			s.Postgres = &ConfigSystemConfigPostgres{}
		}
		s.Postgres.Insert(v.Postgres)
	}
	s.PersistentVolumesEncrypted = v.PersistentVolumesEncrypted
}

func (s *ConfigSystemConfig) Clone() *ConfigSystemConfig {
	if s == nil {
		return nil
	}

	v := &ConfigSystemConfig{}
	v.Auth = s.Auth.Clone()
	v.Graphql = s.Graphql.Clone()
	v.Postgres = s.Postgres.Clone()
	v.PersistentVolumesEncrypted = s.PersistentVolumesEncrypted
	return v
}

type ConfigSystemConfigComparisonExp struct {
	And                        []*ConfigSystemConfigComparisonExp       `json:"_and,omitempty"`
	Not                        *ConfigSystemConfigComparisonExp         `json:"_not,omitempty"`
	Or                         []*ConfigSystemConfigComparisonExp       `json:"_or,omitempty"`
	Auth                       *ConfigSystemConfigAuthComparisonExp     `json:"auth,omitempty"`
	Graphql                    *ConfigSystemConfigGraphqlComparisonExp  `json:"graphql,omitempty"`
	Postgres                   *ConfigSystemConfigPostgresComparisonExp `json:"postgres,omitempty"`
	PersistentVolumesEncrypted *ConfigBooleanComparisonExp              `json:"persistentVolumesEncrypted,omitempty"`
}

func (exp *ConfigSystemConfigComparisonExp) Matches(o *ConfigSystemConfig) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigSystemConfig{
			Auth:     &ConfigSystemConfigAuth{},
			Graphql:  &ConfigSystemConfigGraphql{},
			Postgres: &ConfigSystemConfigPostgres{},
		}
	}
	if !exp.Auth.Matches(o.Auth) {
		return false
	}
	if !exp.Graphql.Matches(o.Graphql) {
		return false
	}
	if !exp.Postgres.Matches(o.Postgres) {
		return false
	}
	if o.PersistentVolumesEncrypted != nil && !exp.PersistentVolumesEncrypted.Matches(*o.PersistentVolumesEncrypted) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigSystemConfigAuth struct {
	Email *ConfigSystemConfigAuthEmail `json:"email,omitempty" toml:"email,omitempty"`
}

func (o *ConfigSystemConfigAuth) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Email != nil {
		m["email"] = o.Email
	}
	return json.Marshal(m)
}

func (o *ConfigSystemConfigAuth) GetEmail() *ConfigSystemConfigAuthEmail {
	if o == nil {
		return nil
	}
	return o.Email
}

type ConfigSystemConfigAuthUpdateInput struct {
	Email      *ConfigSystemConfigAuthEmailUpdateInput `json:"email,omitempty" toml:"email,omitempty"`
	IsSetEmail bool                                    `json:"-"`
}

func (o *ConfigSystemConfigAuthUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if x, ok := m["email"]; ok {
		if x != nil {
			t := &ConfigSystemConfigAuthEmailUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Email = t
		}
		o.IsSetEmail = true
	}

	return nil
}

func (o *ConfigSystemConfigAuthUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigSystemConfigAuthUpdateInput) GetEmail() *ConfigSystemConfigAuthEmailUpdateInput {
	if o == nil {
		return nil
	}
	return o.Email
}

func (s *ConfigSystemConfigAuth) Update(v *ConfigSystemConfigAuthUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetEmail || v.Email != nil {
		if v.Email == nil {
			s.Email = nil
		} else {
			if s.Email == nil {
				s.Email = &ConfigSystemConfigAuthEmail{}
			}
			s.Email.Update(v.Email)
		}
	}
}

type ConfigSystemConfigAuthInsertInput struct {
	Email *ConfigSystemConfigAuthEmailInsertInput `json:"email,omitempty" toml:"email,omitempty"`
}

func (o *ConfigSystemConfigAuthInsertInput) GetEmail() *ConfigSystemConfigAuthEmailInsertInput {
	if o == nil {
		return nil
	}
	return o.Email
}

func (s *ConfigSystemConfigAuth) Insert(v *ConfigSystemConfigAuthInsertInput) {
	if v.Email != nil {
		if s.Email == nil {
			s.Email = &ConfigSystemConfigAuthEmail{}
		}
		s.Email.Insert(v.Email)
	}
}

func (s *ConfigSystemConfigAuth) Clone() *ConfigSystemConfigAuth {
	if s == nil {
		return nil
	}

	v := &ConfigSystemConfigAuth{}
	v.Email = s.Email.Clone()
	return v
}

type ConfigSystemConfigAuthComparisonExp struct {
	And   []*ConfigSystemConfigAuthComparisonExp    `json:"_and,omitempty"`
	Not   *ConfigSystemConfigAuthComparisonExp      `json:"_not,omitempty"`
	Or    []*ConfigSystemConfigAuthComparisonExp    `json:"_or,omitempty"`
	Email *ConfigSystemConfigAuthEmailComparisonExp `json:"email,omitempty"`
}

func (exp *ConfigSystemConfigAuthComparisonExp) Matches(o *ConfigSystemConfigAuth) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigSystemConfigAuth{
			Email: &ConfigSystemConfigAuthEmail{},
		}
	}
	if !exp.Email.Matches(o.Email) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigSystemConfigAuthEmail struct {
	Templates *ConfigSystemConfigAuthEmailTemplates `json:"templates,omitempty" toml:"templates,omitempty"`
}

func (o *ConfigSystemConfigAuthEmail) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Templates != nil {
		m["templates"] = o.Templates
	}
	return json.Marshal(m)
}

func (o *ConfigSystemConfigAuthEmail) GetTemplates() *ConfigSystemConfigAuthEmailTemplates {
	if o == nil {
		return nil
	}
	return o.Templates
}

type ConfigSystemConfigAuthEmailUpdateInput struct {
	Templates      *ConfigSystemConfigAuthEmailTemplatesUpdateInput `json:"templates,omitempty" toml:"templates,omitempty"`
	IsSetTemplates bool                                             `json:"-"`
}

func (o *ConfigSystemConfigAuthEmailUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if x, ok := m["templates"]; ok {
		if x != nil {
			t := &ConfigSystemConfigAuthEmailTemplatesUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Templates = t
		}
		o.IsSetTemplates = true
	}

	return nil
}

func (o *ConfigSystemConfigAuthEmailUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigSystemConfigAuthEmailUpdateInput) GetTemplates() *ConfigSystemConfigAuthEmailTemplatesUpdateInput {
	if o == nil {
		return nil
	}
	return o.Templates
}

func (s *ConfigSystemConfigAuthEmail) Update(v *ConfigSystemConfigAuthEmailUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetTemplates || v.Templates != nil {
		if v.Templates == nil {
			s.Templates = nil
		} else {
			if s.Templates == nil {
				s.Templates = &ConfigSystemConfigAuthEmailTemplates{}
			}
			s.Templates.Update(v.Templates)
		}
	}
}

type ConfigSystemConfigAuthEmailInsertInput struct {
	Templates *ConfigSystemConfigAuthEmailTemplatesInsertInput `json:"templates,omitempty" toml:"templates,omitempty"`
}

func (o *ConfigSystemConfigAuthEmailInsertInput) GetTemplates() *ConfigSystemConfigAuthEmailTemplatesInsertInput {
	if o == nil {
		return nil
	}
	return o.Templates
}

func (s *ConfigSystemConfigAuthEmail) Insert(v *ConfigSystemConfigAuthEmailInsertInput) {
	if v.Templates != nil {
		if s.Templates == nil {
			s.Templates = &ConfigSystemConfigAuthEmailTemplates{}
		}
		s.Templates.Insert(v.Templates)
	}
}

func (s *ConfigSystemConfigAuthEmail) Clone() *ConfigSystemConfigAuthEmail {
	if s == nil {
		return nil
	}

	v := &ConfigSystemConfigAuthEmail{}
	v.Templates = s.Templates.Clone()
	return v
}

type ConfigSystemConfigAuthEmailComparisonExp struct {
	And       []*ConfigSystemConfigAuthEmailComparisonExp        `json:"_and,omitempty"`
	Not       *ConfigSystemConfigAuthEmailComparisonExp          `json:"_not,omitempty"`
	Or        []*ConfigSystemConfigAuthEmailComparisonExp        `json:"_or,omitempty"`
	Templates *ConfigSystemConfigAuthEmailTemplatesComparisonExp `json:"templates,omitempty"`
}

func (exp *ConfigSystemConfigAuthEmailComparisonExp) Matches(o *ConfigSystemConfigAuthEmail) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigSystemConfigAuthEmail{
			Templates: &ConfigSystemConfigAuthEmailTemplates{},
		}
	}
	if !exp.Templates.Matches(o.Templates) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigSystemConfigAuthEmailTemplates struct {
	S3Key *string `json:"s3Key" toml:"s3Key"`
}

func (o *ConfigSystemConfigAuthEmailTemplates) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.S3Key != nil {
		m["s3Key"] = o.S3Key
	}
	return json.Marshal(m)
}

func (o *ConfigSystemConfigAuthEmailTemplates) GetS3Key() *string {
	if o == nil {
		o = &ConfigSystemConfigAuthEmailTemplates{}
	}
	return o.S3Key
}

type ConfigSystemConfigAuthEmailTemplatesUpdateInput struct {
	S3Key      *string `json:"s3Key,omitempty" toml:"s3Key,omitempty"`
	IsSetS3Key bool    `json:"-"`
}

func (o *ConfigSystemConfigAuthEmailTemplatesUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["s3Key"]; ok {
		if v == nil {
			o.S3Key = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.S3Key = &x
		}
		o.IsSetS3Key = true
	}

	return nil
}

func (o *ConfigSystemConfigAuthEmailTemplatesUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigSystemConfigAuthEmailTemplatesUpdateInput) GetS3Key() *string {
	if o == nil {
		o = &ConfigSystemConfigAuthEmailTemplatesUpdateInput{}
	}
	return o.S3Key
}

func (s *ConfigSystemConfigAuthEmailTemplates) Update(v *ConfigSystemConfigAuthEmailTemplatesUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetS3Key || v.S3Key != nil {
		s.S3Key = v.S3Key
	}
}

type ConfigSystemConfigAuthEmailTemplatesInsertInput struct {
	S3Key *string `json:"s3Key,omitempty" toml:"s3Key,omitempty"`
}

func (o *ConfigSystemConfigAuthEmailTemplatesInsertInput) GetS3Key() *string {
	if o == nil {
		o = &ConfigSystemConfigAuthEmailTemplatesInsertInput{}
	}
	return o.S3Key
}

func (s *ConfigSystemConfigAuthEmailTemplates) Insert(v *ConfigSystemConfigAuthEmailTemplatesInsertInput) {
	s.S3Key = v.S3Key
}

func (s *ConfigSystemConfigAuthEmailTemplates) Clone() *ConfigSystemConfigAuthEmailTemplates {
	if s == nil {
		return nil
	}

	v := &ConfigSystemConfigAuthEmailTemplates{}
	v.S3Key = s.S3Key
	return v
}

type ConfigSystemConfigAuthEmailTemplatesComparisonExp struct {
	And   []*ConfigSystemConfigAuthEmailTemplatesComparisonExp `json:"_and,omitempty"`
	Not   *ConfigSystemConfigAuthEmailTemplatesComparisonExp   `json:"_not,omitempty"`
	Or    []*ConfigSystemConfigAuthEmailTemplatesComparisonExp `json:"_or,omitempty"`
	S3Key *ConfigStringComparisonExp                           `json:"s3Key,omitempty"`
}

func (exp *ConfigSystemConfigAuthEmailTemplatesComparisonExp) Matches(o *ConfigSystemConfigAuthEmailTemplates) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigSystemConfigAuthEmailTemplates{}
	}
	if o.S3Key != nil && !exp.S3Key.Matches(*o.S3Key) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigSystemConfigGraphql struct {
	// manually enable graphi on a per-service basis
	// by default it follows the plan
	FeatureAdvancedGraphql *bool `json:"featureAdvancedGraphql" toml:"featureAdvancedGraphql"`
}

func (o *ConfigSystemConfigGraphql) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.FeatureAdvancedGraphql != nil {
		m["featureAdvancedGraphql"] = o.FeatureAdvancedGraphql
	}
	return json.Marshal(m)
}

func (o *ConfigSystemConfigGraphql) GetFeatureAdvancedGraphql() *bool {
	if o == nil {
		o = &ConfigSystemConfigGraphql{}
	}
	return o.FeatureAdvancedGraphql
}

type ConfigSystemConfigGraphqlUpdateInput struct {
	FeatureAdvancedGraphql      *bool `json:"featureAdvancedGraphql,omitempty" toml:"featureAdvancedGraphql,omitempty"`
	IsSetFeatureAdvancedGraphql bool  `json:"-"`
}

func (o *ConfigSystemConfigGraphqlUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["featureAdvancedGraphql"]; ok {
		if v == nil {
			o.FeatureAdvancedGraphql = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x bool
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.FeatureAdvancedGraphql = &x
		}
		o.IsSetFeatureAdvancedGraphql = true
	}

	return nil
}

func (o *ConfigSystemConfigGraphqlUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigSystemConfigGraphqlUpdateInput) GetFeatureAdvancedGraphql() *bool {
	if o == nil {
		o = &ConfigSystemConfigGraphqlUpdateInput{}
	}
	return o.FeatureAdvancedGraphql
}

func (s *ConfigSystemConfigGraphql) Update(v *ConfigSystemConfigGraphqlUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetFeatureAdvancedGraphql || v.FeatureAdvancedGraphql != nil {
		s.FeatureAdvancedGraphql = v.FeatureAdvancedGraphql
	}
}

type ConfigSystemConfigGraphqlInsertInput struct {
	FeatureAdvancedGraphql *bool `json:"featureAdvancedGraphql,omitempty" toml:"featureAdvancedGraphql,omitempty"`
}

func (o *ConfigSystemConfigGraphqlInsertInput) GetFeatureAdvancedGraphql() *bool {
	if o == nil {
		o = &ConfigSystemConfigGraphqlInsertInput{}
	}
	return o.FeatureAdvancedGraphql
}

func (s *ConfigSystemConfigGraphql) Insert(v *ConfigSystemConfigGraphqlInsertInput) {
	s.FeatureAdvancedGraphql = v.FeatureAdvancedGraphql
}

func (s *ConfigSystemConfigGraphql) Clone() *ConfigSystemConfigGraphql {
	if s == nil {
		return nil
	}

	v := &ConfigSystemConfigGraphql{}
	v.FeatureAdvancedGraphql = s.FeatureAdvancedGraphql
	return v
}

type ConfigSystemConfigGraphqlComparisonExp struct {
	And                    []*ConfigSystemConfigGraphqlComparisonExp `json:"_and,omitempty"`
	Not                    *ConfigSystemConfigGraphqlComparisonExp   `json:"_not,omitempty"`
	Or                     []*ConfigSystemConfigGraphqlComparisonExp `json:"_or,omitempty"`
	FeatureAdvancedGraphql *ConfigBooleanComparisonExp               `json:"featureAdvancedGraphql,omitempty"`
}

func (exp *ConfigSystemConfigGraphqlComparisonExp) Matches(o *ConfigSystemConfigGraphql) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigSystemConfigGraphql{}
	}
	if o.FeatureAdvancedGraphql != nil && !exp.FeatureAdvancedGraphql.Matches(*o.FeatureAdvancedGraphql) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigSystemConfigPostgres struct {
	Enabled *bool `json:"enabled" toml:"enabled"`

	MajorVersion *string `json:"majorVersion" toml:"majorVersion"`

	ConnectionString *ConfigSystemConfigPostgresConnectionString `json:"connectionString,omitempty" toml:"connectionString,omitempty"`

	Database string `json:"database" toml:"database"`

	Disk *ConfigSystemConfigPostgresDisk `json:"disk,omitempty" toml:"disk,omitempty"`
}

func (o *ConfigSystemConfigPostgres) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Enabled != nil {
		m["enabled"] = o.Enabled
	}
	if o.MajorVersion != nil {
		m["majorVersion"] = o.MajorVersion
	}
	if o.ConnectionString != nil {
		m["connectionString"] = o.ConnectionString
	}
	m["database"] = o.Database
	if o.Disk != nil {
		m["disk"] = o.Disk
	}
	return json.Marshal(m)
}

func (o *ConfigSystemConfigPostgres) GetEnabled() *bool {
	if o == nil {
		o = &ConfigSystemConfigPostgres{}
	}
	return o.Enabled
}

func (o *ConfigSystemConfigPostgres) GetMajorVersion() *string {
	if o == nil {
		o = &ConfigSystemConfigPostgres{}
	}
	return o.MajorVersion
}

func (o *ConfigSystemConfigPostgres) GetConnectionString() *ConfigSystemConfigPostgresConnectionString {
	if o == nil {
		return nil
	}
	return o.ConnectionString
}

func (o *ConfigSystemConfigPostgres) GetDatabase() string {
	if o == nil {
		o = &ConfigSystemConfigPostgres{}
	}
	return o.Database
}

func (o *ConfigSystemConfigPostgres) GetDisk() *ConfigSystemConfigPostgresDisk {
	if o == nil {
		return nil
	}
	return o.Disk
}

type ConfigSystemConfigPostgresUpdateInput struct {
	Enabled               *bool                                                  `json:"enabled,omitempty" toml:"enabled,omitempty"`
	IsSetEnabled          bool                                                   `json:"-"`
	MajorVersion          *string                                                `json:"majorVersion,omitempty" toml:"majorVersion,omitempty"`
	IsSetMajorVersion     bool                                                   `json:"-"`
	ConnectionString      *ConfigSystemConfigPostgresConnectionStringUpdateInput `json:"connectionString,omitempty" toml:"connectionString,omitempty"`
	IsSetConnectionString bool                                                   `json:"-"`
	Database              *string                                                `json:"database,omitempty" toml:"database,omitempty"`
	IsSetDatabase         bool                                                   `json:"-"`
	Disk                  *ConfigSystemConfigPostgresDiskUpdateInput             `json:"disk,omitempty" toml:"disk,omitempty"`
	IsSetDisk             bool                                                   `json:"-"`
}

func (o *ConfigSystemConfigPostgresUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["enabled"]; ok {
		if v == nil {
			o.Enabled = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x bool
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Enabled = &x
		}
		o.IsSetEnabled = true
	}
	if v, ok := m["majorVersion"]; ok {
		if v == nil {
			o.MajorVersion = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.MajorVersion = &x
		}
		o.IsSetMajorVersion = true
	}
	if x, ok := m["connectionString"]; ok {
		if x != nil {
			t := &ConfigSystemConfigPostgresConnectionStringUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.ConnectionString = t
		}
		o.IsSetConnectionString = true
	}
	if v, ok := m["database"]; ok {
		if v == nil {
			o.Database = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Database = &x
		}
		o.IsSetDatabase = true
	}
	if x, ok := m["disk"]; ok {
		if x != nil {
			t := &ConfigSystemConfigPostgresDiskUpdateInput{}
			if err := t.UnmarshalGQL(x); err != nil {
				return err
			}
			o.Disk = t
		}
		o.IsSetDisk = true
	}

	return nil
}

func (o *ConfigSystemConfigPostgresUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigSystemConfigPostgresUpdateInput) GetEnabled() *bool {
	if o == nil {
		o = &ConfigSystemConfigPostgresUpdateInput{}
	}
	return o.Enabled
}

func (o *ConfigSystemConfigPostgresUpdateInput) GetMajorVersion() *string {
	if o == nil {
		o = &ConfigSystemConfigPostgresUpdateInput{}
	}
	return o.MajorVersion
}

func (o *ConfigSystemConfigPostgresUpdateInput) GetConnectionString() *ConfigSystemConfigPostgresConnectionStringUpdateInput {
	if o == nil {
		return nil
	}
	return o.ConnectionString
}

func (o *ConfigSystemConfigPostgresUpdateInput) GetDatabase() *string {
	if o == nil {
		o = &ConfigSystemConfigPostgresUpdateInput{}
	}
	return o.Database
}

func (o *ConfigSystemConfigPostgresUpdateInput) GetDisk() *ConfigSystemConfigPostgresDiskUpdateInput {
	if o == nil {
		return nil
	}
	return o.Disk
}

func (s *ConfigSystemConfigPostgres) Update(v *ConfigSystemConfigPostgresUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetEnabled || v.Enabled != nil {
		s.Enabled = v.Enabled
	}
	if v.IsSetMajorVersion || v.MajorVersion != nil {
		s.MajorVersion = v.MajorVersion
	}
	if v.IsSetConnectionString || v.ConnectionString != nil {
		if v.ConnectionString == nil {
			s.ConnectionString = nil
		} else {
			if s.ConnectionString == nil {
				s.ConnectionString = &ConfigSystemConfigPostgresConnectionString{}
			}
			s.ConnectionString.Update(v.ConnectionString)
		}
	}
	if v.IsSetDatabase || v.Database != nil {
		if v.Database != nil {
			s.Database = *v.Database
		}
	}
	if v.IsSetDisk || v.Disk != nil {
		if v.Disk == nil {
			s.Disk = nil
		} else {
			if s.Disk == nil {
				s.Disk = &ConfigSystemConfigPostgresDisk{}
			}
			s.Disk.Update(v.Disk)
		}
	}
}

type ConfigSystemConfigPostgresInsertInput struct {
	Enabled          *bool                                                  `json:"enabled,omitempty" toml:"enabled,omitempty"`
	MajorVersion     *string                                                `json:"majorVersion,omitempty" toml:"majorVersion,omitempty"`
	ConnectionString *ConfigSystemConfigPostgresConnectionStringInsertInput `json:"connectionString,omitempty" toml:"connectionString,omitempty"`
	Database         string                                                 `json:"database,omitempty" toml:"database,omitempty"`
	Disk             *ConfigSystemConfigPostgresDiskInsertInput             `json:"disk,omitempty" toml:"disk,omitempty"`
}

func (o *ConfigSystemConfigPostgresInsertInput) GetEnabled() *bool {
	if o == nil {
		o = &ConfigSystemConfigPostgresInsertInput{}
	}
	return o.Enabled
}

func (o *ConfigSystemConfigPostgresInsertInput) GetMajorVersion() *string {
	if o == nil {
		o = &ConfigSystemConfigPostgresInsertInput{}
	}
	return o.MajorVersion
}

func (o *ConfigSystemConfigPostgresInsertInput) GetConnectionString() *ConfigSystemConfigPostgresConnectionStringInsertInput {
	if o == nil {
		return nil
	}
	return o.ConnectionString
}

func (o *ConfigSystemConfigPostgresInsertInput) GetDatabase() string {
	if o == nil {
		o = &ConfigSystemConfigPostgresInsertInput{}
	}
	return o.Database
}

func (o *ConfigSystemConfigPostgresInsertInput) GetDisk() *ConfigSystemConfigPostgresDiskInsertInput {
	if o == nil {
		return nil
	}
	return o.Disk
}

func (s *ConfigSystemConfigPostgres) Insert(v *ConfigSystemConfigPostgresInsertInput) {
	s.Enabled = v.Enabled
	s.MajorVersion = v.MajorVersion
	if v.ConnectionString != nil {
		if s.ConnectionString == nil {
			s.ConnectionString = &ConfigSystemConfigPostgresConnectionString{}
		}
		s.ConnectionString.Insert(v.ConnectionString)
	}
	s.Database = v.Database
	if v.Disk != nil {
		if s.Disk == nil {
			s.Disk = &ConfigSystemConfigPostgresDisk{}
		}
		s.Disk.Insert(v.Disk)
	}
}

func (s *ConfigSystemConfigPostgres) Clone() *ConfigSystemConfigPostgres {
	if s == nil {
		return nil
	}

	v := &ConfigSystemConfigPostgres{}
	v.Enabled = s.Enabled
	v.MajorVersion = s.MajorVersion
	v.ConnectionString = s.ConnectionString.Clone()
	v.Database = s.Database
	v.Disk = s.Disk.Clone()
	return v
}

type ConfigSystemConfigPostgresComparisonExp struct {
	And              []*ConfigSystemConfigPostgresComparisonExp               `json:"_and,omitempty"`
	Not              *ConfigSystemConfigPostgresComparisonExp                 `json:"_not,omitempty"`
	Or               []*ConfigSystemConfigPostgresComparisonExp               `json:"_or,omitempty"`
	Enabled          *ConfigBooleanComparisonExp                              `json:"enabled,omitempty"`
	MajorVersion     *ConfigStringComparisonExp                               `json:"majorVersion,omitempty"`
	ConnectionString *ConfigSystemConfigPostgresConnectionStringComparisonExp `json:"connectionString,omitempty"`
	Database         *ConfigStringComparisonExp                               `json:"database,omitempty"`
	Disk             *ConfigSystemConfigPostgresDiskComparisonExp             `json:"disk,omitempty"`
}

func (exp *ConfigSystemConfigPostgresComparisonExp) Matches(o *ConfigSystemConfigPostgres) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigSystemConfigPostgres{
			ConnectionString: &ConfigSystemConfigPostgresConnectionString{},
			Disk:             &ConfigSystemConfigPostgresDisk{},
		}
	}
	if o.Enabled != nil && !exp.Enabled.Matches(*o.Enabled) {
		return false
	}
	if o.MajorVersion != nil && !exp.MajorVersion.Matches(*o.MajorVersion) {
		return false
	}
	if !exp.ConnectionString.Matches(o.ConnectionString) {
		return false
	}
	if !exp.Database.Matches(o.Database) {
		return false
	}
	if !exp.Disk.Matches(o.Disk) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigSystemConfigPostgresConnectionString struct {
	Backup string `json:"backup" toml:"backup"`

	Hasura string `json:"hasura" toml:"hasura"`

	Auth string `json:"auth" toml:"auth"`

	Storage string `json:"storage" toml:"storage"`
}

func (o *ConfigSystemConfigPostgresConnectionString) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	m["backup"] = o.Backup
	m["hasura"] = o.Hasura
	m["auth"] = o.Auth
	m["storage"] = o.Storage
	return json.Marshal(m)
}

func (o *ConfigSystemConfigPostgresConnectionString) GetBackup() string {
	if o == nil {
		o = &ConfigSystemConfigPostgresConnectionString{}
	}
	return o.Backup
}

func (o *ConfigSystemConfigPostgresConnectionString) GetHasura() string {
	if o == nil {
		o = &ConfigSystemConfigPostgresConnectionString{}
	}
	return o.Hasura
}

func (o *ConfigSystemConfigPostgresConnectionString) GetAuth() string {
	if o == nil {
		o = &ConfigSystemConfigPostgresConnectionString{}
	}
	return o.Auth
}

func (o *ConfigSystemConfigPostgresConnectionString) GetStorage() string {
	if o == nil {
		o = &ConfigSystemConfigPostgresConnectionString{}
	}
	return o.Storage
}

type ConfigSystemConfigPostgresConnectionStringUpdateInput struct {
	Backup       *string `json:"backup,omitempty" toml:"backup,omitempty"`
	IsSetBackup  bool    `json:"-"`
	Hasura       *string `json:"hasura,omitempty" toml:"hasura,omitempty"`
	IsSetHasura  bool    `json:"-"`
	Auth         *string `json:"auth,omitempty" toml:"auth,omitempty"`
	IsSetAuth    bool    `json:"-"`
	Storage      *string `json:"storage,omitempty" toml:"storage,omitempty"`
	IsSetStorage bool    `json:"-"`
}

func (o *ConfigSystemConfigPostgresConnectionStringUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["backup"]; ok {
		if v == nil {
			o.Backup = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Backup = &x
		}
		o.IsSetBackup = true
	}
	if v, ok := m["hasura"]; ok {
		if v == nil {
			o.Hasura = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Hasura = &x
		}
		o.IsSetHasura = true
	}
	if v, ok := m["auth"]; ok {
		if v == nil {
			o.Auth = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Auth = &x
		}
		o.IsSetAuth = true
	}
	if v, ok := m["storage"]; ok {
		if v == nil {
			o.Storage = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x string
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Storage = &x
		}
		o.IsSetStorage = true
	}

	return nil
}

func (o *ConfigSystemConfigPostgresConnectionStringUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigSystemConfigPostgresConnectionStringUpdateInput) GetBackup() *string {
	if o == nil {
		o = &ConfigSystemConfigPostgresConnectionStringUpdateInput{}
	}
	return o.Backup
}

func (o *ConfigSystemConfigPostgresConnectionStringUpdateInput) GetHasura() *string {
	if o == nil {
		o = &ConfigSystemConfigPostgresConnectionStringUpdateInput{}
	}
	return o.Hasura
}

func (o *ConfigSystemConfigPostgresConnectionStringUpdateInput) GetAuth() *string {
	if o == nil {
		o = &ConfigSystemConfigPostgresConnectionStringUpdateInput{}
	}
	return o.Auth
}

func (o *ConfigSystemConfigPostgresConnectionStringUpdateInput) GetStorage() *string {
	if o == nil {
		o = &ConfigSystemConfigPostgresConnectionStringUpdateInput{}
	}
	return o.Storage
}

func (s *ConfigSystemConfigPostgresConnectionString) Update(v *ConfigSystemConfigPostgresConnectionStringUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetBackup || v.Backup != nil {
		if v.Backup != nil {
			s.Backup = *v.Backup
		}
	}
	if v.IsSetHasura || v.Hasura != nil {
		if v.Hasura != nil {
			s.Hasura = *v.Hasura
		}
	}
	if v.IsSetAuth || v.Auth != nil {
		if v.Auth != nil {
			s.Auth = *v.Auth
		}
	}
	if v.IsSetStorage || v.Storage != nil {
		if v.Storage != nil {
			s.Storage = *v.Storage
		}
	}
}

type ConfigSystemConfigPostgresConnectionStringInsertInput struct {
	Backup  string `json:"backup,omitempty" toml:"backup,omitempty"`
	Hasura  string `json:"hasura,omitempty" toml:"hasura,omitempty"`
	Auth    string `json:"auth,omitempty" toml:"auth,omitempty"`
	Storage string `json:"storage,omitempty" toml:"storage,omitempty"`
}

func (o *ConfigSystemConfigPostgresConnectionStringInsertInput) GetBackup() string {
	if o == nil {
		o = &ConfigSystemConfigPostgresConnectionStringInsertInput{}
	}
	return o.Backup
}

func (o *ConfigSystemConfigPostgresConnectionStringInsertInput) GetHasura() string {
	if o == nil {
		o = &ConfigSystemConfigPostgresConnectionStringInsertInput{}
	}
	return o.Hasura
}

func (o *ConfigSystemConfigPostgresConnectionStringInsertInput) GetAuth() string {
	if o == nil {
		o = &ConfigSystemConfigPostgresConnectionStringInsertInput{}
	}
	return o.Auth
}

func (o *ConfigSystemConfigPostgresConnectionStringInsertInput) GetStorage() string {
	if o == nil {
		o = &ConfigSystemConfigPostgresConnectionStringInsertInput{}
	}
	return o.Storage
}

func (s *ConfigSystemConfigPostgresConnectionString) Insert(v *ConfigSystemConfigPostgresConnectionStringInsertInput) {
	s.Backup = v.Backup
	s.Hasura = v.Hasura
	s.Auth = v.Auth
	s.Storage = v.Storage
}

func (s *ConfigSystemConfigPostgresConnectionString) Clone() *ConfigSystemConfigPostgresConnectionString {
	if s == nil {
		return nil
	}

	v := &ConfigSystemConfigPostgresConnectionString{}
	v.Backup = s.Backup
	v.Hasura = s.Hasura
	v.Auth = s.Auth
	v.Storage = s.Storage
	return v
}

type ConfigSystemConfigPostgresConnectionStringComparisonExp struct {
	And     []*ConfigSystemConfigPostgresConnectionStringComparisonExp `json:"_and,omitempty"`
	Not     *ConfigSystemConfigPostgresConnectionStringComparisonExp   `json:"_not,omitempty"`
	Or      []*ConfigSystemConfigPostgresConnectionStringComparisonExp `json:"_or,omitempty"`
	Backup  *ConfigStringComparisonExp                                 `json:"backup,omitempty"`
	Hasura  *ConfigStringComparisonExp                                 `json:"hasura,omitempty"`
	Auth    *ConfigStringComparisonExp                                 `json:"auth,omitempty"`
	Storage *ConfigStringComparisonExp                                 `json:"storage,omitempty"`
}

func (exp *ConfigSystemConfigPostgresConnectionStringComparisonExp) Matches(o *ConfigSystemConfigPostgresConnectionString) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigSystemConfigPostgresConnectionString{}
	}
	if !exp.Backup.Matches(o.Backup) {
		return false
	}
	if !exp.Hasura.Matches(o.Hasura) {
		return false
	}
	if !exp.Auth.Matches(o.Auth) {
		return false
	}
	if !exp.Storage.Matches(o.Storage) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigSystemConfigPostgresDisk struct {
	Iops *uint32 `json:"iops" toml:"iops"`

	Tput *uint32 `json:"tput" toml:"tput"`
}

func (o *ConfigSystemConfigPostgresDisk) MarshalJSON() ([]byte, error) {
	m := make(map[string]any)
	if o.Iops != nil {
		m["iops"] = o.Iops
	}
	if o.Tput != nil {
		m["tput"] = o.Tput
	}
	return json.Marshal(m)
}

func (o *ConfigSystemConfigPostgresDisk) GetIops() *uint32 {
	if o == nil {
		o = &ConfigSystemConfigPostgresDisk{}
	}
	return o.Iops
}

func (o *ConfigSystemConfigPostgresDisk) GetTput() *uint32 {
	if o == nil {
		o = &ConfigSystemConfigPostgresDisk{}
	}
	return o.Tput
}

type ConfigSystemConfigPostgresDiskUpdateInput struct {
	Iops      *uint32 `json:"iops,omitempty" toml:"iops,omitempty"`
	IsSetIops bool    `json:"-"`
	Tput      *uint32 `json:"tput,omitempty" toml:"tput,omitempty"`
	IsSetTput bool    `json:"-"`
}

func (o *ConfigSystemConfigPostgresDiskUpdateInput) UnmarshalGQL(v interface{}) error {
	m, ok := v.(map[string]any)
	if !ok {
		return fmt.Errorf("must be map[string]interface{}, got %T", v)
	}
	if v, ok := m["iops"]; ok {
		if v == nil {
			o.Iops = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x uint32
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Iops = &x
		}
		o.IsSetIops = true
	}
	if v, ok := m["tput"]; ok {
		if v == nil {
			o.Tput = nil
		} else {
			// clearly a not very efficient shortcut
			b, err := json.Marshal(v)
			if err != nil {
				return err
			}
			var x uint32
			if err := json.Unmarshal(b, &x); err != nil {
				return err
			}
			o.Tput = &x
		}
		o.IsSetTput = true
	}

	return nil
}

func (o *ConfigSystemConfigPostgresDiskUpdateInput) MarshalGQL(w io.Writer) {
	enc := json.NewEncoder(w)
	if err := enc.Encode(o); err != nil {
		panic(err)
	}
}

func (o *ConfigSystemConfigPostgresDiskUpdateInput) GetIops() *uint32 {
	if o == nil {
		o = &ConfigSystemConfigPostgresDiskUpdateInput{}
	}
	return o.Iops
}

func (o *ConfigSystemConfigPostgresDiskUpdateInput) GetTput() *uint32 {
	if o == nil {
		o = &ConfigSystemConfigPostgresDiskUpdateInput{}
	}
	return o.Tput
}

func (s *ConfigSystemConfigPostgresDisk) Update(v *ConfigSystemConfigPostgresDiskUpdateInput) {
	if v == nil {
		return
	}
	if v.IsSetIops || v.Iops != nil {
		s.Iops = v.Iops
	}
	if v.IsSetTput || v.Tput != nil {
		s.Tput = v.Tput
	}
}

type ConfigSystemConfigPostgresDiskInsertInput struct {
	Iops *uint32 `json:"iops,omitempty" toml:"iops,omitempty"`
	Tput *uint32 `json:"tput,omitempty" toml:"tput,omitempty"`
}

func (o *ConfigSystemConfigPostgresDiskInsertInput) GetIops() *uint32 {
	if o == nil {
		o = &ConfigSystemConfigPostgresDiskInsertInput{}
	}
	return o.Iops
}

func (o *ConfigSystemConfigPostgresDiskInsertInput) GetTput() *uint32 {
	if o == nil {
		o = &ConfigSystemConfigPostgresDiskInsertInput{}
	}
	return o.Tput
}

func (s *ConfigSystemConfigPostgresDisk) Insert(v *ConfigSystemConfigPostgresDiskInsertInput) {
	s.Iops = v.Iops
	s.Tput = v.Tput
}

func (s *ConfigSystemConfigPostgresDisk) Clone() *ConfigSystemConfigPostgresDisk {
	if s == nil {
		return nil
	}

	v := &ConfigSystemConfigPostgresDisk{}
	v.Iops = s.Iops
	v.Tput = s.Tput
	return v
}

type ConfigSystemConfigPostgresDiskComparisonExp struct {
	And  []*ConfigSystemConfigPostgresDiskComparisonExp `json:"_and,omitempty"`
	Not  *ConfigSystemConfigPostgresDiskComparisonExp   `json:"_not,omitempty"`
	Or   []*ConfigSystemConfigPostgresDiskComparisonExp `json:"_or,omitempty"`
	Iops *ConfigUint32ComparisonExp                     `json:"iops,omitempty"`
	Tput *ConfigUint32ComparisonExp                     `json:"tput,omitempty"`
}

func (exp *ConfigSystemConfigPostgresDiskComparisonExp) Matches(o *ConfigSystemConfigPostgresDisk) bool {
	if exp == nil {
		return true
	}

	if o == nil {
		o = &ConfigSystemConfigPostgresDisk{}
	}
	if o.Iops != nil && !exp.Iops.Matches(*o.Iops) {
		return false
	}
	if o.Tput != nil && !exp.Tput.Matches(*o.Tput) {
		return false
	}

	if exp.And != nil && !all(exp.And, o) {
		return false
	}

	if exp.Or != nil && !or(exp.Or, o) {
		return false
	}

	if exp.Not != nil && exp.Not.Matches(o) {
		return false
	}

	return true
}

type ConfigUrlComparisonExp struct {
	Eq  *string  `json:"_eq,omitempty"`
	Neq *string  `json:"_neq,omitempty"`
	In  []string `json:"_in,omitempty"`
	Nin []string `json:"_nin,omitempty"`
}

func (exp *ConfigUrlComparisonExp) Matches(o string) bool {
	if exp == nil {
		return true
	}

	if exp.Eq != nil && *exp.Eq != o {
		return false
	}

	if exp.Neq != nil && *exp.Neq == o {
		return false
	}

	if exp.In != nil && !contains(exp.In, o) {
		return false
	}

	if exp.Nin != nil && contains(exp.Nin, o) {
		return false
	}

	return true
}

type ConfigUserRoleComparisonExp struct {
	Eq  *string  `json:"_eq,omitempty"`
	Neq *string  `json:"_neq,omitempty"`
	In  []string `json:"_in,omitempty"`
	Nin []string `json:"_nin,omitempty"`
}

func (exp *ConfigUserRoleComparisonExp) Matches(o string) bool {
	if exp == nil {
		return true
	}

	if exp.Eq != nil && *exp.Eq != o {
		return false
	}

	if exp.Neq != nil && *exp.Neq == o {
		return false
	}

	if exp.In != nil && !contains(exp.In, o) {
		return false
	}

	if exp.Nin != nil && contains(exp.Nin, o) {
		return false
	}

	return true
}
