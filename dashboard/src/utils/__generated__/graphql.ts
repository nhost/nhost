import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
const defaultOptions = {} as const;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  ConfigEmail: any;
  ConfigHasuraAPIs: any;
  ConfigInt32: any;
  ConfigLocale: any;
  ConfigPort: any;
  ConfigRunServiceName: any;
  ConfigUint: any;
  ConfigUint8: any;
  ConfigUint32: any;
  ConfigUrl: any;
  ConfigUserRole: any;
  Timestamp: any;
  bigint: any;
  bpchar: any;
  bytea: any;
  citext: any;
  float64: any;
  jsonb: any;
  map: any;
  smallint: any;
  timestamp: any;
  timestamptz: any;
  uuid: any;
};

export type BackupPresignedUrl = {
  __typename?: 'BackupPresignedURL';
  expires_at: Scalars['Timestamp'];
  url: Scalars['String'];
};

export type BackupResult = {
  __typename?: 'BackupResult';
  backupID: Scalars['uuid'];
  size: Scalars['bigint'];
};

export type BackupResultsItem = {
  __typename?: 'BackupResultsItem';
  appID: Scalars['uuid'];
  backupID: Scalars['uuid'];
  error: Scalars['String'];
  size: Scalars['bigint'];
  success: Scalars['Boolean'];
};

/** Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'. */
export type Boolean_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['Boolean']>;
  _gt?: InputMaybe<Scalars['Boolean']>;
  _gte?: InputMaybe<Scalars['Boolean']>;
  _in?: InputMaybe<Array<Scalars['Boolean']>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _lt?: InputMaybe<Scalars['Boolean']>;
  _lte?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<Scalars['Boolean']>;
  _nin?: InputMaybe<Array<Scalars['Boolean']>>;
};

export enum CheckoutStatus {
  Completed = 'COMPLETED',
  Expired = 'EXPIRED',
  Open = 'OPEN'
}

export type ConfigAi = {
  __typename?: 'ConfigAI';
  autoEmbeddings?: Maybe<ConfigAiAutoEmbeddings>;
  openai: ConfigAiOpenai;
  resources: ConfigAiResources;
  version?: Maybe<Scalars['String']>;
  webhookSecret: Scalars['String'];
};

export type ConfigAiAutoEmbeddings = {
  __typename?: 'ConfigAIAutoEmbeddings';
  synchPeriodMinutes?: Maybe<Scalars['ConfigUint32']>;
};

export type ConfigAiAutoEmbeddingsComparisonExp = {
  _and?: InputMaybe<Array<ConfigAiAutoEmbeddingsComparisonExp>>;
  _not?: InputMaybe<ConfigAiAutoEmbeddingsComparisonExp>;
  _or?: InputMaybe<Array<ConfigAiAutoEmbeddingsComparisonExp>>;
  synchPeriodMinutes?: InputMaybe<ConfigUint32ComparisonExp>;
};

export type ConfigAiAutoEmbeddingsInsertInput = {
  synchPeriodMinutes?: InputMaybe<Scalars['ConfigUint32']>;
};

export type ConfigAiAutoEmbeddingsUpdateInput = {
  synchPeriodMinutes?: InputMaybe<Scalars['ConfigUint32']>;
};

export type ConfigAiComparisonExp = {
  _and?: InputMaybe<Array<ConfigAiComparisonExp>>;
  _not?: InputMaybe<ConfigAiComparisonExp>;
  _or?: InputMaybe<Array<ConfigAiComparisonExp>>;
  autoEmbeddings?: InputMaybe<ConfigAiAutoEmbeddingsComparisonExp>;
  openai?: InputMaybe<ConfigAiOpenaiComparisonExp>;
  resources?: InputMaybe<ConfigAiResourcesComparisonExp>;
  version?: InputMaybe<ConfigStringComparisonExp>;
  webhookSecret?: InputMaybe<ConfigStringComparisonExp>;
};

export type ConfigAiInsertInput = {
  autoEmbeddings?: InputMaybe<ConfigAiAutoEmbeddingsInsertInput>;
  openai: ConfigAiOpenaiInsertInput;
  resources: ConfigAiResourcesInsertInput;
  version?: InputMaybe<Scalars['String']>;
  webhookSecret: Scalars['String'];
};

export type ConfigAiOpenai = {
  __typename?: 'ConfigAIOpenai';
  apiKey: Scalars['String'];
  organization?: Maybe<Scalars['String']>;
};

export type ConfigAiOpenaiComparisonExp = {
  _and?: InputMaybe<Array<ConfigAiOpenaiComparisonExp>>;
  _not?: InputMaybe<ConfigAiOpenaiComparisonExp>;
  _or?: InputMaybe<Array<ConfigAiOpenaiComparisonExp>>;
  apiKey?: InputMaybe<ConfigStringComparisonExp>;
  organization?: InputMaybe<ConfigStringComparisonExp>;
};

export type ConfigAiOpenaiInsertInput = {
  apiKey: Scalars['String'];
  organization?: InputMaybe<Scalars['String']>;
};

export type ConfigAiOpenaiUpdateInput = {
  apiKey?: InputMaybe<Scalars['String']>;
  organization?: InputMaybe<Scalars['String']>;
};

export type ConfigAiResources = {
  __typename?: 'ConfigAIResources';
  compute: ConfigComputeResources;
};

export type ConfigAiResourcesComparisonExp = {
  _and?: InputMaybe<Array<ConfigAiResourcesComparisonExp>>;
  _not?: InputMaybe<ConfigAiResourcesComparisonExp>;
  _or?: InputMaybe<Array<ConfigAiResourcesComparisonExp>>;
  compute?: InputMaybe<ConfigComputeResourcesComparisonExp>;
};

export type ConfigAiResourcesInsertInput = {
  compute: ConfigComputeResourcesInsertInput;
};

export type ConfigAiResourcesUpdateInput = {
  compute?: InputMaybe<ConfigComputeResourcesUpdateInput>;
};

export type ConfigAiUpdateInput = {
  autoEmbeddings?: InputMaybe<ConfigAiAutoEmbeddingsUpdateInput>;
  openai?: InputMaybe<ConfigAiOpenaiUpdateInput>;
  resources?: InputMaybe<ConfigAiResourcesUpdateInput>;
  version?: InputMaybe<Scalars['String']>;
  webhookSecret?: InputMaybe<Scalars['String']>;
};

export type ConfigAppConfig = {
  __typename?: 'ConfigAppConfig';
  appID: Scalars['uuid'];
  config: ConfigConfig;
};

export type ConfigAppSecrets = {
  __typename?: 'ConfigAppSecrets';
  appID: Scalars['uuid'];
  secrets: Array<ConfigEnvironmentVariable>;
};

export type ConfigAppSystemConfig = {
  __typename?: 'ConfigAppSystemConfig';
  appID: Scalars['uuid'];
  systemConfig: ConfigSystemConfig;
};

/**
 * Configuration for auth service
 * You can find more information about the configuration here:
 * https://github.com/nhost/hasura-auth/blob/main/docs/environment-variables.md
 */
export type ConfigAuth = {
  __typename?: 'ConfigAuth';
  elevatedPrivileges?: Maybe<ConfigAuthElevatedPrivileges>;
  method?: Maybe<ConfigAuthMethod>;
  misc?: Maybe<ConfigAuthMisc>;
  rateLimit?: Maybe<ConfigAuthRateLimit>;
  redirections?: Maybe<ConfigAuthRedirections>;
  /** Resources for the service */
  resources?: Maybe<ConfigResources>;
  session?: Maybe<ConfigAuthSession>;
  signUp?: Maybe<ConfigAuthSignUp>;
  totp?: Maybe<ConfigAuthTotp>;
  user?: Maybe<ConfigAuthUser>;
  /**
   * Version of auth, you can see available versions in the URL below:
   * https://hub.docker.com/r/nhost/hasura-auth/tags
   *
   * Releases:
   *
   * https://github.com/nhost/hasura-auth/releases
   */
  version?: Maybe<Scalars['String']>;
};

export type ConfigAuthComparisonExp = {
  _and?: InputMaybe<Array<ConfigAuthComparisonExp>>;
  _not?: InputMaybe<ConfigAuthComparisonExp>;
  _or?: InputMaybe<Array<ConfigAuthComparisonExp>>;
  elevatedPrivileges?: InputMaybe<ConfigAuthElevatedPrivilegesComparisonExp>;
  method?: InputMaybe<ConfigAuthMethodComparisonExp>;
  misc?: InputMaybe<ConfigAuthMiscComparisonExp>;
  rateLimit?: InputMaybe<ConfigAuthRateLimitComparisonExp>;
  redirections?: InputMaybe<ConfigAuthRedirectionsComparisonExp>;
  resources?: InputMaybe<ConfigResourcesComparisonExp>;
  session?: InputMaybe<ConfigAuthSessionComparisonExp>;
  signUp?: InputMaybe<ConfigAuthSignUpComparisonExp>;
  totp?: InputMaybe<ConfigAuthTotpComparisonExp>;
  user?: InputMaybe<ConfigAuthUserComparisonExp>;
  version?: InputMaybe<ConfigStringComparisonExp>;
};

export type ConfigAuthElevatedPrivileges = {
  __typename?: 'ConfigAuthElevatedPrivileges';
  mode?: Maybe<Scalars['String']>;
};

export type ConfigAuthElevatedPrivilegesComparisonExp = {
  _and?: InputMaybe<Array<ConfigAuthElevatedPrivilegesComparisonExp>>;
  _not?: InputMaybe<ConfigAuthElevatedPrivilegesComparisonExp>;
  _or?: InputMaybe<Array<ConfigAuthElevatedPrivilegesComparisonExp>>;
  mode?: InputMaybe<ConfigStringComparisonExp>;
};

export type ConfigAuthElevatedPrivilegesInsertInput = {
  mode?: InputMaybe<Scalars['String']>;
};

export type ConfigAuthElevatedPrivilegesUpdateInput = {
  mode?: InputMaybe<Scalars['String']>;
};

export type ConfigAuthInsertInput = {
  elevatedPrivileges?: InputMaybe<ConfigAuthElevatedPrivilegesInsertInput>;
  method?: InputMaybe<ConfigAuthMethodInsertInput>;
  misc?: InputMaybe<ConfigAuthMiscInsertInput>;
  rateLimit?: InputMaybe<ConfigAuthRateLimitInsertInput>;
  redirections?: InputMaybe<ConfigAuthRedirectionsInsertInput>;
  resources?: InputMaybe<ConfigResourcesInsertInput>;
  session?: InputMaybe<ConfigAuthSessionInsertInput>;
  signUp?: InputMaybe<ConfigAuthSignUpInsertInput>;
  totp?: InputMaybe<ConfigAuthTotpInsertInput>;
  user?: InputMaybe<ConfigAuthUserInsertInput>;
  version?: InputMaybe<Scalars['String']>;
};

export type ConfigAuthMethod = {
  __typename?: 'ConfigAuthMethod';
  anonymous?: Maybe<ConfigAuthMethodAnonymous>;
  emailPassword?: Maybe<ConfigAuthMethodEmailPassword>;
  emailPasswordless?: Maybe<ConfigAuthMethodEmailPasswordless>;
  oauth?: Maybe<ConfigAuthMethodOauth>;
  smsPasswordless?: Maybe<ConfigAuthMethodSmsPasswordless>;
  webauthn?: Maybe<ConfigAuthMethodWebauthn>;
};

export type ConfigAuthMethodAnonymous = {
  __typename?: 'ConfigAuthMethodAnonymous';
  enabled?: Maybe<Scalars['Boolean']>;
};

export type ConfigAuthMethodAnonymousComparisonExp = {
  _and?: InputMaybe<Array<ConfigAuthMethodAnonymousComparisonExp>>;
  _not?: InputMaybe<ConfigAuthMethodAnonymousComparisonExp>;
  _or?: InputMaybe<Array<ConfigAuthMethodAnonymousComparisonExp>>;
  enabled?: InputMaybe<ConfigBooleanComparisonExp>;
};

export type ConfigAuthMethodAnonymousInsertInput = {
  enabled?: InputMaybe<Scalars['Boolean']>;
};

export type ConfigAuthMethodAnonymousUpdateInput = {
  enabled?: InputMaybe<Scalars['Boolean']>;
};

export type ConfigAuthMethodComparisonExp = {
  _and?: InputMaybe<Array<ConfigAuthMethodComparisonExp>>;
  _not?: InputMaybe<ConfigAuthMethodComparisonExp>;
  _or?: InputMaybe<Array<ConfigAuthMethodComparisonExp>>;
  anonymous?: InputMaybe<ConfigAuthMethodAnonymousComparisonExp>;
  emailPassword?: InputMaybe<ConfigAuthMethodEmailPasswordComparisonExp>;
  emailPasswordless?: InputMaybe<ConfigAuthMethodEmailPasswordlessComparisonExp>;
  oauth?: InputMaybe<ConfigAuthMethodOauthComparisonExp>;
  smsPasswordless?: InputMaybe<ConfigAuthMethodSmsPasswordlessComparisonExp>;
  webauthn?: InputMaybe<ConfigAuthMethodWebauthnComparisonExp>;
};

export type ConfigAuthMethodEmailPassword = {
  __typename?: 'ConfigAuthMethodEmailPassword';
  emailVerificationRequired?: Maybe<Scalars['Boolean']>;
  /**
   * Disabling email+password sign in is not implmented yet
   * enabled: bool | *true
   */
  hibpEnabled?: Maybe<Scalars['Boolean']>;
  passwordMinLength?: Maybe<Scalars['ConfigUint8']>;
};

export type ConfigAuthMethodEmailPasswordComparisonExp = {
  _and?: InputMaybe<Array<ConfigAuthMethodEmailPasswordComparisonExp>>;
  _not?: InputMaybe<ConfigAuthMethodEmailPasswordComparisonExp>;
  _or?: InputMaybe<Array<ConfigAuthMethodEmailPasswordComparisonExp>>;
  emailVerificationRequired?: InputMaybe<ConfigBooleanComparisonExp>;
  hibpEnabled?: InputMaybe<ConfigBooleanComparisonExp>;
  passwordMinLength?: InputMaybe<ConfigUint8ComparisonExp>;
};

export type ConfigAuthMethodEmailPasswordInsertInput = {
  emailVerificationRequired?: InputMaybe<Scalars['Boolean']>;
  hibpEnabled?: InputMaybe<Scalars['Boolean']>;
  passwordMinLength?: InputMaybe<Scalars['ConfigUint8']>;
};

export type ConfigAuthMethodEmailPasswordUpdateInput = {
  emailVerificationRequired?: InputMaybe<Scalars['Boolean']>;
  hibpEnabled?: InputMaybe<Scalars['Boolean']>;
  passwordMinLength?: InputMaybe<Scalars['ConfigUint8']>;
};

export type ConfigAuthMethodEmailPasswordless = {
  __typename?: 'ConfigAuthMethodEmailPasswordless';
  enabled?: Maybe<Scalars['Boolean']>;
};

export type ConfigAuthMethodEmailPasswordlessComparisonExp = {
  _and?: InputMaybe<Array<ConfigAuthMethodEmailPasswordlessComparisonExp>>;
  _not?: InputMaybe<ConfigAuthMethodEmailPasswordlessComparisonExp>;
  _or?: InputMaybe<Array<ConfigAuthMethodEmailPasswordlessComparisonExp>>;
  enabled?: InputMaybe<ConfigBooleanComparisonExp>;
};

export type ConfigAuthMethodEmailPasswordlessInsertInput = {
  enabled?: InputMaybe<Scalars['Boolean']>;
};

export type ConfigAuthMethodEmailPasswordlessUpdateInput = {
  enabled?: InputMaybe<Scalars['Boolean']>;
};

export type ConfigAuthMethodInsertInput = {
  anonymous?: InputMaybe<ConfigAuthMethodAnonymousInsertInput>;
  emailPassword?: InputMaybe<ConfigAuthMethodEmailPasswordInsertInput>;
  emailPasswordless?: InputMaybe<ConfigAuthMethodEmailPasswordlessInsertInput>;
  oauth?: InputMaybe<ConfigAuthMethodOauthInsertInput>;
  smsPasswordless?: InputMaybe<ConfigAuthMethodSmsPasswordlessInsertInput>;
  webauthn?: InputMaybe<ConfigAuthMethodWebauthnInsertInput>;
};

export type ConfigAuthMethodOauth = {
  __typename?: 'ConfigAuthMethodOauth';
  apple?: Maybe<ConfigAuthMethodOauthApple>;
  azuread?: Maybe<ConfigAuthMethodOauthAzuread>;
  bitbucket?: Maybe<ConfigStandardOauthProvider>;
  discord?: Maybe<ConfigStandardOauthProviderWithScope>;
  facebook?: Maybe<ConfigStandardOauthProviderWithScope>;
  github?: Maybe<ConfigStandardOauthProviderWithScope>;
  gitlab?: Maybe<ConfigStandardOauthProviderWithScope>;
  google?: Maybe<ConfigStandardOauthProviderWithScope>;
  linkedin?: Maybe<ConfigStandardOauthProviderWithScope>;
  spotify?: Maybe<ConfigStandardOauthProviderWithScope>;
  strava?: Maybe<ConfigStandardOauthProviderWithScope>;
  twitch?: Maybe<ConfigStandardOauthProviderWithScope>;
  twitter?: Maybe<ConfigAuthMethodOauthTwitter>;
  windowslive?: Maybe<ConfigStandardOauthProviderWithScope>;
  workos?: Maybe<ConfigAuthMethodOauthWorkos>;
};

export type ConfigAuthMethodOauthApple = {
  __typename?: 'ConfigAuthMethodOauthApple';
  clientId?: Maybe<Scalars['String']>;
  enabled?: Maybe<Scalars['Boolean']>;
  keyId?: Maybe<Scalars['String']>;
  privateKey?: Maybe<Scalars['String']>;
  scope?: Maybe<Array<Scalars['String']>>;
  teamId?: Maybe<Scalars['String']>;
};

export type ConfigAuthMethodOauthAppleComparisonExp = {
  _and?: InputMaybe<Array<ConfigAuthMethodOauthAppleComparisonExp>>;
  _not?: InputMaybe<ConfigAuthMethodOauthAppleComparisonExp>;
  _or?: InputMaybe<Array<ConfigAuthMethodOauthAppleComparisonExp>>;
  clientId?: InputMaybe<ConfigStringComparisonExp>;
  enabled?: InputMaybe<ConfigBooleanComparisonExp>;
  keyId?: InputMaybe<ConfigStringComparisonExp>;
  privateKey?: InputMaybe<ConfigStringComparisonExp>;
  scope?: InputMaybe<ConfigStringComparisonExp>;
  teamId?: InputMaybe<ConfigStringComparisonExp>;
};

export type ConfigAuthMethodOauthAppleInsertInput = {
  clientId?: InputMaybe<Scalars['String']>;
  enabled?: InputMaybe<Scalars['Boolean']>;
  keyId?: InputMaybe<Scalars['String']>;
  privateKey?: InputMaybe<Scalars['String']>;
  scope?: InputMaybe<Array<Scalars['String']>>;
  teamId?: InputMaybe<Scalars['String']>;
};

export type ConfigAuthMethodOauthAppleUpdateInput = {
  clientId?: InputMaybe<Scalars['String']>;
  enabled?: InputMaybe<Scalars['Boolean']>;
  keyId?: InputMaybe<Scalars['String']>;
  privateKey?: InputMaybe<Scalars['String']>;
  scope?: InputMaybe<Array<Scalars['String']>>;
  teamId?: InputMaybe<Scalars['String']>;
};

export type ConfigAuthMethodOauthAzuread = {
  __typename?: 'ConfigAuthMethodOauthAzuread';
  clientId?: Maybe<Scalars['String']>;
  clientSecret?: Maybe<Scalars['String']>;
  enabled?: Maybe<Scalars['Boolean']>;
  tenant?: Maybe<Scalars['String']>;
};

export type ConfigAuthMethodOauthAzureadComparisonExp = {
  _and?: InputMaybe<Array<ConfigAuthMethodOauthAzureadComparisonExp>>;
  _not?: InputMaybe<ConfigAuthMethodOauthAzureadComparisonExp>;
  _or?: InputMaybe<Array<ConfigAuthMethodOauthAzureadComparisonExp>>;
  clientId?: InputMaybe<ConfigStringComparisonExp>;
  clientSecret?: InputMaybe<ConfigStringComparisonExp>;
  enabled?: InputMaybe<ConfigBooleanComparisonExp>;
  tenant?: InputMaybe<ConfigStringComparisonExp>;
};

export type ConfigAuthMethodOauthAzureadInsertInput = {
  clientId?: InputMaybe<Scalars['String']>;
  clientSecret?: InputMaybe<Scalars['String']>;
  enabled?: InputMaybe<Scalars['Boolean']>;
  tenant?: InputMaybe<Scalars['String']>;
};

export type ConfigAuthMethodOauthAzureadUpdateInput = {
  clientId?: InputMaybe<Scalars['String']>;
  clientSecret?: InputMaybe<Scalars['String']>;
  enabled?: InputMaybe<Scalars['Boolean']>;
  tenant?: InputMaybe<Scalars['String']>;
};

export type ConfigAuthMethodOauthComparisonExp = {
  _and?: InputMaybe<Array<ConfigAuthMethodOauthComparisonExp>>;
  _not?: InputMaybe<ConfigAuthMethodOauthComparisonExp>;
  _or?: InputMaybe<Array<ConfigAuthMethodOauthComparisonExp>>;
  apple?: InputMaybe<ConfigAuthMethodOauthAppleComparisonExp>;
  azuread?: InputMaybe<ConfigAuthMethodOauthAzureadComparisonExp>;
  bitbucket?: InputMaybe<ConfigStandardOauthProviderComparisonExp>;
  discord?: InputMaybe<ConfigStandardOauthProviderWithScopeComparisonExp>;
  facebook?: InputMaybe<ConfigStandardOauthProviderWithScopeComparisonExp>;
  github?: InputMaybe<ConfigStandardOauthProviderWithScopeComparisonExp>;
  gitlab?: InputMaybe<ConfigStandardOauthProviderWithScopeComparisonExp>;
  google?: InputMaybe<ConfigStandardOauthProviderWithScopeComparisonExp>;
  linkedin?: InputMaybe<ConfigStandardOauthProviderWithScopeComparisonExp>;
  spotify?: InputMaybe<ConfigStandardOauthProviderWithScopeComparisonExp>;
  strava?: InputMaybe<ConfigStandardOauthProviderWithScopeComparisonExp>;
  twitch?: InputMaybe<ConfigStandardOauthProviderWithScopeComparisonExp>;
  twitter?: InputMaybe<ConfigAuthMethodOauthTwitterComparisonExp>;
  windowslive?: InputMaybe<ConfigStandardOauthProviderWithScopeComparisonExp>;
  workos?: InputMaybe<ConfigAuthMethodOauthWorkosComparisonExp>;
};

export type ConfigAuthMethodOauthInsertInput = {
  apple?: InputMaybe<ConfigAuthMethodOauthAppleInsertInput>;
  azuread?: InputMaybe<ConfigAuthMethodOauthAzureadInsertInput>;
  bitbucket?: InputMaybe<ConfigStandardOauthProviderInsertInput>;
  discord?: InputMaybe<ConfigStandardOauthProviderWithScopeInsertInput>;
  facebook?: InputMaybe<ConfigStandardOauthProviderWithScopeInsertInput>;
  github?: InputMaybe<ConfigStandardOauthProviderWithScopeInsertInput>;
  gitlab?: InputMaybe<ConfigStandardOauthProviderWithScopeInsertInput>;
  google?: InputMaybe<ConfigStandardOauthProviderWithScopeInsertInput>;
  linkedin?: InputMaybe<ConfigStandardOauthProviderWithScopeInsertInput>;
  spotify?: InputMaybe<ConfigStandardOauthProviderWithScopeInsertInput>;
  strava?: InputMaybe<ConfigStandardOauthProviderWithScopeInsertInput>;
  twitch?: InputMaybe<ConfigStandardOauthProviderWithScopeInsertInput>;
  twitter?: InputMaybe<ConfigAuthMethodOauthTwitterInsertInput>;
  windowslive?: InputMaybe<ConfigStandardOauthProviderWithScopeInsertInput>;
  workos?: InputMaybe<ConfigAuthMethodOauthWorkosInsertInput>;
};

export type ConfigAuthMethodOauthTwitter = {
  __typename?: 'ConfigAuthMethodOauthTwitter';
  consumerKey?: Maybe<Scalars['String']>;
  consumerSecret?: Maybe<Scalars['String']>;
  enabled?: Maybe<Scalars['Boolean']>;
};

export type ConfigAuthMethodOauthTwitterComparisonExp = {
  _and?: InputMaybe<Array<ConfigAuthMethodOauthTwitterComparisonExp>>;
  _not?: InputMaybe<ConfigAuthMethodOauthTwitterComparisonExp>;
  _or?: InputMaybe<Array<ConfigAuthMethodOauthTwitterComparisonExp>>;
  consumerKey?: InputMaybe<ConfigStringComparisonExp>;
  consumerSecret?: InputMaybe<ConfigStringComparisonExp>;
  enabled?: InputMaybe<ConfigBooleanComparisonExp>;
};

export type ConfigAuthMethodOauthTwitterInsertInput = {
  consumerKey?: InputMaybe<Scalars['String']>;
  consumerSecret?: InputMaybe<Scalars['String']>;
  enabled?: InputMaybe<Scalars['Boolean']>;
};

export type ConfigAuthMethodOauthTwitterUpdateInput = {
  consumerKey?: InputMaybe<Scalars['String']>;
  consumerSecret?: InputMaybe<Scalars['String']>;
  enabled?: InputMaybe<Scalars['Boolean']>;
};

export type ConfigAuthMethodOauthUpdateInput = {
  apple?: InputMaybe<ConfigAuthMethodOauthAppleUpdateInput>;
  azuread?: InputMaybe<ConfigAuthMethodOauthAzureadUpdateInput>;
  bitbucket?: InputMaybe<ConfigStandardOauthProviderUpdateInput>;
  discord?: InputMaybe<ConfigStandardOauthProviderWithScopeUpdateInput>;
  facebook?: InputMaybe<ConfigStandardOauthProviderWithScopeUpdateInput>;
  github?: InputMaybe<ConfigStandardOauthProviderWithScopeUpdateInput>;
  gitlab?: InputMaybe<ConfigStandardOauthProviderWithScopeUpdateInput>;
  google?: InputMaybe<ConfigStandardOauthProviderWithScopeUpdateInput>;
  linkedin?: InputMaybe<ConfigStandardOauthProviderWithScopeUpdateInput>;
  spotify?: InputMaybe<ConfigStandardOauthProviderWithScopeUpdateInput>;
  strava?: InputMaybe<ConfigStandardOauthProviderWithScopeUpdateInput>;
  twitch?: InputMaybe<ConfigStandardOauthProviderWithScopeUpdateInput>;
  twitter?: InputMaybe<ConfigAuthMethodOauthTwitterUpdateInput>;
  windowslive?: InputMaybe<ConfigStandardOauthProviderWithScopeUpdateInput>;
  workos?: InputMaybe<ConfigAuthMethodOauthWorkosUpdateInput>;
};

export type ConfigAuthMethodOauthWorkos = {
  __typename?: 'ConfigAuthMethodOauthWorkos';
  clientId?: Maybe<Scalars['String']>;
  clientSecret?: Maybe<Scalars['String']>;
  connection?: Maybe<Scalars['String']>;
  enabled?: Maybe<Scalars['Boolean']>;
  organization?: Maybe<Scalars['String']>;
};

export type ConfigAuthMethodOauthWorkosComparisonExp = {
  _and?: InputMaybe<Array<ConfigAuthMethodOauthWorkosComparisonExp>>;
  _not?: InputMaybe<ConfigAuthMethodOauthWorkosComparisonExp>;
  _or?: InputMaybe<Array<ConfigAuthMethodOauthWorkosComparisonExp>>;
  clientId?: InputMaybe<ConfigStringComparisonExp>;
  clientSecret?: InputMaybe<ConfigStringComparisonExp>;
  connection?: InputMaybe<ConfigStringComparisonExp>;
  enabled?: InputMaybe<ConfigBooleanComparisonExp>;
  organization?: InputMaybe<ConfigStringComparisonExp>;
};

export type ConfigAuthMethodOauthWorkosInsertInput = {
  clientId?: InputMaybe<Scalars['String']>;
  clientSecret?: InputMaybe<Scalars['String']>;
  connection?: InputMaybe<Scalars['String']>;
  enabled?: InputMaybe<Scalars['Boolean']>;
  organization?: InputMaybe<Scalars['String']>;
};

export type ConfigAuthMethodOauthWorkosUpdateInput = {
  clientId?: InputMaybe<Scalars['String']>;
  clientSecret?: InputMaybe<Scalars['String']>;
  connection?: InputMaybe<Scalars['String']>;
  enabled?: InputMaybe<Scalars['Boolean']>;
  organization?: InputMaybe<Scalars['String']>;
};

export type ConfigAuthMethodSmsPasswordless = {
  __typename?: 'ConfigAuthMethodSmsPasswordless';
  enabled?: Maybe<Scalars['Boolean']>;
};

export type ConfigAuthMethodSmsPasswordlessComparisonExp = {
  _and?: InputMaybe<Array<ConfigAuthMethodSmsPasswordlessComparisonExp>>;
  _not?: InputMaybe<ConfigAuthMethodSmsPasswordlessComparisonExp>;
  _or?: InputMaybe<Array<ConfigAuthMethodSmsPasswordlessComparisonExp>>;
  enabled?: InputMaybe<ConfigBooleanComparisonExp>;
};

export type ConfigAuthMethodSmsPasswordlessInsertInput = {
  enabled?: InputMaybe<Scalars['Boolean']>;
};

export type ConfigAuthMethodSmsPasswordlessUpdateInput = {
  enabled?: InputMaybe<Scalars['Boolean']>;
};

export type ConfigAuthMethodUpdateInput = {
  anonymous?: InputMaybe<ConfigAuthMethodAnonymousUpdateInput>;
  emailPassword?: InputMaybe<ConfigAuthMethodEmailPasswordUpdateInput>;
  emailPasswordless?: InputMaybe<ConfigAuthMethodEmailPasswordlessUpdateInput>;
  oauth?: InputMaybe<ConfigAuthMethodOauthUpdateInput>;
  smsPasswordless?: InputMaybe<ConfigAuthMethodSmsPasswordlessUpdateInput>;
  webauthn?: InputMaybe<ConfigAuthMethodWebauthnUpdateInput>;
};

export type ConfigAuthMethodWebauthn = {
  __typename?: 'ConfigAuthMethodWebauthn';
  attestation?: Maybe<ConfigAuthMethodWebauthnAttestation>;
  enabled?: Maybe<Scalars['Boolean']>;
  relyingParty?: Maybe<ConfigAuthMethodWebauthnRelyingParty>;
};

export type ConfigAuthMethodWebauthnAttestation = {
  __typename?: 'ConfigAuthMethodWebauthnAttestation';
  timeout?: Maybe<Scalars['ConfigUint32']>;
};

export type ConfigAuthMethodWebauthnAttestationComparisonExp = {
  _and?: InputMaybe<Array<ConfigAuthMethodWebauthnAttestationComparisonExp>>;
  _not?: InputMaybe<ConfigAuthMethodWebauthnAttestationComparisonExp>;
  _or?: InputMaybe<Array<ConfigAuthMethodWebauthnAttestationComparisonExp>>;
  timeout?: InputMaybe<ConfigUint32ComparisonExp>;
};

export type ConfigAuthMethodWebauthnAttestationInsertInput = {
  timeout?: InputMaybe<Scalars['ConfigUint32']>;
};

export type ConfigAuthMethodWebauthnAttestationUpdateInput = {
  timeout?: InputMaybe<Scalars['ConfigUint32']>;
};

export type ConfigAuthMethodWebauthnComparisonExp = {
  _and?: InputMaybe<Array<ConfigAuthMethodWebauthnComparisonExp>>;
  _not?: InputMaybe<ConfigAuthMethodWebauthnComparisonExp>;
  _or?: InputMaybe<Array<ConfigAuthMethodWebauthnComparisonExp>>;
  attestation?: InputMaybe<ConfigAuthMethodWebauthnAttestationComparisonExp>;
  enabled?: InputMaybe<ConfigBooleanComparisonExp>;
  relyingParty?: InputMaybe<ConfigAuthMethodWebauthnRelyingPartyComparisonExp>;
};

export type ConfigAuthMethodWebauthnInsertInput = {
  attestation?: InputMaybe<ConfigAuthMethodWebauthnAttestationInsertInput>;
  enabled?: InputMaybe<Scalars['Boolean']>;
  relyingParty?: InputMaybe<ConfigAuthMethodWebauthnRelyingPartyInsertInput>;
};

export type ConfigAuthMethodWebauthnRelyingParty = {
  __typename?: 'ConfigAuthMethodWebauthnRelyingParty';
  id?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  origins?: Maybe<Array<Scalars['ConfigUrl']>>;
};

export type ConfigAuthMethodWebauthnRelyingPartyComparisonExp = {
  _and?: InputMaybe<Array<ConfigAuthMethodWebauthnRelyingPartyComparisonExp>>;
  _not?: InputMaybe<ConfigAuthMethodWebauthnRelyingPartyComparisonExp>;
  _or?: InputMaybe<Array<ConfigAuthMethodWebauthnRelyingPartyComparisonExp>>;
  id?: InputMaybe<ConfigStringComparisonExp>;
  name?: InputMaybe<ConfigStringComparisonExp>;
  origins?: InputMaybe<ConfigUrlComparisonExp>;
};

export type ConfigAuthMethodWebauthnRelyingPartyInsertInput = {
  id?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
  origins?: InputMaybe<Array<Scalars['ConfigUrl']>>;
};

export type ConfigAuthMethodWebauthnRelyingPartyUpdateInput = {
  id?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
  origins?: InputMaybe<Array<Scalars['ConfigUrl']>>;
};

export type ConfigAuthMethodWebauthnUpdateInput = {
  attestation?: InputMaybe<ConfigAuthMethodWebauthnAttestationUpdateInput>;
  enabled?: InputMaybe<Scalars['Boolean']>;
  relyingParty?: InputMaybe<ConfigAuthMethodWebauthnRelyingPartyUpdateInput>;
};

export type ConfigAuthMisc = {
  __typename?: 'ConfigAuthMisc';
  concealErrors?: Maybe<Scalars['Boolean']>;
};

export type ConfigAuthMiscComparisonExp = {
  _and?: InputMaybe<Array<ConfigAuthMiscComparisonExp>>;
  _not?: InputMaybe<ConfigAuthMiscComparisonExp>;
  _or?: InputMaybe<Array<ConfigAuthMiscComparisonExp>>;
  concealErrors?: InputMaybe<ConfigBooleanComparisonExp>;
};

export type ConfigAuthMiscInsertInput = {
  concealErrors?: InputMaybe<Scalars['Boolean']>;
};

export type ConfigAuthMiscUpdateInput = {
  concealErrors?: InputMaybe<Scalars['Boolean']>;
};

export type ConfigAuthRateLimit = {
  __typename?: 'ConfigAuthRateLimit';
  bruteForce?: Maybe<ConfigRateLimit>;
  emails?: Maybe<ConfigRateLimit>;
  global?: Maybe<ConfigRateLimit>;
  signups?: Maybe<ConfigRateLimit>;
  sms?: Maybe<ConfigRateLimit>;
};

export type ConfigAuthRateLimitComparisonExp = {
  _and?: InputMaybe<Array<ConfigAuthRateLimitComparisonExp>>;
  _not?: InputMaybe<ConfigAuthRateLimitComparisonExp>;
  _or?: InputMaybe<Array<ConfigAuthRateLimitComparisonExp>>;
  bruteForce?: InputMaybe<ConfigRateLimitComparisonExp>;
  emails?: InputMaybe<ConfigRateLimitComparisonExp>;
  global?: InputMaybe<ConfigRateLimitComparisonExp>;
  signups?: InputMaybe<ConfigRateLimitComparisonExp>;
  sms?: InputMaybe<ConfigRateLimitComparisonExp>;
};

export type ConfigAuthRateLimitInsertInput = {
  bruteForce?: InputMaybe<ConfigRateLimitInsertInput>;
  emails?: InputMaybe<ConfigRateLimitInsertInput>;
  global?: InputMaybe<ConfigRateLimitInsertInput>;
  signups?: InputMaybe<ConfigRateLimitInsertInput>;
  sms?: InputMaybe<ConfigRateLimitInsertInput>;
};

export type ConfigAuthRateLimitUpdateInput = {
  bruteForce?: InputMaybe<ConfigRateLimitUpdateInput>;
  emails?: InputMaybe<ConfigRateLimitUpdateInput>;
  global?: InputMaybe<ConfigRateLimitUpdateInput>;
  signups?: InputMaybe<ConfigRateLimitUpdateInput>;
  sms?: InputMaybe<ConfigRateLimitUpdateInput>;
};

export type ConfigAuthRedirections = {
  __typename?: 'ConfigAuthRedirections';
  /** AUTH_ACCESS_CONTROL_ALLOWED_REDIRECT_URLS */
  allowedUrls?: Maybe<Array<Scalars['String']>>;
  /** AUTH_CLIENT_URL */
  clientUrl?: Maybe<Scalars['ConfigUrl']>;
};

export type ConfigAuthRedirectionsComparisonExp = {
  _and?: InputMaybe<Array<ConfigAuthRedirectionsComparisonExp>>;
  _not?: InputMaybe<ConfigAuthRedirectionsComparisonExp>;
  _or?: InputMaybe<Array<ConfigAuthRedirectionsComparisonExp>>;
  allowedUrls?: InputMaybe<ConfigStringComparisonExp>;
  clientUrl?: InputMaybe<ConfigUrlComparisonExp>;
};

export type ConfigAuthRedirectionsInsertInput = {
  allowedUrls?: InputMaybe<Array<Scalars['String']>>;
  clientUrl?: InputMaybe<Scalars['ConfigUrl']>;
};

export type ConfigAuthRedirectionsUpdateInput = {
  allowedUrls?: InputMaybe<Array<Scalars['String']>>;
  clientUrl?: InputMaybe<Scalars['ConfigUrl']>;
};

export type ConfigAuthSession = {
  __typename?: 'ConfigAuthSession';
  accessToken?: Maybe<ConfigAuthSessionAccessToken>;
  refreshToken?: Maybe<ConfigAuthSessionRefreshToken>;
};

export type ConfigAuthSessionAccessToken = {
  __typename?: 'ConfigAuthSessionAccessToken';
  /** AUTH_JWT_CUSTOM_CLAIMS */
  customClaims?: Maybe<Array<ConfigAuthsessionaccessTokenCustomClaims>>;
  /** AUTH_ACCESS_TOKEN_EXPIRES_IN */
  expiresIn?: Maybe<Scalars['ConfigUint32']>;
};

export type ConfigAuthSessionAccessTokenComparisonExp = {
  _and?: InputMaybe<Array<ConfigAuthSessionAccessTokenComparisonExp>>;
  _not?: InputMaybe<ConfigAuthSessionAccessTokenComparisonExp>;
  _or?: InputMaybe<Array<ConfigAuthSessionAccessTokenComparisonExp>>;
  customClaims?: InputMaybe<ConfigAuthsessionaccessTokenCustomClaimsComparisonExp>;
  expiresIn?: InputMaybe<ConfigUint32ComparisonExp>;
};

export type ConfigAuthSessionAccessTokenInsertInput = {
  customClaims?: InputMaybe<Array<ConfigAuthsessionaccessTokenCustomClaimsInsertInput>>;
  expiresIn?: InputMaybe<Scalars['ConfigUint32']>;
};

export type ConfigAuthSessionAccessTokenUpdateInput = {
  customClaims?: InputMaybe<Array<ConfigAuthsessionaccessTokenCustomClaimsUpdateInput>>;
  expiresIn?: InputMaybe<Scalars['ConfigUint32']>;
};

export type ConfigAuthSessionComparisonExp = {
  _and?: InputMaybe<Array<ConfigAuthSessionComparisonExp>>;
  _not?: InputMaybe<ConfigAuthSessionComparisonExp>;
  _or?: InputMaybe<Array<ConfigAuthSessionComparisonExp>>;
  accessToken?: InputMaybe<ConfigAuthSessionAccessTokenComparisonExp>;
  refreshToken?: InputMaybe<ConfigAuthSessionRefreshTokenComparisonExp>;
};

export type ConfigAuthSessionInsertInput = {
  accessToken?: InputMaybe<ConfigAuthSessionAccessTokenInsertInput>;
  refreshToken?: InputMaybe<ConfigAuthSessionRefreshTokenInsertInput>;
};

export type ConfigAuthSessionRefreshToken = {
  __typename?: 'ConfigAuthSessionRefreshToken';
  /** AUTH_REFRESH_TOKEN_EXPIRES_IN */
  expiresIn?: Maybe<Scalars['ConfigUint32']>;
};

export type ConfigAuthSessionRefreshTokenComparisonExp = {
  _and?: InputMaybe<Array<ConfigAuthSessionRefreshTokenComparisonExp>>;
  _not?: InputMaybe<ConfigAuthSessionRefreshTokenComparisonExp>;
  _or?: InputMaybe<Array<ConfigAuthSessionRefreshTokenComparisonExp>>;
  expiresIn?: InputMaybe<ConfigUint32ComparisonExp>;
};

export type ConfigAuthSessionRefreshTokenInsertInput = {
  expiresIn?: InputMaybe<Scalars['ConfigUint32']>;
};

export type ConfigAuthSessionRefreshTokenUpdateInput = {
  expiresIn?: InputMaybe<Scalars['ConfigUint32']>;
};

export type ConfigAuthSessionUpdateInput = {
  accessToken?: InputMaybe<ConfigAuthSessionAccessTokenUpdateInput>;
  refreshToken?: InputMaybe<ConfigAuthSessionRefreshTokenUpdateInput>;
};

export type ConfigAuthSignUp = {
  __typename?: 'ConfigAuthSignUp';
  /** AUTH_DISABLE_NEW_USERS */
  disableNewUsers?: Maybe<Scalars['Boolean']>;
  /** Inverse of AUTH_DISABLE_SIGNUP */
  enabled?: Maybe<Scalars['Boolean']>;
};

export type ConfigAuthSignUpComparisonExp = {
  _and?: InputMaybe<Array<ConfigAuthSignUpComparisonExp>>;
  _not?: InputMaybe<ConfigAuthSignUpComparisonExp>;
  _or?: InputMaybe<Array<ConfigAuthSignUpComparisonExp>>;
  disableNewUsers?: InputMaybe<ConfigBooleanComparisonExp>;
  enabled?: InputMaybe<ConfigBooleanComparisonExp>;
};

export type ConfigAuthSignUpInsertInput = {
  disableNewUsers?: InputMaybe<Scalars['Boolean']>;
  enabled?: InputMaybe<Scalars['Boolean']>;
};

export type ConfigAuthSignUpUpdateInput = {
  disableNewUsers?: InputMaybe<Scalars['Boolean']>;
  enabled?: InputMaybe<Scalars['Boolean']>;
};

export type ConfigAuthTotp = {
  __typename?: 'ConfigAuthTotp';
  enabled?: Maybe<Scalars['Boolean']>;
  issuer?: Maybe<Scalars['String']>;
};

export type ConfigAuthTotpComparisonExp = {
  _and?: InputMaybe<Array<ConfigAuthTotpComparisonExp>>;
  _not?: InputMaybe<ConfigAuthTotpComparisonExp>;
  _or?: InputMaybe<Array<ConfigAuthTotpComparisonExp>>;
  enabled?: InputMaybe<ConfigBooleanComparisonExp>;
  issuer?: InputMaybe<ConfigStringComparisonExp>;
};

export type ConfigAuthTotpInsertInput = {
  enabled?: InputMaybe<Scalars['Boolean']>;
  issuer?: InputMaybe<Scalars['String']>;
};

export type ConfigAuthTotpUpdateInput = {
  enabled?: InputMaybe<Scalars['Boolean']>;
  issuer?: InputMaybe<Scalars['String']>;
};

export type ConfigAuthUpdateInput = {
  elevatedPrivileges?: InputMaybe<ConfigAuthElevatedPrivilegesUpdateInput>;
  method?: InputMaybe<ConfigAuthMethodUpdateInput>;
  misc?: InputMaybe<ConfigAuthMiscUpdateInput>;
  rateLimit?: InputMaybe<ConfigAuthRateLimitUpdateInput>;
  redirections?: InputMaybe<ConfigAuthRedirectionsUpdateInput>;
  resources?: InputMaybe<ConfigResourcesUpdateInput>;
  session?: InputMaybe<ConfigAuthSessionUpdateInput>;
  signUp?: InputMaybe<ConfigAuthSignUpUpdateInput>;
  totp?: InputMaybe<ConfigAuthTotpUpdateInput>;
  user?: InputMaybe<ConfigAuthUserUpdateInput>;
  version?: InputMaybe<Scalars['String']>;
};

export type ConfigAuthUser = {
  __typename?: 'ConfigAuthUser';
  email?: Maybe<ConfigAuthUserEmail>;
  emailDomains?: Maybe<ConfigAuthUserEmailDomains>;
  gravatar?: Maybe<ConfigAuthUserGravatar>;
  locale?: Maybe<ConfigAuthUserLocale>;
  roles?: Maybe<ConfigAuthUserRoles>;
};

export type ConfigAuthUserComparisonExp = {
  _and?: InputMaybe<Array<ConfigAuthUserComparisonExp>>;
  _not?: InputMaybe<ConfigAuthUserComparisonExp>;
  _or?: InputMaybe<Array<ConfigAuthUserComparisonExp>>;
  email?: InputMaybe<ConfigAuthUserEmailComparisonExp>;
  emailDomains?: InputMaybe<ConfigAuthUserEmailDomainsComparisonExp>;
  gravatar?: InputMaybe<ConfigAuthUserGravatarComparisonExp>;
  locale?: InputMaybe<ConfigAuthUserLocaleComparisonExp>;
  roles?: InputMaybe<ConfigAuthUserRolesComparisonExp>;
};

export type ConfigAuthUserEmail = {
  __typename?: 'ConfigAuthUserEmail';
  /** AUTH_ACCESS_CONTROL_ALLOWED_EMAILS */
  allowed?: Maybe<Array<Scalars['ConfigEmail']>>;
  /** AUTH_ACCESS_CONTROL_BLOCKED_EMAILS */
  blocked?: Maybe<Array<Scalars['ConfigEmail']>>;
};

export type ConfigAuthUserEmailComparisonExp = {
  _and?: InputMaybe<Array<ConfigAuthUserEmailComparisonExp>>;
  _not?: InputMaybe<ConfigAuthUserEmailComparisonExp>;
  _or?: InputMaybe<Array<ConfigAuthUserEmailComparisonExp>>;
  allowed?: InputMaybe<ConfigEmailComparisonExp>;
  blocked?: InputMaybe<ConfigEmailComparisonExp>;
};

export type ConfigAuthUserEmailDomains = {
  __typename?: 'ConfigAuthUserEmailDomains';
  /** AUTH_ACCESS_CONTROL_ALLOWED_EMAIL_DOMAINS */
  allowed?: Maybe<Array<Scalars['String']>>;
  /** AUTH_ACCESS_CONTROL_BLOCKED_EMAIL_DOMAINS */
  blocked?: Maybe<Array<Scalars['String']>>;
};

export type ConfigAuthUserEmailDomainsComparisonExp = {
  _and?: InputMaybe<Array<ConfigAuthUserEmailDomainsComparisonExp>>;
  _not?: InputMaybe<ConfigAuthUserEmailDomainsComparisonExp>;
  _or?: InputMaybe<Array<ConfigAuthUserEmailDomainsComparisonExp>>;
  allowed?: InputMaybe<ConfigStringComparisonExp>;
  blocked?: InputMaybe<ConfigStringComparisonExp>;
};

export type ConfigAuthUserEmailDomainsInsertInput = {
  allowed?: InputMaybe<Array<Scalars['String']>>;
  blocked?: InputMaybe<Array<Scalars['String']>>;
};

export type ConfigAuthUserEmailDomainsUpdateInput = {
  allowed?: InputMaybe<Array<Scalars['String']>>;
  blocked?: InputMaybe<Array<Scalars['String']>>;
};

export type ConfigAuthUserEmailInsertInput = {
  allowed?: InputMaybe<Array<Scalars['ConfigEmail']>>;
  blocked?: InputMaybe<Array<Scalars['ConfigEmail']>>;
};

export type ConfigAuthUserEmailUpdateInput = {
  allowed?: InputMaybe<Array<Scalars['ConfigEmail']>>;
  blocked?: InputMaybe<Array<Scalars['ConfigEmail']>>;
};

export type ConfigAuthUserGravatar = {
  __typename?: 'ConfigAuthUserGravatar';
  default?: Maybe<Scalars['String']>;
  /** AUTH_GRAVATAR_ENABLED */
  enabled?: Maybe<Scalars['Boolean']>;
  rating?: Maybe<Scalars['String']>;
};

export type ConfigAuthUserGravatarComparisonExp = {
  _and?: InputMaybe<Array<ConfigAuthUserGravatarComparisonExp>>;
  _not?: InputMaybe<ConfigAuthUserGravatarComparisonExp>;
  _or?: InputMaybe<Array<ConfigAuthUserGravatarComparisonExp>>;
  default?: InputMaybe<ConfigStringComparisonExp>;
  enabled?: InputMaybe<ConfigBooleanComparisonExp>;
  rating?: InputMaybe<ConfigStringComparisonExp>;
};

export type ConfigAuthUserGravatarInsertInput = {
  default?: InputMaybe<Scalars['String']>;
  enabled?: InputMaybe<Scalars['Boolean']>;
  rating?: InputMaybe<Scalars['String']>;
};

export type ConfigAuthUserGravatarUpdateInput = {
  default?: InputMaybe<Scalars['String']>;
  enabled?: InputMaybe<Scalars['Boolean']>;
  rating?: InputMaybe<Scalars['String']>;
};

export type ConfigAuthUserInsertInput = {
  email?: InputMaybe<ConfigAuthUserEmailInsertInput>;
  emailDomains?: InputMaybe<ConfigAuthUserEmailDomainsInsertInput>;
  gravatar?: InputMaybe<ConfigAuthUserGravatarInsertInput>;
  locale?: InputMaybe<ConfigAuthUserLocaleInsertInput>;
  roles?: InputMaybe<ConfigAuthUserRolesInsertInput>;
};

export type ConfigAuthUserLocale = {
  __typename?: 'ConfigAuthUserLocale';
  /** AUTH_LOCALE_ALLOWED_LOCALES */
  allowed?: Maybe<Array<Scalars['ConfigLocale']>>;
  /** AUTH_LOCALE_DEFAULT */
  default?: Maybe<Scalars['ConfigLocale']>;
};

export type ConfigAuthUserLocaleComparisonExp = {
  _and?: InputMaybe<Array<ConfigAuthUserLocaleComparisonExp>>;
  _not?: InputMaybe<ConfigAuthUserLocaleComparisonExp>;
  _or?: InputMaybe<Array<ConfigAuthUserLocaleComparisonExp>>;
  allowed?: InputMaybe<ConfigLocaleComparisonExp>;
  default?: InputMaybe<ConfigLocaleComparisonExp>;
};

export type ConfigAuthUserLocaleInsertInput = {
  allowed?: InputMaybe<Array<Scalars['ConfigLocale']>>;
  default?: InputMaybe<Scalars['ConfigLocale']>;
};

export type ConfigAuthUserLocaleUpdateInput = {
  allowed?: InputMaybe<Array<Scalars['ConfigLocale']>>;
  default?: InputMaybe<Scalars['ConfigLocale']>;
};

export type ConfigAuthUserRoles = {
  __typename?: 'ConfigAuthUserRoles';
  /** AUTH_USER_DEFAULT_ALLOWED_ROLES */
  allowed?: Maybe<Array<Scalars['ConfigUserRole']>>;
  /** AUTH_USER_DEFAULT_ROLE */
  default?: Maybe<Scalars['ConfigUserRole']>;
};

export type ConfigAuthUserRolesComparisonExp = {
  _and?: InputMaybe<Array<ConfigAuthUserRolesComparisonExp>>;
  _not?: InputMaybe<ConfigAuthUserRolesComparisonExp>;
  _or?: InputMaybe<Array<ConfigAuthUserRolesComparisonExp>>;
  allowed?: InputMaybe<ConfigUserRoleComparisonExp>;
  default?: InputMaybe<ConfigUserRoleComparisonExp>;
};

export type ConfigAuthUserRolesInsertInput = {
  allowed?: InputMaybe<Array<Scalars['ConfigUserRole']>>;
  default?: InputMaybe<Scalars['ConfigUserRole']>;
};

export type ConfigAuthUserRolesUpdateInput = {
  allowed?: InputMaybe<Array<Scalars['ConfigUserRole']>>;
  default?: InputMaybe<Scalars['ConfigUserRole']>;
};

export type ConfigAuthUserUpdateInput = {
  email?: InputMaybe<ConfigAuthUserEmailUpdateInput>;
  emailDomains?: InputMaybe<ConfigAuthUserEmailDomainsUpdateInput>;
  gravatar?: InputMaybe<ConfigAuthUserGravatarUpdateInput>;
  locale?: InputMaybe<ConfigAuthUserLocaleUpdateInput>;
  roles?: InputMaybe<ConfigAuthUserRolesUpdateInput>;
};

/** AUTH_JWT_CUSTOM_CLAIMS */
export type ConfigAuthsessionaccessTokenCustomClaims = {
  __typename?: 'ConfigAuthsessionaccessTokenCustomClaims';
  key: Scalars['String'];
  value: Scalars['String'];
};

export type ConfigAuthsessionaccessTokenCustomClaimsComparisonExp = {
  _and?: InputMaybe<Array<ConfigAuthsessionaccessTokenCustomClaimsComparisonExp>>;
  _not?: InputMaybe<ConfigAuthsessionaccessTokenCustomClaimsComparisonExp>;
  _or?: InputMaybe<Array<ConfigAuthsessionaccessTokenCustomClaimsComparisonExp>>;
  key?: InputMaybe<ConfigStringComparisonExp>;
  value?: InputMaybe<ConfigStringComparisonExp>;
};

export type ConfigAuthsessionaccessTokenCustomClaimsInsertInput = {
  key: Scalars['String'];
  value: Scalars['String'];
};

export type ConfigAuthsessionaccessTokenCustomClaimsUpdateInput = {
  key?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

export type ConfigAutoscaler = {
  __typename?: 'ConfigAutoscaler';
  maxReplicas: Scalars['ConfigUint8'];
};

export type ConfigAutoscalerComparisonExp = {
  _and?: InputMaybe<Array<ConfigAutoscalerComparisonExp>>;
  _not?: InputMaybe<ConfigAutoscalerComparisonExp>;
  _or?: InputMaybe<Array<ConfigAutoscalerComparisonExp>>;
  maxReplicas?: InputMaybe<ConfigUint8ComparisonExp>;
};

export type ConfigAutoscalerInsertInput = {
  maxReplicas: Scalars['ConfigUint8'];
};

export type ConfigAutoscalerUpdateInput = {
  maxReplicas?: InputMaybe<Scalars['ConfigUint8']>;
};

export type ConfigBooleanComparisonExp = {
  _eq?: InputMaybe<Scalars['Boolean']>;
  _in?: InputMaybe<Array<Scalars['Boolean']>>;
  _neq?: InputMaybe<Scalars['Boolean']>;
  _nin?: InputMaybe<Array<Scalars['Boolean']>>;
};

export type ConfigClaimMap = {
  __typename?: 'ConfigClaimMap';
  claim: Scalars['String'];
  default?: Maybe<Scalars['String']>;
  path?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

export type ConfigClaimMapComparisonExp = {
  _and?: InputMaybe<Array<ConfigClaimMapComparisonExp>>;
  _not?: InputMaybe<ConfigClaimMapComparisonExp>;
  _or?: InputMaybe<Array<ConfigClaimMapComparisonExp>>;
  claim?: InputMaybe<ConfigStringComparisonExp>;
  default?: InputMaybe<ConfigStringComparisonExp>;
  path?: InputMaybe<ConfigStringComparisonExp>;
  value?: InputMaybe<ConfigStringComparisonExp>;
};

export type ConfigClaimMapInsertInput = {
  claim: Scalars['String'];
  default?: InputMaybe<Scalars['String']>;
  path?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

export type ConfigClaimMapUpdateInput = {
  claim?: InputMaybe<Scalars['String']>;
  default?: InputMaybe<Scalars['String']>;
  path?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** Resource configuration for a service */
export type ConfigComputeResources = {
  __typename?: 'ConfigComputeResources';
  /** milicpus, 1000 milicpus = 1 cpu */
  cpu: Scalars['ConfigUint32'];
  /** MiB: 128MiB to 30GiB */
  memory: Scalars['ConfigUint32'];
};

export type ConfigComputeResourcesComparisonExp = {
  _and?: InputMaybe<Array<ConfigComputeResourcesComparisonExp>>;
  _not?: InputMaybe<ConfigComputeResourcesComparisonExp>;
  _or?: InputMaybe<Array<ConfigComputeResourcesComparisonExp>>;
  cpu?: InputMaybe<ConfigUint32ComparisonExp>;
  memory?: InputMaybe<ConfigUint32ComparisonExp>;
};

export type ConfigComputeResourcesInsertInput = {
  cpu: Scalars['ConfigUint32'];
  memory: Scalars['ConfigUint32'];
};

export type ConfigComputeResourcesUpdateInput = {
  cpu?: InputMaybe<Scalars['ConfigUint32']>;
  memory?: InputMaybe<Scalars['ConfigUint32']>;
};

/** main entrypoint to the configuration */
export type ConfigConfig = {
  __typename?: 'ConfigConfig';
  /** Configuration for graphite service */
  ai?: Maybe<ConfigAi>;
  /** Configuration for auth service */
  auth?: Maybe<ConfigAuth>;
  /** Configuration for functions service */
  functions?: Maybe<ConfigFunctions>;
  /** Global configuration that applies to all services */
  global?: Maybe<ConfigGlobal>;
  /** Advanced configuration for GraphQL */
  graphql?: Maybe<ConfigGraphql>;
  /** Configuration for hasura */
  hasura: ConfigHasura;
  /** Configuration for observability service */
  observability: ConfigObservability;
  /** Configuration for postgres service */
  postgres?: Maybe<ConfigPostgres>;
  /** Configuration for third party providers like SMTP, SMS, etc. */
  provider?: Maybe<ConfigProvider>;
  /** Configuration for storage service */
  storage?: Maybe<ConfigStorage>;
};

export type ConfigConfigComparisonExp = {
  _and?: InputMaybe<Array<ConfigConfigComparisonExp>>;
  _not?: InputMaybe<ConfigConfigComparisonExp>;
  _or?: InputMaybe<Array<ConfigConfigComparisonExp>>;
  ai?: InputMaybe<ConfigAiComparisonExp>;
  auth?: InputMaybe<ConfigAuthComparisonExp>;
  functions?: InputMaybe<ConfigFunctionsComparisonExp>;
  global?: InputMaybe<ConfigGlobalComparisonExp>;
  graphql?: InputMaybe<ConfigGraphqlComparisonExp>;
  hasura?: InputMaybe<ConfigHasuraComparisonExp>;
  observability?: InputMaybe<ConfigObservabilityComparisonExp>;
  postgres?: InputMaybe<ConfigPostgresComparisonExp>;
  provider?: InputMaybe<ConfigProviderComparisonExp>;
  storage?: InputMaybe<ConfigStorageComparisonExp>;
};

export type ConfigConfigInsertInput = {
  ai?: InputMaybe<ConfigAiInsertInput>;
  auth?: InputMaybe<ConfigAuthInsertInput>;
  functions?: InputMaybe<ConfigFunctionsInsertInput>;
  global?: InputMaybe<ConfigGlobalInsertInput>;
  graphql?: InputMaybe<ConfigGraphqlInsertInput>;
  hasura: ConfigHasuraInsertInput;
  observability: ConfigObservabilityInsertInput;
  postgres?: InputMaybe<ConfigPostgresInsertInput>;
  provider?: InputMaybe<ConfigProviderInsertInput>;
  storage?: InputMaybe<ConfigStorageInsertInput>;
};

export type ConfigConfigUpdateInput = {
  ai?: InputMaybe<ConfigAiUpdateInput>;
  auth?: InputMaybe<ConfigAuthUpdateInput>;
  functions?: InputMaybe<ConfigFunctionsUpdateInput>;
  global?: InputMaybe<ConfigGlobalUpdateInput>;
  graphql?: InputMaybe<ConfigGraphqlUpdateInput>;
  hasura?: InputMaybe<ConfigHasuraUpdateInput>;
  observability?: InputMaybe<ConfigObservabilityUpdateInput>;
  postgres?: InputMaybe<ConfigPostgresUpdateInput>;
  provider?: InputMaybe<ConfigProviderUpdateInput>;
  storage?: InputMaybe<ConfigStorageUpdateInput>;
};

export type ConfigEmailComparisonExp = {
  _eq?: InputMaybe<Scalars['ConfigEmail']>;
  _in?: InputMaybe<Array<Scalars['ConfigEmail']>>;
  _neq?: InputMaybe<Scalars['ConfigEmail']>;
  _nin?: InputMaybe<Array<Scalars['ConfigEmail']>>;
};

export type ConfigEnvironmentVariable = {
  __typename?: 'ConfigEnvironmentVariable';
  name: Scalars['String'];
  /** Value of the environment variable */
  value: Scalars['String'];
};

export type ConfigEnvironmentVariableComparisonExp = {
  _and?: InputMaybe<Array<ConfigEnvironmentVariableComparisonExp>>;
  _not?: InputMaybe<ConfigEnvironmentVariableComparisonExp>;
  _or?: InputMaybe<Array<ConfigEnvironmentVariableComparisonExp>>;
  name?: InputMaybe<ConfigStringComparisonExp>;
  value?: InputMaybe<ConfigStringComparisonExp>;
};

export type ConfigEnvironmentVariableInsertInput = {
  name: Scalars['String'];
  value: Scalars['String'];
};

export type ConfigEnvironmentVariableUpdateInput = {
  name?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

export type ConfigFloatComparisonExp = {
  _eq?: InputMaybe<Scalars['Float']>;
  _in?: InputMaybe<Array<Scalars['Float']>>;
  _neq?: InputMaybe<Scalars['Float']>;
  _nin?: InputMaybe<Array<Scalars['Float']>>;
};

/** Configuration for functions service */
export type ConfigFunctions = {
  __typename?: 'ConfigFunctions';
  node?: Maybe<ConfigFunctionsNode>;
  rateLimit?: Maybe<ConfigRateLimit>;
  resources?: Maybe<ConfigFunctionsResources>;
};

export type ConfigFunctionsComparisonExp = {
  _and?: InputMaybe<Array<ConfigFunctionsComparisonExp>>;
  _not?: InputMaybe<ConfigFunctionsComparisonExp>;
  _or?: InputMaybe<Array<ConfigFunctionsComparisonExp>>;
  node?: InputMaybe<ConfigFunctionsNodeComparisonExp>;
  rateLimit?: InputMaybe<ConfigRateLimitComparisonExp>;
  resources?: InputMaybe<ConfigFunctionsResourcesComparisonExp>;
};

export type ConfigFunctionsInsertInput = {
  node?: InputMaybe<ConfigFunctionsNodeInsertInput>;
  rateLimit?: InputMaybe<ConfigRateLimitInsertInput>;
  resources?: InputMaybe<ConfigFunctionsResourcesInsertInput>;
};

export type ConfigFunctionsNode = {
  __typename?: 'ConfigFunctionsNode';
  version?: Maybe<Scalars['Int']>;
};

export type ConfigFunctionsNodeComparisonExp = {
  _and?: InputMaybe<Array<ConfigFunctionsNodeComparisonExp>>;
  _not?: InputMaybe<ConfigFunctionsNodeComparisonExp>;
  _or?: InputMaybe<Array<ConfigFunctionsNodeComparisonExp>>;
  version?: InputMaybe<ConfigIntComparisonExp>;
};

export type ConfigFunctionsNodeInsertInput = {
  version?: InputMaybe<Scalars['Int']>;
};

export type ConfigFunctionsNodeUpdateInput = {
  version?: InputMaybe<Scalars['Int']>;
};

export type ConfigFunctionsResources = {
  __typename?: 'ConfigFunctionsResources';
  networking?: Maybe<ConfigNetworking>;
};

export type ConfigFunctionsResourcesComparisonExp = {
  _and?: InputMaybe<Array<ConfigFunctionsResourcesComparisonExp>>;
  _not?: InputMaybe<ConfigFunctionsResourcesComparisonExp>;
  _or?: InputMaybe<Array<ConfigFunctionsResourcesComparisonExp>>;
  networking?: InputMaybe<ConfigNetworkingComparisonExp>;
};

export type ConfigFunctionsResourcesInsertInput = {
  networking?: InputMaybe<ConfigNetworkingInsertInput>;
};

export type ConfigFunctionsResourcesUpdateInput = {
  networking?: InputMaybe<ConfigNetworkingUpdateInput>;
};

export type ConfigFunctionsUpdateInput = {
  node?: InputMaybe<ConfigFunctionsNodeUpdateInput>;
  rateLimit?: InputMaybe<ConfigRateLimitUpdateInput>;
  resources?: InputMaybe<ConfigFunctionsResourcesUpdateInput>;
};

/** Global configuration that applies to all services */
export type ConfigGlobal = {
  __typename?: 'ConfigGlobal';
  /** User-defined environment variables that are spread over all services */
  environment?: Maybe<Array<ConfigGlobalEnvironmentVariable>>;
};

export type ConfigGlobalComparisonExp = {
  _and?: InputMaybe<Array<ConfigGlobalComparisonExp>>;
  _not?: InputMaybe<ConfigGlobalComparisonExp>;
  _or?: InputMaybe<Array<ConfigGlobalComparisonExp>>;
  environment?: InputMaybe<ConfigGlobalEnvironmentVariableComparisonExp>;
};

export type ConfigGlobalEnvironmentVariable = {
  __typename?: 'ConfigGlobalEnvironmentVariable';
  name: Scalars['String'];
  /** Value of the environment variable */
  value: Scalars['String'];
};

export type ConfigGlobalEnvironmentVariableComparisonExp = {
  _and?: InputMaybe<Array<ConfigGlobalEnvironmentVariableComparisonExp>>;
  _not?: InputMaybe<ConfigGlobalEnvironmentVariableComparisonExp>;
  _or?: InputMaybe<Array<ConfigGlobalEnvironmentVariableComparisonExp>>;
  name?: InputMaybe<ConfigStringComparisonExp>;
  value?: InputMaybe<ConfigStringComparisonExp>;
};

export type ConfigGlobalEnvironmentVariableInsertInput = {
  name: Scalars['String'];
  value: Scalars['String'];
};

export type ConfigGlobalEnvironmentVariableUpdateInput = {
  name?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

export type ConfigGlobalInsertInput = {
  environment?: InputMaybe<Array<ConfigGlobalEnvironmentVariableInsertInput>>;
};

export type ConfigGlobalUpdateInput = {
  environment?: InputMaybe<Array<ConfigGlobalEnvironmentVariableUpdateInput>>;
};

export type ConfigGrafana = {
  __typename?: 'ConfigGrafana';
  adminPassword: Scalars['String'];
  alerting?: Maybe<ConfigGrafanaAlerting>;
  contacts?: Maybe<ConfigGrafanaContacts>;
  smtp?: Maybe<ConfigGrafanaSmtp>;
};

export type ConfigGrafanaAlerting = {
  __typename?: 'ConfigGrafanaAlerting';
  enabled?: Maybe<Scalars['Boolean']>;
};

export type ConfigGrafanaAlertingComparisonExp = {
  _and?: InputMaybe<Array<ConfigGrafanaAlertingComparisonExp>>;
  _not?: InputMaybe<ConfigGrafanaAlertingComparisonExp>;
  _or?: InputMaybe<Array<ConfigGrafanaAlertingComparisonExp>>;
  enabled?: InputMaybe<ConfigBooleanComparisonExp>;
};

export type ConfigGrafanaAlertingInsertInput = {
  enabled?: InputMaybe<Scalars['Boolean']>;
};

export type ConfigGrafanaAlertingUpdateInput = {
  enabled?: InputMaybe<Scalars['Boolean']>;
};

export type ConfigGrafanaComparisonExp = {
  _and?: InputMaybe<Array<ConfigGrafanaComparisonExp>>;
  _not?: InputMaybe<ConfigGrafanaComparisonExp>;
  _or?: InputMaybe<Array<ConfigGrafanaComparisonExp>>;
  adminPassword?: InputMaybe<ConfigStringComparisonExp>;
  alerting?: InputMaybe<ConfigGrafanaAlertingComparisonExp>;
  contacts?: InputMaybe<ConfigGrafanaContactsComparisonExp>;
  smtp?: InputMaybe<ConfigGrafanaSmtpComparisonExp>;
};

export type ConfigGrafanaContacts = {
  __typename?: 'ConfigGrafanaContacts';
  discord?: Maybe<Array<ConfigGrafanacontactsDiscord>>;
  emails?: Maybe<Array<Scalars['String']>>;
  pagerduty?: Maybe<Array<ConfigGrafanacontactsPagerduty>>;
  slack?: Maybe<Array<ConfigGrafanacontactsSlack>>;
  webhook?: Maybe<Array<ConfigGrafanacontactsWebhook>>;
};

export type ConfigGrafanaContactsComparisonExp = {
  _and?: InputMaybe<Array<ConfigGrafanaContactsComparisonExp>>;
  _not?: InputMaybe<ConfigGrafanaContactsComparisonExp>;
  _or?: InputMaybe<Array<ConfigGrafanaContactsComparisonExp>>;
  discord?: InputMaybe<ConfigGrafanacontactsDiscordComparisonExp>;
  emails?: InputMaybe<ConfigStringComparisonExp>;
  pagerduty?: InputMaybe<ConfigGrafanacontactsPagerdutyComparisonExp>;
  slack?: InputMaybe<ConfigGrafanacontactsSlackComparisonExp>;
  webhook?: InputMaybe<ConfigGrafanacontactsWebhookComparisonExp>;
};

export type ConfigGrafanaContactsInsertInput = {
  discord?: InputMaybe<Array<ConfigGrafanacontactsDiscordInsertInput>>;
  emails?: InputMaybe<Array<Scalars['String']>>;
  pagerduty?: InputMaybe<Array<ConfigGrafanacontactsPagerdutyInsertInput>>;
  slack?: InputMaybe<Array<ConfigGrafanacontactsSlackInsertInput>>;
  webhook?: InputMaybe<Array<ConfigGrafanacontactsWebhookInsertInput>>;
};

export type ConfigGrafanaContactsUpdateInput = {
  discord?: InputMaybe<Array<ConfigGrafanacontactsDiscordUpdateInput>>;
  emails?: InputMaybe<Array<Scalars['String']>>;
  pagerduty?: InputMaybe<Array<ConfigGrafanacontactsPagerdutyUpdateInput>>;
  slack?: InputMaybe<Array<ConfigGrafanacontactsSlackUpdateInput>>;
  webhook?: InputMaybe<Array<ConfigGrafanacontactsWebhookUpdateInput>>;
};

export type ConfigGrafanaInsertInput = {
  adminPassword: Scalars['String'];
  alerting?: InputMaybe<ConfigGrafanaAlertingInsertInput>;
  contacts?: InputMaybe<ConfigGrafanaContactsInsertInput>;
  smtp?: InputMaybe<ConfigGrafanaSmtpInsertInput>;
};

export type ConfigGrafanaSmtp = {
  __typename?: 'ConfigGrafanaSmtp';
  host: Scalars['String'];
  password: Scalars['String'];
  port: Scalars['ConfigPort'];
  sender: Scalars['String'];
  user: Scalars['String'];
};

export type ConfigGrafanaSmtpComparisonExp = {
  _and?: InputMaybe<Array<ConfigGrafanaSmtpComparisonExp>>;
  _not?: InputMaybe<ConfigGrafanaSmtpComparisonExp>;
  _or?: InputMaybe<Array<ConfigGrafanaSmtpComparisonExp>>;
  host?: InputMaybe<ConfigStringComparisonExp>;
  password?: InputMaybe<ConfigStringComparisonExp>;
  port?: InputMaybe<ConfigPortComparisonExp>;
  sender?: InputMaybe<ConfigStringComparisonExp>;
  user?: InputMaybe<ConfigStringComparisonExp>;
};

export type ConfigGrafanaSmtpInsertInput = {
  host: Scalars['String'];
  password: Scalars['String'];
  port: Scalars['ConfigPort'];
  sender: Scalars['String'];
  user: Scalars['String'];
};

export type ConfigGrafanaSmtpUpdateInput = {
  host?: InputMaybe<Scalars['String']>;
  password?: InputMaybe<Scalars['String']>;
  port?: InputMaybe<Scalars['ConfigPort']>;
  sender?: InputMaybe<Scalars['String']>;
  user?: InputMaybe<Scalars['String']>;
};

export type ConfigGrafanaUpdateInput = {
  adminPassword?: InputMaybe<Scalars['String']>;
  alerting?: InputMaybe<ConfigGrafanaAlertingUpdateInput>;
  contacts?: InputMaybe<ConfigGrafanaContactsUpdateInput>;
  smtp?: InputMaybe<ConfigGrafanaSmtpUpdateInput>;
};

export type ConfigGrafanacontactsDiscord = {
  __typename?: 'ConfigGrafanacontactsDiscord';
  avatarUrl: Scalars['String'];
  url: Scalars['String'];
};

export type ConfigGrafanacontactsDiscordComparisonExp = {
  _and?: InputMaybe<Array<ConfigGrafanacontactsDiscordComparisonExp>>;
  _not?: InputMaybe<ConfigGrafanacontactsDiscordComparisonExp>;
  _or?: InputMaybe<Array<ConfigGrafanacontactsDiscordComparisonExp>>;
  avatarUrl?: InputMaybe<ConfigStringComparisonExp>;
  url?: InputMaybe<ConfigStringComparisonExp>;
};

export type ConfigGrafanacontactsDiscordInsertInput = {
  avatarUrl: Scalars['String'];
  url: Scalars['String'];
};

export type ConfigGrafanacontactsDiscordUpdateInput = {
  avatarUrl?: InputMaybe<Scalars['String']>;
  url?: InputMaybe<Scalars['String']>;
};

export type ConfigGrafanacontactsPagerduty = {
  __typename?: 'ConfigGrafanacontactsPagerduty';
  class: Scalars['String'];
  component: Scalars['String'];
  group: Scalars['String'];
  integrationKey: Scalars['String'];
  severity: Scalars['String'];
};

export type ConfigGrafanacontactsPagerdutyComparisonExp = {
  _and?: InputMaybe<Array<ConfigGrafanacontactsPagerdutyComparisonExp>>;
  _not?: InputMaybe<ConfigGrafanacontactsPagerdutyComparisonExp>;
  _or?: InputMaybe<Array<ConfigGrafanacontactsPagerdutyComparisonExp>>;
  class?: InputMaybe<ConfigStringComparisonExp>;
  component?: InputMaybe<ConfigStringComparisonExp>;
  group?: InputMaybe<ConfigStringComparisonExp>;
  integrationKey?: InputMaybe<ConfigStringComparisonExp>;
  severity?: InputMaybe<ConfigStringComparisonExp>;
};

export type ConfigGrafanacontactsPagerdutyInsertInput = {
  class: Scalars['String'];
  component: Scalars['String'];
  group: Scalars['String'];
  integrationKey: Scalars['String'];
  severity: Scalars['String'];
};

export type ConfigGrafanacontactsPagerdutyUpdateInput = {
  class?: InputMaybe<Scalars['String']>;
  component?: InputMaybe<Scalars['String']>;
  group?: InputMaybe<Scalars['String']>;
  integrationKey?: InputMaybe<Scalars['String']>;
  severity?: InputMaybe<Scalars['String']>;
};

export type ConfigGrafanacontactsSlack = {
  __typename?: 'ConfigGrafanacontactsSlack';
  endpointURL: Scalars['String'];
  iconEmoji: Scalars['String'];
  iconURL: Scalars['String'];
  mentionChannel: Scalars['String'];
  mentionGroups: Array<Scalars['String']>;
  mentionUsers: Array<Scalars['String']>;
  recipient: Scalars['String'];
  token: Scalars['String'];
  url: Scalars['String'];
  username: Scalars['String'];
};

export type ConfigGrafanacontactsSlackComparisonExp = {
  _and?: InputMaybe<Array<ConfigGrafanacontactsSlackComparisonExp>>;
  _not?: InputMaybe<ConfigGrafanacontactsSlackComparisonExp>;
  _or?: InputMaybe<Array<ConfigGrafanacontactsSlackComparisonExp>>;
  endpointURL?: InputMaybe<ConfigStringComparisonExp>;
  iconEmoji?: InputMaybe<ConfigStringComparisonExp>;
  iconURL?: InputMaybe<ConfigStringComparisonExp>;
  mentionChannel?: InputMaybe<ConfigStringComparisonExp>;
  mentionGroups?: InputMaybe<ConfigStringComparisonExp>;
  mentionUsers?: InputMaybe<ConfigStringComparisonExp>;
  recipient?: InputMaybe<ConfigStringComparisonExp>;
  token?: InputMaybe<ConfigStringComparisonExp>;
  url?: InputMaybe<ConfigStringComparisonExp>;
  username?: InputMaybe<ConfigStringComparisonExp>;
};

export type ConfigGrafanacontactsSlackInsertInput = {
  endpointURL: Scalars['String'];
  iconEmoji: Scalars['String'];
  iconURL: Scalars['String'];
  mentionChannel: Scalars['String'];
  mentionGroups: Array<Scalars['String']>;
  mentionUsers: Array<Scalars['String']>;
  recipient: Scalars['String'];
  token: Scalars['String'];
  url: Scalars['String'];
  username: Scalars['String'];
};

export type ConfigGrafanacontactsSlackUpdateInput = {
  endpointURL?: InputMaybe<Scalars['String']>;
  iconEmoji?: InputMaybe<Scalars['String']>;
  iconURL?: InputMaybe<Scalars['String']>;
  mentionChannel?: InputMaybe<Scalars['String']>;
  mentionGroups?: InputMaybe<Array<Scalars['String']>>;
  mentionUsers?: InputMaybe<Array<Scalars['String']>>;
  recipient?: InputMaybe<Scalars['String']>;
  token?: InputMaybe<Scalars['String']>;
  url?: InputMaybe<Scalars['String']>;
  username?: InputMaybe<Scalars['String']>;
};

export type ConfigGrafanacontactsWebhook = {
  __typename?: 'ConfigGrafanacontactsWebhook';
  authorizationCredentials: Scalars['String'];
  authorizationScheme: Scalars['String'];
  httpMethod: Scalars['String'];
  maxAlerts: Scalars['Int'];
  password: Scalars['String'];
  url: Scalars['String'];
  username: Scalars['String'];
};

export type ConfigGrafanacontactsWebhookComparisonExp = {
  _and?: InputMaybe<Array<ConfigGrafanacontactsWebhookComparisonExp>>;
  _not?: InputMaybe<ConfigGrafanacontactsWebhookComparisonExp>;
  _or?: InputMaybe<Array<ConfigGrafanacontactsWebhookComparisonExp>>;
  authorizationCredentials?: InputMaybe<ConfigStringComparisonExp>;
  authorizationScheme?: InputMaybe<ConfigStringComparisonExp>;
  httpMethod?: InputMaybe<ConfigStringComparisonExp>;
  maxAlerts?: InputMaybe<ConfigIntComparisonExp>;
  password?: InputMaybe<ConfigStringComparisonExp>;
  url?: InputMaybe<ConfigStringComparisonExp>;
  username?: InputMaybe<ConfigStringComparisonExp>;
};

export type ConfigGrafanacontactsWebhookInsertInput = {
  authorizationCredentials: Scalars['String'];
  authorizationScheme: Scalars['String'];
  httpMethod: Scalars['String'];
  maxAlerts: Scalars['Int'];
  password: Scalars['String'];
  url: Scalars['String'];
  username: Scalars['String'];
};

export type ConfigGrafanacontactsWebhookUpdateInput = {
  authorizationCredentials?: InputMaybe<Scalars['String']>;
  authorizationScheme?: InputMaybe<Scalars['String']>;
  httpMethod?: InputMaybe<Scalars['String']>;
  maxAlerts?: InputMaybe<Scalars['Int']>;
  password?: InputMaybe<Scalars['String']>;
  url?: InputMaybe<Scalars['String']>;
  username?: InputMaybe<Scalars['String']>;
};

export type ConfigGraphql = {
  __typename?: 'ConfigGraphql';
  security?: Maybe<ConfigGraphqlSecurity>;
};

export type ConfigGraphqlComparisonExp = {
  _and?: InputMaybe<Array<ConfigGraphqlComparisonExp>>;
  _not?: InputMaybe<ConfigGraphqlComparisonExp>;
  _or?: InputMaybe<Array<ConfigGraphqlComparisonExp>>;
  security?: InputMaybe<ConfigGraphqlSecurityComparisonExp>;
};

export type ConfigGraphqlInsertInput = {
  security?: InputMaybe<ConfigGraphqlSecurityInsertInput>;
};

export type ConfigGraphqlSecurity = {
  __typename?: 'ConfigGraphqlSecurity';
  forbidAminSecret?: Maybe<Scalars['Boolean']>;
  maxDepthQueries?: Maybe<Scalars['ConfigUint']>;
};

export type ConfigGraphqlSecurityComparisonExp = {
  _and?: InputMaybe<Array<ConfigGraphqlSecurityComparisonExp>>;
  _not?: InputMaybe<ConfigGraphqlSecurityComparisonExp>;
  _or?: InputMaybe<Array<ConfigGraphqlSecurityComparisonExp>>;
  forbidAminSecret?: InputMaybe<ConfigBooleanComparisonExp>;
  maxDepthQueries?: InputMaybe<ConfigUintComparisonExp>;
};

export type ConfigGraphqlSecurityInsertInput = {
  forbidAminSecret?: InputMaybe<Scalars['Boolean']>;
  maxDepthQueries?: InputMaybe<Scalars['ConfigUint']>;
};

export type ConfigGraphqlSecurityUpdateInput = {
  forbidAminSecret?: InputMaybe<Scalars['Boolean']>;
  maxDepthQueries?: InputMaybe<Scalars['ConfigUint']>;
};

export type ConfigGraphqlUpdateInput = {
  security?: InputMaybe<ConfigGraphqlSecurityUpdateInput>;
};

/** Configuration for hasura service */
export type ConfigHasura = {
  __typename?: 'ConfigHasura';
  /** Admin secret */
  adminSecret: Scalars['String'];
  authHook?: Maybe<ConfigHasuraAuthHook>;
  events?: Maybe<ConfigHasuraEvents>;
  /** JWT Secrets configuration */
  jwtSecrets?: Maybe<Array<ConfigJwtSecret>>;
  logs?: Maybe<ConfigHasuraLogs>;
  rateLimit?: Maybe<ConfigRateLimit>;
  /** Resources for the service */
  resources?: Maybe<ConfigResources>;
  /**
   * Configuration for hasura services
   * Reference: https://hasura.io/docs/latest/deployment/graphql-engine-flags/reference/
   */
  settings?: Maybe<ConfigHasuraSettings>;
  /**
   * Version of hasura, you can see available versions in the URL below:
   * https://hub.docker.com/r/hasura/graphql-engine/tags
   */
  version?: Maybe<Scalars['String']>;
  /** Webhook secret */
  webhookSecret: Scalars['String'];
};

export type ConfigHasuraApIsComparisonExp = {
  _eq?: InputMaybe<Scalars['ConfigHasuraAPIs']>;
  _in?: InputMaybe<Array<Scalars['ConfigHasuraAPIs']>>;
  _neq?: InputMaybe<Scalars['ConfigHasuraAPIs']>;
  _nin?: InputMaybe<Array<Scalars['ConfigHasuraAPIs']>>;
};

export type ConfigHasuraAuthHook = {
  __typename?: 'ConfigHasuraAuthHook';
  mode?: Maybe<Scalars['String']>;
  /** HASURA_GRAPHQL_AUTH_HOOK_SEND_REQUEST_BODY */
  sendRequestBody?: Maybe<Scalars['Boolean']>;
  /** HASURA_GRAPHQL_AUTH_HOOK */
  url: Scalars['String'];
};

export type ConfigHasuraAuthHookComparisonExp = {
  _and?: InputMaybe<Array<ConfigHasuraAuthHookComparisonExp>>;
  _not?: InputMaybe<ConfigHasuraAuthHookComparisonExp>;
  _or?: InputMaybe<Array<ConfigHasuraAuthHookComparisonExp>>;
  mode?: InputMaybe<ConfigStringComparisonExp>;
  sendRequestBody?: InputMaybe<ConfigBooleanComparisonExp>;
  url?: InputMaybe<ConfigStringComparisonExp>;
};

export type ConfigHasuraAuthHookInsertInput = {
  mode?: InputMaybe<Scalars['String']>;
  sendRequestBody?: InputMaybe<Scalars['Boolean']>;
  url: Scalars['String'];
};

export type ConfigHasuraAuthHookUpdateInput = {
  mode?: InputMaybe<Scalars['String']>;
  sendRequestBody?: InputMaybe<Scalars['Boolean']>;
  url?: InputMaybe<Scalars['String']>;
};

export type ConfigHasuraComparisonExp = {
  _and?: InputMaybe<Array<ConfigHasuraComparisonExp>>;
  _not?: InputMaybe<ConfigHasuraComparisonExp>;
  _or?: InputMaybe<Array<ConfigHasuraComparisonExp>>;
  adminSecret?: InputMaybe<ConfigStringComparisonExp>;
  authHook?: InputMaybe<ConfigHasuraAuthHookComparisonExp>;
  events?: InputMaybe<ConfigHasuraEventsComparisonExp>;
  jwtSecrets?: InputMaybe<ConfigJwtSecretComparisonExp>;
  logs?: InputMaybe<ConfigHasuraLogsComparisonExp>;
  rateLimit?: InputMaybe<ConfigRateLimitComparisonExp>;
  resources?: InputMaybe<ConfigResourcesComparisonExp>;
  settings?: InputMaybe<ConfigHasuraSettingsComparisonExp>;
  version?: InputMaybe<ConfigStringComparisonExp>;
  webhookSecret?: InputMaybe<ConfigStringComparisonExp>;
};

export type ConfigHasuraEvents = {
  __typename?: 'ConfigHasuraEvents';
  /** HASURA_GRAPHQL_EVENTS_HTTP_POOL_SIZE */
  httpPoolSize?: Maybe<Scalars['ConfigUint32']>;
};

export type ConfigHasuraEventsComparisonExp = {
  _and?: InputMaybe<Array<ConfigHasuraEventsComparisonExp>>;
  _not?: InputMaybe<ConfigHasuraEventsComparisonExp>;
  _or?: InputMaybe<Array<ConfigHasuraEventsComparisonExp>>;
  httpPoolSize?: InputMaybe<ConfigUint32ComparisonExp>;
};

export type ConfigHasuraEventsInsertInput = {
  httpPoolSize?: InputMaybe<Scalars['ConfigUint32']>;
};

export type ConfigHasuraEventsUpdateInput = {
  httpPoolSize?: InputMaybe<Scalars['ConfigUint32']>;
};

export type ConfigHasuraInsertInput = {
  adminSecret: Scalars['String'];
  authHook?: InputMaybe<ConfigHasuraAuthHookInsertInput>;
  events?: InputMaybe<ConfigHasuraEventsInsertInput>;
  jwtSecrets?: InputMaybe<Array<ConfigJwtSecretInsertInput>>;
  logs?: InputMaybe<ConfigHasuraLogsInsertInput>;
  rateLimit?: InputMaybe<ConfigRateLimitInsertInput>;
  resources?: InputMaybe<ConfigResourcesInsertInput>;
  settings?: InputMaybe<ConfigHasuraSettingsInsertInput>;
  version?: InputMaybe<Scalars['String']>;
  webhookSecret: Scalars['String'];
};

export type ConfigHasuraLogs = {
  __typename?: 'ConfigHasuraLogs';
  level?: Maybe<Scalars['String']>;
};

export type ConfigHasuraLogsComparisonExp = {
  _and?: InputMaybe<Array<ConfigHasuraLogsComparisonExp>>;
  _not?: InputMaybe<ConfigHasuraLogsComparisonExp>;
  _or?: InputMaybe<Array<ConfigHasuraLogsComparisonExp>>;
  level?: InputMaybe<ConfigStringComparisonExp>;
};

export type ConfigHasuraLogsInsertInput = {
  level?: InputMaybe<Scalars['String']>;
};

export type ConfigHasuraLogsUpdateInput = {
  level?: InputMaybe<Scalars['String']>;
};

/**
 * Configuration for hasura services
 * Reference: https://hasura.io/docs/latest/deployment/graphql-engine-flags/reference/
 */
export type ConfigHasuraSettings = {
  __typename?: 'ConfigHasuraSettings';
  /** HASURA_GRAPHQL_CORS_DOMAIN */
  corsDomain?: Maybe<Array<Scalars['ConfigUrl']>>;
  /** HASURA_GRAPHQL_DEV_MODE */
  devMode?: Maybe<Scalars['Boolean']>;
  /** HASURA_GRAPHQL_ENABLE_ALLOWLIST */
  enableAllowList?: Maybe<Scalars['Boolean']>;
  /** HASURA_GRAPHQL_ENABLE_CONSOLE */
  enableConsole?: Maybe<Scalars['Boolean']>;
  /** HASURA_GRAPHQL_ENABLE_REMOTE_SCHEMA_PERMISSIONS */
  enableRemoteSchemaPermissions?: Maybe<Scalars['Boolean']>;
  /** HASURA_GRAPHQL_ENABLED_APIS */
  enabledAPIs?: Maybe<Array<Scalars['ConfigHasuraAPIs']>>;
  /** HASURA_GRAPHQL_INFER_FUNCTION_PERMISSIONS */
  inferFunctionPermissions?: Maybe<Scalars['Boolean']>;
  /** HASURA_GRAPHQL_LIVE_QUERIES_MULTIPLEXED_REFETCH_INTERVAL */
  liveQueriesMultiplexedRefetchInterval?: Maybe<Scalars['ConfigUint32']>;
  /** HASURA_GRAPHQL_STRINGIFY_NUMERIC_TYPES */
  stringifyNumericTypes?: Maybe<Scalars['Boolean']>;
};

export type ConfigHasuraSettingsComparisonExp = {
  _and?: InputMaybe<Array<ConfigHasuraSettingsComparisonExp>>;
  _not?: InputMaybe<ConfigHasuraSettingsComparisonExp>;
  _or?: InputMaybe<Array<ConfigHasuraSettingsComparisonExp>>;
  corsDomain?: InputMaybe<ConfigUrlComparisonExp>;
  devMode?: InputMaybe<ConfigBooleanComparisonExp>;
  enableAllowList?: InputMaybe<ConfigBooleanComparisonExp>;
  enableConsole?: InputMaybe<ConfigBooleanComparisonExp>;
  enableRemoteSchemaPermissions?: InputMaybe<ConfigBooleanComparisonExp>;
  enabledAPIs?: InputMaybe<ConfigHasuraApIsComparisonExp>;
  inferFunctionPermissions?: InputMaybe<ConfigBooleanComparisonExp>;
  liveQueriesMultiplexedRefetchInterval?: InputMaybe<ConfigUint32ComparisonExp>;
  stringifyNumericTypes?: InputMaybe<ConfigBooleanComparisonExp>;
};

export type ConfigHasuraSettingsInsertInput = {
  corsDomain?: InputMaybe<Array<Scalars['ConfigUrl']>>;
  devMode?: InputMaybe<Scalars['Boolean']>;
  enableAllowList?: InputMaybe<Scalars['Boolean']>;
  enableConsole?: InputMaybe<Scalars['Boolean']>;
  enableRemoteSchemaPermissions?: InputMaybe<Scalars['Boolean']>;
  enabledAPIs?: InputMaybe<Array<Scalars['ConfigHasuraAPIs']>>;
  inferFunctionPermissions?: InputMaybe<Scalars['Boolean']>;
  liveQueriesMultiplexedRefetchInterval?: InputMaybe<Scalars['ConfigUint32']>;
  stringifyNumericTypes?: InputMaybe<Scalars['Boolean']>;
};

export type ConfigHasuraSettingsUpdateInput = {
  corsDomain?: InputMaybe<Array<Scalars['ConfigUrl']>>;
  devMode?: InputMaybe<Scalars['Boolean']>;
  enableAllowList?: InputMaybe<Scalars['Boolean']>;
  enableConsole?: InputMaybe<Scalars['Boolean']>;
  enableRemoteSchemaPermissions?: InputMaybe<Scalars['Boolean']>;
  enabledAPIs?: InputMaybe<Array<Scalars['ConfigHasuraAPIs']>>;
  inferFunctionPermissions?: InputMaybe<Scalars['Boolean']>;
  liveQueriesMultiplexedRefetchInterval?: InputMaybe<Scalars['ConfigUint32']>;
  stringifyNumericTypes?: InputMaybe<Scalars['Boolean']>;
};

export type ConfigHasuraUpdateInput = {
  adminSecret?: InputMaybe<Scalars['String']>;
  authHook?: InputMaybe<ConfigHasuraAuthHookUpdateInput>;
  events?: InputMaybe<ConfigHasuraEventsUpdateInput>;
  jwtSecrets?: InputMaybe<Array<ConfigJwtSecretUpdateInput>>;
  logs?: InputMaybe<ConfigHasuraLogsUpdateInput>;
  rateLimit?: InputMaybe<ConfigRateLimitUpdateInput>;
  resources?: InputMaybe<ConfigResourcesUpdateInput>;
  settings?: InputMaybe<ConfigHasuraSettingsUpdateInput>;
  version?: InputMaybe<Scalars['String']>;
  webhookSecret?: InputMaybe<Scalars['String']>;
};

export type ConfigHealthCheck = {
  __typename?: 'ConfigHealthCheck';
  initialDelaySeconds?: Maybe<Scalars['Int']>;
  port: Scalars['ConfigPort'];
  probePeriodSeconds?: Maybe<Scalars['Int']>;
};

export type ConfigHealthCheckComparisonExp = {
  _and?: InputMaybe<Array<ConfigHealthCheckComparisonExp>>;
  _not?: InputMaybe<ConfigHealthCheckComparisonExp>;
  _or?: InputMaybe<Array<ConfigHealthCheckComparisonExp>>;
  initialDelaySeconds?: InputMaybe<ConfigIntComparisonExp>;
  port?: InputMaybe<ConfigPortComparisonExp>;
  probePeriodSeconds?: InputMaybe<ConfigIntComparisonExp>;
};

export type ConfigHealthCheckInsertInput = {
  initialDelaySeconds?: InputMaybe<Scalars['Int']>;
  port: Scalars['ConfigPort'];
  probePeriodSeconds?: InputMaybe<Scalars['Int']>;
};

export type ConfigHealthCheckUpdateInput = {
  initialDelaySeconds?: InputMaybe<Scalars['Int']>;
  port?: InputMaybe<Scalars['ConfigPort']>;
  probePeriodSeconds?: InputMaybe<Scalars['Int']>;
};

export type ConfigIngress = {
  __typename?: 'ConfigIngress';
  fqdn?: Maybe<Array<Scalars['String']>>;
};

export type ConfigIngressComparisonExp = {
  _and?: InputMaybe<Array<ConfigIngressComparisonExp>>;
  _not?: InputMaybe<ConfigIngressComparisonExp>;
  _or?: InputMaybe<Array<ConfigIngressComparisonExp>>;
  fqdn?: InputMaybe<ConfigStringComparisonExp>;
};

export type ConfigIngressInsertInput = {
  fqdn?: InputMaybe<Array<Scalars['String']>>;
};

export type ConfigIngressUpdateInput = {
  fqdn?: InputMaybe<Array<Scalars['String']>>;
};

export type ConfigInsertConfigResponse = {
  __typename?: 'ConfigInsertConfigResponse';
  config: ConfigConfig;
  secrets: Array<ConfigEnvironmentVariable>;
  systemConfig: ConfigSystemConfig;
};

export type ConfigInt32ComparisonExp = {
  _eq?: InputMaybe<Scalars['ConfigInt32']>;
  _in?: InputMaybe<Array<Scalars['ConfigInt32']>>;
  _neq?: InputMaybe<Scalars['ConfigInt32']>;
  _nin?: InputMaybe<Array<Scalars['ConfigInt32']>>;
};

export type ConfigIntComparisonExp = {
  _eq?: InputMaybe<Scalars['Int']>;
  _in?: InputMaybe<Array<Scalars['Int']>>;
  _neq?: InputMaybe<Scalars['Int']>;
  _nin?: InputMaybe<Array<Scalars['Int']>>;
};

/** See https://hasura.io/docs/latest/auth/authentication/jwt/ */
export type ConfigJwtSecret = {
  __typename?: 'ConfigJWTSecret';
  allowed_skew?: Maybe<Scalars['ConfigUint32']>;
  audience?: Maybe<Scalars['String']>;
  claims_format?: Maybe<Scalars['String']>;
  claims_map?: Maybe<Array<ConfigClaimMap>>;
  claims_namespace?: Maybe<Scalars['String']>;
  claims_namespace_path?: Maybe<Scalars['String']>;
  header?: Maybe<Scalars['String']>;
  issuer?: Maybe<Scalars['String']>;
  jwk_url?: Maybe<Scalars['ConfigUrl']>;
  key?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
};

export type ConfigJwtSecretComparisonExp = {
  _and?: InputMaybe<Array<ConfigJwtSecretComparisonExp>>;
  _not?: InputMaybe<ConfigJwtSecretComparisonExp>;
  _or?: InputMaybe<Array<ConfigJwtSecretComparisonExp>>;
  allowed_skew?: InputMaybe<ConfigUint32ComparisonExp>;
  audience?: InputMaybe<ConfigStringComparisonExp>;
  claims_format?: InputMaybe<ConfigStringComparisonExp>;
  claims_map?: InputMaybe<ConfigClaimMapComparisonExp>;
  claims_namespace?: InputMaybe<ConfigStringComparisonExp>;
  claims_namespace_path?: InputMaybe<ConfigStringComparisonExp>;
  header?: InputMaybe<ConfigStringComparisonExp>;
  issuer?: InputMaybe<ConfigStringComparisonExp>;
  jwk_url?: InputMaybe<ConfigUrlComparisonExp>;
  key?: InputMaybe<ConfigStringComparisonExp>;
  type?: InputMaybe<ConfigStringComparisonExp>;
};

export type ConfigJwtSecretInsertInput = {
  allowed_skew?: InputMaybe<Scalars['ConfigUint32']>;
  audience?: InputMaybe<Scalars['String']>;
  claims_format?: InputMaybe<Scalars['String']>;
  claims_map?: InputMaybe<Array<ConfigClaimMapInsertInput>>;
  claims_namespace?: InputMaybe<Scalars['String']>;
  claims_namespace_path?: InputMaybe<Scalars['String']>;
  header?: InputMaybe<Scalars['String']>;
  issuer?: InputMaybe<Scalars['String']>;
  jwk_url?: InputMaybe<Scalars['ConfigUrl']>;
  key?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<Scalars['String']>;
};

export type ConfigJwtSecretUpdateInput = {
  allowed_skew?: InputMaybe<Scalars['ConfigUint32']>;
  audience?: InputMaybe<Scalars['String']>;
  claims_format?: InputMaybe<Scalars['String']>;
  claims_map?: InputMaybe<Array<ConfigClaimMapUpdateInput>>;
  claims_namespace?: InputMaybe<Scalars['String']>;
  claims_namespace_path?: InputMaybe<Scalars['String']>;
  header?: InputMaybe<Scalars['String']>;
  issuer?: InputMaybe<Scalars['String']>;
  jwk_url?: InputMaybe<Scalars['ConfigUrl']>;
  key?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<Scalars['String']>;
};

export type ConfigLocaleComparisonExp = {
  _eq?: InputMaybe<Scalars['ConfigLocale']>;
  _in?: InputMaybe<Array<Scalars['ConfigLocale']>>;
  _neq?: InputMaybe<Scalars['ConfigLocale']>;
  _nin?: InputMaybe<Array<Scalars['ConfigLocale']>>;
};

export type ConfigNetworking = {
  __typename?: 'ConfigNetworking';
  ingresses?: Maybe<Array<ConfigIngress>>;
};

export type ConfigNetworkingComparisonExp = {
  _and?: InputMaybe<Array<ConfigNetworkingComparisonExp>>;
  _not?: InputMaybe<ConfigNetworkingComparisonExp>;
  _or?: InputMaybe<Array<ConfigNetworkingComparisonExp>>;
  ingresses?: InputMaybe<ConfigIngressComparisonExp>;
};

export type ConfigNetworkingInsertInput = {
  ingresses?: InputMaybe<Array<ConfigIngressInsertInput>>;
};

export type ConfigNetworkingUpdateInput = {
  ingresses?: InputMaybe<Array<ConfigIngressUpdateInput>>;
};

export type ConfigObservability = {
  __typename?: 'ConfigObservability';
  grafana: ConfigGrafana;
};

export type ConfigObservabilityComparisonExp = {
  _and?: InputMaybe<Array<ConfigObservabilityComparisonExp>>;
  _not?: InputMaybe<ConfigObservabilityComparisonExp>;
  _or?: InputMaybe<Array<ConfigObservabilityComparisonExp>>;
  grafana?: InputMaybe<ConfigGrafanaComparisonExp>;
};

export type ConfigObservabilityInsertInput = {
  grafana: ConfigGrafanaInsertInput;
};

export type ConfigObservabilityUpdateInput = {
  grafana?: InputMaybe<ConfigGrafanaUpdateInput>;
};

export type ConfigPortComparisonExp = {
  _eq?: InputMaybe<Scalars['ConfigPort']>;
  _in?: InputMaybe<Array<Scalars['ConfigPort']>>;
  _neq?: InputMaybe<Scalars['ConfigPort']>;
  _nin?: InputMaybe<Array<Scalars['ConfigPort']>>;
};

/** Configuration for postgres service */
export type ConfigPostgres = {
  __typename?: 'ConfigPostgres';
  /** Resources for the service */
  resources?: Maybe<ConfigPostgresResources>;
  settings?: Maybe<ConfigPostgresSettings>;
  /**
   * Version of postgres, you can see available versions in the URL below:
   * https://hub.docker.com/r/nhost/postgres/tags
   */
  version?: Maybe<Scalars['String']>;
};

export type ConfigPostgresComparisonExp = {
  _and?: InputMaybe<Array<ConfigPostgresComparisonExp>>;
  _not?: InputMaybe<ConfigPostgresComparisonExp>;
  _or?: InputMaybe<Array<ConfigPostgresComparisonExp>>;
  resources?: InputMaybe<ConfigPostgresResourcesComparisonExp>;
  settings?: InputMaybe<ConfigPostgresSettingsComparisonExp>;
  version?: InputMaybe<ConfigStringComparisonExp>;
};

export type ConfigPostgresInsertInput = {
  resources?: InputMaybe<ConfigPostgresResourcesInsertInput>;
  settings?: InputMaybe<ConfigPostgresSettingsInsertInput>;
  version?: InputMaybe<Scalars['String']>;
};

/** Resources for the service */
export type ConfigPostgresResources = {
  __typename?: 'ConfigPostgresResources';
  autoscaler?: Maybe<ConfigAutoscaler>;
  compute?: Maybe<ConfigResourcesCompute>;
  enablePublicAccess?: Maybe<Scalars['Boolean']>;
  networking?: Maybe<ConfigNetworking>;
  /** Number of replicas for a service */
  replicas?: Maybe<Scalars['ConfigUint8']>;
  storage?: Maybe<ConfigPostgresStorage>;
};

export type ConfigPostgresResourcesComparisonExp = {
  _and?: InputMaybe<Array<ConfigPostgresResourcesComparisonExp>>;
  _not?: InputMaybe<ConfigPostgresResourcesComparisonExp>;
  _or?: InputMaybe<Array<ConfigPostgresResourcesComparisonExp>>;
  autoscaler?: InputMaybe<ConfigAutoscalerComparisonExp>;
  compute?: InputMaybe<ConfigResourcesComputeComparisonExp>;
  enablePublicAccess?: InputMaybe<ConfigBooleanComparisonExp>;
  networking?: InputMaybe<ConfigNetworkingComparisonExp>;
  replicas?: InputMaybe<ConfigUint8ComparisonExp>;
  storage?: InputMaybe<ConfigPostgresStorageComparisonExp>;
};

export type ConfigPostgresResourcesInsertInput = {
  autoscaler?: InputMaybe<ConfigAutoscalerInsertInput>;
  compute?: InputMaybe<ConfigResourcesComputeInsertInput>;
  enablePublicAccess?: InputMaybe<Scalars['Boolean']>;
  networking?: InputMaybe<ConfigNetworkingInsertInput>;
  replicas?: InputMaybe<Scalars['ConfigUint8']>;
  storage?: InputMaybe<ConfigPostgresStorageInsertInput>;
};

export type ConfigPostgresResourcesUpdateInput = {
  autoscaler?: InputMaybe<ConfigAutoscalerUpdateInput>;
  compute?: InputMaybe<ConfigResourcesComputeUpdateInput>;
  enablePublicAccess?: InputMaybe<Scalars['Boolean']>;
  networking?: InputMaybe<ConfigNetworkingUpdateInput>;
  replicas?: InputMaybe<Scalars['ConfigUint8']>;
  storage?: InputMaybe<ConfigPostgresStorageUpdateInput>;
};

export type ConfigPostgresSettings = {
  __typename?: 'ConfigPostgresSettings';
  checkpointCompletionTarget?: Maybe<Scalars['Float']>;
  defaultStatisticsTarget?: Maybe<Scalars['ConfigInt32']>;
  effectiveCacheSize?: Maybe<Scalars['String']>;
  effectiveIOConcurrency?: Maybe<Scalars['ConfigInt32']>;
  hugePages?: Maybe<Scalars['String']>;
  jit?: Maybe<Scalars['String']>;
  maintenanceWorkMem?: Maybe<Scalars['String']>;
  maxConnections?: Maybe<Scalars['ConfigInt32']>;
  maxParallelMaintenanceWorkers?: Maybe<Scalars['ConfigInt32']>;
  maxParallelWorkers?: Maybe<Scalars['ConfigInt32']>;
  maxParallelWorkersPerGather?: Maybe<Scalars['ConfigInt32']>;
  maxReplicationSlots?: Maybe<Scalars['ConfigInt32']>;
  maxWalSenders?: Maybe<Scalars['ConfigInt32']>;
  maxWalSize?: Maybe<Scalars['String']>;
  maxWorkerProcesses?: Maybe<Scalars['ConfigInt32']>;
  minWalSize?: Maybe<Scalars['String']>;
  randomPageCost?: Maybe<Scalars['Float']>;
  sharedBuffers?: Maybe<Scalars['String']>;
  walBuffers?: Maybe<Scalars['String']>;
  walLevel?: Maybe<Scalars['String']>;
  workMem?: Maybe<Scalars['String']>;
};

export type ConfigPostgresSettingsComparisonExp = {
  _and?: InputMaybe<Array<ConfigPostgresSettingsComparisonExp>>;
  _not?: InputMaybe<ConfigPostgresSettingsComparisonExp>;
  _or?: InputMaybe<Array<ConfigPostgresSettingsComparisonExp>>;
  checkpointCompletionTarget?: InputMaybe<ConfigFloatComparisonExp>;
  defaultStatisticsTarget?: InputMaybe<ConfigInt32ComparisonExp>;
  effectiveCacheSize?: InputMaybe<ConfigStringComparisonExp>;
  effectiveIOConcurrency?: InputMaybe<ConfigInt32ComparisonExp>;
  hugePages?: InputMaybe<ConfigStringComparisonExp>;
  jit?: InputMaybe<ConfigStringComparisonExp>;
  maintenanceWorkMem?: InputMaybe<ConfigStringComparisonExp>;
  maxConnections?: InputMaybe<ConfigInt32ComparisonExp>;
  maxParallelMaintenanceWorkers?: InputMaybe<ConfigInt32ComparisonExp>;
  maxParallelWorkers?: InputMaybe<ConfigInt32ComparisonExp>;
  maxParallelWorkersPerGather?: InputMaybe<ConfigInt32ComparisonExp>;
  maxReplicationSlots?: InputMaybe<ConfigInt32ComparisonExp>;
  maxWalSenders?: InputMaybe<ConfigInt32ComparisonExp>;
  maxWalSize?: InputMaybe<ConfigStringComparisonExp>;
  maxWorkerProcesses?: InputMaybe<ConfigInt32ComparisonExp>;
  minWalSize?: InputMaybe<ConfigStringComparisonExp>;
  randomPageCost?: InputMaybe<ConfigFloatComparisonExp>;
  sharedBuffers?: InputMaybe<ConfigStringComparisonExp>;
  walBuffers?: InputMaybe<ConfigStringComparisonExp>;
  walLevel?: InputMaybe<ConfigStringComparisonExp>;
  workMem?: InputMaybe<ConfigStringComparisonExp>;
};

export type ConfigPostgresSettingsInsertInput = {
  checkpointCompletionTarget?: InputMaybe<Scalars['Float']>;
  defaultStatisticsTarget?: InputMaybe<Scalars['ConfigInt32']>;
  effectiveCacheSize?: InputMaybe<Scalars['String']>;
  effectiveIOConcurrency?: InputMaybe<Scalars['ConfigInt32']>;
  hugePages?: InputMaybe<Scalars['String']>;
  jit?: InputMaybe<Scalars['String']>;
  maintenanceWorkMem?: InputMaybe<Scalars['String']>;
  maxConnections?: InputMaybe<Scalars['ConfigInt32']>;
  maxParallelMaintenanceWorkers?: InputMaybe<Scalars['ConfigInt32']>;
  maxParallelWorkers?: InputMaybe<Scalars['ConfigInt32']>;
  maxParallelWorkersPerGather?: InputMaybe<Scalars['ConfigInt32']>;
  maxReplicationSlots?: InputMaybe<Scalars['ConfigInt32']>;
  maxWalSenders?: InputMaybe<Scalars['ConfigInt32']>;
  maxWalSize?: InputMaybe<Scalars['String']>;
  maxWorkerProcesses?: InputMaybe<Scalars['ConfigInt32']>;
  minWalSize?: InputMaybe<Scalars['String']>;
  randomPageCost?: InputMaybe<Scalars['Float']>;
  sharedBuffers?: InputMaybe<Scalars['String']>;
  walBuffers?: InputMaybe<Scalars['String']>;
  walLevel?: InputMaybe<Scalars['String']>;
  workMem?: InputMaybe<Scalars['String']>;
};

export type ConfigPostgresSettingsUpdateInput = {
  checkpointCompletionTarget?: InputMaybe<Scalars['Float']>;
  defaultStatisticsTarget?: InputMaybe<Scalars['ConfigInt32']>;
  effectiveCacheSize?: InputMaybe<Scalars['String']>;
  effectiveIOConcurrency?: InputMaybe<Scalars['ConfigInt32']>;
  hugePages?: InputMaybe<Scalars['String']>;
  jit?: InputMaybe<Scalars['String']>;
  maintenanceWorkMem?: InputMaybe<Scalars['String']>;
  maxConnections?: InputMaybe<Scalars['ConfigInt32']>;
  maxParallelMaintenanceWorkers?: InputMaybe<Scalars['ConfigInt32']>;
  maxParallelWorkers?: InputMaybe<Scalars['ConfigInt32']>;
  maxParallelWorkersPerGather?: InputMaybe<Scalars['ConfigInt32']>;
  maxReplicationSlots?: InputMaybe<Scalars['ConfigInt32']>;
  maxWalSenders?: InputMaybe<Scalars['ConfigInt32']>;
  maxWalSize?: InputMaybe<Scalars['String']>;
  maxWorkerProcesses?: InputMaybe<Scalars['ConfigInt32']>;
  minWalSize?: InputMaybe<Scalars['String']>;
  randomPageCost?: InputMaybe<Scalars['Float']>;
  sharedBuffers?: InputMaybe<Scalars['String']>;
  walBuffers?: InputMaybe<Scalars['String']>;
  walLevel?: InputMaybe<Scalars['String']>;
  workMem?: InputMaybe<Scalars['String']>;
};

export type ConfigPostgresStorage = {
  __typename?: 'ConfigPostgresStorage';
  /** GiB */
  capacity: Scalars['ConfigUint32'];
};

export type ConfigPostgresStorageComparisonExp = {
  _and?: InputMaybe<Array<ConfigPostgresStorageComparisonExp>>;
  _not?: InputMaybe<ConfigPostgresStorageComparisonExp>;
  _or?: InputMaybe<Array<ConfigPostgresStorageComparisonExp>>;
  capacity?: InputMaybe<ConfigUint32ComparisonExp>;
};

export type ConfigPostgresStorageInsertInput = {
  capacity: Scalars['ConfigUint32'];
};

export type ConfigPostgresStorageUpdateInput = {
  capacity?: InputMaybe<Scalars['ConfigUint32']>;
};

export type ConfigPostgresUpdateInput = {
  resources?: InputMaybe<ConfigPostgresResourcesUpdateInput>;
  settings?: InputMaybe<ConfigPostgresSettingsUpdateInput>;
  version?: InputMaybe<Scalars['String']>;
};

export type ConfigProvider = {
  __typename?: 'ConfigProvider';
  sms?: Maybe<ConfigSms>;
  smtp?: Maybe<ConfigSmtp>;
};

export type ConfigProviderComparisonExp = {
  _and?: InputMaybe<Array<ConfigProviderComparisonExp>>;
  _not?: InputMaybe<ConfigProviderComparisonExp>;
  _or?: InputMaybe<Array<ConfigProviderComparisonExp>>;
  sms?: InputMaybe<ConfigSmsComparisonExp>;
  smtp?: InputMaybe<ConfigSmtpComparisonExp>;
};

export type ConfigProviderInsertInput = {
  sms?: InputMaybe<ConfigSmsInsertInput>;
  smtp?: InputMaybe<ConfigSmtpInsertInput>;
};

export type ConfigProviderUpdateInput = {
  sms?: InputMaybe<ConfigSmsUpdateInput>;
  smtp?: InputMaybe<ConfigSmtpUpdateInput>;
};

export type ConfigRateLimit = {
  __typename?: 'ConfigRateLimit';
  interval: Scalars['String'];
  limit: Scalars['ConfigUint32'];
};

export type ConfigRateLimitComparisonExp = {
  _and?: InputMaybe<Array<ConfigRateLimitComparisonExp>>;
  _not?: InputMaybe<ConfigRateLimitComparisonExp>;
  _or?: InputMaybe<Array<ConfigRateLimitComparisonExp>>;
  interval?: InputMaybe<ConfigStringComparisonExp>;
  limit?: InputMaybe<ConfigUint32ComparisonExp>;
};

export type ConfigRateLimitInsertInput = {
  interval: Scalars['String'];
  limit: Scalars['ConfigUint32'];
};

export type ConfigRateLimitUpdateInput = {
  interval?: InputMaybe<Scalars['String']>;
  limit?: InputMaybe<Scalars['ConfigUint32']>;
};

/** Resource configuration for a service */
export type ConfigResources = {
  __typename?: 'ConfigResources';
  autoscaler?: Maybe<ConfigAutoscaler>;
  compute?: Maybe<ConfigResourcesCompute>;
  networking?: Maybe<ConfigNetworking>;
  /** Number of replicas for a service */
  replicas?: Maybe<Scalars['ConfigUint8']>;
};

export type ConfigResourcesComparisonExp = {
  _and?: InputMaybe<Array<ConfigResourcesComparisonExp>>;
  _not?: InputMaybe<ConfigResourcesComparisonExp>;
  _or?: InputMaybe<Array<ConfigResourcesComparisonExp>>;
  autoscaler?: InputMaybe<ConfigAutoscalerComparisonExp>;
  compute?: InputMaybe<ConfigResourcesComputeComparisonExp>;
  networking?: InputMaybe<ConfigNetworkingComparisonExp>;
  replicas?: InputMaybe<ConfigUint8ComparisonExp>;
};

export type ConfigResourcesCompute = {
  __typename?: 'ConfigResourcesCompute';
  /** milicpus, 1000 milicpus = 1 cpu */
  cpu: Scalars['ConfigUint32'];
  /** MiB: 128MiB to 30GiB */
  memory: Scalars['ConfigUint32'];
};

export type ConfigResourcesComputeComparisonExp = {
  _and?: InputMaybe<Array<ConfigResourcesComputeComparisonExp>>;
  _not?: InputMaybe<ConfigResourcesComputeComparisonExp>;
  _or?: InputMaybe<Array<ConfigResourcesComputeComparisonExp>>;
  cpu?: InputMaybe<ConfigUint32ComparisonExp>;
  memory?: InputMaybe<ConfigUint32ComparisonExp>;
};

export type ConfigResourcesComputeInsertInput = {
  cpu: Scalars['ConfigUint32'];
  memory: Scalars['ConfigUint32'];
};

export type ConfigResourcesComputeUpdateInput = {
  cpu?: InputMaybe<Scalars['ConfigUint32']>;
  memory?: InputMaybe<Scalars['ConfigUint32']>;
};

export type ConfigResourcesInsertInput = {
  autoscaler?: InputMaybe<ConfigAutoscalerInsertInput>;
  compute?: InputMaybe<ConfigResourcesComputeInsertInput>;
  networking?: InputMaybe<ConfigNetworkingInsertInput>;
  replicas?: InputMaybe<Scalars['ConfigUint8']>;
};

export type ConfigResourcesUpdateInput = {
  autoscaler?: InputMaybe<ConfigAutoscalerUpdateInput>;
  compute?: InputMaybe<ConfigResourcesComputeUpdateInput>;
  networking?: InputMaybe<ConfigNetworkingUpdateInput>;
  replicas?: InputMaybe<Scalars['ConfigUint8']>;
};

export type ConfigRunServiceConfig = {
  __typename?: 'ConfigRunServiceConfig';
  command?: Maybe<Array<Scalars['String']>>;
  environment?: Maybe<Array<ConfigEnvironmentVariable>>;
  healthCheck?: Maybe<ConfigHealthCheck>;
  image: ConfigRunServiceImage;
  name: Scalars['ConfigRunServiceName'];
  ports?: Maybe<Array<ConfigRunServicePort>>;
  resources: ConfigRunServiceResources;
};

export type ConfigRunServiceConfigComparisonExp = {
  _and?: InputMaybe<Array<ConfigRunServiceConfigComparisonExp>>;
  _not?: InputMaybe<ConfigRunServiceConfigComparisonExp>;
  _or?: InputMaybe<Array<ConfigRunServiceConfigComparisonExp>>;
  command?: InputMaybe<ConfigStringComparisonExp>;
  environment?: InputMaybe<ConfigEnvironmentVariableComparisonExp>;
  healthCheck?: InputMaybe<ConfigHealthCheckComparisonExp>;
  image?: InputMaybe<ConfigRunServiceImageComparisonExp>;
  name?: InputMaybe<ConfigRunServiceNameComparisonExp>;
  ports?: InputMaybe<ConfigRunServicePortComparisonExp>;
  resources?: InputMaybe<ConfigRunServiceResourcesComparisonExp>;
};

export type ConfigRunServiceConfigInsertInput = {
  command?: InputMaybe<Array<Scalars['String']>>;
  environment?: InputMaybe<Array<ConfigEnvironmentVariableInsertInput>>;
  healthCheck?: InputMaybe<ConfigHealthCheckInsertInput>;
  image: ConfigRunServiceImageInsertInput;
  name: Scalars['ConfigRunServiceName'];
  ports?: InputMaybe<Array<ConfigRunServicePortInsertInput>>;
  resources: ConfigRunServiceResourcesInsertInput;
};

export type ConfigRunServiceConfigUpdateInput = {
  command?: InputMaybe<Array<Scalars['String']>>;
  environment?: InputMaybe<Array<ConfigEnvironmentVariableUpdateInput>>;
  healthCheck?: InputMaybe<ConfigHealthCheckUpdateInput>;
  image?: InputMaybe<ConfigRunServiceImageUpdateInput>;
  name?: InputMaybe<Scalars['ConfigRunServiceName']>;
  ports?: InputMaybe<Array<ConfigRunServicePortUpdateInput>>;
  resources?: InputMaybe<ConfigRunServiceResourcesUpdateInput>;
};

export type ConfigRunServiceConfigWithId = {
  __typename?: 'ConfigRunServiceConfigWithID';
  config: ConfigRunServiceConfig;
  serviceID: Scalars['uuid'];
};

export type ConfigRunServiceImage = {
  __typename?: 'ConfigRunServiceImage';
  image: Scalars['String'];
  /** content of "auths", i.e., { "auths": $THIS } */
  pullCredentials?: Maybe<Scalars['String']>;
};

export type ConfigRunServiceImageComparisonExp = {
  _and?: InputMaybe<Array<ConfigRunServiceImageComparisonExp>>;
  _not?: InputMaybe<ConfigRunServiceImageComparisonExp>;
  _or?: InputMaybe<Array<ConfigRunServiceImageComparisonExp>>;
  image?: InputMaybe<ConfigStringComparisonExp>;
  pullCredentials?: InputMaybe<ConfigStringComparisonExp>;
};

export type ConfigRunServiceImageInsertInput = {
  image: Scalars['String'];
  pullCredentials?: InputMaybe<Scalars['String']>;
};

export type ConfigRunServiceImageUpdateInput = {
  image?: InputMaybe<Scalars['String']>;
  pullCredentials?: InputMaybe<Scalars['String']>;
};

export type ConfigRunServiceNameComparisonExp = {
  _eq?: InputMaybe<Scalars['ConfigRunServiceName']>;
  _in?: InputMaybe<Array<Scalars['ConfigRunServiceName']>>;
  _neq?: InputMaybe<Scalars['ConfigRunServiceName']>;
  _nin?: InputMaybe<Array<Scalars['ConfigRunServiceName']>>;
};

export type ConfigRunServicePort = {
  __typename?: 'ConfigRunServicePort';
  ingresses?: Maybe<Array<ConfigIngress>>;
  port: Scalars['ConfigPort'];
  publish?: Maybe<Scalars['Boolean']>;
  rateLimit?: Maybe<ConfigRateLimit>;
  type: Scalars['String'];
};

export type ConfigRunServicePortComparisonExp = {
  _and?: InputMaybe<Array<ConfigRunServicePortComparisonExp>>;
  _not?: InputMaybe<ConfigRunServicePortComparisonExp>;
  _or?: InputMaybe<Array<ConfigRunServicePortComparisonExp>>;
  ingresses?: InputMaybe<ConfigIngressComparisonExp>;
  port?: InputMaybe<ConfigPortComparisonExp>;
  publish?: InputMaybe<ConfigBooleanComparisonExp>;
  rateLimit?: InputMaybe<ConfigRateLimitComparisonExp>;
  type?: InputMaybe<ConfigStringComparisonExp>;
};

export type ConfigRunServicePortInsertInput = {
  ingresses?: InputMaybe<Array<ConfigIngressInsertInput>>;
  port: Scalars['ConfigPort'];
  publish?: InputMaybe<Scalars['Boolean']>;
  rateLimit?: InputMaybe<ConfigRateLimitInsertInput>;
  type: Scalars['String'];
};

export type ConfigRunServicePortUpdateInput = {
  ingresses?: InputMaybe<Array<ConfigIngressUpdateInput>>;
  port?: InputMaybe<Scalars['ConfigPort']>;
  publish?: InputMaybe<Scalars['Boolean']>;
  rateLimit?: InputMaybe<ConfigRateLimitUpdateInput>;
  type?: InputMaybe<Scalars['String']>;
};

/** Resource configuration for a service */
export type ConfigRunServiceResources = {
  __typename?: 'ConfigRunServiceResources';
  autoscaler?: Maybe<ConfigAutoscaler>;
  compute: ConfigComputeResources;
  /** Number of replicas for a service */
  replicas: Scalars['ConfigUint8'];
  storage?: Maybe<Array<ConfigRunServiceResourcesStorage>>;
};

export type ConfigRunServiceResourcesComparisonExp = {
  _and?: InputMaybe<Array<ConfigRunServiceResourcesComparisonExp>>;
  _not?: InputMaybe<ConfigRunServiceResourcesComparisonExp>;
  _or?: InputMaybe<Array<ConfigRunServiceResourcesComparisonExp>>;
  autoscaler?: InputMaybe<ConfigAutoscalerComparisonExp>;
  compute?: InputMaybe<ConfigComputeResourcesComparisonExp>;
  replicas?: InputMaybe<ConfigUint8ComparisonExp>;
  storage?: InputMaybe<ConfigRunServiceResourcesStorageComparisonExp>;
};

export type ConfigRunServiceResourcesInsertInput = {
  autoscaler?: InputMaybe<ConfigAutoscalerInsertInput>;
  compute: ConfigComputeResourcesInsertInput;
  replicas: Scalars['ConfigUint8'];
  storage?: InputMaybe<Array<ConfigRunServiceResourcesStorageInsertInput>>;
};

export type ConfigRunServiceResourcesStorage = {
  __typename?: 'ConfigRunServiceResourcesStorage';
  /** GiB */
  capacity: Scalars['ConfigUint32'];
  /** name of the volume, changing it will cause data loss */
  name: Scalars['ConfigRunServiceName'];
  path: Scalars['String'];
};

export type ConfigRunServiceResourcesStorageComparisonExp = {
  _and?: InputMaybe<Array<ConfigRunServiceResourcesStorageComparisonExp>>;
  _not?: InputMaybe<ConfigRunServiceResourcesStorageComparisonExp>;
  _or?: InputMaybe<Array<ConfigRunServiceResourcesStorageComparisonExp>>;
  capacity?: InputMaybe<ConfigUint32ComparisonExp>;
  name?: InputMaybe<ConfigRunServiceNameComparisonExp>;
  path?: InputMaybe<ConfigStringComparisonExp>;
};

export type ConfigRunServiceResourcesStorageInsertInput = {
  capacity: Scalars['ConfigUint32'];
  name: Scalars['ConfigRunServiceName'];
  path: Scalars['String'];
};

export type ConfigRunServiceResourcesStorageUpdateInput = {
  capacity?: InputMaybe<Scalars['ConfigUint32']>;
  name?: InputMaybe<Scalars['ConfigRunServiceName']>;
  path?: InputMaybe<Scalars['String']>;
};

export type ConfigRunServiceResourcesUpdateInput = {
  autoscaler?: InputMaybe<ConfigAutoscalerUpdateInput>;
  compute?: InputMaybe<ConfigComputeResourcesUpdateInput>;
  replicas?: InputMaybe<Scalars['ConfigUint8']>;
  storage?: InputMaybe<Array<ConfigRunServiceResourcesStorageUpdateInput>>;
};

export type ConfigSms = {
  __typename?: 'ConfigSms';
  accountSid: Scalars['String'];
  authToken: Scalars['String'];
  messagingServiceId: Scalars['String'];
  provider?: Maybe<Scalars['String']>;
};

export type ConfigSmsComparisonExp = {
  _and?: InputMaybe<Array<ConfigSmsComparisonExp>>;
  _not?: InputMaybe<ConfigSmsComparisonExp>;
  _or?: InputMaybe<Array<ConfigSmsComparisonExp>>;
  accountSid?: InputMaybe<ConfigStringComparisonExp>;
  authToken?: InputMaybe<ConfigStringComparisonExp>;
  messagingServiceId?: InputMaybe<ConfigStringComparisonExp>;
  provider?: InputMaybe<ConfigStringComparisonExp>;
};

export type ConfigSmsInsertInput = {
  accountSid: Scalars['String'];
  authToken: Scalars['String'];
  messagingServiceId: Scalars['String'];
  provider?: InputMaybe<Scalars['String']>;
};

export type ConfigSmsUpdateInput = {
  accountSid?: InputMaybe<Scalars['String']>;
  authToken?: InputMaybe<Scalars['String']>;
  messagingServiceId?: InputMaybe<Scalars['String']>;
  provider?: InputMaybe<Scalars['String']>;
};

export type ConfigSmtp = {
  __typename?: 'ConfigSmtp';
  host: Scalars['String'];
  method: Scalars['String'];
  password: Scalars['String'];
  port: Scalars['ConfigPort'];
  secure: Scalars['Boolean'];
  sender: Scalars['String'];
  user: Scalars['String'];
};

export type ConfigSmtpComparisonExp = {
  _and?: InputMaybe<Array<ConfigSmtpComparisonExp>>;
  _not?: InputMaybe<ConfigSmtpComparisonExp>;
  _or?: InputMaybe<Array<ConfigSmtpComparisonExp>>;
  host?: InputMaybe<ConfigStringComparisonExp>;
  method?: InputMaybe<ConfigStringComparisonExp>;
  password?: InputMaybe<ConfigStringComparisonExp>;
  port?: InputMaybe<ConfigPortComparisonExp>;
  secure?: InputMaybe<ConfigBooleanComparisonExp>;
  sender?: InputMaybe<ConfigStringComparisonExp>;
  user?: InputMaybe<ConfigStringComparisonExp>;
};

export type ConfigSmtpInsertInput = {
  host: Scalars['String'];
  method: Scalars['String'];
  password: Scalars['String'];
  port: Scalars['ConfigPort'];
  secure: Scalars['Boolean'];
  sender: Scalars['String'];
  user: Scalars['String'];
};

export type ConfigSmtpUpdateInput = {
  host?: InputMaybe<Scalars['String']>;
  method?: InputMaybe<Scalars['String']>;
  password?: InputMaybe<Scalars['String']>;
  port?: InputMaybe<Scalars['ConfigPort']>;
  secure?: InputMaybe<Scalars['Boolean']>;
  sender?: InputMaybe<Scalars['String']>;
  user?: InputMaybe<Scalars['String']>;
};

export type ConfigStandardOauthProvider = {
  __typename?: 'ConfigStandardOauthProvider';
  clientId?: Maybe<Scalars['String']>;
  clientSecret?: Maybe<Scalars['String']>;
  enabled?: Maybe<Scalars['Boolean']>;
};

export type ConfigStandardOauthProviderComparisonExp = {
  _and?: InputMaybe<Array<ConfigStandardOauthProviderComparisonExp>>;
  _not?: InputMaybe<ConfigStandardOauthProviderComparisonExp>;
  _or?: InputMaybe<Array<ConfigStandardOauthProviderComparisonExp>>;
  clientId?: InputMaybe<ConfigStringComparisonExp>;
  clientSecret?: InputMaybe<ConfigStringComparisonExp>;
  enabled?: InputMaybe<ConfigBooleanComparisonExp>;
};

export type ConfigStandardOauthProviderInsertInput = {
  clientId?: InputMaybe<Scalars['String']>;
  clientSecret?: InputMaybe<Scalars['String']>;
  enabled?: InputMaybe<Scalars['Boolean']>;
};

export type ConfigStandardOauthProviderUpdateInput = {
  clientId?: InputMaybe<Scalars['String']>;
  clientSecret?: InputMaybe<Scalars['String']>;
  enabled?: InputMaybe<Scalars['Boolean']>;
};

export type ConfigStandardOauthProviderWithScope = {
  __typename?: 'ConfigStandardOauthProviderWithScope';
  clientId?: Maybe<Scalars['String']>;
  clientSecret?: Maybe<Scalars['String']>;
  enabled?: Maybe<Scalars['Boolean']>;
  scope?: Maybe<Array<Scalars['String']>>;
};

export type ConfigStandardOauthProviderWithScopeComparisonExp = {
  _and?: InputMaybe<Array<ConfigStandardOauthProviderWithScopeComparisonExp>>;
  _not?: InputMaybe<ConfigStandardOauthProviderWithScopeComparisonExp>;
  _or?: InputMaybe<Array<ConfigStandardOauthProviderWithScopeComparisonExp>>;
  clientId?: InputMaybe<ConfigStringComparisonExp>;
  clientSecret?: InputMaybe<ConfigStringComparisonExp>;
  enabled?: InputMaybe<ConfigBooleanComparisonExp>;
  scope?: InputMaybe<ConfigStringComparisonExp>;
};

export type ConfigStandardOauthProviderWithScopeInsertInput = {
  clientId?: InputMaybe<Scalars['String']>;
  clientSecret?: InputMaybe<Scalars['String']>;
  enabled?: InputMaybe<Scalars['Boolean']>;
  scope?: InputMaybe<Array<Scalars['String']>>;
};

export type ConfigStandardOauthProviderWithScopeUpdateInput = {
  clientId?: InputMaybe<Scalars['String']>;
  clientSecret?: InputMaybe<Scalars['String']>;
  enabled?: InputMaybe<Scalars['Boolean']>;
  scope?: InputMaybe<Array<Scalars['String']>>;
};

/** Configuration for storage service */
export type ConfigStorage = {
  __typename?: 'ConfigStorage';
  antivirus?: Maybe<ConfigStorageAntivirus>;
  rateLimit?: Maybe<ConfigRateLimit>;
  /**
   * Networking (custom domains at the moment) are not allowed as we need to do further
   * configurations in the CDN. We will enable it again in the future.
   */
  resources?: Maybe<ConfigResources>;
  /**
   * Version of storage service, you can see available versions in the URL below:
   * https://hub.docker.com/r/nhost/hasura-storage/tags
   *
   * Releases:
   *
   * https://github.com/nhost/hasura-storage/releases
   */
  version?: Maybe<Scalars['String']>;
};

export type ConfigStorageAntivirus = {
  __typename?: 'ConfigStorageAntivirus';
  server?: Maybe<Scalars['String']>;
};

export type ConfigStorageAntivirusComparisonExp = {
  _and?: InputMaybe<Array<ConfigStorageAntivirusComparisonExp>>;
  _not?: InputMaybe<ConfigStorageAntivirusComparisonExp>;
  _or?: InputMaybe<Array<ConfigStorageAntivirusComparisonExp>>;
  server?: InputMaybe<ConfigStringComparisonExp>;
};

export type ConfigStorageAntivirusInsertInput = {
  server?: InputMaybe<Scalars['String']>;
};

export type ConfigStorageAntivirusUpdateInput = {
  server?: InputMaybe<Scalars['String']>;
};

export type ConfigStorageComparisonExp = {
  _and?: InputMaybe<Array<ConfigStorageComparisonExp>>;
  _not?: InputMaybe<ConfigStorageComparisonExp>;
  _or?: InputMaybe<Array<ConfigStorageComparisonExp>>;
  antivirus?: InputMaybe<ConfigStorageAntivirusComparisonExp>;
  rateLimit?: InputMaybe<ConfigRateLimitComparisonExp>;
  resources?: InputMaybe<ConfigResourcesComparisonExp>;
  version?: InputMaybe<ConfigStringComparisonExp>;
};

export type ConfigStorageInsertInput = {
  antivirus?: InputMaybe<ConfigStorageAntivirusInsertInput>;
  rateLimit?: InputMaybe<ConfigRateLimitInsertInput>;
  resources?: InputMaybe<ConfigResourcesInsertInput>;
  version?: InputMaybe<Scalars['String']>;
};

export type ConfigStorageUpdateInput = {
  antivirus?: InputMaybe<ConfigStorageAntivirusUpdateInput>;
  rateLimit?: InputMaybe<ConfigRateLimitUpdateInput>;
  resources?: InputMaybe<ConfigResourcesUpdateInput>;
  version?: InputMaybe<Scalars['String']>;
};

export type ConfigStringComparisonExp = {
  _eq?: InputMaybe<Scalars['String']>;
  _in?: InputMaybe<Array<Scalars['String']>>;
  _neq?: InputMaybe<Scalars['String']>;
  _nin?: InputMaybe<Array<Scalars['String']>>;
};

export type ConfigSystemConfig = {
  __typename?: 'ConfigSystemConfig';
  auth?: Maybe<ConfigSystemConfigAuth>;
  graphql?: Maybe<ConfigSystemConfigGraphql>;
  postgres: ConfigSystemConfigPostgres;
};

export type ConfigSystemConfigAuth = {
  __typename?: 'ConfigSystemConfigAuth';
  email?: Maybe<ConfigSystemConfigAuthEmail>;
};

export type ConfigSystemConfigAuthComparisonExp = {
  _and?: InputMaybe<Array<ConfigSystemConfigAuthComparisonExp>>;
  _not?: InputMaybe<ConfigSystemConfigAuthComparisonExp>;
  _or?: InputMaybe<Array<ConfigSystemConfigAuthComparisonExp>>;
  email?: InputMaybe<ConfigSystemConfigAuthEmailComparisonExp>;
};

export type ConfigSystemConfigAuthEmail = {
  __typename?: 'ConfigSystemConfigAuthEmail';
  templates?: Maybe<ConfigSystemConfigAuthEmailTemplates>;
};

export type ConfigSystemConfigAuthEmailComparisonExp = {
  _and?: InputMaybe<Array<ConfigSystemConfigAuthEmailComparisonExp>>;
  _not?: InputMaybe<ConfigSystemConfigAuthEmailComparisonExp>;
  _or?: InputMaybe<Array<ConfigSystemConfigAuthEmailComparisonExp>>;
  templates?: InputMaybe<ConfigSystemConfigAuthEmailTemplatesComparisonExp>;
};

export type ConfigSystemConfigAuthEmailInsertInput = {
  templates?: InputMaybe<ConfigSystemConfigAuthEmailTemplatesInsertInput>;
};

export type ConfigSystemConfigAuthEmailTemplates = {
  __typename?: 'ConfigSystemConfigAuthEmailTemplates';
  s3Key?: Maybe<Scalars['String']>;
};

export type ConfigSystemConfigAuthEmailTemplatesComparisonExp = {
  _and?: InputMaybe<Array<ConfigSystemConfigAuthEmailTemplatesComparisonExp>>;
  _not?: InputMaybe<ConfigSystemConfigAuthEmailTemplatesComparisonExp>;
  _or?: InputMaybe<Array<ConfigSystemConfigAuthEmailTemplatesComparisonExp>>;
  s3Key?: InputMaybe<ConfigStringComparisonExp>;
};

export type ConfigSystemConfigAuthEmailTemplatesInsertInput = {
  s3Key?: InputMaybe<Scalars['String']>;
};

export type ConfigSystemConfigAuthEmailTemplatesUpdateInput = {
  s3Key?: InputMaybe<Scalars['String']>;
};

export type ConfigSystemConfigAuthEmailUpdateInput = {
  templates?: InputMaybe<ConfigSystemConfigAuthEmailTemplatesUpdateInput>;
};

export type ConfigSystemConfigAuthInsertInput = {
  email?: InputMaybe<ConfigSystemConfigAuthEmailInsertInput>;
};

export type ConfigSystemConfigAuthUpdateInput = {
  email?: InputMaybe<ConfigSystemConfigAuthEmailUpdateInput>;
};

export type ConfigSystemConfigComparisonExp = {
  _and?: InputMaybe<Array<ConfigSystemConfigComparisonExp>>;
  _not?: InputMaybe<ConfigSystemConfigComparisonExp>;
  _or?: InputMaybe<Array<ConfigSystemConfigComparisonExp>>;
  auth?: InputMaybe<ConfigSystemConfigAuthComparisonExp>;
  graphql?: InputMaybe<ConfigSystemConfigGraphqlComparisonExp>;
  postgres?: InputMaybe<ConfigSystemConfigPostgresComparisonExp>;
};

export type ConfigSystemConfigGraphql = {
  __typename?: 'ConfigSystemConfigGraphql';
  /**
   * manually enable graphi on a per-service basis
   * by default it follows the plan
   */
  featureAdvancedGraphql?: Maybe<Scalars['Boolean']>;
};

export type ConfigSystemConfigGraphqlComparisonExp = {
  _and?: InputMaybe<Array<ConfigSystemConfigGraphqlComparisonExp>>;
  _not?: InputMaybe<ConfigSystemConfigGraphqlComparisonExp>;
  _or?: InputMaybe<Array<ConfigSystemConfigGraphqlComparisonExp>>;
  featureAdvancedGraphql?: InputMaybe<ConfigBooleanComparisonExp>;
};

export type ConfigSystemConfigGraphqlInsertInput = {
  featureAdvancedGraphql?: InputMaybe<Scalars['Boolean']>;
};

export type ConfigSystemConfigGraphqlUpdateInput = {
  featureAdvancedGraphql?: InputMaybe<Scalars['Boolean']>;
};

export type ConfigSystemConfigInsertInput = {
  auth?: InputMaybe<ConfigSystemConfigAuthInsertInput>;
  graphql?: InputMaybe<ConfigSystemConfigGraphqlInsertInput>;
  postgres: ConfigSystemConfigPostgresInsertInput;
};

export type ConfigSystemConfigPostgres = {
  __typename?: 'ConfigSystemConfigPostgres';
  connectionString: ConfigSystemConfigPostgresConnectionString;
  database: Scalars['String'];
  disk?: Maybe<ConfigSystemConfigPostgresDisk>;
  enabled?: Maybe<Scalars['Boolean']>;
  majorVersion?: Maybe<Scalars['String']>;
};

export type ConfigSystemConfigPostgresComparisonExp = {
  _and?: InputMaybe<Array<ConfigSystemConfigPostgresComparisonExp>>;
  _not?: InputMaybe<ConfigSystemConfigPostgresComparisonExp>;
  _or?: InputMaybe<Array<ConfigSystemConfigPostgresComparisonExp>>;
  connectionString?: InputMaybe<ConfigSystemConfigPostgresConnectionStringComparisonExp>;
  database?: InputMaybe<ConfigStringComparisonExp>;
  disk?: InputMaybe<ConfigSystemConfigPostgresDiskComparisonExp>;
  enabled?: InputMaybe<ConfigBooleanComparisonExp>;
  majorVersion?: InputMaybe<ConfigStringComparisonExp>;
};

export type ConfigSystemConfigPostgresConnectionString = {
  __typename?: 'ConfigSystemConfigPostgresConnectionString';
  auth: Scalars['String'];
  backup: Scalars['String'];
  hasura: Scalars['String'];
  storage: Scalars['String'];
};

export type ConfigSystemConfigPostgresConnectionStringComparisonExp = {
  _and?: InputMaybe<Array<ConfigSystemConfigPostgresConnectionStringComparisonExp>>;
  _not?: InputMaybe<ConfigSystemConfigPostgresConnectionStringComparisonExp>;
  _or?: InputMaybe<Array<ConfigSystemConfigPostgresConnectionStringComparisonExp>>;
  auth?: InputMaybe<ConfigStringComparisonExp>;
  backup?: InputMaybe<ConfigStringComparisonExp>;
  hasura?: InputMaybe<ConfigStringComparisonExp>;
  storage?: InputMaybe<ConfigStringComparisonExp>;
};

export type ConfigSystemConfigPostgresConnectionStringInsertInput = {
  auth: Scalars['String'];
  backup: Scalars['String'];
  hasura: Scalars['String'];
  storage: Scalars['String'];
};

export type ConfigSystemConfigPostgresConnectionStringUpdateInput = {
  auth?: InputMaybe<Scalars['String']>;
  backup?: InputMaybe<Scalars['String']>;
  hasura?: InputMaybe<Scalars['String']>;
  storage?: InputMaybe<Scalars['String']>;
};

export type ConfigSystemConfigPostgresDisk = {
  __typename?: 'ConfigSystemConfigPostgresDisk';
  iops?: Maybe<Scalars['ConfigUint32']>;
  tput?: Maybe<Scalars['ConfigUint32']>;
};

export type ConfigSystemConfigPostgresDiskComparisonExp = {
  _and?: InputMaybe<Array<ConfigSystemConfigPostgresDiskComparisonExp>>;
  _not?: InputMaybe<ConfigSystemConfigPostgresDiskComparisonExp>;
  _or?: InputMaybe<Array<ConfigSystemConfigPostgresDiskComparisonExp>>;
  iops?: InputMaybe<ConfigUint32ComparisonExp>;
  tput?: InputMaybe<ConfigUint32ComparisonExp>;
};

export type ConfigSystemConfigPostgresDiskInsertInput = {
  iops?: InputMaybe<Scalars['ConfigUint32']>;
  tput?: InputMaybe<Scalars['ConfigUint32']>;
};

export type ConfigSystemConfigPostgresDiskUpdateInput = {
  iops?: InputMaybe<Scalars['ConfigUint32']>;
  tput?: InputMaybe<Scalars['ConfigUint32']>;
};

export type ConfigSystemConfigPostgresInsertInput = {
  connectionString: ConfigSystemConfigPostgresConnectionStringInsertInput;
  database: Scalars['String'];
  disk?: InputMaybe<ConfigSystemConfigPostgresDiskInsertInput>;
  enabled?: InputMaybe<Scalars['Boolean']>;
  majorVersion?: InputMaybe<Scalars['String']>;
};

export type ConfigSystemConfigPostgresUpdateInput = {
  connectionString?: InputMaybe<ConfigSystemConfigPostgresConnectionStringUpdateInput>;
  database?: InputMaybe<Scalars['String']>;
  disk?: InputMaybe<ConfigSystemConfigPostgresDiskUpdateInput>;
  enabled?: InputMaybe<Scalars['Boolean']>;
  majorVersion?: InputMaybe<Scalars['String']>;
};

export type ConfigSystemConfigUpdateInput = {
  auth?: InputMaybe<ConfigSystemConfigAuthUpdateInput>;
  graphql?: InputMaybe<ConfigSystemConfigGraphqlUpdateInput>;
  postgres?: InputMaybe<ConfigSystemConfigPostgresUpdateInput>;
};

export type ConfigUint8ComparisonExp = {
  _eq?: InputMaybe<Scalars['ConfigUint8']>;
  _in?: InputMaybe<Array<Scalars['ConfigUint8']>>;
  _neq?: InputMaybe<Scalars['ConfigUint8']>;
  _nin?: InputMaybe<Array<Scalars['ConfigUint8']>>;
};

export type ConfigUint32ComparisonExp = {
  _eq?: InputMaybe<Scalars['ConfigUint32']>;
  _in?: InputMaybe<Array<Scalars['ConfigUint32']>>;
  _neq?: InputMaybe<Scalars['ConfigUint32']>;
  _nin?: InputMaybe<Array<Scalars['ConfigUint32']>>;
};

export type ConfigUintComparisonExp = {
  _eq?: InputMaybe<Scalars['ConfigUint']>;
  _in?: InputMaybe<Array<Scalars['ConfigUint']>>;
  _neq?: InputMaybe<Scalars['ConfigUint']>;
  _nin?: InputMaybe<Array<Scalars['ConfigUint']>>;
};

export type ConfigUrlComparisonExp = {
  _eq?: InputMaybe<Scalars['ConfigUrl']>;
  _in?: InputMaybe<Array<Scalars['ConfigUrl']>>;
  _neq?: InputMaybe<Scalars['ConfigUrl']>;
  _nin?: InputMaybe<Array<Scalars['ConfigUrl']>>;
};

export type ConfigUserRoleComparisonExp = {
  _eq?: InputMaybe<Scalars['ConfigUserRole']>;
  _in?: InputMaybe<Array<Scalars['ConfigUserRole']>>;
  _neq?: InputMaybe<Scalars['ConfigUserRole']>;
  _nin?: InputMaybe<Array<Scalars['ConfigUserRole']>>;
};

export type ContainerError = {
  __typename?: 'ContainerError';
  lastError: LastError;
  name: Scalars['String'];
};

/** Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'. */
export type Int_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['Int']>;
  _gt?: InputMaybe<Scalars['Int']>;
  _gte?: InputMaybe<Scalars['Int']>;
  _in?: InputMaybe<Array<Scalars['Int']>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _lt?: InputMaybe<Scalars['Int']>;
  _lte?: InputMaybe<Scalars['Int']>;
  _neq?: InputMaybe<Scalars['Int']>;
  _nin?: InputMaybe<Array<Scalars['Int']>>;
};

export type InvoiceItem = {
  __typename?: 'InvoiceItem';
  Amount: Scalars['float64'];
  Description: Scalars['String'];
};

export type InvoiceSummary = {
  __typename?: 'InvoiceSummary';
  AmountDue: Scalars['float64'];
  PeriodEnd: Scalars['Timestamp'];
  items: Array<InvoiceItem>;
};

export type LastError = {
  __typename?: 'LastError';
  exitCode: Scalars['Int'];
  message: Scalars['String'];
  reason: Scalars['String'];
};

export type Log = {
  __typename?: 'Log';
  log: Scalars['String'];
  service: Scalars['String'];
  timestamp: Scalars['Timestamp'];
};

export type Metrics = {
  __typename?: 'Metrics';
  value: Scalars['float64'];
};

export type PostOrganizationRequestResponse = {
  __typename?: 'PostOrganizationRequestResponse';
  Slug: Scalars['String'];
  Status: CheckoutStatus;
};

export type ProjectStatusResponse = {
  __typename?: 'ProjectStatusResponse';
  services: Array<ServiceStatus>;
};

export type ReplicaStatus = {
  __typename?: 'ReplicaStatus';
  date: Scalars['Timestamp'];
  errors: Array<ContainerError>;
  ready: Scalars['Boolean'];
};

export enum ServiceState {
  Error = 'Error',
  None = 'None',
  Running = 'Running',
  UpdateError = 'UpdateError',
  Updating = 'Updating'
}

export type ServiceStatus = {
  __typename?: 'ServiceStatus';
  name: Scalars['String'];
  replicas: Array<ReplicaStatus>;
  state: ServiceState;
};

export type StatsLiveApps = {
  __typename?: 'StatsLiveApps';
  appID: Array<Scalars['uuid']>;
  count: Scalars['Int'];
};

/** Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'. */
export type String_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['String']>;
  _gt?: InputMaybe<Scalars['String']>;
  _gte?: InputMaybe<Scalars['String']>;
  /** does the column match the given case-insensitive pattern */
  _ilike?: InputMaybe<Scalars['String']>;
  _in?: InputMaybe<Array<Scalars['String']>>;
  /** does the column match the given POSIX regular expression, case insensitive */
  _iregex?: InputMaybe<Scalars['String']>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  /** does the column match the given pattern */
  _like?: InputMaybe<Scalars['String']>;
  _lt?: InputMaybe<Scalars['String']>;
  _lte?: InputMaybe<Scalars['String']>;
  _neq?: InputMaybe<Scalars['String']>;
  /** does the column NOT match the given case-insensitive pattern */
  _nilike?: InputMaybe<Scalars['String']>;
  _nin?: InputMaybe<Array<Scalars['String']>>;
  /** does the column NOT match the given POSIX regular expression, case insensitive */
  _niregex?: InputMaybe<Scalars['String']>;
  /** does the column NOT match the given pattern */
  _nlike?: InputMaybe<Scalars['String']>;
  /** does the column NOT match the given POSIX regular expression, case sensitive */
  _nregex?: InputMaybe<Scalars['String']>;
  /** does the column NOT match the given SQL regular expression */
  _nsimilar?: InputMaybe<Scalars['String']>;
  /** does the column match the given POSIX regular expression, case sensitive */
  _regex?: InputMaybe<Scalars['String']>;
  /** does the column match the given SQL regular expression */
  _similar?: InputMaybe<Scalars['String']>;
};

export type UsageSummary = {
  __typename?: 'UsageSummary';
  EgressBytes: Scalars['float64'];
  EgressCDNBytes: Scalars['float64'];
  EgressPgbouncerBytes: Scalars['float64'];
  LambdaUsageSeconds: Scalars['float64'];
  appID: Scalars['uuid'];
};

/** columns and relationships of "announcements" */
export type Announcements = {
  __typename?: 'announcements';
  content: Scalars['String'];
  createdAt: Scalars['timestamptz'];
  expiresAt?: Maybe<Scalars['timestamptz']>;
  href: Scalars['String'];
  id: Scalars['uuid'];
  updatedAt: Scalars['timestamptz'];
};

/** aggregated selection of "announcements" */
export type Announcements_Aggregate = {
  __typename?: 'announcements_aggregate';
  aggregate?: Maybe<Announcements_Aggregate_Fields>;
  nodes: Array<Announcements>;
};

/** aggregate fields of "announcements" */
export type Announcements_Aggregate_Fields = {
  __typename?: 'announcements_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Announcements_Max_Fields>;
  min?: Maybe<Announcements_Min_Fields>;
};


/** aggregate fields of "announcements" */
export type Announcements_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Announcements_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "announcements". All fields are combined with a logical 'AND'. */
export type Announcements_Bool_Exp = {
  _and?: InputMaybe<Array<Announcements_Bool_Exp>>;
  _not?: InputMaybe<Announcements_Bool_Exp>;
  _or?: InputMaybe<Array<Announcements_Bool_Exp>>;
  content?: InputMaybe<String_Comparison_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  expiresAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  href?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "announcements" */
export enum Announcements_Constraint {
  /** unique or primary key constraint on columns "id" */
  AnnouncementsPkey = 'announcements_pkey'
}

/** input type for inserting data into table "announcements" */
export type Announcements_Insert_Input = {
  content?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  expiresAt?: InputMaybe<Scalars['timestamptz']>;
  href?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Announcements_Max_Fields = {
  __typename?: 'announcements_max_fields';
  content?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  expiresAt?: Maybe<Scalars['timestamptz']>;
  href?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Announcements_Min_Fields = {
  __typename?: 'announcements_min_fields';
  content?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  expiresAt?: Maybe<Scalars['timestamptz']>;
  href?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "announcements" */
export type Announcements_Mutation_Response = {
  __typename?: 'announcements_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Announcements>;
};

/** on_conflict condition type for table "announcements" */
export type Announcements_On_Conflict = {
  constraint: Announcements_Constraint;
  update_columns?: Array<Announcements_Update_Column>;
  where?: InputMaybe<Announcements_Bool_Exp>;
};

/** Ordering options when selecting data from "announcements". */
export type Announcements_Order_By = {
  content?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  expiresAt?: InputMaybe<Order_By>;
  href?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
};

/** primary key columns input for table: announcements */
export type Announcements_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "announcements" */
export enum Announcements_Select_Column {
  /** column name */
  Content = 'content',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  ExpiresAt = 'expiresAt',
  /** column name */
  Href = 'href',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "announcements" */
export type Announcements_Set_Input = {
  content?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  expiresAt?: InputMaybe<Scalars['timestamptz']>;
  href?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** Streaming cursor of the table "announcements" */
export type Announcements_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Announcements_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Announcements_Stream_Cursor_Value_Input = {
  content?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  expiresAt?: InputMaybe<Scalars['timestamptz']>;
  href?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** update columns of table "announcements" */
export enum Announcements_Update_Column {
  /** column name */
  Content = 'content',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  ExpiresAt = 'expiresAt',
  /** column name */
  Href = 'href',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type Announcements_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Announcements_Set_Input>;
  /** filter the rows which have to be updated */
  where: Announcements_Bool_Exp;
};

/** columns and relationships of "app_state_history" */
export type AppStateHistory = {
  __typename?: 'appStateHistory';
  /** An object relationship */
  app: Apps;
  appId: Scalars['uuid'];
  /** An object relationship */
  appState: AppStates;
  createdAt: Scalars['timestamptz'];
  id: Scalars['uuid'];
  message?: Maybe<Scalars['String']>;
  stateId: Scalars['Int'];
};

/** aggregated selection of "app_state_history" */
export type AppStateHistory_Aggregate = {
  __typename?: 'appStateHistory_aggregate';
  aggregate?: Maybe<AppStateHistory_Aggregate_Fields>;
  nodes: Array<AppStateHistory>;
};

export type AppStateHistory_Aggregate_Bool_Exp = {
  count?: InputMaybe<AppStateHistory_Aggregate_Bool_Exp_Count>;
};

export type AppStateHistory_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<AppStateHistory_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<AppStateHistory_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "app_state_history" */
export type AppStateHistory_Aggregate_Fields = {
  __typename?: 'appStateHistory_aggregate_fields';
  avg?: Maybe<AppStateHistory_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<AppStateHistory_Max_Fields>;
  min?: Maybe<AppStateHistory_Min_Fields>;
  stddev?: Maybe<AppStateHistory_Stddev_Fields>;
  stddev_pop?: Maybe<AppStateHistory_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<AppStateHistory_Stddev_Samp_Fields>;
  sum?: Maybe<AppStateHistory_Sum_Fields>;
  var_pop?: Maybe<AppStateHistory_Var_Pop_Fields>;
  var_samp?: Maybe<AppStateHistory_Var_Samp_Fields>;
  variance?: Maybe<AppStateHistory_Variance_Fields>;
};


/** aggregate fields of "app_state_history" */
export type AppStateHistory_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<AppStateHistory_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "app_state_history" */
export type AppStateHistory_Aggregate_Order_By = {
  avg?: InputMaybe<AppStateHistory_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<AppStateHistory_Max_Order_By>;
  min?: InputMaybe<AppStateHistory_Min_Order_By>;
  stddev?: InputMaybe<AppStateHistory_Stddev_Order_By>;
  stddev_pop?: InputMaybe<AppStateHistory_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<AppStateHistory_Stddev_Samp_Order_By>;
  sum?: InputMaybe<AppStateHistory_Sum_Order_By>;
  var_pop?: InputMaybe<AppStateHistory_Var_Pop_Order_By>;
  var_samp?: InputMaybe<AppStateHistory_Var_Samp_Order_By>;
  variance?: InputMaybe<AppStateHistory_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "app_state_history" */
export type AppStateHistory_Arr_Rel_Insert_Input = {
  data: Array<AppStateHistory_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<AppStateHistory_On_Conflict>;
};

/** aggregate avg on columns */
export type AppStateHistory_Avg_Fields = {
  __typename?: 'appStateHistory_avg_fields';
  stateId?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "app_state_history" */
export type AppStateHistory_Avg_Order_By = {
  stateId?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "app_state_history". All fields are combined with a logical 'AND'. */
export type AppStateHistory_Bool_Exp = {
  _and?: InputMaybe<Array<AppStateHistory_Bool_Exp>>;
  _not?: InputMaybe<AppStateHistory_Bool_Exp>;
  _or?: InputMaybe<Array<AppStateHistory_Bool_Exp>>;
  app?: InputMaybe<Apps_Bool_Exp>;
  appId?: InputMaybe<Uuid_Comparison_Exp>;
  appState?: InputMaybe<AppStates_Bool_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  message?: InputMaybe<String_Comparison_Exp>;
  stateId?: InputMaybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "app_state_history" */
export enum AppStateHistory_Constraint {
  /** unique or primary key constraint on columns "id" */
  AppStateHistoryPkey = 'app_state_history_pkey'
}

/** input type for incrementing numeric columns in table "app_state_history" */
export type AppStateHistory_Inc_Input = {
  stateId?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "app_state_history" */
export type AppStateHistory_Insert_Input = {
  app?: InputMaybe<Apps_Obj_Rel_Insert_Input>;
  appId?: InputMaybe<Scalars['uuid']>;
  appState?: InputMaybe<AppStates_Obj_Rel_Insert_Input>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  message?: InputMaybe<Scalars['String']>;
  stateId?: InputMaybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type AppStateHistory_Max_Fields = {
  __typename?: 'appStateHistory_max_fields';
  appId?: Maybe<Scalars['uuid']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  message?: Maybe<Scalars['String']>;
  stateId?: Maybe<Scalars['Int']>;
};

/** order by max() on columns of table "app_state_history" */
export type AppStateHistory_Max_Order_By = {
  appId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  message?: InputMaybe<Order_By>;
  stateId?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type AppStateHistory_Min_Fields = {
  __typename?: 'appStateHistory_min_fields';
  appId?: Maybe<Scalars['uuid']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  message?: Maybe<Scalars['String']>;
  stateId?: Maybe<Scalars['Int']>;
};

/** order by min() on columns of table "app_state_history" */
export type AppStateHistory_Min_Order_By = {
  appId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  message?: InputMaybe<Order_By>;
  stateId?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "app_state_history" */
export type AppStateHistory_Mutation_Response = {
  __typename?: 'appStateHistory_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<AppStateHistory>;
};

/** on_conflict condition type for table "app_state_history" */
export type AppStateHistory_On_Conflict = {
  constraint: AppStateHistory_Constraint;
  update_columns?: Array<AppStateHistory_Update_Column>;
  where?: InputMaybe<AppStateHistory_Bool_Exp>;
};

/** Ordering options when selecting data from "app_state_history". */
export type AppStateHistory_Order_By = {
  app?: InputMaybe<Apps_Order_By>;
  appId?: InputMaybe<Order_By>;
  appState?: InputMaybe<AppStates_Order_By>;
  createdAt?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  message?: InputMaybe<Order_By>;
  stateId?: InputMaybe<Order_By>;
};

/** primary key columns input for table: app_state_history */
export type AppStateHistory_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "app_state_history" */
export enum AppStateHistory_Select_Column {
  /** column name */
  AppId = 'appId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  Message = 'message',
  /** column name */
  StateId = 'stateId'
}

/** input type for updating data in table "app_state_history" */
export type AppStateHistory_Set_Input = {
  appId?: InputMaybe<Scalars['uuid']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  message?: InputMaybe<Scalars['String']>;
  stateId?: InputMaybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type AppStateHistory_Stddev_Fields = {
  __typename?: 'appStateHistory_stddev_fields';
  stateId?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "app_state_history" */
export type AppStateHistory_Stddev_Order_By = {
  stateId?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type AppStateHistory_Stddev_Pop_Fields = {
  __typename?: 'appStateHistory_stddev_pop_fields';
  stateId?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "app_state_history" */
export type AppStateHistory_Stddev_Pop_Order_By = {
  stateId?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type AppStateHistory_Stddev_Samp_Fields = {
  __typename?: 'appStateHistory_stddev_samp_fields';
  stateId?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "app_state_history" */
export type AppStateHistory_Stddev_Samp_Order_By = {
  stateId?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "appStateHistory" */
export type AppStateHistory_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: AppStateHistory_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type AppStateHistory_Stream_Cursor_Value_Input = {
  appId?: InputMaybe<Scalars['uuid']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  message?: InputMaybe<Scalars['String']>;
  stateId?: InputMaybe<Scalars['Int']>;
};

/** aggregate sum on columns */
export type AppStateHistory_Sum_Fields = {
  __typename?: 'appStateHistory_sum_fields';
  stateId?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "app_state_history" */
export type AppStateHistory_Sum_Order_By = {
  stateId?: InputMaybe<Order_By>;
};

/** update columns of table "app_state_history" */
export enum AppStateHistory_Update_Column {
  /** column name */
  AppId = 'appId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  Message = 'message',
  /** column name */
  StateId = 'stateId'
}

export type AppStateHistory_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<AppStateHistory_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<AppStateHistory_Set_Input>;
  /** filter the rows which have to be updated */
  where: AppStateHistory_Bool_Exp;
};

/** aggregate var_pop on columns */
export type AppStateHistory_Var_Pop_Fields = {
  __typename?: 'appStateHistory_var_pop_fields';
  stateId?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "app_state_history" */
export type AppStateHistory_Var_Pop_Order_By = {
  stateId?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type AppStateHistory_Var_Samp_Fields = {
  __typename?: 'appStateHistory_var_samp_fields';
  stateId?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "app_state_history" */
export type AppStateHistory_Var_Samp_Order_By = {
  stateId?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type AppStateHistory_Variance_Fields = {
  __typename?: 'appStateHistory_variance_fields';
  stateId?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "app_state_history" */
export type AppStateHistory_Variance_Order_By = {
  stateId?: InputMaybe<Order_By>;
};

/** columns and relationships of "app_states" */
export type AppStates = {
  __typename?: 'appStates';
  /** An array relationship */
  appStates: Array<AppStateHistory>;
  /** An aggregate relationship */
  appStates_aggregate: AppStateHistory_Aggregate;
  /** An array relationship */
  apps: Array<Apps>;
  /** An aggregate relationship */
  apps_aggregate: Apps_Aggregate;
  id: Scalars['Int'];
  name: Scalars['String'];
};


/** columns and relationships of "app_states" */
export type AppStatesAppStatesArgs = {
  distinct_on?: InputMaybe<Array<AppStateHistory_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<AppStateHistory_Order_By>>;
  where?: InputMaybe<AppStateHistory_Bool_Exp>;
};


/** columns and relationships of "app_states" */
export type AppStatesAppStates_AggregateArgs = {
  distinct_on?: InputMaybe<Array<AppStateHistory_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<AppStateHistory_Order_By>>;
  where?: InputMaybe<AppStateHistory_Bool_Exp>;
};


/** columns and relationships of "app_states" */
export type AppStatesAppsArgs = {
  distinct_on?: InputMaybe<Array<Apps_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Apps_Order_By>>;
  where?: InputMaybe<Apps_Bool_Exp>;
};


/** columns and relationships of "app_states" */
export type AppStatesApps_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Apps_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Apps_Order_By>>;
  where?: InputMaybe<Apps_Bool_Exp>;
};

/** aggregated selection of "app_states" */
export type AppStates_Aggregate = {
  __typename?: 'appStates_aggregate';
  aggregate?: Maybe<AppStates_Aggregate_Fields>;
  nodes: Array<AppStates>;
};

/** aggregate fields of "app_states" */
export type AppStates_Aggregate_Fields = {
  __typename?: 'appStates_aggregate_fields';
  avg?: Maybe<AppStates_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<AppStates_Max_Fields>;
  min?: Maybe<AppStates_Min_Fields>;
  stddev?: Maybe<AppStates_Stddev_Fields>;
  stddev_pop?: Maybe<AppStates_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<AppStates_Stddev_Samp_Fields>;
  sum?: Maybe<AppStates_Sum_Fields>;
  var_pop?: Maybe<AppStates_Var_Pop_Fields>;
  var_samp?: Maybe<AppStates_Var_Samp_Fields>;
  variance?: Maybe<AppStates_Variance_Fields>;
};


/** aggregate fields of "app_states" */
export type AppStates_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<AppStates_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type AppStates_Avg_Fields = {
  __typename?: 'appStates_avg_fields';
  id?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "app_states". All fields are combined with a logical 'AND'. */
export type AppStates_Bool_Exp = {
  _and?: InputMaybe<Array<AppStates_Bool_Exp>>;
  _not?: InputMaybe<AppStates_Bool_Exp>;
  _or?: InputMaybe<Array<AppStates_Bool_Exp>>;
  appStates?: InputMaybe<AppStateHistory_Bool_Exp>;
  appStates_aggregate?: InputMaybe<AppStateHistory_Aggregate_Bool_Exp>;
  apps?: InputMaybe<Apps_Bool_Exp>;
  apps_aggregate?: InputMaybe<Apps_Aggregate_Bool_Exp>;
  id?: InputMaybe<Int_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "app_states" */
export enum AppStates_Constraint {
  /** unique or primary key constraint on columns "name" */
  AppStatesNameKey = 'app_states_name_key',
  /** unique or primary key constraint on columns "id" */
  AppStatesPkey = 'app_states_pkey'
}

/** input type for incrementing numeric columns in table "app_states" */
export type AppStates_Inc_Input = {
  id?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "app_states" */
export type AppStates_Insert_Input = {
  appStates?: InputMaybe<AppStateHistory_Arr_Rel_Insert_Input>;
  apps?: InputMaybe<Apps_Arr_Rel_Insert_Input>;
  id?: InputMaybe<Scalars['Int']>;
  name?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type AppStates_Max_Fields = {
  __typename?: 'appStates_max_fields';
  id?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type AppStates_Min_Fields = {
  __typename?: 'appStates_min_fields';
  id?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "app_states" */
export type AppStates_Mutation_Response = {
  __typename?: 'appStates_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<AppStates>;
};

/** input type for inserting object relation for remote table "app_states" */
export type AppStates_Obj_Rel_Insert_Input = {
  data: AppStates_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<AppStates_On_Conflict>;
};

/** on_conflict condition type for table "app_states" */
export type AppStates_On_Conflict = {
  constraint: AppStates_Constraint;
  update_columns?: Array<AppStates_Update_Column>;
  where?: InputMaybe<AppStates_Bool_Exp>;
};

/** Ordering options when selecting data from "app_states". */
export type AppStates_Order_By = {
  appStates_aggregate?: InputMaybe<AppStateHistory_Aggregate_Order_By>;
  apps_aggregate?: InputMaybe<Apps_Aggregate_Order_By>;
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
};

/** primary key columns input for table: app_states */
export type AppStates_Pk_Columns_Input = {
  id: Scalars['Int'];
};

/** select columns of table "app_states" */
export enum AppStates_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "app_states" */
export type AppStates_Set_Input = {
  id?: InputMaybe<Scalars['Int']>;
  name?: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type AppStates_Stddev_Fields = {
  __typename?: 'appStates_stddev_fields';
  id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type AppStates_Stddev_Pop_Fields = {
  __typename?: 'appStates_stddev_pop_fields';
  id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type AppStates_Stddev_Samp_Fields = {
  __typename?: 'appStates_stddev_samp_fields';
  id?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "appStates" */
export type AppStates_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: AppStates_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type AppStates_Stream_Cursor_Value_Input = {
  id?: InputMaybe<Scalars['Int']>;
  name?: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type AppStates_Sum_Fields = {
  __typename?: 'appStates_sum_fields';
  id?: Maybe<Scalars['Int']>;
};

/** update columns of table "app_states" */
export enum AppStates_Update_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name'
}

export type AppStates_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<AppStates_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<AppStates_Set_Input>;
  /** filter the rows which have to be updated */
  where: AppStates_Bool_Exp;
};

/** aggregate var_pop on columns */
export type AppStates_Var_Pop_Fields = {
  __typename?: 'appStates_var_pop_fields';
  id?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type AppStates_Var_Samp_Fields = {
  __typename?: 'appStates_var_samp_fields';
  id?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type AppStates_Variance_Fields = {
  __typename?: 'appStates_variance_fields';
  id?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "apps" */
export type Apps = {
  __typename?: 'apps';
  appSecrets: Array<ConfigEnvironmentVariable>;
  /** An array relationship */
  appStates: Array<AppStateHistory>;
  /** An aggregate relationship */
  appStates_aggregate: AppStateHistory_Aggregate;
  /** An array relationship */
  backups: Array<Backups>;
  /** An aggregate relationship */
  backups_aggregate: Backups_Aggregate;
  /** An object relationship */
  billingDedicatedCompute?: Maybe<Billing_Dedicated_Compute>;
  /** An object relationship */
  billingDedicatedComputeReports?: Maybe<Billing_Dedicated_Compute_Reports>;
  /** An object relationship */
  billingSubscriptions?: Maybe<Billing_Subscriptions>;
  config?: Maybe<ConfigConfig>;
  createdAt: Scalars['timestamptz'];
  /** An object relationship */
  creator?: Maybe<Users>;
  creatorUserId?: Maybe<Scalars['uuid']>;
  currentState?: Maybe<Scalars['Int']>;
  /** An array relationship */
  deployments: Array<Deployments>;
  /** An aggregate relationship */
  deployments_aggregate: Deployments_Aggregate;
  /** An object relationship */
  desiredAppState: AppStates;
  desiredState: Scalars['Int'];
  /** An array relationship */
  featureFlags: Array<FeatureFlags>;
  /** An aggregate relationship */
  featureFlags_aggregate: FeatureFlags_Aggregate;
  /** An object relationship */
  githubRepository?: Maybe<GithubRepositories>;
  githubRepositoryId?: Maybe<Scalars['uuid']>;
  id: Scalars['uuid'];
  isLocked?: Maybe<Scalars['Boolean']>;
  isLockedReason?: Maybe<Scalars['String']>;
  /** An object relationship */
  legacyPlan?: Maybe<Plans>;
  legacyPlanID?: Maybe<Scalars['uuid']>;
  legacyStripeSubscriptionId?: Maybe<Scalars['String']>;
  metadataFunctions: Scalars['jsonb'];
  mimirConfigEnc?: Maybe<Scalars['String']>;
  mimirSecretsEnc?: Maybe<Scalars['String']>;
  mimirSystemConfigEnc?: Maybe<Scalars['String']>;
  name: Scalars['String'];
  nhostBaseFolder: Scalars['String'];
  /** An object relationship */
  organization?: Maybe<Organizations>;
  organizationID?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  region: Regions;
  regionId: Scalars['uuid'];
  repositoryProductionBranch: Scalars['String'];
  /** An array relationship */
  runServices: Array<Run_Service>;
  /** An aggregate relationship */
  runServices_aggregate: Run_Service_Aggregate;
  slug: Scalars['String'];
  stateMatch?: Maybe<Scalars['Boolean']>;
  subdomain: Scalars['String'];
  systemConfig?: Maybe<ConfigSystemConfig>;
  updatedAt: Scalars['timestamptz'];
  /** An object relationship */
  workspace?: Maybe<Workspaces>;
  workspaceId?: Maybe<Scalars['uuid']>;
};


/** columns and relationships of "apps" */
export type AppsAppStatesArgs = {
  distinct_on?: InputMaybe<Array<AppStateHistory_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<AppStateHistory_Order_By>>;
  where?: InputMaybe<AppStateHistory_Bool_Exp>;
};


/** columns and relationships of "apps" */
export type AppsAppStates_AggregateArgs = {
  distinct_on?: InputMaybe<Array<AppStateHistory_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<AppStateHistory_Order_By>>;
  where?: InputMaybe<AppStateHistory_Bool_Exp>;
};


/** columns and relationships of "apps" */
export type AppsBackupsArgs = {
  distinct_on?: InputMaybe<Array<Backups_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Backups_Order_By>>;
  where?: InputMaybe<Backups_Bool_Exp>;
};


/** columns and relationships of "apps" */
export type AppsBackups_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Backups_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Backups_Order_By>>;
  where?: InputMaybe<Backups_Bool_Exp>;
};


/** columns and relationships of "apps" */
export type AppsConfigArgs = {
  resolve: Scalars['Boolean'];
};


/** columns and relationships of "apps" */
export type AppsDeploymentsArgs = {
  distinct_on?: InputMaybe<Array<Deployments_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Deployments_Order_By>>;
  where?: InputMaybe<Deployments_Bool_Exp>;
};


/** columns and relationships of "apps" */
export type AppsDeployments_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Deployments_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Deployments_Order_By>>;
  where?: InputMaybe<Deployments_Bool_Exp>;
};


/** columns and relationships of "apps" */
export type AppsFeatureFlagsArgs = {
  distinct_on?: InputMaybe<Array<FeatureFlags_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<FeatureFlags_Order_By>>;
  where?: InputMaybe<FeatureFlags_Bool_Exp>;
};


/** columns and relationships of "apps" */
export type AppsFeatureFlags_AggregateArgs = {
  distinct_on?: InputMaybe<Array<FeatureFlags_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<FeatureFlags_Order_By>>;
  where?: InputMaybe<FeatureFlags_Bool_Exp>;
};


/** columns and relationships of "apps" */
export type AppsMetadataFunctionsArgs = {
  path?: InputMaybe<Scalars['String']>;
};


/** columns and relationships of "apps" */
export type AppsRunServicesArgs = {
  distinct_on?: InputMaybe<Array<Run_Service_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Run_Service_Order_By>>;
  where?: InputMaybe<Run_Service_Bool_Exp>;
};


/** columns and relationships of "apps" */
export type AppsRunServices_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Run_Service_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Run_Service_Order_By>>;
  where?: InputMaybe<Run_Service_Bool_Exp>;
};

/** aggregated selection of "apps" */
export type Apps_Aggregate = {
  __typename?: 'apps_aggregate';
  aggregate?: Maybe<Apps_Aggregate_Fields>;
  nodes: Array<Apps>;
};

export type Apps_Aggregate_Bool_Exp = {
  bool_and?: InputMaybe<Apps_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: InputMaybe<Apps_Aggregate_Bool_Exp_Bool_Or>;
  count?: InputMaybe<Apps_Aggregate_Bool_Exp_Count>;
};

export type Apps_Aggregate_Bool_Exp_Bool_And = {
  arguments: Apps_Select_Column_Apps_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<Apps_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Apps_Aggregate_Bool_Exp_Bool_Or = {
  arguments: Apps_Select_Column_Apps_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<Apps_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Apps_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Apps_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<Apps_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "apps" */
export type Apps_Aggregate_Fields = {
  __typename?: 'apps_aggregate_fields';
  avg?: Maybe<Apps_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Apps_Max_Fields>;
  min?: Maybe<Apps_Min_Fields>;
  stddev?: Maybe<Apps_Stddev_Fields>;
  stddev_pop?: Maybe<Apps_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Apps_Stddev_Samp_Fields>;
  sum?: Maybe<Apps_Sum_Fields>;
  var_pop?: Maybe<Apps_Var_Pop_Fields>;
  var_samp?: Maybe<Apps_Var_Samp_Fields>;
  variance?: Maybe<Apps_Variance_Fields>;
};


/** aggregate fields of "apps" */
export type Apps_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Apps_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "apps" */
export type Apps_Aggregate_Order_By = {
  avg?: InputMaybe<Apps_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Apps_Max_Order_By>;
  min?: InputMaybe<Apps_Min_Order_By>;
  stddev?: InputMaybe<Apps_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Apps_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Apps_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Apps_Sum_Order_By>;
  var_pop?: InputMaybe<Apps_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Apps_Var_Samp_Order_By>;
  variance?: InputMaybe<Apps_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Apps_Append_Input = {
  metadataFunctions?: InputMaybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "apps" */
export type Apps_Arr_Rel_Insert_Input = {
  data: Array<Apps_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Apps_On_Conflict>;
};

/** aggregate avg on columns */
export type Apps_Avg_Fields = {
  __typename?: 'apps_avg_fields';
  currentState?: Maybe<Scalars['Float']>;
  desiredState?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "apps" */
export type Apps_Avg_Order_By = {
  currentState?: InputMaybe<Order_By>;
  desiredState?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "apps". All fields are combined with a logical 'AND'. */
export type Apps_Bool_Exp = {
  _and?: InputMaybe<Array<Apps_Bool_Exp>>;
  _not?: InputMaybe<Apps_Bool_Exp>;
  _or?: InputMaybe<Array<Apps_Bool_Exp>>;
  appStates?: InputMaybe<AppStateHistory_Bool_Exp>;
  appStates_aggregate?: InputMaybe<AppStateHistory_Aggregate_Bool_Exp>;
  backups?: InputMaybe<Backups_Bool_Exp>;
  backups_aggregate?: InputMaybe<Backups_Aggregate_Bool_Exp>;
  billingDedicatedCompute?: InputMaybe<Billing_Dedicated_Compute_Bool_Exp>;
  billingDedicatedComputeReports?: InputMaybe<Billing_Dedicated_Compute_Reports_Bool_Exp>;
  billingSubscriptions?: InputMaybe<Billing_Subscriptions_Bool_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  creator?: InputMaybe<Users_Bool_Exp>;
  creatorUserId?: InputMaybe<Uuid_Comparison_Exp>;
  currentState?: InputMaybe<Int_Comparison_Exp>;
  deployments?: InputMaybe<Deployments_Bool_Exp>;
  deployments_aggregate?: InputMaybe<Deployments_Aggregate_Bool_Exp>;
  desiredAppState?: InputMaybe<AppStates_Bool_Exp>;
  desiredState?: InputMaybe<Int_Comparison_Exp>;
  featureFlags?: InputMaybe<FeatureFlags_Bool_Exp>;
  featureFlags_aggregate?: InputMaybe<FeatureFlags_Aggregate_Bool_Exp>;
  githubRepository?: InputMaybe<GithubRepositories_Bool_Exp>;
  githubRepositoryId?: InputMaybe<Uuid_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  isLocked?: InputMaybe<Boolean_Comparison_Exp>;
  isLockedReason?: InputMaybe<String_Comparison_Exp>;
  legacyPlan?: InputMaybe<Plans_Bool_Exp>;
  legacyPlanID?: InputMaybe<Uuid_Comparison_Exp>;
  legacyStripeSubscriptionId?: InputMaybe<String_Comparison_Exp>;
  metadataFunctions?: InputMaybe<Jsonb_Comparison_Exp>;
  mimirConfigEnc?: InputMaybe<String_Comparison_Exp>;
  mimirSecretsEnc?: InputMaybe<String_Comparison_Exp>;
  mimirSystemConfigEnc?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  nhostBaseFolder?: InputMaybe<String_Comparison_Exp>;
  organization?: InputMaybe<Organizations_Bool_Exp>;
  organizationID?: InputMaybe<Uuid_Comparison_Exp>;
  region?: InputMaybe<Regions_Bool_Exp>;
  regionId?: InputMaybe<Uuid_Comparison_Exp>;
  repositoryProductionBranch?: InputMaybe<String_Comparison_Exp>;
  runServices?: InputMaybe<Run_Service_Bool_Exp>;
  runServices_aggregate?: InputMaybe<Run_Service_Aggregate_Bool_Exp>;
  slug?: InputMaybe<String_Comparison_Exp>;
  stateMatch?: InputMaybe<Boolean_Comparison_Exp>;
  subdomain?: InputMaybe<String_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  workspace?: InputMaybe<Workspaces_Bool_Exp>;
  workspaceId?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "apps" */
export enum Apps_Constraint {
  /** unique or primary key constraint on columns "id" */
  AppsPkey = 'apps_pkey',
  /** unique or primary key constraint on columns "subdomain" */
  AppsSubdomainKey = 'apps_subdomain_key',
  /** unique or primary key constraint on columns "workspace_id", "slug" */
  AppsWorkspaceIdSlugKey = 'apps_workspace_id_slug_key'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Apps_Delete_At_Path_Input = {
  metadataFunctions?: InputMaybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Apps_Delete_Elem_Input = {
  metadataFunctions?: InputMaybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Apps_Delete_Key_Input = {
  metadataFunctions?: InputMaybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "apps" */
export type Apps_Inc_Input = {
  currentState?: InputMaybe<Scalars['Int']>;
  desiredState?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "apps" */
export type Apps_Insert_Input = {
  appStates?: InputMaybe<AppStateHistory_Arr_Rel_Insert_Input>;
  backups?: InputMaybe<Backups_Arr_Rel_Insert_Input>;
  billingDedicatedCompute?: InputMaybe<Billing_Dedicated_Compute_Obj_Rel_Insert_Input>;
  billingDedicatedComputeReports?: InputMaybe<Billing_Dedicated_Compute_Reports_Obj_Rel_Insert_Input>;
  billingSubscriptions?: InputMaybe<Billing_Subscriptions_Obj_Rel_Insert_Input>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  creator?: InputMaybe<Users_Obj_Rel_Insert_Input>;
  creatorUserId?: InputMaybe<Scalars['uuid']>;
  currentState?: InputMaybe<Scalars['Int']>;
  deployments?: InputMaybe<Deployments_Arr_Rel_Insert_Input>;
  desiredAppState?: InputMaybe<AppStates_Obj_Rel_Insert_Input>;
  desiredState?: InputMaybe<Scalars['Int']>;
  featureFlags?: InputMaybe<FeatureFlags_Arr_Rel_Insert_Input>;
  githubRepository?: InputMaybe<GithubRepositories_Obj_Rel_Insert_Input>;
  githubRepositoryId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  isLocked?: InputMaybe<Scalars['Boolean']>;
  isLockedReason?: InputMaybe<Scalars['String']>;
  legacyPlan?: InputMaybe<Plans_Obj_Rel_Insert_Input>;
  legacyPlanID?: InputMaybe<Scalars['uuid']>;
  legacyStripeSubscriptionId?: InputMaybe<Scalars['String']>;
  metadataFunctions?: InputMaybe<Scalars['jsonb']>;
  mimirConfigEnc?: InputMaybe<Scalars['String']>;
  mimirSecretsEnc?: InputMaybe<Scalars['String']>;
  mimirSystemConfigEnc?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
  nhostBaseFolder?: InputMaybe<Scalars['String']>;
  organization?: InputMaybe<Organizations_Obj_Rel_Insert_Input>;
  organizationID?: InputMaybe<Scalars['uuid']>;
  region?: InputMaybe<Regions_Obj_Rel_Insert_Input>;
  regionId?: InputMaybe<Scalars['uuid']>;
  repositoryProductionBranch?: InputMaybe<Scalars['String']>;
  runServices?: InputMaybe<Run_Service_Arr_Rel_Insert_Input>;
  slug?: InputMaybe<Scalars['String']>;
  subdomain?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  workspace?: InputMaybe<Workspaces_Obj_Rel_Insert_Input>;
  workspaceId?: InputMaybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type Apps_Max_Fields = {
  __typename?: 'apps_max_fields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  creatorUserId?: Maybe<Scalars['uuid']>;
  currentState?: Maybe<Scalars['Int']>;
  desiredState?: Maybe<Scalars['Int']>;
  githubRepositoryId?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  isLockedReason?: Maybe<Scalars['String']>;
  legacyPlanID?: Maybe<Scalars['uuid']>;
  legacyStripeSubscriptionId?: Maybe<Scalars['String']>;
  mimirConfigEnc?: Maybe<Scalars['String']>;
  mimirSecretsEnc?: Maybe<Scalars['String']>;
  mimirSystemConfigEnc?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  nhostBaseFolder?: Maybe<Scalars['String']>;
  organizationID?: Maybe<Scalars['uuid']>;
  regionId?: Maybe<Scalars['uuid']>;
  repositoryProductionBranch?: Maybe<Scalars['String']>;
  slug?: Maybe<Scalars['String']>;
  subdomain?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  workspaceId?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "apps" */
export type Apps_Max_Order_By = {
  createdAt?: InputMaybe<Order_By>;
  creatorUserId?: InputMaybe<Order_By>;
  currentState?: InputMaybe<Order_By>;
  desiredState?: InputMaybe<Order_By>;
  githubRepositoryId?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  isLockedReason?: InputMaybe<Order_By>;
  legacyPlanID?: InputMaybe<Order_By>;
  legacyStripeSubscriptionId?: InputMaybe<Order_By>;
  mimirConfigEnc?: InputMaybe<Order_By>;
  mimirSecretsEnc?: InputMaybe<Order_By>;
  mimirSystemConfigEnc?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  nhostBaseFolder?: InputMaybe<Order_By>;
  organizationID?: InputMaybe<Order_By>;
  regionId?: InputMaybe<Order_By>;
  repositoryProductionBranch?: InputMaybe<Order_By>;
  slug?: InputMaybe<Order_By>;
  subdomain?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  workspaceId?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Apps_Min_Fields = {
  __typename?: 'apps_min_fields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  creatorUserId?: Maybe<Scalars['uuid']>;
  currentState?: Maybe<Scalars['Int']>;
  desiredState?: Maybe<Scalars['Int']>;
  githubRepositoryId?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  isLockedReason?: Maybe<Scalars['String']>;
  legacyPlanID?: Maybe<Scalars['uuid']>;
  legacyStripeSubscriptionId?: Maybe<Scalars['String']>;
  mimirConfigEnc?: Maybe<Scalars['String']>;
  mimirSecretsEnc?: Maybe<Scalars['String']>;
  mimirSystemConfigEnc?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  nhostBaseFolder?: Maybe<Scalars['String']>;
  organizationID?: Maybe<Scalars['uuid']>;
  regionId?: Maybe<Scalars['uuid']>;
  repositoryProductionBranch?: Maybe<Scalars['String']>;
  slug?: Maybe<Scalars['String']>;
  subdomain?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  workspaceId?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "apps" */
export type Apps_Min_Order_By = {
  createdAt?: InputMaybe<Order_By>;
  creatorUserId?: InputMaybe<Order_By>;
  currentState?: InputMaybe<Order_By>;
  desiredState?: InputMaybe<Order_By>;
  githubRepositoryId?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  isLockedReason?: InputMaybe<Order_By>;
  legacyPlanID?: InputMaybe<Order_By>;
  legacyStripeSubscriptionId?: InputMaybe<Order_By>;
  mimirConfigEnc?: InputMaybe<Order_By>;
  mimirSecretsEnc?: InputMaybe<Order_By>;
  mimirSystemConfigEnc?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  nhostBaseFolder?: InputMaybe<Order_By>;
  organizationID?: InputMaybe<Order_By>;
  regionId?: InputMaybe<Order_By>;
  repositoryProductionBranch?: InputMaybe<Order_By>;
  slug?: InputMaybe<Order_By>;
  subdomain?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  workspaceId?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "apps" */
export type Apps_Mutation_Response = {
  __typename?: 'apps_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Apps>;
};

/** input type for inserting object relation for remote table "apps" */
export type Apps_Obj_Rel_Insert_Input = {
  data: Apps_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Apps_On_Conflict>;
};

/** on_conflict condition type for table "apps" */
export type Apps_On_Conflict = {
  constraint: Apps_Constraint;
  update_columns?: Array<Apps_Update_Column>;
  where?: InputMaybe<Apps_Bool_Exp>;
};

/** Ordering options when selecting data from "apps". */
export type Apps_Order_By = {
  appStates_aggregate?: InputMaybe<AppStateHistory_Aggregate_Order_By>;
  backups_aggregate?: InputMaybe<Backups_Aggregate_Order_By>;
  billingDedicatedCompute?: InputMaybe<Billing_Dedicated_Compute_Order_By>;
  billingDedicatedComputeReports?: InputMaybe<Billing_Dedicated_Compute_Reports_Order_By>;
  billingSubscriptions?: InputMaybe<Billing_Subscriptions_Order_By>;
  createdAt?: InputMaybe<Order_By>;
  creator?: InputMaybe<Users_Order_By>;
  creatorUserId?: InputMaybe<Order_By>;
  currentState?: InputMaybe<Order_By>;
  deployments_aggregate?: InputMaybe<Deployments_Aggregate_Order_By>;
  desiredAppState?: InputMaybe<AppStates_Order_By>;
  desiredState?: InputMaybe<Order_By>;
  featureFlags_aggregate?: InputMaybe<FeatureFlags_Aggregate_Order_By>;
  githubRepository?: InputMaybe<GithubRepositories_Order_By>;
  githubRepositoryId?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  isLocked?: InputMaybe<Order_By>;
  isLockedReason?: InputMaybe<Order_By>;
  legacyPlan?: InputMaybe<Plans_Order_By>;
  legacyPlanID?: InputMaybe<Order_By>;
  legacyStripeSubscriptionId?: InputMaybe<Order_By>;
  metadataFunctions?: InputMaybe<Order_By>;
  mimirConfigEnc?: InputMaybe<Order_By>;
  mimirSecretsEnc?: InputMaybe<Order_By>;
  mimirSystemConfigEnc?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  nhostBaseFolder?: InputMaybe<Order_By>;
  organization?: InputMaybe<Organizations_Order_By>;
  organizationID?: InputMaybe<Order_By>;
  region?: InputMaybe<Regions_Order_By>;
  regionId?: InputMaybe<Order_By>;
  repositoryProductionBranch?: InputMaybe<Order_By>;
  runServices_aggregate?: InputMaybe<Run_Service_Aggregate_Order_By>;
  slug?: InputMaybe<Order_By>;
  stateMatch?: InputMaybe<Order_By>;
  subdomain?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  workspace?: InputMaybe<Workspaces_Order_By>;
  workspaceId?: InputMaybe<Order_By>;
};

/** primary key columns input for table: apps */
export type Apps_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Apps_Prepend_Input = {
  metadataFunctions?: InputMaybe<Scalars['jsonb']>;
};

/** select columns of table "apps" */
export enum Apps_Select_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatorUserId = 'creatorUserId',
  /** column name */
  CurrentState = 'currentState',
  /** column name */
  DesiredState = 'desiredState',
  /** column name */
  GithubRepositoryId = 'githubRepositoryId',
  /** column name */
  Id = 'id',
  /** column name */
  IsLocked = 'isLocked',
  /** column name */
  IsLockedReason = 'isLockedReason',
  /** column name */
  LegacyPlanId = 'legacyPlanID',
  /** column name */
  LegacyStripeSubscriptionId = 'legacyStripeSubscriptionId',
  /** column name */
  MetadataFunctions = 'metadataFunctions',
  /** column name */
  MimirConfigEnc = 'mimirConfigEnc',
  /** column name */
  MimirSecretsEnc = 'mimirSecretsEnc',
  /** column name */
  MimirSystemConfigEnc = 'mimirSystemConfigEnc',
  /** column name */
  Name = 'name',
  /** column name */
  NhostBaseFolder = 'nhostBaseFolder',
  /** column name */
  OrganizationId = 'organizationID',
  /** column name */
  RegionId = 'regionId',
  /** column name */
  RepositoryProductionBranch = 'repositoryProductionBranch',
  /** column name */
  Slug = 'slug',
  /** column name */
  StateMatch = 'stateMatch',
  /** column name */
  Subdomain = 'subdomain',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  WorkspaceId = 'workspaceId'
}

/** select "apps_aggregate_bool_exp_bool_and_arguments_columns" columns of table "apps" */
export enum Apps_Select_Column_Apps_Aggregate_Bool_Exp_Bool_And_Arguments_Columns {
  /** column name */
  IsLocked = 'isLocked',
  /** column name */
  StateMatch = 'stateMatch'
}

/** select "apps_aggregate_bool_exp_bool_or_arguments_columns" columns of table "apps" */
export enum Apps_Select_Column_Apps_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns {
  /** column name */
  IsLocked = 'isLocked',
  /** column name */
  StateMatch = 'stateMatch'
}

/** input type for updating data in table "apps" */
export type Apps_Set_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  creatorUserId?: InputMaybe<Scalars['uuid']>;
  currentState?: InputMaybe<Scalars['Int']>;
  desiredState?: InputMaybe<Scalars['Int']>;
  githubRepositoryId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  isLocked?: InputMaybe<Scalars['Boolean']>;
  isLockedReason?: InputMaybe<Scalars['String']>;
  legacyPlanID?: InputMaybe<Scalars['uuid']>;
  legacyStripeSubscriptionId?: InputMaybe<Scalars['String']>;
  metadataFunctions?: InputMaybe<Scalars['jsonb']>;
  mimirConfigEnc?: InputMaybe<Scalars['String']>;
  mimirSecretsEnc?: InputMaybe<Scalars['String']>;
  mimirSystemConfigEnc?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
  nhostBaseFolder?: InputMaybe<Scalars['String']>;
  organizationID?: InputMaybe<Scalars['uuid']>;
  regionId?: InputMaybe<Scalars['uuid']>;
  repositoryProductionBranch?: InputMaybe<Scalars['String']>;
  slug?: InputMaybe<Scalars['String']>;
  subdomain?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  workspaceId?: InputMaybe<Scalars['uuid']>;
};

/** aggregate stddev on columns */
export type Apps_Stddev_Fields = {
  __typename?: 'apps_stddev_fields';
  currentState?: Maybe<Scalars['Float']>;
  desiredState?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "apps" */
export type Apps_Stddev_Order_By = {
  currentState?: InputMaybe<Order_By>;
  desiredState?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Apps_Stddev_Pop_Fields = {
  __typename?: 'apps_stddev_pop_fields';
  currentState?: Maybe<Scalars['Float']>;
  desiredState?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "apps" */
export type Apps_Stddev_Pop_Order_By = {
  currentState?: InputMaybe<Order_By>;
  desiredState?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Apps_Stddev_Samp_Fields = {
  __typename?: 'apps_stddev_samp_fields';
  currentState?: Maybe<Scalars['Float']>;
  desiredState?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "apps" */
export type Apps_Stddev_Samp_Order_By = {
  currentState?: InputMaybe<Order_By>;
  desiredState?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "apps" */
export type Apps_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Apps_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Apps_Stream_Cursor_Value_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  creatorUserId?: InputMaybe<Scalars['uuid']>;
  currentState?: InputMaybe<Scalars['Int']>;
  desiredState?: InputMaybe<Scalars['Int']>;
  githubRepositoryId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  isLocked?: InputMaybe<Scalars['Boolean']>;
  isLockedReason?: InputMaybe<Scalars['String']>;
  legacyPlanID?: InputMaybe<Scalars['uuid']>;
  legacyStripeSubscriptionId?: InputMaybe<Scalars['String']>;
  metadataFunctions?: InputMaybe<Scalars['jsonb']>;
  mimirConfigEnc?: InputMaybe<Scalars['String']>;
  mimirSecretsEnc?: InputMaybe<Scalars['String']>;
  mimirSystemConfigEnc?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
  nhostBaseFolder?: InputMaybe<Scalars['String']>;
  organizationID?: InputMaybe<Scalars['uuid']>;
  regionId?: InputMaybe<Scalars['uuid']>;
  repositoryProductionBranch?: InputMaybe<Scalars['String']>;
  slug?: InputMaybe<Scalars['String']>;
  stateMatch?: InputMaybe<Scalars['Boolean']>;
  subdomain?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  workspaceId?: InputMaybe<Scalars['uuid']>;
};

/** aggregate sum on columns */
export type Apps_Sum_Fields = {
  __typename?: 'apps_sum_fields';
  currentState?: Maybe<Scalars['Int']>;
  desiredState?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "apps" */
export type Apps_Sum_Order_By = {
  currentState?: InputMaybe<Order_By>;
  desiredState?: InputMaybe<Order_By>;
};

/** update columns of table "apps" */
export enum Apps_Update_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatorUserId = 'creatorUserId',
  /** column name */
  CurrentState = 'currentState',
  /** column name */
  DesiredState = 'desiredState',
  /** column name */
  GithubRepositoryId = 'githubRepositoryId',
  /** column name */
  Id = 'id',
  /** column name */
  IsLocked = 'isLocked',
  /** column name */
  IsLockedReason = 'isLockedReason',
  /** column name */
  LegacyPlanId = 'legacyPlanID',
  /** column name */
  LegacyStripeSubscriptionId = 'legacyStripeSubscriptionId',
  /** column name */
  MetadataFunctions = 'metadataFunctions',
  /** column name */
  MimirConfigEnc = 'mimirConfigEnc',
  /** column name */
  MimirSecretsEnc = 'mimirSecretsEnc',
  /** column name */
  MimirSystemConfigEnc = 'mimirSystemConfigEnc',
  /** column name */
  Name = 'name',
  /** column name */
  NhostBaseFolder = 'nhostBaseFolder',
  /** column name */
  OrganizationId = 'organizationID',
  /** column name */
  RegionId = 'regionId',
  /** column name */
  RepositoryProductionBranch = 'repositoryProductionBranch',
  /** column name */
  Slug = 'slug',
  /** column name */
  Subdomain = 'subdomain',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  WorkspaceId = 'workspaceId'
}

export type Apps_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<Apps_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<Apps_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<Apps_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<Apps_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Apps_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<Apps_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Apps_Set_Input>;
  /** filter the rows which have to be updated */
  where: Apps_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Apps_Var_Pop_Fields = {
  __typename?: 'apps_var_pop_fields';
  currentState?: Maybe<Scalars['Float']>;
  desiredState?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "apps" */
export type Apps_Var_Pop_Order_By = {
  currentState?: InputMaybe<Order_By>;
  desiredState?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Apps_Var_Samp_Fields = {
  __typename?: 'apps_var_samp_fields';
  currentState?: Maybe<Scalars['Float']>;
  desiredState?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "apps" */
export type Apps_Var_Samp_Order_By = {
  currentState?: InputMaybe<Order_By>;
  desiredState?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Apps_Variance_Fields = {
  __typename?: 'apps_variance_fields';
  currentState?: Maybe<Scalars['Float']>;
  desiredState?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "apps" */
export type Apps_Variance_Order_By = {
  currentState?: InputMaybe<Order_By>;
  desiredState?: InputMaybe<Order_By>;
};

/** Oauth requests, inserted before redirecting to the provider's site. Don't modify its structure as Hasura Auth relies on it to function properly. */
export type AuthProviderRequests = {
  __typename?: 'authProviderRequests';
  id: Scalars['uuid'];
  options?: Maybe<Scalars['jsonb']>;
};


/** Oauth requests, inserted before redirecting to the provider's site. Don't modify its structure as Hasura Auth relies on it to function properly. */
export type AuthProviderRequestsOptionsArgs = {
  path?: InputMaybe<Scalars['String']>;
};

/** aggregated selection of "auth.provider_requests" */
export type AuthProviderRequests_Aggregate = {
  __typename?: 'authProviderRequests_aggregate';
  aggregate?: Maybe<AuthProviderRequests_Aggregate_Fields>;
  nodes: Array<AuthProviderRequests>;
};

/** aggregate fields of "auth.provider_requests" */
export type AuthProviderRequests_Aggregate_Fields = {
  __typename?: 'authProviderRequests_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<AuthProviderRequests_Max_Fields>;
  min?: Maybe<AuthProviderRequests_Min_Fields>;
};


/** aggregate fields of "auth.provider_requests" */
export type AuthProviderRequests_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<AuthProviderRequests_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type AuthProviderRequests_Append_Input = {
  options?: InputMaybe<Scalars['jsonb']>;
};

/** Boolean expression to filter rows from the table "auth.provider_requests". All fields are combined with a logical 'AND'. */
export type AuthProviderRequests_Bool_Exp = {
  _and?: InputMaybe<Array<AuthProviderRequests_Bool_Exp>>;
  _not?: InputMaybe<AuthProviderRequests_Bool_Exp>;
  _or?: InputMaybe<Array<AuthProviderRequests_Bool_Exp>>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  options?: InputMaybe<Jsonb_Comparison_Exp>;
};

/** unique or primary key constraints on table "auth.provider_requests" */
export enum AuthProviderRequests_Constraint {
  /** unique or primary key constraint on columns "id" */
  ProviderRequestsPkey = 'provider_requests_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type AuthProviderRequests_Delete_At_Path_Input = {
  options?: InputMaybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type AuthProviderRequests_Delete_Elem_Input = {
  options?: InputMaybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type AuthProviderRequests_Delete_Key_Input = {
  options?: InputMaybe<Scalars['String']>;
};

/** input type for inserting data into table "auth.provider_requests" */
export type AuthProviderRequests_Insert_Input = {
  id?: InputMaybe<Scalars['uuid']>;
  options?: InputMaybe<Scalars['jsonb']>;
};

/** aggregate max on columns */
export type AuthProviderRequests_Max_Fields = {
  __typename?: 'authProviderRequests_max_fields';
  id?: Maybe<Scalars['uuid']>;
};

/** aggregate min on columns */
export type AuthProviderRequests_Min_Fields = {
  __typename?: 'authProviderRequests_min_fields';
  id?: Maybe<Scalars['uuid']>;
};

/** response of any mutation on the table "auth.provider_requests" */
export type AuthProviderRequests_Mutation_Response = {
  __typename?: 'authProviderRequests_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<AuthProviderRequests>;
};

/** on_conflict condition type for table "auth.provider_requests" */
export type AuthProviderRequests_On_Conflict = {
  constraint: AuthProviderRequests_Constraint;
  update_columns?: Array<AuthProviderRequests_Update_Column>;
  where?: InputMaybe<AuthProviderRequests_Bool_Exp>;
};

/** Ordering options when selecting data from "auth.provider_requests". */
export type AuthProviderRequests_Order_By = {
  id?: InputMaybe<Order_By>;
  options?: InputMaybe<Order_By>;
};

/** primary key columns input for table: auth.provider_requests */
export type AuthProviderRequests_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type AuthProviderRequests_Prepend_Input = {
  options?: InputMaybe<Scalars['jsonb']>;
};

/** select columns of table "auth.provider_requests" */
export enum AuthProviderRequests_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Options = 'options'
}

/** input type for updating data in table "auth.provider_requests" */
export type AuthProviderRequests_Set_Input = {
  id?: InputMaybe<Scalars['uuid']>;
  options?: InputMaybe<Scalars['jsonb']>;
};

/** Streaming cursor of the table "authProviderRequests" */
export type AuthProviderRequests_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: AuthProviderRequests_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type AuthProviderRequests_Stream_Cursor_Value_Input = {
  id?: InputMaybe<Scalars['uuid']>;
  options?: InputMaybe<Scalars['jsonb']>;
};

/** update columns of table "auth.provider_requests" */
export enum AuthProviderRequests_Update_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Options = 'options'
}

export type AuthProviderRequests_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<AuthProviderRequests_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<AuthProviderRequests_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<AuthProviderRequests_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<AuthProviderRequests_Delete_Key_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<AuthProviderRequests_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<AuthProviderRequests_Set_Input>;
  /** filter the rows which have to be updated */
  where: AuthProviderRequests_Bool_Exp;
};

/** List of available Oauth providers. Don't modify its structure as Hasura Auth relies on it to function properly. */
export type AuthProviders = {
  __typename?: 'authProviders';
  id: Scalars['String'];
  /** An array relationship */
  userProviders: Array<AuthUserProviders>;
  /** An aggregate relationship */
  userProviders_aggregate: AuthUserProviders_Aggregate;
};


/** List of available Oauth providers. Don't modify its structure as Hasura Auth relies on it to function properly. */
export type AuthProvidersUserProvidersArgs = {
  distinct_on?: InputMaybe<Array<AuthUserProviders_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<AuthUserProviders_Order_By>>;
  where?: InputMaybe<AuthUserProviders_Bool_Exp>;
};


/** List of available Oauth providers. Don't modify its structure as Hasura Auth relies on it to function properly. */
export type AuthProvidersUserProviders_AggregateArgs = {
  distinct_on?: InputMaybe<Array<AuthUserProviders_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<AuthUserProviders_Order_By>>;
  where?: InputMaybe<AuthUserProviders_Bool_Exp>;
};

/** aggregated selection of "auth.providers" */
export type AuthProviders_Aggregate = {
  __typename?: 'authProviders_aggregate';
  aggregate?: Maybe<AuthProviders_Aggregate_Fields>;
  nodes: Array<AuthProviders>;
};

/** aggregate fields of "auth.providers" */
export type AuthProviders_Aggregate_Fields = {
  __typename?: 'authProviders_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<AuthProviders_Max_Fields>;
  min?: Maybe<AuthProviders_Min_Fields>;
};


/** aggregate fields of "auth.providers" */
export type AuthProviders_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<AuthProviders_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "auth.providers". All fields are combined with a logical 'AND'. */
export type AuthProviders_Bool_Exp = {
  _and?: InputMaybe<Array<AuthProviders_Bool_Exp>>;
  _not?: InputMaybe<AuthProviders_Bool_Exp>;
  _or?: InputMaybe<Array<AuthProviders_Bool_Exp>>;
  id?: InputMaybe<String_Comparison_Exp>;
  userProviders?: InputMaybe<AuthUserProviders_Bool_Exp>;
  userProviders_aggregate?: InputMaybe<AuthUserProviders_Aggregate_Bool_Exp>;
};

/** unique or primary key constraints on table "auth.providers" */
export enum AuthProviders_Constraint {
  /** unique or primary key constraint on columns "id" */
  ProvidersPkey = 'providers_pkey'
}

/** input type for inserting data into table "auth.providers" */
export type AuthProviders_Insert_Input = {
  id?: InputMaybe<Scalars['String']>;
  userProviders?: InputMaybe<AuthUserProviders_Arr_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type AuthProviders_Max_Fields = {
  __typename?: 'authProviders_max_fields';
  id?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type AuthProviders_Min_Fields = {
  __typename?: 'authProviders_min_fields';
  id?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "auth.providers" */
export type AuthProviders_Mutation_Response = {
  __typename?: 'authProviders_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<AuthProviders>;
};

/** input type for inserting object relation for remote table "auth.providers" */
export type AuthProviders_Obj_Rel_Insert_Input = {
  data: AuthProviders_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<AuthProviders_On_Conflict>;
};

/** on_conflict condition type for table "auth.providers" */
export type AuthProviders_On_Conflict = {
  constraint: AuthProviders_Constraint;
  update_columns?: Array<AuthProviders_Update_Column>;
  where?: InputMaybe<AuthProviders_Bool_Exp>;
};

/** Ordering options when selecting data from "auth.providers". */
export type AuthProviders_Order_By = {
  id?: InputMaybe<Order_By>;
  userProviders_aggregate?: InputMaybe<AuthUserProviders_Aggregate_Order_By>;
};

/** primary key columns input for table: auth.providers */
export type AuthProviders_Pk_Columns_Input = {
  id: Scalars['String'];
};

/** select columns of table "auth.providers" */
export enum AuthProviders_Select_Column {
  /** column name */
  Id = 'id'
}

/** input type for updating data in table "auth.providers" */
export type AuthProviders_Set_Input = {
  id?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "authProviders" */
export type AuthProviders_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: AuthProviders_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type AuthProviders_Stream_Cursor_Value_Input = {
  id?: InputMaybe<Scalars['String']>;
};

/** update columns of table "auth.providers" */
export enum AuthProviders_Update_Column {
  /** column name */
  Id = 'id'
}

export type AuthProviders_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<AuthProviders_Set_Input>;
  /** filter the rows which have to be updated */
  where: AuthProviders_Bool_Exp;
};

/** columns and relationships of "auth.refresh_token_types" */
export type AuthRefreshTokenTypes = {
  __typename?: 'authRefreshTokenTypes';
  comment?: Maybe<Scalars['String']>;
  /** An array relationship */
  refreshTokens: Array<AuthRefreshTokens>;
  /** An aggregate relationship */
  refreshTokens_aggregate: AuthRefreshTokens_Aggregate;
  value: Scalars['String'];
};


/** columns and relationships of "auth.refresh_token_types" */
export type AuthRefreshTokenTypesRefreshTokensArgs = {
  distinct_on?: InputMaybe<Array<AuthRefreshTokens_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<AuthRefreshTokens_Order_By>>;
  where?: InputMaybe<AuthRefreshTokens_Bool_Exp>;
};


/** columns and relationships of "auth.refresh_token_types" */
export type AuthRefreshTokenTypesRefreshTokens_AggregateArgs = {
  distinct_on?: InputMaybe<Array<AuthRefreshTokens_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<AuthRefreshTokens_Order_By>>;
  where?: InputMaybe<AuthRefreshTokens_Bool_Exp>;
};

/** aggregated selection of "auth.refresh_token_types" */
export type AuthRefreshTokenTypes_Aggregate = {
  __typename?: 'authRefreshTokenTypes_aggregate';
  aggregate?: Maybe<AuthRefreshTokenTypes_Aggregate_Fields>;
  nodes: Array<AuthRefreshTokenTypes>;
};

/** aggregate fields of "auth.refresh_token_types" */
export type AuthRefreshTokenTypes_Aggregate_Fields = {
  __typename?: 'authRefreshTokenTypes_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<AuthRefreshTokenTypes_Max_Fields>;
  min?: Maybe<AuthRefreshTokenTypes_Min_Fields>;
};


/** aggregate fields of "auth.refresh_token_types" */
export type AuthRefreshTokenTypes_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<AuthRefreshTokenTypes_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "auth.refresh_token_types". All fields are combined with a logical 'AND'. */
export type AuthRefreshTokenTypes_Bool_Exp = {
  _and?: InputMaybe<Array<AuthRefreshTokenTypes_Bool_Exp>>;
  _not?: InputMaybe<AuthRefreshTokenTypes_Bool_Exp>;
  _or?: InputMaybe<Array<AuthRefreshTokenTypes_Bool_Exp>>;
  comment?: InputMaybe<String_Comparison_Exp>;
  refreshTokens?: InputMaybe<AuthRefreshTokens_Bool_Exp>;
  refreshTokens_aggregate?: InputMaybe<AuthRefreshTokens_Aggregate_Bool_Exp>;
  value?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "auth.refresh_token_types" */
export enum AuthRefreshTokenTypes_Constraint {
  /** unique or primary key constraint on columns "value" */
  RefreshTokenTypesPkey = 'refresh_token_types_pkey'
}

export enum AuthRefreshTokenTypes_Enum {
  /** Personal access token */
  Pat = 'pat',
  /** Regular refresh token */
  Regular = 'regular'
}

/** Boolean expression to compare columns of type "authRefreshTokenTypes_enum". All fields are combined with logical 'AND'. */
export type AuthRefreshTokenTypes_Enum_Comparison_Exp = {
  _eq?: InputMaybe<AuthRefreshTokenTypes_Enum>;
  _in?: InputMaybe<Array<AuthRefreshTokenTypes_Enum>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<AuthRefreshTokenTypes_Enum>;
  _nin?: InputMaybe<Array<AuthRefreshTokenTypes_Enum>>;
};

/** input type for inserting data into table "auth.refresh_token_types" */
export type AuthRefreshTokenTypes_Insert_Input = {
  comment?: InputMaybe<Scalars['String']>;
  refreshTokens?: InputMaybe<AuthRefreshTokens_Arr_Rel_Insert_Input>;
  value?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type AuthRefreshTokenTypes_Max_Fields = {
  __typename?: 'authRefreshTokenTypes_max_fields';
  comment?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type AuthRefreshTokenTypes_Min_Fields = {
  __typename?: 'authRefreshTokenTypes_min_fields';
  comment?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "auth.refresh_token_types" */
export type AuthRefreshTokenTypes_Mutation_Response = {
  __typename?: 'authRefreshTokenTypes_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<AuthRefreshTokenTypes>;
};

/** on_conflict condition type for table "auth.refresh_token_types" */
export type AuthRefreshTokenTypes_On_Conflict = {
  constraint: AuthRefreshTokenTypes_Constraint;
  update_columns?: Array<AuthRefreshTokenTypes_Update_Column>;
  where?: InputMaybe<AuthRefreshTokenTypes_Bool_Exp>;
};

/** Ordering options when selecting data from "auth.refresh_token_types". */
export type AuthRefreshTokenTypes_Order_By = {
  comment?: InputMaybe<Order_By>;
  refreshTokens_aggregate?: InputMaybe<AuthRefreshTokens_Aggregate_Order_By>;
  value?: InputMaybe<Order_By>;
};

/** primary key columns input for table: auth.refresh_token_types */
export type AuthRefreshTokenTypes_Pk_Columns_Input = {
  value: Scalars['String'];
};

/** select columns of table "auth.refresh_token_types" */
export enum AuthRefreshTokenTypes_Select_Column {
  /** column name */
  Comment = 'comment',
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "auth.refresh_token_types" */
export type AuthRefreshTokenTypes_Set_Input = {
  comment?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "authRefreshTokenTypes" */
export type AuthRefreshTokenTypes_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: AuthRefreshTokenTypes_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type AuthRefreshTokenTypes_Stream_Cursor_Value_Input = {
  comment?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** update columns of table "auth.refresh_token_types" */
export enum AuthRefreshTokenTypes_Update_Column {
  /** column name */
  Comment = 'comment',
  /** column name */
  Value = 'value'
}

export type AuthRefreshTokenTypes_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<AuthRefreshTokenTypes_Set_Input>;
  /** filter the rows which have to be updated */
  where: AuthRefreshTokenTypes_Bool_Exp;
};

/** User refresh tokens. Hasura auth uses them to rotate new access tokens as long as the refresh token is not expired. Don't modify its structure as Hasura Auth relies on it to function properly. */
export type AuthRefreshTokens = {
  __typename?: 'authRefreshTokens';
  createdAt: Scalars['timestamptz'];
  expiresAt: Scalars['timestamptz'];
  id: Scalars['uuid'];
  metadata?: Maybe<Scalars['jsonb']>;
  refreshTokenHash?: Maybe<Scalars['String']>;
  type: AuthRefreshTokenTypes_Enum;
  /** An object relationship */
  user: Users;
  userId: Scalars['uuid'];
};


/** User refresh tokens. Hasura auth uses them to rotate new access tokens as long as the refresh token is not expired. Don't modify its structure as Hasura Auth relies on it to function properly. */
export type AuthRefreshTokensMetadataArgs = {
  path?: InputMaybe<Scalars['String']>;
};

/** aggregated selection of "auth.refresh_tokens" */
export type AuthRefreshTokens_Aggregate = {
  __typename?: 'authRefreshTokens_aggregate';
  aggregate?: Maybe<AuthRefreshTokens_Aggregate_Fields>;
  nodes: Array<AuthRefreshTokens>;
};

export type AuthRefreshTokens_Aggregate_Bool_Exp = {
  count?: InputMaybe<AuthRefreshTokens_Aggregate_Bool_Exp_Count>;
};

export type AuthRefreshTokens_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<AuthRefreshTokens_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<AuthRefreshTokens_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "auth.refresh_tokens" */
export type AuthRefreshTokens_Aggregate_Fields = {
  __typename?: 'authRefreshTokens_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<AuthRefreshTokens_Max_Fields>;
  min?: Maybe<AuthRefreshTokens_Min_Fields>;
};


/** aggregate fields of "auth.refresh_tokens" */
export type AuthRefreshTokens_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<AuthRefreshTokens_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "auth.refresh_tokens" */
export type AuthRefreshTokens_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<AuthRefreshTokens_Max_Order_By>;
  min?: InputMaybe<AuthRefreshTokens_Min_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type AuthRefreshTokens_Append_Input = {
  metadata?: InputMaybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "auth.refresh_tokens" */
export type AuthRefreshTokens_Arr_Rel_Insert_Input = {
  data: Array<AuthRefreshTokens_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<AuthRefreshTokens_On_Conflict>;
};

/** Boolean expression to filter rows from the table "auth.refresh_tokens". All fields are combined with a logical 'AND'. */
export type AuthRefreshTokens_Bool_Exp = {
  _and?: InputMaybe<Array<AuthRefreshTokens_Bool_Exp>>;
  _not?: InputMaybe<AuthRefreshTokens_Bool_Exp>;
  _or?: InputMaybe<Array<AuthRefreshTokens_Bool_Exp>>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  expiresAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  metadata?: InputMaybe<Jsonb_Comparison_Exp>;
  refreshTokenHash?: InputMaybe<String_Comparison_Exp>;
  type?: InputMaybe<AuthRefreshTokenTypes_Enum_Comparison_Exp>;
  user?: InputMaybe<Users_Bool_Exp>;
  userId?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "auth.refresh_tokens" */
export enum AuthRefreshTokens_Constraint {
  /** unique or primary key constraint on columns "id" */
  RefreshTokensPkey = 'refresh_tokens_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type AuthRefreshTokens_Delete_At_Path_Input = {
  metadata?: InputMaybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type AuthRefreshTokens_Delete_Elem_Input = {
  metadata?: InputMaybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type AuthRefreshTokens_Delete_Key_Input = {
  metadata?: InputMaybe<Scalars['String']>;
};

/** input type for inserting data into table "auth.refresh_tokens" */
export type AuthRefreshTokens_Insert_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  expiresAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  metadata?: InputMaybe<Scalars['jsonb']>;
  refreshTokenHash?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<AuthRefreshTokenTypes_Enum>;
  user?: InputMaybe<Users_Obj_Rel_Insert_Input>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type AuthRefreshTokens_Max_Fields = {
  __typename?: 'authRefreshTokens_max_fields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  expiresAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  refreshTokenHash?: Maybe<Scalars['String']>;
  userId?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "auth.refresh_tokens" */
export type AuthRefreshTokens_Max_Order_By = {
  createdAt?: InputMaybe<Order_By>;
  expiresAt?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  refreshTokenHash?: InputMaybe<Order_By>;
  userId?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type AuthRefreshTokens_Min_Fields = {
  __typename?: 'authRefreshTokens_min_fields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  expiresAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  refreshTokenHash?: Maybe<Scalars['String']>;
  userId?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "auth.refresh_tokens" */
export type AuthRefreshTokens_Min_Order_By = {
  createdAt?: InputMaybe<Order_By>;
  expiresAt?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  refreshTokenHash?: InputMaybe<Order_By>;
  userId?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "auth.refresh_tokens" */
export type AuthRefreshTokens_Mutation_Response = {
  __typename?: 'authRefreshTokens_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<AuthRefreshTokens>;
};

/** on_conflict condition type for table "auth.refresh_tokens" */
export type AuthRefreshTokens_On_Conflict = {
  constraint: AuthRefreshTokens_Constraint;
  update_columns?: Array<AuthRefreshTokens_Update_Column>;
  where?: InputMaybe<AuthRefreshTokens_Bool_Exp>;
};

/** Ordering options when selecting data from "auth.refresh_tokens". */
export type AuthRefreshTokens_Order_By = {
  createdAt?: InputMaybe<Order_By>;
  expiresAt?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  metadata?: InputMaybe<Order_By>;
  refreshTokenHash?: InputMaybe<Order_By>;
  type?: InputMaybe<Order_By>;
  user?: InputMaybe<Users_Order_By>;
  userId?: InputMaybe<Order_By>;
};

/** primary key columns input for table: auth.refresh_tokens */
export type AuthRefreshTokens_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type AuthRefreshTokens_Prepend_Input = {
  metadata?: InputMaybe<Scalars['jsonb']>;
};

/** select columns of table "auth.refresh_tokens" */
export enum AuthRefreshTokens_Select_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  ExpiresAt = 'expiresAt',
  /** column name */
  Id = 'id',
  /** column name */
  Metadata = 'metadata',
  /** column name */
  RefreshTokenHash = 'refreshTokenHash',
  /** column name */
  Type = 'type',
  /** column name */
  UserId = 'userId'
}

/** input type for updating data in table "auth.refresh_tokens" */
export type AuthRefreshTokens_Set_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  expiresAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  metadata?: InputMaybe<Scalars['jsonb']>;
  refreshTokenHash?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<AuthRefreshTokenTypes_Enum>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** Streaming cursor of the table "authRefreshTokens" */
export type AuthRefreshTokens_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: AuthRefreshTokens_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type AuthRefreshTokens_Stream_Cursor_Value_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  expiresAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  metadata?: InputMaybe<Scalars['jsonb']>;
  refreshTokenHash?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<AuthRefreshTokenTypes_Enum>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** update columns of table "auth.refresh_tokens" */
export enum AuthRefreshTokens_Update_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  ExpiresAt = 'expiresAt',
  /** column name */
  Id = 'id',
  /** column name */
  Metadata = 'metadata',
  /** column name */
  RefreshTokenHash = 'refreshTokenHash',
  /** column name */
  Type = 'type',
  /** column name */
  UserId = 'userId'
}

export type AuthRefreshTokens_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<AuthRefreshTokens_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<AuthRefreshTokens_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<AuthRefreshTokens_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<AuthRefreshTokens_Delete_Key_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<AuthRefreshTokens_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<AuthRefreshTokens_Set_Input>;
  /** filter the rows which have to be updated */
  where: AuthRefreshTokens_Bool_Exp;
};

/** Persistent Hasura roles for users. Don't modify its structure as Hasura Auth relies on it to function properly. */
export type AuthRoles = {
  __typename?: 'authRoles';
  role: Scalars['String'];
  /** An array relationship */
  userRoles: Array<AuthUserRoles>;
  /** An aggregate relationship */
  userRoles_aggregate: AuthUserRoles_Aggregate;
  /** An array relationship */
  usersByDefaultRole: Array<Users>;
  /** An aggregate relationship */
  usersByDefaultRole_aggregate: Users_Aggregate;
};


/** Persistent Hasura roles for users. Don't modify its structure as Hasura Auth relies on it to function properly. */
export type AuthRolesUserRolesArgs = {
  distinct_on?: InputMaybe<Array<AuthUserRoles_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<AuthUserRoles_Order_By>>;
  where?: InputMaybe<AuthUserRoles_Bool_Exp>;
};


/** Persistent Hasura roles for users. Don't modify its structure as Hasura Auth relies on it to function properly. */
export type AuthRolesUserRoles_AggregateArgs = {
  distinct_on?: InputMaybe<Array<AuthUserRoles_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<AuthUserRoles_Order_By>>;
  where?: InputMaybe<AuthUserRoles_Bool_Exp>;
};


/** Persistent Hasura roles for users. Don't modify its structure as Hasura Auth relies on it to function properly. */
export type AuthRolesUsersByDefaultRoleArgs = {
  distinct_on?: InputMaybe<Array<Users_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Users_Order_By>>;
  where?: InputMaybe<Users_Bool_Exp>;
};


/** Persistent Hasura roles for users. Don't modify its structure as Hasura Auth relies on it to function properly. */
export type AuthRolesUsersByDefaultRole_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Users_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Users_Order_By>>;
  where?: InputMaybe<Users_Bool_Exp>;
};

/** aggregated selection of "auth.roles" */
export type AuthRoles_Aggregate = {
  __typename?: 'authRoles_aggregate';
  aggregate?: Maybe<AuthRoles_Aggregate_Fields>;
  nodes: Array<AuthRoles>;
};

/** aggregate fields of "auth.roles" */
export type AuthRoles_Aggregate_Fields = {
  __typename?: 'authRoles_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<AuthRoles_Max_Fields>;
  min?: Maybe<AuthRoles_Min_Fields>;
};


/** aggregate fields of "auth.roles" */
export type AuthRoles_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<AuthRoles_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "auth.roles". All fields are combined with a logical 'AND'. */
export type AuthRoles_Bool_Exp = {
  _and?: InputMaybe<Array<AuthRoles_Bool_Exp>>;
  _not?: InputMaybe<AuthRoles_Bool_Exp>;
  _or?: InputMaybe<Array<AuthRoles_Bool_Exp>>;
  role?: InputMaybe<String_Comparison_Exp>;
  userRoles?: InputMaybe<AuthUserRoles_Bool_Exp>;
  userRoles_aggregate?: InputMaybe<AuthUserRoles_Aggregate_Bool_Exp>;
  usersByDefaultRole?: InputMaybe<Users_Bool_Exp>;
  usersByDefaultRole_aggregate?: InputMaybe<Users_Aggregate_Bool_Exp>;
};

/** unique or primary key constraints on table "auth.roles" */
export enum AuthRoles_Constraint {
  /** unique or primary key constraint on columns "role" */
  RolesPkey = 'roles_pkey'
}

/** input type for inserting data into table "auth.roles" */
export type AuthRoles_Insert_Input = {
  role?: InputMaybe<Scalars['String']>;
  userRoles?: InputMaybe<AuthUserRoles_Arr_Rel_Insert_Input>;
  usersByDefaultRole?: InputMaybe<Users_Arr_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type AuthRoles_Max_Fields = {
  __typename?: 'authRoles_max_fields';
  role?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type AuthRoles_Min_Fields = {
  __typename?: 'authRoles_min_fields';
  role?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "auth.roles" */
export type AuthRoles_Mutation_Response = {
  __typename?: 'authRoles_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<AuthRoles>;
};

/** input type for inserting object relation for remote table "auth.roles" */
export type AuthRoles_Obj_Rel_Insert_Input = {
  data: AuthRoles_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<AuthRoles_On_Conflict>;
};

/** on_conflict condition type for table "auth.roles" */
export type AuthRoles_On_Conflict = {
  constraint: AuthRoles_Constraint;
  update_columns?: Array<AuthRoles_Update_Column>;
  where?: InputMaybe<AuthRoles_Bool_Exp>;
};

/** Ordering options when selecting data from "auth.roles". */
export type AuthRoles_Order_By = {
  role?: InputMaybe<Order_By>;
  userRoles_aggregate?: InputMaybe<AuthUserRoles_Aggregate_Order_By>;
  usersByDefaultRole_aggregate?: InputMaybe<Users_Aggregate_Order_By>;
};

/** primary key columns input for table: auth.roles */
export type AuthRoles_Pk_Columns_Input = {
  role: Scalars['String'];
};

/** select columns of table "auth.roles" */
export enum AuthRoles_Select_Column {
  /** column name */
  Role = 'role'
}

/** input type for updating data in table "auth.roles" */
export type AuthRoles_Set_Input = {
  role?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "authRoles" */
export type AuthRoles_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: AuthRoles_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type AuthRoles_Stream_Cursor_Value_Input = {
  role?: InputMaybe<Scalars['String']>;
};

/** update columns of table "auth.roles" */
export enum AuthRoles_Update_Column {
  /** column name */
  Role = 'role'
}

export type AuthRoles_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<AuthRoles_Set_Input>;
  /** filter the rows which have to be updated */
  where: AuthRoles_Bool_Exp;
};

/** Active providers for a given user. Don't modify its structure as Hasura Auth relies on it to function properly. */
export type AuthUserProviders = {
  __typename?: 'authUserProviders';
  accessToken: Scalars['String'];
  createdAt: Scalars['timestamptz'];
  id: Scalars['uuid'];
  /** An object relationship */
  provider: AuthProviders;
  providerId: Scalars['String'];
  providerUserId: Scalars['String'];
  refreshToken?: Maybe<Scalars['String']>;
  updatedAt: Scalars['timestamptz'];
  /** An object relationship */
  user: Users;
  userId: Scalars['uuid'];
};

/** aggregated selection of "auth.user_providers" */
export type AuthUserProviders_Aggregate = {
  __typename?: 'authUserProviders_aggregate';
  aggregate?: Maybe<AuthUserProviders_Aggregate_Fields>;
  nodes: Array<AuthUserProviders>;
};

export type AuthUserProviders_Aggregate_Bool_Exp = {
  count?: InputMaybe<AuthUserProviders_Aggregate_Bool_Exp_Count>;
};

export type AuthUserProviders_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<AuthUserProviders_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<AuthUserProviders_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "auth.user_providers" */
export type AuthUserProviders_Aggregate_Fields = {
  __typename?: 'authUserProviders_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<AuthUserProviders_Max_Fields>;
  min?: Maybe<AuthUserProviders_Min_Fields>;
};


/** aggregate fields of "auth.user_providers" */
export type AuthUserProviders_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<AuthUserProviders_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "auth.user_providers" */
export type AuthUserProviders_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<AuthUserProviders_Max_Order_By>;
  min?: InputMaybe<AuthUserProviders_Min_Order_By>;
};

/** input type for inserting array relation for remote table "auth.user_providers" */
export type AuthUserProviders_Arr_Rel_Insert_Input = {
  data: Array<AuthUserProviders_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<AuthUserProviders_On_Conflict>;
};

/** Boolean expression to filter rows from the table "auth.user_providers". All fields are combined with a logical 'AND'. */
export type AuthUserProviders_Bool_Exp = {
  _and?: InputMaybe<Array<AuthUserProviders_Bool_Exp>>;
  _not?: InputMaybe<AuthUserProviders_Bool_Exp>;
  _or?: InputMaybe<Array<AuthUserProviders_Bool_Exp>>;
  accessToken?: InputMaybe<String_Comparison_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  provider?: InputMaybe<AuthProviders_Bool_Exp>;
  providerId?: InputMaybe<String_Comparison_Exp>;
  providerUserId?: InputMaybe<String_Comparison_Exp>;
  refreshToken?: InputMaybe<String_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  user?: InputMaybe<Users_Bool_Exp>;
  userId?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "auth.user_providers" */
export enum AuthUserProviders_Constraint {
  /** unique or primary key constraint on columns "id" */
  UserProvidersPkey = 'user_providers_pkey',
  /** unique or primary key constraint on columns "provider_user_id", "provider_id" */
  UserProvidersProviderIdProviderUserIdKey = 'user_providers_provider_id_provider_user_id_key',
  /** unique or primary key constraint on columns "user_id", "provider_id" */
  UserProvidersUserIdProviderIdKey = 'user_providers_user_id_provider_id_key'
}

/** input type for inserting data into table "auth.user_providers" */
export type AuthUserProviders_Insert_Input = {
  accessToken?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  provider?: InputMaybe<AuthProviders_Obj_Rel_Insert_Input>;
  providerId?: InputMaybe<Scalars['String']>;
  providerUserId?: InputMaybe<Scalars['String']>;
  refreshToken?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  user?: InputMaybe<Users_Obj_Rel_Insert_Input>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type AuthUserProviders_Max_Fields = {
  __typename?: 'authUserProviders_max_fields';
  accessToken?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  providerId?: Maybe<Scalars['String']>;
  providerUserId?: Maybe<Scalars['String']>;
  refreshToken?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userId?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "auth.user_providers" */
export type AuthUserProviders_Max_Order_By = {
  accessToken?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  providerId?: InputMaybe<Order_By>;
  providerUserId?: InputMaybe<Order_By>;
  refreshToken?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  userId?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type AuthUserProviders_Min_Fields = {
  __typename?: 'authUserProviders_min_fields';
  accessToken?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  providerId?: Maybe<Scalars['String']>;
  providerUserId?: Maybe<Scalars['String']>;
  refreshToken?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userId?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "auth.user_providers" */
export type AuthUserProviders_Min_Order_By = {
  accessToken?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  providerId?: InputMaybe<Order_By>;
  providerUserId?: InputMaybe<Order_By>;
  refreshToken?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  userId?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "auth.user_providers" */
export type AuthUserProviders_Mutation_Response = {
  __typename?: 'authUserProviders_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<AuthUserProviders>;
};

/** on_conflict condition type for table "auth.user_providers" */
export type AuthUserProviders_On_Conflict = {
  constraint: AuthUserProviders_Constraint;
  update_columns?: Array<AuthUserProviders_Update_Column>;
  where?: InputMaybe<AuthUserProviders_Bool_Exp>;
};

/** Ordering options when selecting data from "auth.user_providers". */
export type AuthUserProviders_Order_By = {
  accessToken?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  provider?: InputMaybe<AuthProviders_Order_By>;
  providerId?: InputMaybe<Order_By>;
  providerUserId?: InputMaybe<Order_By>;
  refreshToken?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  user?: InputMaybe<Users_Order_By>;
  userId?: InputMaybe<Order_By>;
};

/** primary key columns input for table: auth.user_providers */
export type AuthUserProviders_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "auth.user_providers" */
export enum AuthUserProviders_Select_Column {
  /** column name */
  AccessToken = 'accessToken',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  ProviderId = 'providerId',
  /** column name */
  ProviderUserId = 'providerUserId',
  /** column name */
  RefreshToken = 'refreshToken',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

/** input type for updating data in table "auth.user_providers" */
export type AuthUserProviders_Set_Input = {
  accessToken?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  providerId?: InputMaybe<Scalars['String']>;
  providerUserId?: InputMaybe<Scalars['String']>;
  refreshToken?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** Streaming cursor of the table "authUserProviders" */
export type AuthUserProviders_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: AuthUserProviders_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type AuthUserProviders_Stream_Cursor_Value_Input = {
  accessToken?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  providerId?: InputMaybe<Scalars['String']>;
  providerUserId?: InputMaybe<Scalars['String']>;
  refreshToken?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** update columns of table "auth.user_providers" */
export enum AuthUserProviders_Update_Column {
  /** column name */
  AccessToken = 'accessToken',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  ProviderId = 'providerId',
  /** column name */
  ProviderUserId = 'providerUserId',
  /** column name */
  RefreshToken = 'refreshToken',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

export type AuthUserProviders_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<AuthUserProviders_Set_Input>;
  /** filter the rows which have to be updated */
  where: AuthUserProviders_Bool_Exp;
};

/** Roles of users. Don't modify its structure as Hasura Auth relies on it to function properly. */
export type AuthUserRoles = {
  __typename?: 'authUserRoles';
  createdAt: Scalars['timestamptz'];
  id: Scalars['uuid'];
  role: Scalars['String'];
  /** An object relationship */
  roleByRole: AuthRoles;
  /** An object relationship */
  user: Users;
  userId: Scalars['uuid'];
};

/** aggregated selection of "auth.user_roles" */
export type AuthUserRoles_Aggregate = {
  __typename?: 'authUserRoles_aggregate';
  aggregate?: Maybe<AuthUserRoles_Aggregate_Fields>;
  nodes: Array<AuthUserRoles>;
};

export type AuthUserRoles_Aggregate_Bool_Exp = {
  count?: InputMaybe<AuthUserRoles_Aggregate_Bool_Exp_Count>;
};

export type AuthUserRoles_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<AuthUserRoles_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<AuthUserRoles_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "auth.user_roles" */
export type AuthUserRoles_Aggregate_Fields = {
  __typename?: 'authUserRoles_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<AuthUserRoles_Max_Fields>;
  min?: Maybe<AuthUserRoles_Min_Fields>;
};


/** aggregate fields of "auth.user_roles" */
export type AuthUserRoles_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<AuthUserRoles_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "auth.user_roles" */
export type AuthUserRoles_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<AuthUserRoles_Max_Order_By>;
  min?: InputMaybe<AuthUserRoles_Min_Order_By>;
};

/** input type for inserting array relation for remote table "auth.user_roles" */
export type AuthUserRoles_Arr_Rel_Insert_Input = {
  data: Array<AuthUserRoles_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<AuthUserRoles_On_Conflict>;
};

/** Boolean expression to filter rows from the table "auth.user_roles". All fields are combined with a logical 'AND'. */
export type AuthUserRoles_Bool_Exp = {
  _and?: InputMaybe<Array<AuthUserRoles_Bool_Exp>>;
  _not?: InputMaybe<AuthUserRoles_Bool_Exp>;
  _or?: InputMaybe<Array<AuthUserRoles_Bool_Exp>>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  role?: InputMaybe<String_Comparison_Exp>;
  roleByRole?: InputMaybe<AuthRoles_Bool_Exp>;
  user?: InputMaybe<Users_Bool_Exp>;
  userId?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "auth.user_roles" */
export enum AuthUserRoles_Constraint {
  /** unique or primary key constraint on columns "id" */
  UserRolesPkey = 'user_roles_pkey',
  /** unique or primary key constraint on columns "user_id", "role" */
  UserRolesUserIdRoleKey = 'user_roles_user_id_role_key'
}

/** input type for inserting data into table "auth.user_roles" */
export type AuthUserRoles_Insert_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  role?: InputMaybe<Scalars['String']>;
  roleByRole?: InputMaybe<AuthRoles_Obj_Rel_Insert_Input>;
  user?: InputMaybe<Users_Obj_Rel_Insert_Input>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type AuthUserRoles_Max_Fields = {
  __typename?: 'authUserRoles_max_fields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  role?: Maybe<Scalars['String']>;
  userId?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "auth.user_roles" */
export type AuthUserRoles_Max_Order_By = {
  createdAt?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  role?: InputMaybe<Order_By>;
  userId?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type AuthUserRoles_Min_Fields = {
  __typename?: 'authUserRoles_min_fields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  role?: Maybe<Scalars['String']>;
  userId?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "auth.user_roles" */
export type AuthUserRoles_Min_Order_By = {
  createdAt?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  role?: InputMaybe<Order_By>;
  userId?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "auth.user_roles" */
export type AuthUserRoles_Mutation_Response = {
  __typename?: 'authUserRoles_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<AuthUserRoles>;
};

/** on_conflict condition type for table "auth.user_roles" */
export type AuthUserRoles_On_Conflict = {
  constraint: AuthUserRoles_Constraint;
  update_columns?: Array<AuthUserRoles_Update_Column>;
  where?: InputMaybe<AuthUserRoles_Bool_Exp>;
};

/** Ordering options when selecting data from "auth.user_roles". */
export type AuthUserRoles_Order_By = {
  createdAt?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  role?: InputMaybe<Order_By>;
  roleByRole?: InputMaybe<AuthRoles_Order_By>;
  user?: InputMaybe<Users_Order_By>;
  userId?: InputMaybe<Order_By>;
};

/** primary key columns input for table: auth.user_roles */
export type AuthUserRoles_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "auth.user_roles" */
export enum AuthUserRoles_Select_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  Role = 'role',
  /** column name */
  UserId = 'userId'
}

/** input type for updating data in table "auth.user_roles" */
export type AuthUserRoles_Set_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  role?: InputMaybe<Scalars['String']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** Streaming cursor of the table "authUserRoles" */
export type AuthUserRoles_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: AuthUserRoles_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type AuthUserRoles_Stream_Cursor_Value_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  role?: InputMaybe<Scalars['String']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** update columns of table "auth.user_roles" */
export enum AuthUserRoles_Update_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  Role = 'role',
  /** column name */
  UserId = 'userId'
}

export type AuthUserRoles_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<AuthUserRoles_Set_Input>;
  /** filter the rows which have to be updated */
  where: AuthUserRoles_Bool_Exp;
};

/** User webauthn security keys. Don't modify its structure as Hasura Auth relies on it to function properly. */
export type AuthUserSecurityKeys = {
  __typename?: 'authUserSecurityKeys';
  counter: Scalars['bigint'];
  credentialId: Scalars['String'];
  credentialPublicKey?: Maybe<Scalars['bytea']>;
  id: Scalars['uuid'];
  nickname?: Maybe<Scalars['String']>;
  transports: Scalars['String'];
  /** An object relationship */
  user: Users;
  userId: Scalars['uuid'];
};

/** aggregated selection of "auth.user_security_keys" */
export type AuthUserSecurityKeys_Aggregate = {
  __typename?: 'authUserSecurityKeys_aggregate';
  aggregate?: Maybe<AuthUserSecurityKeys_Aggregate_Fields>;
  nodes: Array<AuthUserSecurityKeys>;
};

export type AuthUserSecurityKeys_Aggregate_Bool_Exp = {
  count?: InputMaybe<AuthUserSecurityKeys_Aggregate_Bool_Exp_Count>;
};

export type AuthUserSecurityKeys_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<AuthUserSecurityKeys_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<AuthUserSecurityKeys_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "auth.user_security_keys" */
export type AuthUserSecurityKeys_Aggregate_Fields = {
  __typename?: 'authUserSecurityKeys_aggregate_fields';
  avg?: Maybe<AuthUserSecurityKeys_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<AuthUserSecurityKeys_Max_Fields>;
  min?: Maybe<AuthUserSecurityKeys_Min_Fields>;
  stddev?: Maybe<AuthUserSecurityKeys_Stddev_Fields>;
  stddev_pop?: Maybe<AuthUserSecurityKeys_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<AuthUserSecurityKeys_Stddev_Samp_Fields>;
  sum?: Maybe<AuthUserSecurityKeys_Sum_Fields>;
  var_pop?: Maybe<AuthUserSecurityKeys_Var_Pop_Fields>;
  var_samp?: Maybe<AuthUserSecurityKeys_Var_Samp_Fields>;
  variance?: Maybe<AuthUserSecurityKeys_Variance_Fields>;
};


/** aggregate fields of "auth.user_security_keys" */
export type AuthUserSecurityKeys_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<AuthUserSecurityKeys_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "auth.user_security_keys" */
export type AuthUserSecurityKeys_Aggregate_Order_By = {
  avg?: InputMaybe<AuthUserSecurityKeys_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<AuthUserSecurityKeys_Max_Order_By>;
  min?: InputMaybe<AuthUserSecurityKeys_Min_Order_By>;
  stddev?: InputMaybe<AuthUserSecurityKeys_Stddev_Order_By>;
  stddev_pop?: InputMaybe<AuthUserSecurityKeys_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<AuthUserSecurityKeys_Stddev_Samp_Order_By>;
  sum?: InputMaybe<AuthUserSecurityKeys_Sum_Order_By>;
  var_pop?: InputMaybe<AuthUserSecurityKeys_Var_Pop_Order_By>;
  var_samp?: InputMaybe<AuthUserSecurityKeys_Var_Samp_Order_By>;
  variance?: InputMaybe<AuthUserSecurityKeys_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "auth.user_security_keys" */
export type AuthUserSecurityKeys_Arr_Rel_Insert_Input = {
  data: Array<AuthUserSecurityKeys_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<AuthUserSecurityKeys_On_Conflict>;
};

/** aggregate avg on columns */
export type AuthUserSecurityKeys_Avg_Fields = {
  __typename?: 'authUserSecurityKeys_avg_fields';
  counter?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "auth.user_security_keys" */
export type AuthUserSecurityKeys_Avg_Order_By = {
  counter?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "auth.user_security_keys". All fields are combined with a logical 'AND'. */
export type AuthUserSecurityKeys_Bool_Exp = {
  _and?: InputMaybe<Array<AuthUserSecurityKeys_Bool_Exp>>;
  _not?: InputMaybe<AuthUserSecurityKeys_Bool_Exp>;
  _or?: InputMaybe<Array<AuthUserSecurityKeys_Bool_Exp>>;
  counter?: InputMaybe<Bigint_Comparison_Exp>;
  credentialId?: InputMaybe<String_Comparison_Exp>;
  credentialPublicKey?: InputMaybe<Bytea_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  nickname?: InputMaybe<String_Comparison_Exp>;
  transports?: InputMaybe<String_Comparison_Exp>;
  user?: InputMaybe<Users_Bool_Exp>;
  userId?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "auth.user_security_keys" */
export enum AuthUserSecurityKeys_Constraint {
  /** unique or primary key constraint on columns "credential_id" */
  UserSecurityKeyCredentialIdKey = 'user_security_key_credential_id_key',
  /** unique or primary key constraint on columns "id" */
  UserSecurityKeysPkey = 'user_security_keys_pkey'
}

/** input type for incrementing numeric columns in table "auth.user_security_keys" */
export type AuthUserSecurityKeys_Inc_Input = {
  counter?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "auth.user_security_keys" */
export type AuthUserSecurityKeys_Insert_Input = {
  counter?: InputMaybe<Scalars['bigint']>;
  credentialId?: InputMaybe<Scalars['String']>;
  credentialPublicKey?: InputMaybe<Scalars['bytea']>;
  id?: InputMaybe<Scalars['uuid']>;
  nickname?: InputMaybe<Scalars['String']>;
  transports?: InputMaybe<Scalars['String']>;
  user?: InputMaybe<Users_Obj_Rel_Insert_Input>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type AuthUserSecurityKeys_Max_Fields = {
  __typename?: 'authUserSecurityKeys_max_fields';
  counter?: Maybe<Scalars['bigint']>;
  credentialId?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  nickname?: Maybe<Scalars['String']>;
  transports?: Maybe<Scalars['String']>;
  userId?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "auth.user_security_keys" */
export type AuthUserSecurityKeys_Max_Order_By = {
  counter?: InputMaybe<Order_By>;
  credentialId?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  nickname?: InputMaybe<Order_By>;
  transports?: InputMaybe<Order_By>;
  userId?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type AuthUserSecurityKeys_Min_Fields = {
  __typename?: 'authUserSecurityKeys_min_fields';
  counter?: Maybe<Scalars['bigint']>;
  credentialId?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  nickname?: Maybe<Scalars['String']>;
  transports?: Maybe<Scalars['String']>;
  userId?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "auth.user_security_keys" */
export type AuthUserSecurityKeys_Min_Order_By = {
  counter?: InputMaybe<Order_By>;
  credentialId?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  nickname?: InputMaybe<Order_By>;
  transports?: InputMaybe<Order_By>;
  userId?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "auth.user_security_keys" */
export type AuthUserSecurityKeys_Mutation_Response = {
  __typename?: 'authUserSecurityKeys_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<AuthUserSecurityKeys>;
};

/** on_conflict condition type for table "auth.user_security_keys" */
export type AuthUserSecurityKeys_On_Conflict = {
  constraint: AuthUserSecurityKeys_Constraint;
  update_columns?: Array<AuthUserSecurityKeys_Update_Column>;
  where?: InputMaybe<AuthUserSecurityKeys_Bool_Exp>;
};

/** Ordering options when selecting data from "auth.user_security_keys". */
export type AuthUserSecurityKeys_Order_By = {
  counter?: InputMaybe<Order_By>;
  credentialId?: InputMaybe<Order_By>;
  credentialPublicKey?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  nickname?: InputMaybe<Order_By>;
  transports?: InputMaybe<Order_By>;
  user?: InputMaybe<Users_Order_By>;
  userId?: InputMaybe<Order_By>;
};

/** primary key columns input for table: auth.user_security_keys */
export type AuthUserSecurityKeys_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "auth.user_security_keys" */
export enum AuthUserSecurityKeys_Select_Column {
  /** column name */
  Counter = 'counter',
  /** column name */
  CredentialId = 'credentialId',
  /** column name */
  CredentialPublicKey = 'credentialPublicKey',
  /** column name */
  Id = 'id',
  /** column name */
  Nickname = 'nickname',
  /** column name */
  Transports = 'transports',
  /** column name */
  UserId = 'userId'
}

/** input type for updating data in table "auth.user_security_keys" */
export type AuthUserSecurityKeys_Set_Input = {
  counter?: InputMaybe<Scalars['bigint']>;
  credentialId?: InputMaybe<Scalars['String']>;
  credentialPublicKey?: InputMaybe<Scalars['bytea']>;
  id?: InputMaybe<Scalars['uuid']>;
  nickname?: InputMaybe<Scalars['String']>;
  transports?: InputMaybe<Scalars['String']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** aggregate stddev on columns */
export type AuthUserSecurityKeys_Stddev_Fields = {
  __typename?: 'authUserSecurityKeys_stddev_fields';
  counter?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "auth.user_security_keys" */
export type AuthUserSecurityKeys_Stddev_Order_By = {
  counter?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type AuthUserSecurityKeys_Stddev_Pop_Fields = {
  __typename?: 'authUserSecurityKeys_stddev_pop_fields';
  counter?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "auth.user_security_keys" */
export type AuthUserSecurityKeys_Stddev_Pop_Order_By = {
  counter?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type AuthUserSecurityKeys_Stddev_Samp_Fields = {
  __typename?: 'authUserSecurityKeys_stddev_samp_fields';
  counter?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "auth.user_security_keys" */
export type AuthUserSecurityKeys_Stddev_Samp_Order_By = {
  counter?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "authUserSecurityKeys" */
export type AuthUserSecurityKeys_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: AuthUserSecurityKeys_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type AuthUserSecurityKeys_Stream_Cursor_Value_Input = {
  counter?: InputMaybe<Scalars['bigint']>;
  credentialId?: InputMaybe<Scalars['String']>;
  credentialPublicKey?: InputMaybe<Scalars['bytea']>;
  id?: InputMaybe<Scalars['uuid']>;
  nickname?: InputMaybe<Scalars['String']>;
  transports?: InputMaybe<Scalars['String']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** aggregate sum on columns */
export type AuthUserSecurityKeys_Sum_Fields = {
  __typename?: 'authUserSecurityKeys_sum_fields';
  counter?: Maybe<Scalars['bigint']>;
};

/** order by sum() on columns of table "auth.user_security_keys" */
export type AuthUserSecurityKeys_Sum_Order_By = {
  counter?: InputMaybe<Order_By>;
};

/** update columns of table "auth.user_security_keys" */
export enum AuthUserSecurityKeys_Update_Column {
  /** column name */
  Counter = 'counter',
  /** column name */
  CredentialId = 'credentialId',
  /** column name */
  CredentialPublicKey = 'credentialPublicKey',
  /** column name */
  Id = 'id',
  /** column name */
  Nickname = 'nickname',
  /** column name */
  Transports = 'transports',
  /** column name */
  UserId = 'userId'
}

export type AuthUserSecurityKeys_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<AuthUserSecurityKeys_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<AuthUserSecurityKeys_Set_Input>;
  /** filter the rows which have to be updated */
  where: AuthUserSecurityKeys_Bool_Exp;
};

/** aggregate var_pop on columns */
export type AuthUserSecurityKeys_Var_Pop_Fields = {
  __typename?: 'authUserSecurityKeys_var_pop_fields';
  counter?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "auth.user_security_keys" */
export type AuthUserSecurityKeys_Var_Pop_Order_By = {
  counter?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type AuthUserSecurityKeys_Var_Samp_Fields = {
  __typename?: 'authUserSecurityKeys_var_samp_fields';
  counter?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "auth.user_security_keys" */
export type AuthUserSecurityKeys_Var_Samp_Order_By = {
  counter?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type AuthUserSecurityKeys_Variance_Fields = {
  __typename?: 'authUserSecurityKeys_variance_fields';
  counter?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "auth.user_security_keys" */
export type AuthUserSecurityKeys_Variance_Order_By = {
  counter?: InputMaybe<Order_By>;
};

/** Internal table for tracking migrations. Don't modify its structure as Hasura Auth relies on it to function properly. */
export type Auth_Migrations = {
  __typename?: 'auth_migrations';
  executed_at?: Maybe<Scalars['timestamp']>;
  hash: Scalars['String'];
  id: Scalars['Int'];
  name: Scalars['String'];
};

/** aggregated selection of "auth.migrations" */
export type Auth_Migrations_Aggregate = {
  __typename?: 'auth_migrations_aggregate';
  aggregate?: Maybe<Auth_Migrations_Aggregate_Fields>;
  nodes: Array<Auth_Migrations>;
};

/** aggregate fields of "auth.migrations" */
export type Auth_Migrations_Aggregate_Fields = {
  __typename?: 'auth_migrations_aggregate_fields';
  avg?: Maybe<Auth_Migrations_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Auth_Migrations_Max_Fields>;
  min?: Maybe<Auth_Migrations_Min_Fields>;
  stddev?: Maybe<Auth_Migrations_Stddev_Fields>;
  stddev_pop?: Maybe<Auth_Migrations_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Auth_Migrations_Stddev_Samp_Fields>;
  sum?: Maybe<Auth_Migrations_Sum_Fields>;
  var_pop?: Maybe<Auth_Migrations_Var_Pop_Fields>;
  var_samp?: Maybe<Auth_Migrations_Var_Samp_Fields>;
  variance?: Maybe<Auth_Migrations_Variance_Fields>;
};


/** aggregate fields of "auth.migrations" */
export type Auth_Migrations_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Auth_Migrations_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Auth_Migrations_Avg_Fields = {
  __typename?: 'auth_migrations_avg_fields';
  id?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "auth.migrations". All fields are combined with a logical 'AND'. */
export type Auth_Migrations_Bool_Exp = {
  _and?: InputMaybe<Array<Auth_Migrations_Bool_Exp>>;
  _not?: InputMaybe<Auth_Migrations_Bool_Exp>;
  _or?: InputMaybe<Array<Auth_Migrations_Bool_Exp>>;
  executed_at?: InputMaybe<Timestamp_Comparison_Exp>;
  hash?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Int_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "auth.migrations" */
export enum Auth_Migrations_Constraint {
  /** unique or primary key constraint on columns "name" */
  MigrationsNameKey = 'migrations_name_key',
  /** unique or primary key constraint on columns "id" */
  MigrationsPkey = 'migrations_pkey'
}

/** input type for incrementing numeric columns in table "auth.migrations" */
export type Auth_Migrations_Inc_Input = {
  id?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "auth.migrations" */
export type Auth_Migrations_Insert_Input = {
  executed_at?: InputMaybe<Scalars['timestamp']>;
  hash?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['Int']>;
  name?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Auth_Migrations_Max_Fields = {
  __typename?: 'auth_migrations_max_fields';
  executed_at?: Maybe<Scalars['timestamp']>;
  hash?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Auth_Migrations_Min_Fields = {
  __typename?: 'auth_migrations_min_fields';
  executed_at?: Maybe<Scalars['timestamp']>;
  hash?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "auth.migrations" */
export type Auth_Migrations_Mutation_Response = {
  __typename?: 'auth_migrations_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Auth_Migrations>;
};

/** on_conflict condition type for table "auth.migrations" */
export type Auth_Migrations_On_Conflict = {
  constraint: Auth_Migrations_Constraint;
  update_columns?: Array<Auth_Migrations_Update_Column>;
  where?: InputMaybe<Auth_Migrations_Bool_Exp>;
};

/** Ordering options when selecting data from "auth.migrations". */
export type Auth_Migrations_Order_By = {
  executed_at?: InputMaybe<Order_By>;
  hash?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
};

/** primary key columns input for table: auth.migrations */
export type Auth_Migrations_Pk_Columns_Input = {
  id: Scalars['Int'];
};

/** select columns of table "auth.migrations" */
export enum Auth_Migrations_Select_Column {
  /** column name */
  ExecutedAt = 'executed_at',
  /** column name */
  Hash = 'hash',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "auth.migrations" */
export type Auth_Migrations_Set_Input = {
  executed_at?: InputMaybe<Scalars['timestamp']>;
  hash?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['Int']>;
  name?: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type Auth_Migrations_Stddev_Fields = {
  __typename?: 'auth_migrations_stddev_fields';
  id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Auth_Migrations_Stddev_Pop_Fields = {
  __typename?: 'auth_migrations_stddev_pop_fields';
  id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Auth_Migrations_Stddev_Samp_Fields = {
  __typename?: 'auth_migrations_stddev_samp_fields';
  id?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "auth_migrations" */
export type Auth_Migrations_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Auth_Migrations_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Auth_Migrations_Stream_Cursor_Value_Input = {
  executed_at?: InputMaybe<Scalars['timestamp']>;
  hash?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['Int']>;
  name?: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type Auth_Migrations_Sum_Fields = {
  __typename?: 'auth_migrations_sum_fields';
  id?: Maybe<Scalars['Int']>;
};

/** update columns of table "auth.migrations" */
export enum Auth_Migrations_Update_Column {
  /** column name */
  ExecutedAt = 'executed_at',
  /** column name */
  Hash = 'hash',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name'
}

export type Auth_Migrations_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Auth_Migrations_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Auth_Migrations_Set_Input>;
  /** filter the rows which have to be updated */
  where: Auth_Migrations_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Auth_Migrations_Var_Pop_Fields = {
  __typename?: 'auth_migrations_var_pop_fields';
  id?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Auth_Migrations_Var_Samp_Fields = {
  __typename?: 'auth_migrations_var_samp_fields';
  id?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Auth_Migrations_Variance_Fields = {
  __typename?: 'auth_migrations_variance_fields';
  id?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "backups" */
export type Backups = {
  __typename?: 'backups';
  /** An object relationship */
  app: Apps;
  appId: Scalars['uuid'];
  completedAt?: Maybe<Scalars['timestamptz']>;
  createdAt: Scalars['timestamptz'];
  expiresAt?: Maybe<Scalars['timestamptz']>;
  id: Scalars['uuid'];
  size: Scalars['bigint'];
};

/** aggregated selection of "backups" */
export type Backups_Aggregate = {
  __typename?: 'backups_aggregate';
  aggregate?: Maybe<Backups_Aggregate_Fields>;
  nodes: Array<Backups>;
};

export type Backups_Aggregate_Bool_Exp = {
  count?: InputMaybe<Backups_Aggregate_Bool_Exp_Count>;
};

export type Backups_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Backups_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<Backups_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "backups" */
export type Backups_Aggregate_Fields = {
  __typename?: 'backups_aggregate_fields';
  avg?: Maybe<Backups_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Backups_Max_Fields>;
  min?: Maybe<Backups_Min_Fields>;
  stddev?: Maybe<Backups_Stddev_Fields>;
  stddev_pop?: Maybe<Backups_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Backups_Stddev_Samp_Fields>;
  sum?: Maybe<Backups_Sum_Fields>;
  var_pop?: Maybe<Backups_Var_Pop_Fields>;
  var_samp?: Maybe<Backups_Var_Samp_Fields>;
  variance?: Maybe<Backups_Variance_Fields>;
};


/** aggregate fields of "backups" */
export type Backups_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Backups_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "backups" */
export type Backups_Aggregate_Order_By = {
  avg?: InputMaybe<Backups_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Backups_Max_Order_By>;
  min?: InputMaybe<Backups_Min_Order_By>;
  stddev?: InputMaybe<Backups_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Backups_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Backups_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Backups_Sum_Order_By>;
  var_pop?: InputMaybe<Backups_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Backups_Var_Samp_Order_By>;
  variance?: InputMaybe<Backups_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "backups" */
export type Backups_Arr_Rel_Insert_Input = {
  data: Array<Backups_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Backups_On_Conflict>;
};

/** aggregate avg on columns */
export type Backups_Avg_Fields = {
  __typename?: 'backups_avg_fields';
  size?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "backups" */
export type Backups_Avg_Order_By = {
  size?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "backups". All fields are combined with a logical 'AND'. */
export type Backups_Bool_Exp = {
  _and?: InputMaybe<Array<Backups_Bool_Exp>>;
  _not?: InputMaybe<Backups_Bool_Exp>;
  _or?: InputMaybe<Array<Backups_Bool_Exp>>;
  app?: InputMaybe<Apps_Bool_Exp>;
  appId?: InputMaybe<Uuid_Comparison_Exp>;
  completedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  expiresAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  size?: InputMaybe<Bigint_Comparison_Exp>;
};

/** unique or primary key constraints on table "backups" */
export enum Backups_Constraint {
  /** unique or primary key constraint on columns "id" */
  BackupsPkey = 'backups_pkey'
}

/** input type for incrementing numeric columns in table "backups" */
export type Backups_Inc_Input = {
  size?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "backups" */
export type Backups_Insert_Input = {
  app?: InputMaybe<Apps_Obj_Rel_Insert_Input>;
  appId?: InputMaybe<Scalars['uuid']>;
  completedAt?: InputMaybe<Scalars['timestamptz']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  expiresAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  size?: InputMaybe<Scalars['bigint']>;
};

/** aggregate max on columns */
export type Backups_Max_Fields = {
  __typename?: 'backups_max_fields';
  appId?: Maybe<Scalars['uuid']>;
  completedAt?: Maybe<Scalars['timestamptz']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  expiresAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  size?: Maybe<Scalars['bigint']>;
};

/** order by max() on columns of table "backups" */
export type Backups_Max_Order_By = {
  appId?: InputMaybe<Order_By>;
  completedAt?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  expiresAt?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  size?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Backups_Min_Fields = {
  __typename?: 'backups_min_fields';
  appId?: Maybe<Scalars['uuid']>;
  completedAt?: Maybe<Scalars['timestamptz']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  expiresAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  size?: Maybe<Scalars['bigint']>;
};

/** order by min() on columns of table "backups" */
export type Backups_Min_Order_By = {
  appId?: InputMaybe<Order_By>;
  completedAt?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  expiresAt?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  size?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "backups" */
export type Backups_Mutation_Response = {
  __typename?: 'backups_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Backups>;
};

/** on_conflict condition type for table "backups" */
export type Backups_On_Conflict = {
  constraint: Backups_Constraint;
  update_columns?: Array<Backups_Update_Column>;
  where?: InputMaybe<Backups_Bool_Exp>;
};

/** Ordering options when selecting data from "backups". */
export type Backups_Order_By = {
  app?: InputMaybe<Apps_Order_By>;
  appId?: InputMaybe<Order_By>;
  completedAt?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  expiresAt?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  size?: InputMaybe<Order_By>;
};

/** primary key columns input for table: backups */
export type Backups_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "backups" */
export enum Backups_Select_Column {
  /** column name */
  AppId = 'appId',
  /** column name */
  CompletedAt = 'completedAt',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  ExpiresAt = 'expiresAt',
  /** column name */
  Id = 'id',
  /** column name */
  Size = 'size'
}

/** input type for updating data in table "backups" */
export type Backups_Set_Input = {
  appId?: InputMaybe<Scalars['uuid']>;
  completedAt?: InputMaybe<Scalars['timestamptz']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  expiresAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  size?: InputMaybe<Scalars['bigint']>;
};

/** aggregate stddev on columns */
export type Backups_Stddev_Fields = {
  __typename?: 'backups_stddev_fields';
  size?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "backups" */
export type Backups_Stddev_Order_By = {
  size?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Backups_Stddev_Pop_Fields = {
  __typename?: 'backups_stddev_pop_fields';
  size?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "backups" */
export type Backups_Stddev_Pop_Order_By = {
  size?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Backups_Stddev_Samp_Fields = {
  __typename?: 'backups_stddev_samp_fields';
  size?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "backups" */
export type Backups_Stddev_Samp_Order_By = {
  size?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "backups" */
export type Backups_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Backups_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Backups_Stream_Cursor_Value_Input = {
  appId?: InputMaybe<Scalars['uuid']>;
  completedAt?: InputMaybe<Scalars['timestamptz']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  expiresAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  size?: InputMaybe<Scalars['bigint']>;
};

/** aggregate sum on columns */
export type Backups_Sum_Fields = {
  __typename?: 'backups_sum_fields';
  size?: Maybe<Scalars['bigint']>;
};

/** order by sum() on columns of table "backups" */
export type Backups_Sum_Order_By = {
  size?: InputMaybe<Order_By>;
};

/** update columns of table "backups" */
export enum Backups_Update_Column {
  /** column name */
  AppId = 'appId',
  /** column name */
  CompletedAt = 'completedAt',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  ExpiresAt = 'expiresAt',
  /** column name */
  Id = 'id',
  /** column name */
  Size = 'size'
}

export type Backups_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Backups_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Backups_Set_Input>;
  /** filter the rows which have to be updated */
  where: Backups_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Backups_Var_Pop_Fields = {
  __typename?: 'backups_var_pop_fields';
  size?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "backups" */
export type Backups_Var_Pop_Order_By = {
  size?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Backups_Var_Samp_Fields = {
  __typename?: 'backups_var_samp_fields';
  size?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "backups" */
export type Backups_Var_Samp_Order_By = {
  size?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Backups_Variance_Fields = {
  __typename?: 'backups_variance_fields';
  size?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "backups" */
export type Backups_Variance_Order_By = {
  size?: InputMaybe<Order_By>;
};

/** Boolean expression to compare columns of type "bigint". All fields are combined with logical 'AND'. */
export type Bigint_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['bigint']>;
  _gt?: InputMaybe<Scalars['bigint']>;
  _gte?: InputMaybe<Scalars['bigint']>;
  _in?: InputMaybe<Array<Scalars['bigint']>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _lt?: InputMaybe<Scalars['bigint']>;
  _lte?: InputMaybe<Scalars['bigint']>;
  _neq?: InputMaybe<Scalars['bigint']>;
  _nin?: InputMaybe<Array<Scalars['bigint']>>;
};

/** columns and relationships of "billing.dedicated_compute" */
export type Billing_Dedicated_Compute = {
  __typename?: 'billing_dedicated_compute';
  /** An object relationship */
  app?: Maybe<Apps>;
  appID: Scalars['uuid'];
  createdAt: Scalars['timestamptz'];
  id: Scalars['uuid'];
  totalMillicores: Scalars['Int'];
  updatedAt: Scalars['timestamptz'];
};

/** aggregated selection of "billing.dedicated_compute" */
export type Billing_Dedicated_Compute_Aggregate = {
  __typename?: 'billing_dedicated_compute_aggregate';
  aggregate?: Maybe<Billing_Dedicated_Compute_Aggregate_Fields>;
  nodes: Array<Billing_Dedicated_Compute>;
};

/** aggregate fields of "billing.dedicated_compute" */
export type Billing_Dedicated_Compute_Aggregate_Fields = {
  __typename?: 'billing_dedicated_compute_aggregate_fields';
  avg?: Maybe<Billing_Dedicated_Compute_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Billing_Dedicated_Compute_Max_Fields>;
  min?: Maybe<Billing_Dedicated_Compute_Min_Fields>;
  stddev?: Maybe<Billing_Dedicated_Compute_Stddev_Fields>;
  stddev_pop?: Maybe<Billing_Dedicated_Compute_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Billing_Dedicated_Compute_Stddev_Samp_Fields>;
  sum?: Maybe<Billing_Dedicated_Compute_Sum_Fields>;
  var_pop?: Maybe<Billing_Dedicated_Compute_Var_Pop_Fields>;
  var_samp?: Maybe<Billing_Dedicated_Compute_Var_Samp_Fields>;
  variance?: Maybe<Billing_Dedicated_Compute_Variance_Fields>;
};


/** aggregate fields of "billing.dedicated_compute" */
export type Billing_Dedicated_Compute_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Billing_Dedicated_Compute_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Billing_Dedicated_Compute_Avg_Fields = {
  __typename?: 'billing_dedicated_compute_avg_fields';
  totalMillicores?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "billing.dedicated_compute". All fields are combined with a logical 'AND'. */
export type Billing_Dedicated_Compute_Bool_Exp = {
  _and?: InputMaybe<Array<Billing_Dedicated_Compute_Bool_Exp>>;
  _not?: InputMaybe<Billing_Dedicated_Compute_Bool_Exp>;
  _or?: InputMaybe<Array<Billing_Dedicated_Compute_Bool_Exp>>;
  app?: InputMaybe<Apps_Bool_Exp>;
  appID?: InputMaybe<Uuid_Comparison_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  totalMillicores?: InputMaybe<Int_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "billing.dedicated_compute" */
export enum Billing_Dedicated_Compute_Constraint {
  /** unique or primary key constraint on columns "app_id" */
  DedicatedComputeAppIdKey = 'dedicated_compute_app_id_key',
  /** unique or primary key constraint on columns "id" */
  DedicatedComputePkey = 'dedicated_compute_pkey'
}

/** input type for incrementing numeric columns in table "billing.dedicated_compute" */
export type Billing_Dedicated_Compute_Inc_Input = {
  totalMillicores?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "billing.dedicated_compute" */
export type Billing_Dedicated_Compute_Insert_Input = {
  app?: InputMaybe<Apps_Obj_Rel_Insert_Input>;
  appID?: InputMaybe<Scalars['uuid']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  totalMillicores?: InputMaybe<Scalars['Int']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Billing_Dedicated_Compute_Max_Fields = {
  __typename?: 'billing_dedicated_compute_max_fields';
  appID?: Maybe<Scalars['uuid']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  totalMillicores?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Billing_Dedicated_Compute_Min_Fields = {
  __typename?: 'billing_dedicated_compute_min_fields';
  appID?: Maybe<Scalars['uuid']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  totalMillicores?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "billing.dedicated_compute" */
export type Billing_Dedicated_Compute_Mutation_Response = {
  __typename?: 'billing_dedicated_compute_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Billing_Dedicated_Compute>;
};

/** input type for inserting object relation for remote table "billing.dedicated_compute" */
export type Billing_Dedicated_Compute_Obj_Rel_Insert_Input = {
  data: Billing_Dedicated_Compute_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Billing_Dedicated_Compute_On_Conflict>;
};

/** on_conflict condition type for table "billing.dedicated_compute" */
export type Billing_Dedicated_Compute_On_Conflict = {
  constraint: Billing_Dedicated_Compute_Constraint;
  update_columns?: Array<Billing_Dedicated_Compute_Update_Column>;
  where?: InputMaybe<Billing_Dedicated_Compute_Bool_Exp>;
};

/** Ordering options when selecting data from "billing.dedicated_compute". */
export type Billing_Dedicated_Compute_Order_By = {
  app?: InputMaybe<Apps_Order_By>;
  appID?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  totalMillicores?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
};

/** primary key columns input for table: billing.dedicated_compute */
export type Billing_Dedicated_Compute_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** columns and relationships of "billing.dedicated_compute_reports" */
export type Billing_Dedicated_Compute_Reports = {
  __typename?: 'billing_dedicated_compute_reports';
  /** An object relationship */
  app?: Maybe<Apps>;
  app_id: Scalars['uuid'];
  created_at: Scalars['timestamptz'];
  id: Scalars['uuid'];
  pending: Scalars['Boolean'];
  report_ends: Scalars['timestamptz'];
  report_starts: Scalars['timestamptz'];
  total_millicores: Scalars['Int'];
  updated_at: Scalars['timestamptz'];
};

/** aggregated selection of "billing.dedicated_compute_reports" */
export type Billing_Dedicated_Compute_Reports_Aggregate = {
  __typename?: 'billing_dedicated_compute_reports_aggregate';
  aggregate?: Maybe<Billing_Dedicated_Compute_Reports_Aggregate_Fields>;
  nodes: Array<Billing_Dedicated_Compute_Reports>;
};

/** aggregate fields of "billing.dedicated_compute_reports" */
export type Billing_Dedicated_Compute_Reports_Aggregate_Fields = {
  __typename?: 'billing_dedicated_compute_reports_aggregate_fields';
  avg?: Maybe<Billing_Dedicated_Compute_Reports_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Billing_Dedicated_Compute_Reports_Max_Fields>;
  min?: Maybe<Billing_Dedicated_Compute_Reports_Min_Fields>;
  stddev?: Maybe<Billing_Dedicated_Compute_Reports_Stddev_Fields>;
  stddev_pop?: Maybe<Billing_Dedicated_Compute_Reports_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Billing_Dedicated_Compute_Reports_Stddev_Samp_Fields>;
  sum?: Maybe<Billing_Dedicated_Compute_Reports_Sum_Fields>;
  var_pop?: Maybe<Billing_Dedicated_Compute_Reports_Var_Pop_Fields>;
  var_samp?: Maybe<Billing_Dedicated_Compute_Reports_Var_Samp_Fields>;
  variance?: Maybe<Billing_Dedicated_Compute_Reports_Variance_Fields>;
};


/** aggregate fields of "billing.dedicated_compute_reports" */
export type Billing_Dedicated_Compute_Reports_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Billing_Dedicated_Compute_Reports_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Billing_Dedicated_Compute_Reports_Avg_Fields = {
  __typename?: 'billing_dedicated_compute_reports_avg_fields';
  total_millicores?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "billing.dedicated_compute_reports". All fields are combined with a logical 'AND'. */
export type Billing_Dedicated_Compute_Reports_Bool_Exp = {
  _and?: InputMaybe<Array<Billing_Dedicated_Compute_Reports_Bool_Exp>>;
  _not?: InputMaybe<Billing_Dedicated_Compute_Reports_Bool_Exp>;
  _or?: InputMaybe<Array<Billing_Dedicated_Compute_Reports_Bool_Exp>>;
  app?: InputMaybe<Apps_Bool_Exp>;
  app_id?: InputMaybe<Uuid_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  pending?: InputMaybe<Boolean_Comparison_Exp>;
  report_ends?: InputMaybe<Timestamptz_Comparison_Exp>;
  report_starts?: InputMaybe<Timestamptz_Comparison_Exp>;
  total_millicores?: InputMaybe<Int_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "billing.dedicated_compute_reports" */
export enum Billing_Dedicated_Compute_Reports_Constraint {
  /** unique or primary key constraint on columns "id" */
  DedicatedComputeReportsPkey = 'dedicated_compute_reports_pkey'
}

/** input type for incrementing numeric columns in table "billing.dedicated_compute_reports" */
export type Billing_Dedicated_Compute_Reports_Inc_Input = {
  total_millicores?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "billing.dedicated_compute_reports" */
export type Billing_Dedicated_Compute_Reports_Insert_Input = {
  app?: InputMaybe<Apps_Obj_Rel_Insert_Input>;
  app_id?: InputMaybe<Scalars['uuid']>;
  created_at?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  pending?: InputMaybe<Scalars['Boolean']>;
  report_ends?: InputMaybe<Scalars['timestamptz']>;
  report_starts?: InputMaybe<Scalars['timestamptz']>;
  total_millicores?: InputMaybe<Scalars['Int']>;
  updated_at?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Billing_Dedicated_Compute_Reports_Max_Fields = {
  __typename?: 'billing_dedicated_compute_reports_max_fields';
  app_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  report_ends?: Maybe<Scalars['timestamptz']>;
  report_starts?: Maybe<Scalars['timestamptz']>;
  total_millicores?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Billing_Dedicated_Compute_Reports_Min_Fields = {
  __typename?: 'billing_dedicated_compute_reports_min_fields';
  app_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  report_ends?: Maybe<Scalars['timestamptz']>;
  report_starts?: Maybe<Scalars['timestamptz']>;
  total_millicores?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "billing.dedicated_compute_reports" */
export type Billing_Dedicated_Compute_Reports_Mutation_Response = {
  __typename?: 'billing_dedicated_compute_reports_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Billing_Dedicated_Compute_Reports>;
};

/** input type for inserting object relation for remote table "billing.dedicated_compute_reports" */
export type Billing_Dedicated_Compute_Reports_Obj_Rel_Insert_Input = {
  data: Billing_Dedicated_Compute_Reports_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Billing_Dedicated_Compute_Reports_On_Conflict>;
};

/** on_conflict condition type for table "billing.dedicated_compute_reports" */
export type Billing_Dedicated_Compute_Reports_On_Conflict = {
  constraint: Billing_Dedicated_Compute_Reports_Constraint;
  update_columns?: Array<Billing_Dedicated_Compute_Reports_Update_Column>;
  where?: InputMaybe<Billing_Dedicated_Compute_Reports_Bool_Exp>;
};

/** Ordering options when selecting data from "billing.dedicated_compute_reports". */
export type Billing_Dedicated_Compute_Reports_Order_By = {
  app?: InputMaybe<Apps_Order_By>;
  app_id?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  pending?: InputMaybe<Order_By>;
  report_ends?: InputMaybe<Order_By>;
  report_starts?: InputMaybe<Order_By>;
  total_millicores?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: billing.dedicated_compute_reports */
export type Billing_Dedicated_Compute_Reports_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "billing.dedicated_compute_reports" */
export enum Billing_Dedicated_Compute_Reports_Select_Column {
  /** column name */
  AppId = 'app_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  Pending = 'pending',
  /** column name */
  ReportEnds = 'report_ends',
  /** column name */
  ReportStarts = 'report_starts',
  /** column name */
  TotalMillicores = 'total_millicores',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "billing.dedicated_compute_reports" */
export type Billing_Dedicated_Compute_Reports_Set_Input = {
  app_id?: InputMaybe<Scalars['uuid']>;
  created_at?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  pending?: InputMaybe<Scalars['Boolean']>;
  report_ends?: InputMaybe<Scalars['timestamptz']>;
  report_starts?: InputMaybe<Scalars['timestamptz']>;
  total_millicores?: InputMaybe<Scalars['Int']>;
  updated_at?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Billing_Dedicated_Compute_Reports_Stddev_Fields = {
  __typename?: 'billing_dedicated_compute_reports_stddev_fields';
  total_millicores?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Billing_Dedicated_Compute_Reports_Stddev_Pop_Fields = {
  __typename?: 'billing_dedicated_compute_reports_stddev_pop_fields';
  total_millicores?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Billing_Dedicated_Compute_Reports_Stddev_Samp_Fields = {
  __typename?: 'billing_dedicated_compute_reports_stddev_samp_fields';
  total_millicores?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "billing_dedicated_compute_reports" */
export type Billing_Dedicated_Compute_Reports_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Billing_Dedicated_Compute_Reports_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Billing_Dedicated_Compute_Reports_Stream_Cursor_Value_Input = {
  app_id?: InputMaybe<Scalars['uuid']>;
  created_at?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  pending?: InputMaybe<Scalars['Boolean']>;
  report_ends?: InputMaybe<Scalars['timestamptz']>;
  report_starts?: InputMaybe<Scalars['timestamptz']>;
  total_millicores?: InputMaybe<Scalars['Int']>;
  updated_at?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate sum on columns */
export type Billing_Dedicated_Compute_Reports_Sum_Fields = {
  __typename?: 'billing_dedicated_compute_reports_sum_fields';
  total_millicores?: Maybe<Scalars['Int']>;
};

/** update columns of table "billing.dedicated_compute_reports" */
export enum Billing_Dedicated_Compute_Reports_Update_Column {
  /** column name */
  AppId = 'app_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  Pending = 'pending',
  /** column name */
  ReportEnds = 'report_ends',
  /** column name */
  ReportStarts = 'report_starts',
  /** column name */
  TotalMillicores = 'total_millicores',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Billing_Dedicated_Compute_Reports_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Billing_Dedicated_Compute_Reports_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Billing_Dedicated_Compute_Reports_Set_Input>;
  /** filter the rows which have to be updated */
  where: Billing_Dedicated_Compute_Reports_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Billing_Dedicated_Compute_Reports_Var_Pop_Fields = {
  __typename?: 'billing_dedicated_compute_reports_var_pop_fields';
  total_millicores?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Billing_Dedicated_Compute_Reports_Var_Samp_Fields = {
  __typename?: 'billing_dedicated_compute_reports_var_samp_fields';
  total_millicores?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Billing_Dedicated_Compute_Reports_Variance_Fields = {
  __typename?: 'billing_dedicated_compute_reports_variance_fields';
  total_millicores?: Maybe<Scalars['Float']>;
};

/** select columns of table "billing.dedicated_compute" */
export enum Billing_Dedicated_Compute_Select_Column {
  /** column name */
  AppId = 'appID',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  TotalMillicores = 'totalMillicores',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "billing.dedicated_compute" */
export type Billing_Dedicated_Compute_Set_Input = {
  appID?: InputMaybe<Scalars['uuid']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  totalMillicores?: InputMaybe<Scalars['Int']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Billing_Dedicated_Compute_Stddev_Fields = {
  __typename?: 'billing_dedicated_compute_stddev_fields';
  totalMillicores?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Billing_Dedicated_Compute_Stddev_Pop_Fields = {
  __typename?: 'billing_dedicated_compute_stddev_pop_fields';
  totalMillicores?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Billing_Dedicated_Compute_Stddev_Samp_Fields = {
  __typename?: 'billing_dedicated_compute_stddev_samp_fields';
  totalMillicores?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "billing_dedicated_compute" */
export type Billing_Dedicated_Compute_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Billing_Dedicated_Compute_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Billing_Dedicated_Compute_Stream_Cursor_Value_Input = {
  appID?: InputMaybe<Scalars['uuid']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  totalMillicores?: InputMaybe<Scalars['Int']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate sum on columns */
export type Billing_Dedicated_Compute_Sum_Fields = {
  __typename?: 'billing_dedicated_compute_sum_fields';
  totalMillicores?: Maybe<Scalars['Int']>;
};

/** update columns of table "billing.dedicated_compute" */
export enum Billing_Dedicated_Compute_Update_Column {
  /** column name */
  AppId = 'appID',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  TotalMillicores = 'totalMillicores',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type Billing_Dedicated_Compute_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Billing_Dedicated_Compute_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Billing_Dedicated_Compute_Set_Input>;
  /** filter the rows which have to be updated */
  where: Billing_Dedicated_Compute_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Billing_Dedicated_Compute_Var_Pop_Fields = {
  __typename?: 'billing_dedicated_compute_var_pop_fields';
  totalMillicores?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Billing_Dedicated_Compute_Var_Samp_Fields = {
  __typename?: 'billing_dedicated_compute_var_samp_fields';
  totalMillicores?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Billing_Dedicated_Compute_Variance_Fields = {
  __typename?: 'billing_dedicated_compute_variance_fields';
  totalMillicores?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "billing.report_type" */
export type Billing_Report_Type = {
  __typename?: 'billing_report_type';
  comment?: Maybe<Scalars['String']>;
  value: Scalars['String'];
};

/** aggregated selection of "billing.report_type" */
export type Billing_Report_Type_Aggregate = {
  __typename?: 'billing_report_type_aggregate';
  aggregate?: Maybe<Billing_Report_Type_Aggregate_Fields>;
  nodes: Array<Billing_Report_Type>;
};

/** aggregate fields of "billing.report_type" */
export type Billing_Report_Type_Aggregate_Fields = {
  __typename?: 'billing_report_type_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Billing_Report_Type_Max_Fields>;
  min?: Maybe<Billing_Report_Type_Min_Fields>;
};


/** aggregate fields of "billing.report_type" */
export type Billing_Report_Type_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Billing_Report_Type_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "billing.report_type". All fields are combined with a logical 'AND'. */
export type Billing_Report_Type_Bool_Exp = {
  _and?: InputMaybe<Array<Billing_Report_Type_Bool_Exp>>;
  _not?: InputMaybe<Billing_Report_Type_Bool_Exp>;
  _or?: InputMaybe<Array<Billing_Report_Type_Bool_Exp>>;
  comment?: InputMaybe<String_Comparison_Exp>;
  value?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "billing.report_type" */
export enum Billing_Report_Type_Constraint {
  /** unique or primary key constraint on columns "value" */
  ReportTypePkey = 'report_type_pkey'
}

export enum Billing_Report_Type_Enum {
  /** Dedicated compute */
  DedicatedCompute = 'dedicated_compute',
  /** Egress usage in MB */
  Egress = 'egress',
  /** Functions usage in seconds */
  Functions = 'functions'
}

/** Boolean expression to compare columns of type "billing_report_type_enum". All fields are combined with logical 'AND'. */
export type Billing_Report_Type_Enum_Comparison_Exp = {
  _eq?: InputMaybe<Billing_Report_Type_Enum>;
  _in?: InputMaybe<Array<Billing_Report_Type_Enum>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<Billing_Report_Type_Enum>;
  _nin?: InputMaybe<Array<Billing_Report_Type_Enum>>;
};

/** input type for inserting data into table "billing.report_type" */
export type Billing_Report_Type_Insert_Input = {
  comment?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Billing_Report_Type_Max_Fields = {
  __typename?: 'billing_report_type_max_fields';
  comment?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Billing_Report_Type_Min_Fields = {
  __typename?: 'billing_report_type_min_fields';
  comment?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "billing.report_type" */
export type Billing_Report_Type_Mutation_Response = {
  __typename?: 'billing_report_type_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Billing_Report_Type>;
};

/** on_conflict condition type for table "billing.report_type" */
export type Billing_Report_Type_On_Conflict = {
  constraint: Billing_Report_Type_Constraint;
  update_columns?: Array<Billing_Report_Type_Update_Column>;
  where?: InputMaybe<Billing_Report_Type_Bool_Exp>;
};

/** Ordering options when selecting data from "billing.report_type". */
export type Billing_Report_Type_Order_By = {
  comment?: InputMaybe<Order_By>;
  value?: InputMaybe<Order_By>;
};

/** primary key columns input for table: billing.report_type */
export type Billing_Report_Type_Pk_Columns_Input = {
  value: Scalars['String'];
};

/** select columns of table "billing.report_type" */
export enum Billing_Report_Type_Select_Column {
  /** column name */
  Comment = 'comment',
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "billing.report_type" */
export type Billing_Report_Type_Set_Input = {
  comment?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "billing_report_type" */
export type Billing_Report_Type_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Billing_Report_Type_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Billing_Report_Type_Stream_Cursor_Value_Input = {
  comment?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** update columns of table "billing.report_type" */
export enum Billing_Report_Type_Update_Column {
  /** column name */
  Comment = 'comment',
  /** column name */
  Value = 'value'
}

export type Billing_Report_Type_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Billing_Report_Type_Set_Input>;
  /** filter the rows which have to be updated */
  where: Billing_Report_Type_Bool_Exp;
};

/** columns and relationships of "billing.reports" */
export type Billing_Reports = {
  __typename?: 'billing_reports';
  appID: Scalars['uuid'];
  createdAt: Scalars['timestamptz'];
  id: Scalars['uuid'];
  pending: Scalars['Boolean'];
  reportEnds: Scalars['timestamptz'];
  reportStarts: Scalars['timestamptz'];
  type: Billing_Report_Type_Enum;
  updatedAt: Scalars['timestamptz'];
  value: Scalars['Int'];
};

/** aggregated selection of "billing.reports" */
export type Billing_Reports_Aggregate = {
  __typename?: 'billing_reports_aggregate';
  aggregate?: Maybe<Billing_Reports_Aggregate_Fields>;
  nodes: Array<Billing_Reports>;
};

export type Billing_Reports_Aggregate_Bool_Exp = {
  bool_and?: InputMaybe<Billing_Reports_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: InputMaybe<Billing_Reports_Aggregate_Bool_Exp_Bool_Or>;
  count?: InputMaybe<Billing_Reports_Aggregate_Bool_Exp_Count>;
};

export type Billing_Reports_Aggregate_Bool_Exp_Bool_And = {
  arguments: Billing_Reports_Select_Column_Billing_Reports_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<Billing_Reports_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Billing_Reports_Aggregate_Bool_Exp_Bool_Or = {
  arguments: Billing_Reports_Select_Column_Billing_Reports_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<Billing_Reports_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Billing_Reports_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Billing_Reports_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<Billing_Reports_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "billing.reports" */
export type Billing_Reports_Aggregate_Fields = {
  __typename?: 'billing_reports_aggregate_fields';
  avg?: Maybe<Billing_Reports_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Billing_Reports_Max_Fields>;
  min?: Maybe<Billing_Reports_Min_Fields>;
  stddev?: Maybe<Billing_Reports_Stddev_Fields>;
  stddev_pop?: Maybe<Billing_Reports_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Billing_Reports_Stddev_Samp_Fields>;
  sum?: Maybe<Billing_Reports_Sum_Fields>;
  var_pop?: Maybe<Billing_Reports_Var_Pop_Fields>;
  var_samp?: Maybe<Billing_Reports_Var_Samp_Fields>;
  variance?: Maybe<Billing_Reports_Variance_Fields>;
};


/** aggregate fields of "billing.reports" */
export type Billing_Reports_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Billing_Reports_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "billing.reports" */
export type Billing_Reports_Aggregate_Order_By = {
  avg?: InputMaybe<Billing_Reports_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Billing_Reports_Max_Order_By>;
  min?: InputMaybe<Billing_Reports_Min_Order_By>;
  stddev?: InputMaybe<Billing_Reports_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Billing_Reports_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Billing_Reports_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Billing_Reports_Sum_Order_By>;
  var_pop?: InputMaybe<Billing_Reports_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Billing_Reports_Var_Samp_Order_By>;
  variance?: InputMaybe<Billing_Reports_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "billing.reports" */
export type Billing_Reports_Arr_Rel_Insert_Input = {
  data: Array<Billing_Reports_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Billing_Reports_On_Conflict>;
};

/** aggregate avg on columns */
export type Billing_Reports_Avg_Fields = {
  __typename?: 'billing_reports_avg_fields';
  value?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "billing.reports" */
export type Billing_Reports_Avg_Order_By = {
  value?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "billing.reports". All fields are combined with a logical 'AND'. */
export type Billing_Reports_Bool_Exp = {
  _and?: InputMaybe<Array<Billing_Reports_Bool_Exp>>;
  _not?: InputMaybe<Billing_Reports_Bool_Exp>;
  _or?: InputMaybe<Array<Billing_Reports_Bool_Exp>>;
  appID?: InputMaybe<Uuid_Comparison_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  pending?: InputMaybe<Boolean_Comparison_Exp>;
  reportEnds?: InputMaybe<Timestamptz_Comparison_Exp>;
  reportStarts?: InputMaybe<Timestamptz_Comparison_Exp>;
  type?: InputMaybe<Billing_Report_Type_Enum_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  value?: InputMaybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "billing.reports" */
export enum Billing_Reports_Constraint {
  /** unique or primary key constraint on columns "id" */
  ReportsPkey = 'reports_pkey'
}

/** input type for incrementing numeric columns in table "billing.reports" */
export type Billing_Reports_Inc_Input = {
  value?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "billing.reports" */
export type Billing_Reports_Insert_Input = {
  appID?: InputMaybe<Scalars['uuid']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  pending?: InputMaybe<Scalars['Boolean']>;
  reportEnds?: InputMaybe<Scalars['timestamptz']>;
  reportStarts?: InputMaybe<Scalars['timestamptz']>;
  type?: InputMaybe<Billing_Report_Type_Enum>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  value?: InputMaybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type Billing_Reports_Max_Fields = {
  __typename?: 'billing_reports_max_fields';
  appID?: Maybe<Scalars['uuid']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  reportEnds?: Maybe<Scalars['timestamptz']>;
  reportStarts?: Maybe<Scalars['timestamptz']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  value?: Maybe<Scalars['Int']>;
};

/** order by max() on columns of table "billing.reports" */
export type Billing_Reports_Max_Order_By = {
  appID?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  reportEnds?: InputMaybe<Order_By>;
  reportStarts?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  value?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Billing_Reports_Min_Fields = {
  __typename?: 'billing_reports_min_fields';
  appID?: Maybe<Scalars['uuid']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  reportEnds?: Maybe<Scalars['timestamptz']>;
  reportStarts?: Maybe<Scalars['timestamptz']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  value?: Maybe<Scalars['Int']>;
};

/** order by min() on columns of table "billing.reports" */
export type Billing_Reports_Min_Order_By = {
  appID?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  reportEnds?: InputMaybe<Order_By>;
  reportStarts?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  value?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "billing.reports" */
export type Billing_Reports_Mutation_Response = {
  __typename?: 'billing_reports_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Billing_Reports>;
};

/** on_conflict condition type for table "billing.reports" */
export type Billing_Reports_On_Conflict = {
  constraint: Billing_Reports_Constraint;
  update_columns?: Array<Billing_Reports_Update_Column>;
  where?: InputMaybe<Billing_Reports_Bool_Exp>;
};

/** Ordering options when selecting data from "billing.reports". */
export type Billing_Reports_Order_By = {
  appID?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  pending?: InputMaybe<Order_By>;
  reportEnds?: InputMaybe<Order_By>;
  reportStarts?: InputMaybe<Order_By>;
  type?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  value?: InputMaybe<Order_By>;
};

/** primary key columns input for table: billing.reports */
export type Billing_Reports_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "billing.reports" */
export enum Billing_Reports_Select_Column {
  /** column name */
  AppId = 'appID',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  Pending = 'pending',
  /** column name */
  ReportEnds = 'reportEnds',
  /** column name */
  ReportStarts = 'reportStarts',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  Value = 'value'
}

/** select "billing_reports_aggregate_bool_exp_bool_and_arguments_columns" columns of table "billing.reports" */
export enum Billing_Reports_Select_Column_Billing_Reports_Aggregate_Bool_Exp_Bool_And_Arguments_Columns {
  /** column name */
  Pending = 'pending'
}

/** select "billing_reports_aggregate_bool_exp_bool_or_arguments_columns" columns of table "billing.reports" */
export enum Billing_Reports_Select_Column_Billing_Reports_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns {
  /** column name */
  Pending = 'pending'
}

/** input type for updating data in table "billing.reports" */
export type Billing_Reports_Set_Input = {
  appID?: InputMaybe<Scalars['uuid']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  pending?: InputMaybe<Scalars['Boolean']>;
  reportEnds?: InputMaybe<Scalars['timestamptz']>;
  reportStarts?: InputMaybe<Scalars['timestamptz']>;
  type?: InputMaybe<Billing_Report_Type_Enum>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  value?: InputMaybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type Billing_Reports_Stddev_Fields = {
  __typename?: 'billing_reports_stddev_fields';
  value?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "billing.reports" */
export type Billing_Reports_Stddev_Order_By = {
  value?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Billing_Reports_Stddev_Pop_Fields = {
  __typename?: 'billing_reports_stddev_pop_fields';
  value?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "billing.reports" */
export type Billing_Reports_Stddev_Pop_Order_By = {
  value?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Billing_Reports_Stddev_Samp_Fields = {
  __typename?: 'billing_reports_stddev_samp_fields';
  value?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "billing.reports" */
export type Billing_Reports_Stddev_Samp_Order_By = {
  value?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "billing_reports" */
export type Billing_Reports_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Billing_Reports_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Billing_Reports_Stream_Cursor_Value_Input = {
  appID?: InputMaybe<Scalars['uuid']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  pending?: InputMaybe<Scalars['Boolean']>;
  reportEnds?: InputMaybe<Scalars['timestamptz']>;
  reportStarts?: InputMaybe<Scalars['timestamptz']>;
  type?: InputMaybe<Billing_Report_Type_Enum>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  value?: InputMaybe<Scalars['Int']>;
};

/** aggregate sum on columns */
export type Billing_Reports_Sum_Fields = {
  __typename?: 'billing_reports_sum_fields';
  value?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "billing.reports" */
export type Billing_Reports_Sum_Order_By = {
  value?: InputMaybe<Order_By>;
};

/** update columns of table "billing.reports" */
export enum Billing_Reports_Update_Column {
  /** column name */
  AppId = 'appID',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  Pending = 'pending',
  /** column name */
  ReportEnds = 'reportEnds',
  /** column name */
  ReportStarts = 'reportStarts',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  Value = 'value'
}

export type Billing_Reports_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Billing_Reports_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Billing_Reports_Set_Input>;
  /** filter the rows which have to be updated */
  where: Billing_Reports_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Billing_Reports_Var_Pop_Fields = {
  __typename?: 'billing_reports_var_pop_fields';
  value?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "billing.reports" */
export type Billing_Reports_Var_Pop_Order_By = {
  value?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Billing_Reports_Var_Samp_Fields = {
  __typename?: 'billing_reports_var_samp_fields';
  value?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "billing.reports" */
export type Billing_Reports_Var_Samp_Order_By = {
  value?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Billing_Reports_Variance_Fields = {
  __typename?: 'billing_reports_variance_fields';
  value?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "billing.reports" */
export type Billing_Reports_Variance_Order_By = {
  value?: InputMaybe<Order_By>;
};

/** columns and relationships of "billing.resources" */
export type Billing_Resources = {
  __typename?: 'billing_resources';
  appID: Scalars['uuid'];
  createdAt: Scalars['timestamptz'];
  customDomains: Scalars['Int'];
  functionsAmount: Scalars['Int'];
  id: Scalars['uuid'];
  persistentVolume: Scalars['Int'];
  updatedAt: Scalars['timestamptz'];
};

/** aggregated selection of "billing.resources" */
export type Billing_Resources_Aggregate = {
  __typename?: 'billing_resources_aggregate';
  aggregate?: Maybe<Billing_Resources_Aggregate_Fields>;
  nodes: Array<Billing_Resources>;
};

/** aggregate fields of "billing.resources" */
export type Billing_Resources_Aggregate_Fields = {
  __typename?: 'billing_resources_aggregate_fields';
  avg?: Maybe<Billing_Resources_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Billing_Resources_Max_Fields>;
  min?: Maybe<Billing_Resources_Min_Fields>;
  stddev?: Maybe<Billing_Resources_Stddev_Fields>;
  stddev_pop?: Maybe<Billing_Resources_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Billing_Resources_Stddev_Samp_Fields>;
  sum?: Maybe<Billing_Resources_Sum_Fields>;
  var_pop?: Maybe<Billing_Resources_Var_Pop_Fields>;
  var_samp?: Maybe<Billing_Resources_Var_Samp_Fields>;
  variance?: Maybe<Billing_Resources_Variance_Fields>;
};


/** aggregate fields of "billing.resources" */
export type Billing_Resources_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Billing_Resources_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Billing_Resources_Avg_Fields = {
  __typename?: 'billing_resources_avg_fields';
  customDomains?: Maybe<Scalars['Float']>;
  functionsAmount?: Maybe<Scalars['Float']>;
  persistentVolume?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "billing.resources". All fields are combined with a logical 'AND'. */
export type Billing_Resources_Bool_Exp = {
  _and?: InputMaybe<Array<Billing_Resources_Bool_Exp>>;
  _not?: InputMaybe<Billing_Resources_Bool_Exp>;
  _or?: InputMaybe<Array<Billing_Resources_Bool_Exp>>;
  appID?: InputMaybe<Uuid_Comparison_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  customDomains?: InputMaybe<Int_Comparison_Exp>;
  functionsAmount?: InputMaybe<Int_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  persistentVolume?: InputMaybe<Int_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "billing.resources" */
export enum Billing_Resources_Constraint {
  /** unique or primary key constraint on columns "app_id" */
  ResourcesAppIdKey = 'resources_app_id_key',
  /** unique or primary key constraint on columns "id" */
  ResourcesPkey = 'resources_pkey'
}

/** input type for incrementing numeric columns in table "billing.resources" */
export type Billing_Resources_Inc_Input = {
  customDomains?: InputMaybe<Scalars['Int']>;
  functionsAmount?: InputMaybe<Scalars['Int']>;
  persistentVolume?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "billing.resources" */
export type Billing_Resources_Insert_Input = {
  appID?: InputMaybe<Scalars['uuid']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  customDomains?: InputMaybe<Scalars['Int']>;
  functionsAmount?: InputMaybe<Scalars['Int']>;
  id?: InputMaybe<Scalars['uuid']>;
  persistentVolume?: InputMaybe<Scalars['Int']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Billing_Resources_Max_Fields = {
  __typename?: 'billing_resources_max_fields';
  appID?: Maybe<Scalars['uuid']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  customDomains?: Maybe<Scalars['Int']>;
  functionsAmount?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['uuid']>;
  persistentVolume?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Billing_Resources_Min_Fields = {
  __typename?: 'billing_resources_min_fields';
  appID?: Maybe<Scalars['uuid']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  customDomains?: Maybe<Scalars['Int']>;
  functionsAmount?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['uuid']>;
  persistentVolume?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "billing.resources" */
export type Billing_Resources_Mutation_Response = {
  __typename?: 'billing_resources_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Billing_Resources>;
};

/** input type for inserting object relation for remote table "billing.resources" */
export type Billing_Resources_Obj_Rel_Insert_Input = {
  data: Billing_Resources_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Billing_Resources_On_Conflict>;
};

/** on_conflict condition type for table "billing.resources" */
export type Billing_Resources_On_Conflict = {
  constraint: Billing_Resources_Constraint;
  update_columns?: Array<Billing_Resources_Update_Column>;
  where?: InputMaybe<Billing_Resources_Bool_Exp>;
};

/** Ordering options when selecting data from "billing.resources". */
export type Billing_Resources_Order_By = {
  appID?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  customDomains?: InputMaybe<Order_By>;
  functionsAmount?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  persistentVolume?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
};

/** primary key columns input for table: billing.resources */
export type Billing_Resources_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "billing.resources" */
export enum Billing_Resources_Select_Column {
  /** column name */
  AppId = 'appID',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CustomDomains = 'customDomains',
  /** column name */
  FunctionsAmount = 'functionsAmount',
  /** column name */
  Id = 'id',
  /** column name */
  PersistentVolume = 'persistentVolume',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "billing.resources" */
export type Billing_Resources_Set_Input = {
  appID?: InputMaybe<Scalars['uuid']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  customDomains?: InputMaybe<Scalars['Int']>;
  functionsAmount?: InputMaybe<Scalars['Int']>;
  id?: InputMaybe<Scalars['uuid']>;
  persistentVolume?: InputMaybe<Scalars['Int']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Billing_Resources_Stddev_Fields = {
  __typename?: 'billing_resources_stddev_fields';
  customDomains?: Maybe<Scalars['Float']>;
  functionsAmount?: Maybe<Scalars['Float']>;
  persistentVolume?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Billing_Resources_Stddev_Pop_Fields = {
  __typename?: 'billing_resources_stddev_pop_fields';
  customDomains?: Maybe<Scalars['Float']>;
  functionsAmount?: Maybe<Scalars['Float']>;
  persistentVolume?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Billing_Resources_Stddev_Samp_Fields = {
  __typename?: 'billing_resources_stddev_samp_fields';
  customDomains?: Maybe<Scalars['Float']>;
  functionsAmount?: Maybe<Scalars['Float']>;
  persistentVolume?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "billing_resources" */
export type Billing_Resources_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Billing_Resources_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Billing_Resources_Stream_Cursor_Value_Input = {
  appID?: InputMaybe<Scalars['uuid']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  customDomains?: InputMaybe<Scalars['Int']>;
  functionsAmount?: InputMaybe<Scalars['Int']>;
  id?: InputMaybe<Scalars['uuid']>;
  persistentVolume?: InputMaybe<Scalars['Int']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate sum on columns */
export type Billing_Resources_Sum_Fields = {
  __typename?: 'billing_resources_sum_fields';
  customDomains?: Maybe<Scalars['Int']>;
  functionsAmount?: Maybe<Scalars['Int']>;
  persistentVolume?: Maybe<Scalars['Int']>;
};

/** update columns of table "billing.resources" */
export enum Billing_Resources_Update_Column {
  /** column name */
  AppId = 'appID',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CustomDomains = 'customDomains',
  /** column name */
  FunctionsAmount = 'functionsAmount',
  /** column name */
  Id = 'id',
  /** column name */
  PersistentVolume = 'persistentVolume',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type Billing_Resources_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Billing_Resources_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Billing_Resources_Set_Input>;
  /** filter the rows which have to be updated */
  where: Billing_Resources_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Billing_Resources_Var_Pop_Fields = {
  __typename?: 'billing_resources_var_pop_fields';
  customDomains?: Maybe<Scalars['Float']>;
  functionsAmount?: Maybe<Scalars['Float']>;
  persistentVolume?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Billing_Resources_Var_Samp_Fields = {
  __typename?: 'billing_resources_var_samp_fields';
  customDomains?: Maybe<Scalars['Float']>;
  functionsAmount?: Maybe<Scalars['Float']>;
  persistentVolume?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Billing_Resources_Variance_Fields = {
  __typename?: 'billing_resources_variance_fields';
  customDomains?: Maybe<Scalars['Float']>;
  functionsAmount?: Maybe<Scalars['Float']>;
  persistentVolume?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "billing.subscriptions" */
export type Billing_Subscriptions = {
  __typename?: 'billing_subscriptions';
  /** An object relationship */
  app?: Maybe<Apps>;
  appID: Scalars['uuid'];
  createdAt: Scalars['timestamptz'];
  customDomains?: Maybe<Scalars['String']>;
  dedicatedCompute?: Maybe<Scalars['String']>;
  egress?: Maybe<Scalars['String']>;
  functions?: Maybe<Scalars['String']>;
  functionsAmount?: Maybe<Scalars['String']>;
  id: Scalars['uuid'];
  persistentVolume?: Maybe<Scalars['String']>;
  /** An array relationship */
  reports: Array<Billing_Reports>;
  /** An aggregate relationship */
  reports_aggregate: Billing_Reports_Aggregate;
  /** An object relationship */
  resources?: Maybe<Billing_Resources>;
  updatedAt: Scalars['timestamptz'];
};


/** columns and relationships of "billing.subscriptions" */
export type Billing_SubscriptionsReportsArgs = {
  distinct_on?: InputMaybe<Array<Billing_Reports_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Billing_Reports_Order_By>>;
  where?: InputMaybe<Billing_Reports_Bool_Exp>;
};


/** columns and relationships of "billing.subscriptions" */
export type Billing_SubscriptionsReports_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Billing_Reports_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Billing_Reports_Order_By>>;
  where?: InputMaybe<Billing_Reports_Bool_Exp>;
};

/** aggregated selection of "billing.subscriptions" */
export type Billing_Subscriptions_Aggregate = {
  __typename?: 'billing_subscriptions_aggregate';
  aggregate?: Maybe<Billing_Subscriptions_Aggregate_Fields>;
  nodes: Array<Billing_Subscriptions>;
};

/** aggregate fields of "billing.subscriptions" */
export type Billing_Subscriptions_Aggregate_Fields = {
  __typename?: 'billing_subscriptions_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Billing_Subscriptions_Max_Fields>;
  min?: Maybe<Billing_Subscriptions_Min_Fields>;
};


/** aggregate fields of "billing.subscriptions" */
export type Billing_Subscriptions_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Billing_Subscriptions_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "billing.subscriptions". All fields are combined with a logical 'AND'. */
export type Billing_Subscriptions_Bool_Exp = {
  _and?: InputMaybe<Array<Billing_Subscriptions_Bool_Exp>>;
  _not?: InputMaybe<Billing_Subscriptions_Bool_Exp>;
  _or?: InputMaybe<Array<Billing_Subscriptions_Bool_Exp>>;
  app?: InputMaybe<Apps_Bool_Exp>;
  appID?: InputMaybe<Uuid_Comparison_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  customDomains?: InputMaybe<String_Comparison_Exp>;
  dedicatedCompute?: InputMaybe<String_Comparison_Exp>;
  egress?: InputMaybe<String_Comparison_Exp>;
  functions?: InputMaybe<String_Comparison_Exp>;
  functionsAmount?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  persistentVolume?: InputMaybe<String_Comparison_Exp>;
  reports?: InputMaybe<Billing_Reports_Bool_Exp>;
  reports_aggregate?: InputMaybe<Billing_Reports_Aggregate_Bool_Exp>;
  resources?: InputMaybe<Billing_Resources_Bool_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "billing.subscriptions" */
export enum Billing_Subscriptions_Constraint {
  /** unique or primary key constraint on columns "app_id" */
  SubscriptionsAppIdKey = 'subscriptions_app_id_key',
  /** unique or primary key constraint on columns "custom_domains" */
  SubscriptionsCustomDomainsKey = 'subscriptions_custom_domains_key',
  /** unique or primary key constraint on columns "dedicated_compute" */
  SubscriptionsDedicatedComputeKey = 'subscriptions_dedicated_compute_key',
  /** unique or primary key constraint on columns "egress" */
  SubscriptionsEgressKey = 'subscriptions_egress_key',
  /** unique or primary key constraint on columns "functions_amount" */
  SubscriptionsFunctionsAmountKey = 'subscriptions_functions_amount_key',
  /** unique or primary key constraint on columns "functions" */
  SubscriptionsFunctionsKey = 'subscriptions_functions_key',
  /** unique or primary key constraint on columns "persistent_volume" */
  SubscriptionsPersistentVolumeKey = 'subscriptions_persistent_volume_key',
  /** unique or primary key constraint on columns "id" */
  SubscriptionsPkey = 'subscriptions_pkey'
}

/** input type for inserting data into table "billing.subscriptions" */
export type Billing_Subscriptions_Insert_Input = {
  app?: InputMaybe<Apps_Obj_Rel_Insert_Input>;
  appID?: InputMaybe<Scalars['uuid']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  customDomains?: InputMaybe<Scalars['String']>;
  dedicatedCompute?: InputMaybe<Scalars['String']>;
  egress?: InputMaybe<Scalars['String']>;
  functions?: InputMaybe<Scalars['String']>;
  functionsAmount?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  persistentVolume?: InputMaybe<Scalars['String']>;
  reports?: InputMaybe<Billing_Reports_Arr_Rel_Insert_Input>;
  resources?: InputMaybe<Billing_Resources_Obj_Rel_Insert_Input>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Billing_Subscriptions_Max_Fields = {
  __typename?: 'billing_subscriptions_max_fields';
  appID?: Maybe<Scalars['uuid']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  customDomains?: Maybe<Scalars['String']>;
  dedicatedCompute?: Maybe<Scalars['String']>;
  egress?: Maybe<Scalars['String']>;
  functions?: Maybe<Scalars['String']>;
  functionsAmount?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  persistentVolume?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Billing_Subscriptions_Min_Fields = {
  __typename?: 'billing_subscriptions_min_fields';
  appID?: Maybe<Scalars['uuid']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  customDomains?: Maybe<Scalars['String']>;
  dedicatedCompute?: Maybe<Scalars['String']>;
  egress?: Maybe<Scalars['String']>;
  functions?: Maybe<Scalars['String']>;
  functionsAmount?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  persistentVolume?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "billing.subscriptions" */
export type Billing_Subscriptions_Mutation_Response = {
  __typename?: 'billing_subscriptions_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Billing_Subscriptions>;
};

/** input type for inserting object relation for remote table "billing.subscriptions" */
export type Billing_Subscriptions_Obj_Rel_Insert_Input = {
  data: Billing_Subscriptions_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Billing_Subscriptions_On_Conflict>;
};

/** on_conflict condition type for table "billing.subscriptions" */
export type Billing_Subscriptions_On_Conflict = {
  constraint: Billing_Subscriptions_Constraint;
  update_columns?: Array<Billing_Subscriptions_Update_Column>;
  where?: InputMaybe<Billing_Subscriptions_Bool_Exp>;
};

/** Ordering options when selecting data from "billing.subscriptions". */
export type Billing_Subscriptions_Order_By = {
  app?: InputMaybe<Apps_Order_By>;
  appID?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  customDomains?: InputMaybe<Order_By>;
  dedicatedCompute?: InputMaybe<Order_By>;
  egress?: InputMaybe<Order_By>;
  functions?: InputMaybe<Order_By>;
  functionsAmount?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  persistentVolume?: InputMaybe<Order_By>;
  reports_aggregate?: InputMaybe<Billing_Reports_Aggregate_Order_By>;
  resources?: InputMaybe<Billing_Resources_Order_By>;
  updatedAt?: InputMaybe<Order_By>;
};

/** primary key columns input for table: billing.subscriptions */
export type Billing_Subscriptions_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "billing.subscriptions" */
export enum Billing_Subscriptions_Select_Column {
  /** column name */
  AppId = 'appID',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CustomDomains = 'customDomains',
  /** column name */
  DedicatedCompute = 'dedicatedCompute',
  /** column name */
  Egress = 'egress',
  /** column name */
  Functions = 'functions',
  /** column name */
  FunctionsAmount = 'functionsAmount',
  /** column name */
  Id = 'id',
  /** column name */
  PersistentVolume = 'persistentVolume',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "billing.subscriptions" */
export type Billing_Subscriptions_Set_Input = {
  appID?: InputMaybe<Scalars['uuid']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  customDomains?: InputMaybe<Scalars['String']>;
  dedicatedCompute?: InputMaybe<Scalars['String']>;
  egress?: InputMaybe<Scalars['String']>;
  functions?: InputMaybe<Scalars['String']>;
  functionsAmount?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  persistentVolume?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** Streaming cursor of the table "billing_subscriptions" */
export type Billing_Subscriptions_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Billing_Subscriptions_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Billing_Subscriptions_Stream_Cursor_Value_Input = {
  appID?: InputMaybe<Scalars['uuid']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  customDomains?: InputMaybe<Scalars['String']>;
  dedicatedCompute?: InputMaybe<Scalars['String']>;
  egress?: InputMaybe<Scalars['String']>;
  functions?: InputMaybe<Scalars['String']>;
  functionsAmount?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  persistentVolume?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** update columns of table "billing.subscriptions" */
export enum Billing_Subscriptions_Update_Column {
  /** column name */
  AppId = 'appID',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CustomDomains = 'customDomains',
  /** column name */
  DedicatedCompute = 'dedicatedCompute',
  /** column name */
  Egress = 'egress',
  /** column name */
  Functions = 'functions',
  /** column name */
  FunctionsAmount = 'functionsAmount',
  /** column name */
  Id = 'id',
  /** column name */
  PersistentVolume = 'persistentVolume',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type Billing_Subscriptions_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Billing_Subscriptions_Set_Input>;
  /** filter the rows which have to be updated */
  where: Billing_Subscriptions_Bool_Exp;
};

/** Boolean expression to compare columns of type "bpchar". All fields are combined with logical 'AND'. */
export type Bpchar_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['bpchar']>;
  _gt?: InputMaybe<Scalars['bpchar']>;
  _gte?: InputMaybe<Scalars['bpchar']>;
  /** does the column match the given case-insensitive pattern */
  _ilike?: InputMaybe<Scalars['bpchar']>;
  _in?: InputMaybe<Array<Scalars['bpchar']>>;
  /** does the column match the given POSIX regular expression, case insensitive */
  _iregex?: InputMaybe<Scalars['bpchar']>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  /** does the column match the given pattern */
  _like?: InputMaybe<Scalars['bpchar']>;
  _lt?: InputMaybe<Scalars['bpchar']>;
  _lte?: InputMaybe<Scalars['bpchar']>;
  _neq?: InputMaybe<Scalars['bpchar']>;
  /** does the column NOT match the given case-insensitive pattern */
  _nilike?: InputMaybe<Scalars['bpchar']>;
  _nin?: InputMaybe<Array<Scalars['bpchar']>>;
  /** does the column NOT match the given POSIX regular expression, case insensitive */
  _niregex?: InputMaybe<Scalars['bpchar']>;
  /** does the column NOT match the given pattern */
  _nlike?: InputMaybe<Scalars['bpchar']>;
  /** does the column NOT match the given POSIX regular expression, case sensitive */
  _nregex?: InputMaybe<Scalars['bpchar']>;
  /** does the column NOT match the given SQL regular expression */
  _nsimilar?: InputMaybe<Scalars['bpchar']>;
  /** does the column match the given POSIX regular expression, case sensitive */
  _regex?: InputMaybe<Scalars['bpchar']>;
  /** does the column match the given SQL regular expression */
  _similar?: InputMaybe<Scalars['bpchar']>;
};

/** columns and relationships of "storage.buckets" */
export type Buckets = {
  __typename?: 'buckets';
  cacheControl?: Maybe<Scalars['String']>;
  createdAt: Scalars['timestamptz'];
  downloadExpiration: Scalars['Int'];
  /** An array relationship */
  files: Array<Files>;
  /** An aggregate relationship */
  files_aggregate: Files_Aggregate;
  id: Scalars['String'];
  maxUploadFileSize: Scalars['Int'];
  minUploadFileSize: Scalars['Int'];
  presignedUrlsEnabled: Scalars['Boolean'];
  updatedAt: Scalars['timestamptz'];
};


/** columns and relationships of "storage.buckets" */
export type BucketsFilesArgs = {
  distinct_on?: InputMaybe<Array<Files_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Files_Order_By>>;
  where?: InputMaybe<Files_Bool_Exp>;
};


/** columns and relationships of "storage.buckets" */
export type BucketsFiles_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Files_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Files_Order_By>>;
  where?: InputMaybe<Files_Bool_Exp>;
};

/** aggregated selection of "storage.buckets" */
export type Buckets_Aggregate = {
  __typename?: 'buckets_aggregate';
  aggregate?: Maybe<Buckets_Aggregate_Fields>;
  nodes: Array<Buckets>;
};

/** aggregate fields of "storage.buckets" */
export type Buckets_Aggregate_Fields = {
  __typename?: 'buckets_aggregate_fields';
  avg?: Maybe<Buckets_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Buckets_Max_Fields>;
  min?: Maybe<Buckets_Min_Fields>;
  stddev?: Maybe<Buckets_Stddev_Fields>;
  stddev_pop?: Maybe<Buckets_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Buckets_Stddev_Samp_Fields>;
  sum?: Maybe<Buckets_Sum_Fields>;
  var_pop?: Maybe<Buckets_Var_Pop_Fields>;
  var_samp?: Maybe<Buckets_Var_Samp_Fields>;
  variance?: Maybe<Buckets_Variance_Fields>;
};


/** aggregate fields of "storage.buckets" */
export type Buckets_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Buckets_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Buckets_Avg_Fields = {
  __typename?: 'buckets_avg_fields';
  downloadExpiration?: Maybe<Scalars['Float']>;
  maxUploadFileSize?: Maybe<Scalars['Float']>;
  minUploadFileSize?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "storage.buckets". All fields are combined with a logical 'AND'. */
export type Buckets_Bool_Exp = {
  _and?: InputMaybe<Array<Buckets_Bool_Exp>>;
  _not?: InputMaybe<Buckets_Bool_Exp>;
  _or?: InputMaybe<Array<Buckets_Bool_Exp>>;
  cacheControl?: InputMaybe<String_Comparison_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  downloadExpiration?: InputMaybe<Int_Comparison_Exp>;
  files?: InputMaybe<Files_Bool_Exp>;
  files_aggregate?: InputMaybe<Files_Aggregate_Bool_Exp>;
  id?: InputMaybe<String_Comparison_Exp>;
  maxUploadFileSize?: InputMaybe<Int_Comparison_Exp>;
  minUploadFileSize?: InputMaybe<Int_Comparison_Exp>;
  presignedUrlsEnabled?: InputMaybe<Boolean_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "storage.buckets" */
export enum Buckets_Constraint {
  /** unique or primary key constraint on columns "id" */
  BucketsPkey = 'buckets_pkey'
}

/** input type for incrementing numeric columns in table "storage.buckets" */
export type Buckets_Inc_Input = {
  downloadExpiration?: InputMaybe<Scalars['Int']>;
  maxUploadFileSize?: InputMaybe<Scalars['Int']>;
  minUploadFileSize?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "storage.buckets" */
export type Buckets_Insert_Input = {
  cacheControl?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  downloadExpiration?: InputMaybe<Scalars['Int']>;
  files?: InputMaybe<Files_Arr_Rel_Insert_Input>;
  id?: InputMaybe<Scalars['String']>;
  maxUploadFileSize?: InputMaybe<Scalars['Int']>;
  minUploadFileSize?: InputMaybe<Scalars['Int']>;
  presignedUrlsEnabled?: InputMaybe<Scalars['Boolean']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Buckets_Max_Fields = {
  __typename?: 'buckets_max_fields';
  cacheControl?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  downloadExpiration?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['String']>;
  maxUploadFileSize?: Maybe<Scalars['Int']>;
  minUploadFileSize?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Buckets_Min_Fields = {
  __typename?: 'buckets_min_fields';
  cacheControl?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  downloadExpiration?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['String']>;
  maxUploadFileSize?: Maybe<Scalars['Int']>;
  minUploadFileSize?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "storage.buckets" */
export type Buckets_Mutation_Response = {
  __typename?: 'buckets_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Buckets>;
};

/** input type for inserting object relation for remote table "storage.buckets" */
export type Buckets_Obj_Rel_Insert_Input = {
  data: Buckets_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Buckets_On_Conflict>;
};

/** on_conflict condition type for table "storage.buckets" */
export type Buckets_On_Conflict = {
  constraint: Buckets_Constraint;
  update_columns?: Array<Buckets_Update_Column>;
  where?: InputMaybe<Buckets_Bool_Exp>;
};

/** Ordering options when selecting data from "storage.buckets". */
export type Buckets_Order_By = {
  cacheControl?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  downloadExpiration?: InputMaybe<Order_By>;
  files_aggregate?: InputMaybe<Files_Aggregate_Order_By>;
  id?: InputMaybe<Order_By>;
  maxUploadFileSize?: InputMaybe<Order_By>;
  minUploadFileSize?: InputMaybe<Order_By>;
  presignedUrlsEnabled?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
};

/** primary key columns input for table: storage.buckets */
export type Buckets_Pk_Columns_Input = {
  id: Scalars['String'];
};

/** select columns of table "storage.buckets" */
export enum Buckets_Select_Column {
  /** column name */
  CacheControl = 'cacheControl',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DownloadExpiration = 'downloadExpiration',
  /** column name */
  Id = 'id',
  /** column name */
  MaxUploadFileSize = 'maxUploadFileSize',
  /** column name */
  MinUploadFileSize = 'minUploadFileSize',
  /** column name */
  PresignedUrlsEnabled = 'presignedUrlsEnabled',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "storage.buckets" */
export type Buckets_Set_Input = {
  cacheControl?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  downloadExpiration?: InputMaybe<Scalars['Int']>;
  id?: InputMaybe<Scalars['String']>;
  maxUploadFileSize?: InputMaybe<Scalars['Int']>;
  minUploadFileSize?: InputMaybe<Scalars['Int']>;
  presignedUrlsEnabled?: InputMaybe<Scalars['Boolean']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Buckets_Stddev_Fields = {
  __typename?: 'buckets_stddev_fields';
  downloadExpiration?: Maybe<Scalars['Float']>;
  maxUploadFileSize?: Maybe<Scalars['Float']>;
  minUploadFileSize?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Buckets_Stddev_Pop_Fields = {
  __typename?: 'buckets_stddev_pop_fields';
  downloadExpiration?: Maybe<Scalars['Float']>;
  maxUploadFileSize?: Maybe<Scalars['Float']>;
  minUploadFileSize?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Buckets_Stddev_Samp_Fields = {
  __typename?: 'buckets_stddev_samp_fields';
  downloadExpiration?: Maybe<Scalars['Float']>;
  maxUploadFileSize?: Maybe<Scalars['Float']>;
  minUploadFileSize?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "buckets" */
export type Buckets_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Buckets_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Buckets_Stream_Cursor_Value_Input = {
  cacheControl?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  downloadExpiration?: InputMaybe<Scalars['Int']>;
  id?: InputMaybe<Scalars['String']>;
  maxUploadFileSize?: InputMaybe<Scalars['Int']>;
  minUploadFileSize?: InputMaybe<Scalars['Int']>;
  presignedUrlsEnabled?: InputMaybe<Scalars['Boolean']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate sum on columns */
export type Buckets_Sum_Fields = {
  __typename?: 'buckets_sum_fields';
  downloadExpiration?: Maybe<Scalars['Int']>;
  maxUploadFileSize?: Maybe<Scalars['Int']>;
  minUploadFileSize?: Maybe<Scalars['Int']>;
};

/** update columns of table "storage.buckets" */
export enum Buckets_Update_Column {
  /** column name */
  CacheControl = 'cacheControl',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DownloadExpiration = 'downloadExpiration',
  /** column name */
  Id = 'id',
  /** column name */
  MaxUploadFileSize = 'maxUploadFileSize',
  /** column name */
  MinUploadFileSize = 'minUploadFileSize',
  /** column name */
  PresignedUrlsEnabled = 'presignedUrlsEnabled',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type Buckets_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Buckets_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Buckets_Set_Input>;
  /** filter the rows which have to be updated */
  where: Buckets_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Buckets_Var_Pop_Fields = {
  __typename?: 'buckets_var_pop_fields';
  downloadExpiration?: Maybe<Scalars['Float']>;
  maxUploadFileSize?: Maybe<Scalars['Float']>;
  minUploadFileSize?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Buckets_Var_Samp_Fields = {
  __typename?: 'buckets_var_samp_fields';
  downloadExpiration?: Maybe<Scalars['Float']>;
  maxUploadFileSize?: Maybe<Scalars['Float']>;
  minUploadFileSize?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Buckets_Variance_Fields = {
  __typename?: 'buckets_variance_fields';
  downloadExpiration?: Maybe<Scalars['Float']>;
  maxUploadFileSize?: Maybe<Scalars['Float']>;
  minUploadFileSize?: Maybe<Scalars['Float']>;
};

/** Boolean expression to compare columns of type "bytea". All fields are combined with logical 'AND'. */
export type Bytea_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['bytea']>;
  _gt?: InputMaybe<Scalars['bytea']>;
  _gte?: InputMaybe<Scalars['bytea']>;
  _in?: InputMaybe<Array<Scalars['bytea']>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _lt?: InputMaybe<Scalars['bytea']>;
  _lte?: InputMaybe<Scalars['bytea']>;
  _neq?: InputMaybe<Scalars['bytea']>;
  _nin?: InputMaybe<Array<Scalars['bytea']>>;
};

/** Boolean expression to compare columns of type "citext". All fields are combined with logical 'AND'. */
export type Citext_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['citext']>;
  _gt?: InputMaybe<Scalars['citext']>;
  _gte?: InputMaybe<Scalars['citext']>;
  /** does the column match the given case-insensitive pattern */
  _ilike?: InputMaybe<Scalars['citext']>;
  _in?: InputMaybe<Array<Scalars['citext']>>;
  /** does the column match the given POSIX regular expression, case insensitive */
  _iregex?: InputMaybe<Scalars['citext']>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  /** does the column match the given pattern */
  _like?: InputMaybe<Scalars['citext']>;
  _lt?: InputMaybe<Scalars['citext']>;
  _lte?: InputMaybe<Scalars['citext']>;
  _neq?: InputMaybe<Scalars['citext']>;
  /** does the column NOT match the given case-insensitive pattern */
  _nilike?: InputMaybe<Scalars['citext']>;
  _nin?: InputMaybe<Array<Scalars['citext']>>;
  /** does the column NOT match the given POSIX regular expression, case insensitive */
  _niregex?: InputMaybe<Scalars['citext']>;
  /** does the column NOT match the given pattern */
  _nlike?: InputMaybe<Scalars['citext']>;
  /** does the column NOT match the given POSIX regular expression, case sensitive */
  _nregex?: InputMaybe<Scalars['citext']>;
  /** does the column NOT match the given SQL regular expression */
  _nsimilar?: InputMaybe<Scalars['citext']>;
  /** does the column match the given POSIX regular expression, case sensitive */
  _regex?: InputMaybe<Scalars['citext']>;
  /** does the column match the given SQL regular expression */
  _similar?: InputMaybe<Scalars['citext']>;
};

/** columns and relationships of "cli_tokens" */
export type CliTokens = {
  __typename?: 'cliTokens';
  createdAt: Scalars['timestamptz'];
  id: Scalars['uuid'];
  token: Scalars['uuid'];
  updatedAt: Scalars['timestamptz'];
  /** An object relationship */
  user: Users;
  userId: Scalars['uuid'];
};

/** aggregated selection of "cli_tokens" */
export type CliTokens_Aggregate = {
  __typename?: 'cliTokens_aggregate';
  aggregate?: Maybe<CliTokens_Aggregate_Fields>;
  nodes: Array<CliTokens>;
};

export type CliTokens_Aggregate_Bool_Exp = {
  count?: InputMaybe<CliTokens_Aggregate_Bool_Exp_Count>;
};

export type CliTokens_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<CliTokens_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<CliTokens_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "cli_tokens" */
export type CliTokens_Aggregate_Fields = {
  __typename?: 'cliTokens_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<CliTokens_Max_Fields>;
  min?: Maybe<CliTokens_Min_Fields>;
};


/** aggregate fields of "cli_tokens" */
export type CliTokens_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<CliTokens_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "cli_tokens" */
export type CliTokens_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<CliTokens_Max_Order_By>;
  min?: InputMaybe<CliTokens_Min_Order_By>;
};

/** input type for inserting array relation for remote table "cli_tokens" */
export type CliTokens_Arr_Rel_Insert_Input = {
  data: Array<CliTokens_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<CliTokens_On_Conflict>;
};

/** Boolean expression to filter rows from the table "cli_tokens". All fields are combined with a logical 'AND'. */
export type CliTokens_Bool_Exp = {
  _and?: InputMaybe<Array<CliTokens_Bool_Exp>>;
  _not?: InputMaybe<CliTokens_Bool_Exp>;
  _or?: InputMaybe<Array<CliTokens_Bool_Exp>>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  token?: InputMaybe<Uuid_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  user?: InputMaybe<Users_Bool_Exp>;
  userId?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "cli_tokens" */
export enum CliTokens_Constraint {
  /** unique or primary key constraint on columns "id" */
  CliTokensPkey = 'cliTokens_pkey'
}

/** input type for inserting data into table "cli_tokens" */
export type CliTokens_Insert_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  token?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  user?: InputMaybe<Users_Obj_Rel_Insert_Input>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type CliTokens_Max_Fields = {
  __typename?: 'cliTokens_max_fields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  token?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userId?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "cli_tokens" */
export type CliTokens_Max_Order_By = {
  createdAt?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  token?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  userId?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type CliTokens_Min_Fields = {
  __typename?: 'cliTokens_min_fields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  token?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userId?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "cli_tokens" */
export type CliTokens_Min_Order_By = {
  createdAt?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  token?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  userId?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "cli_tokens" */
export type CliTokens_Mutation_Response = {
  __typename?: 'cliTokens_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<CliTokens>;
};

/** on_conflict condition type for table "cli_tokens" */
export type CliTokens_On_Conflict = {
  constraint: CliTokens_Constraint;
  update_columns?: Array<CliTokens_Update_Column>;
  where?: InputMaybe<CliTokens_Bool_Exp>;
};

/** Ordering options when selecting data from "cli_tokens". */
export type CliTokens_Order_By = {
  createdAt?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  token?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  user?: InputMaybe<Users_Order_By>;
  userId?: InputMaybe<Order_By>;
};

/** primary key columns input for table: cli_tokens */
export type CliTokens_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "cli_tokens" */
export enum CliTokens_Select_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  Token = 'token',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

/** input type for updating data in table "cli_tokens" */
export type CliTokens_Set_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  token?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** Streaming cursor of the table "cliTokens" */
export type CliTokens_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: CliTokens_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type CliTokens_Stream_Cursor_Value_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  token?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** update columns of table "cli_tokens" */
export enum CliTokens_Update_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  Token = 'token',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

export type CliTokens_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<CliTokens_Set_Input>;
  /** filter the rows which have to be updated */
  where: CliTokens_Bool_Exp;
};

/** columns and relationships of "continents" */
export type Continents = {
  __typename?: 'continents';
  /** Continent code */
  code: Scalars['bpchar'];
  /** An array relationship */
  countries: Array<Countries>;
  /** An aggregate relationship */
  countries_aggregate: Countries_Aggregate;
  /** Continent name */
  name?: Maybe<Scalars['String']>;
};


/** columns and relationships of "continents" */
export type ContinentsCountriesArgs = {
  distinct_on?: InputMaybe<Array<Countries_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Countries_Order_By>>;
  where?: InputMaybe<Countries_Bool_Exp>;
};


/** columns and relationships of "continents" */
export type ContinentsCountries_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Countries_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Countries_Order_By>>;
  where?: InputMaybe<Countries_Bool_Exp>;
};

/** aggregated selection of "continents" */
export type Continents_Aggregate = {
  __typename?: 'continents_aggregate';
  aggregate?: Maybe<Continents_Aggregate_Fields>;
  nodes: Array<Continents>;
};

/** aggregate fields of "continents" */
export type Continents_Aggregate_Fields = {
  __typename?: 'continents_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Continents_Max_Fields>;
  min?: Maybe<Continents_Min_Fields>;
};


/** aggregate fields of "continents" */
export type Continents_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Continents_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "continents". All fields are combined with a logical 'AND'. */
export type Continents_Bool_Exp = {
  _and?: InputMaybe<Array<Continents_Bool_Exp>>;
  _not?: InputMaybe<Continents_Bool_Exp>;
  _or?: InputMaybe<Array<Continents_Bool_Exp>>;
  code?: InputMaybe<Bpchar_Comparison_Exp>;
  countries?: InputMaybe<Countries_Bool_Exp>;
  countries_aggregate?: InputMaybe<Countries_Aggregate_Bool_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "continents" */
export enum Continents_Constraint {
  /** unique or primary key constraint on columns "code" */
  ContinentPkey = 'continent_pkey'
}

/** input type for inserting data into table "continents" */
export type Continents_Insert_Input = {
  /** Continent code */
  code?: InputMaybe<Scalars['bpchar']>;
  countries?: InputMaybe<Countries_Arr_Rel_Insert_Input>;
  /** Continent name */
  name?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Continents_Max_Fields = {
  __typename?: 'continents_max_fields';
  /** Continent code */
  code?: Maybe<Scalars['bpchar']>;
  /** Continent name */
  name?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Continents_Min_Fields = {
  __typename?: 'continents_min_fields';
  /** Continent code */
  code?: Maybe<Scalars['bpchar']>;
  /** Continent name */
  name?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "continents" */
export type Continents_Mutation_Response = {
  __typename?: 'continents_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Continents>;
};

/** input type for inserting object relation for remote table "continents" */
export type Continents_Obj_Rel_Insert_Input = {
  data: Continents_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Continents_On_Conflict>;
};

/** on_conflict condition type for table "continents" */
export type Continents_On_Conflict = {
  constraint: Continents_Constraint;
  update_columns?: Array<Continents_Update_Column>;
  where?: InputMaybe<Continents_Bool_Exp>;
};

/** Ordering options when selecting data from "continents". */
export type Continents_Order_By = {
  code?: InputMaybe<Order_By>;
  countries_aggregate?: InputMaybe<Countries_Aggregate_Order_By>;
  name?: InputMaybe<Order_By>;
};

/** primary key columns input for table: continents */
export type Continents_Pk_Columns_Input = {
  /** Continent code */
  code: Scalars['bpchar'];
};

/** select columns of table "continents" */
export enum Continents_Select_Column {
  /** column name */
  Code = 'code',
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "continents" */
export type Continents_Set_Input = {
  /** Continent code */
  code?: InputMaybe<Scalars['bpchar']>;
  /** Continent name */
  name?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "continents" */
export type Continents_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Continents_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Continents_Stream_Cursor_Value_Input = {
  /** Continent code */
  code?: InputMaybe<Scalars['bpchar']>;
  /** Continent name */
  name?: InputMaybe<Scalars['String']>;
};

/** update columns of table "continents" */
export enum Continents_Update_Column {
  /** column name */
  Code = 'code',
  /** column name */
  Name = 'name'
}

export type Continents_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Continents_Set_Input>;
  /** filter the rows which have to be updated */
  where: Continents_Bool_Exp;
};

/** columns and relationships of "countries" */
export type Countries = {
  __typename?: 'countries';
  /** Two-letter country code (ISO 3166-1 alpha-2) */
  code: Scalars['bpchar'];
  /** An object relationship */
  continent: Continents;
  continentCode: Scalars['bpchar'];
  emojiFlag?: Maybe<Scalars['String']>;
  /** Full English country name */
  fullName?: Maybe<Scalars['String']>;
  /** Three-letter country code (ISO 3166-1 alpha-3) */
  iso3?: Maybe<Scalars['bpchar']>;
  /** Three-letter country code (ISO 3166-1 numeric) */
  isoNumber?: Maybe<Scalars['smallint']>;
  /** An array relationship */
  locations: Array<Regions>;
  /** An aggregate relationship */
  locations_aggregate: Regions_Aggregate;
  /** English country name */
  name: Scalars['String'];
  /** An array relationship */
  workspaces: Array<Workspaces>;
  /** An aggregate relationship */
  workspaces_aggregate: Workspaces_Aggregate;
};


/** columns and relationships of "countries" */
export type CountriesLocationsArgs = {
  distinct_on?: InputMaybe<Array<Regions_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Regions_Order_By>>;
  where?: InputMaybe<Regions_Bool_Exp>;
};


/** columns and relationships of "countries" */
export type CountriesLocations_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Regions_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Regions_Order_By>>;
  where?: InputMaybe<Regions_Bool_Exp>;
};


/** columns and relationships of "countries" */
export type CountriesWorkspacesArgs = {
  distinct_on?: InputMaybe<Array<Workspaces_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Workspaces_Order_By>>;
  where?: InputMaybe<Workspaces_Bool_Exp>;
};


/** columns and relationships of "countries" */
export type CountriesWorkspaces_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Workspaces_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Workspaces_Order_By>>;
  where?: InputMaybe<Workspaces_Bool_Exp>;
};

/** aggregated selection of "countries" */
export type Countries_Aggregate = {
  __typename?: 'countries_aggregate';
  aggregate?: Maybe<Countries_Aggregate_Fields>;
  nodes: Array<Countries>;
};

export type Countries_Aggregate_Bool_Exp = {
  count?: InputMaybe<Countries_Aggregate_Bool_Exp_Count>;
};

export type Countries_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Countries_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<Countries_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "countries" */
export type Countries_Aggregate_Fields = {
  __typename?: 'countries_aggregate_fields';
  avg?: Maybe<Countries_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Countries_Max_Fields>;
  min?: Maybe<Countries_Min_Fields>;
  stddev?: Maybe<Countries_Stddev_Fields>;
  stddev_pop?: Maybe<Countries_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Countries_Stddev_Samp_Fields>;
  sum?: Maybe<Countries_Sum_Fields>;
  var_pop?: Maybe<Countries_Var_Pop_Fields>;
  var_samp?: Maybe<Countries_Var_Samp_Fields>;
  variance?: Maybe<Countries_Variance_Fields>;
};


/** aggregate fields of "countries" */
export type Countries_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Countries_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "countries" */
export type Countries_Aggregate_Order_By = {
  avg?: InputMaybe<Countries_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Countries_Max_Order_By>;
  min?: InputMaybe<Countries_Min_Order_By>;
  stddev?: InputMaybe<Countries_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Countries_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Countries_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Countries_Sum_Order_By>;
  var_pop?: InputMaybe<Countries_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Countries_Var_Samp_Order_By>;
  variance?: InputMaybe<Countries_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "countries" */
export type Countries_Arr_Rel_Insert_Input = {
  data: Array<Countries_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Countries_On_Conflict>;
};

/** aggregate avg on columns */
export type Countries_Avg_Fields = {
  __typename?: 'countries_avg_fields';
  /** Three-letter country code (ISO 3166-1 numeric) */
  isoNumber?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "countries" */
export type Countries_Avg_Order_By = {
  /** Three-letter country code (ISO 3166-1 numeric) */
  isoNumber?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "countries". All fields are combined with a logical 'AND'. */
export type Countries_Bool_Exp = {
  _and?: InputMaybe<Array<Countries_Bool_Exp>>;
  _not?: InputMaybe<Countries_Bool_Exp>;
  _or?: InputMaybe<Array<Countries_Bool_Exp>>;
  code?: InputMaybe<Bpchar_Comparison_Exp>;
  continent?: InputMaybe<Continents_Bool_Exp>;
  continentCode?: InputMaybe<Bpchar_Comparison_Exp>;
  emojiFlag?: InputMaybe<String_Comparison_Exp>;
  fullName?: InputMaybe<String_Comparison_Exp>;
  iso3?: InputMaybe<Bpchar_Comparison_Exp>;
  isoNumber?: InputMaybe<Smallint_Comparison_Exp>;
  locations?: InputMaybe<Regions_Bool_Exp>;
  locations_aggregate?: InputMaybe<Regions_Aggregate_Bool_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  workspaces?: InputMaybe<Workspaces_Bool_Exp>;
  workspaces_aggregate?: InputMaybe<Workspaces_Aggregate_Bool_Exp>;
};

/** unique or primary key constraints on table "countries" */
export enum Countries_Constraint {
  /** unique or primary key constraint on columns "code" */
  CountryPkey = 'country_pkey'
}

/** input type for incrementing numeric columns in table "countries" */
export type Countries_Inc_Input = {
  /** Three-letter country code (ISO 3166-1 numeric) */
  isoNumber?: InputMaybe<Scalars['smallint']>;
};

/** input type for inserting data into table "countries" */
export type Countries_Insert_Input = {
  /** Two-letter country code (ISO 3166-1 alpha-2) */
  code?: InputMaybe<Scalars['bpchar']>;
  continent?: InputMaybe<Continents_Obj_Rel_Insert_Input>;
  continentCode?: InputMaybe<Scalars['bpchar']>;
  emojiFlag?: InputMaybe<Scalars['String']>;
  /** Full English country name */
  fullName?: InputMaybe<Scalars['String']>;
  /** Three-letter country code (ISO 3166-1 alpha-3) */
  iso3?: InputMaybe<Scalars['bpchar']>;
  /** Three-letter country code (ISO 3166-1 numeric) */
  isoNumber?: InputMaybe<Scalars['smallint']>;
  locations?: InputMaybe<Regions_Arr_Rel_Insert_Input>;
  /** English country name */
  name?: InputMaybe<Scalars['String']>;
  workspaces?: InputMaybe<Workspaces_Arr_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Countries_Max_Fields = {
  __typename?: 'countries_max_fields';
  /** Two-letter country code (ISO 3166-1 alpha-2) */
  code?: Maybe<Scalars['bpchar']>;
  continentCode?: Maybe<Scalars['bpchar']>;
  emojiFlag?: Maybe<Scalars['String']>;
  /** Full English country name */
  fullName?: Maybe<Scalars['String']>;
  /** Three-letter country code (ISO 3166-1 alpha-3) */
  iso3?: Maybe<Scalars['bpchar']>;
  /** Three-letter country code (ISO 3166-1 numeric) */
  isoNumber?: Maybe<Scalars['smallint']>;
  /** English country name */
  name?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "countries" */
export type Countries_Max_Order_By = {
  /** Two-letter country code (ISO 3166-1 alpha-2) */
  code?: InputMaybe<Order_By>;
  continentCode?: InputMaybe<Order_By>;
  emojiFlag?: InputMaybe<Order_By>;
  /** Full English country name */
  fullName?: InputMaybe<Order_By>;
  /** Three-letter country code (ISO 3166-1 alpha-3) */
  iso3?: InputMaybe<Order_By>;
  /** Three-letter country code (ISO 3166-1 numeric) */
  isoNumber?: InputMaybe<Order_By>;
  /** English country name */
  name?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Countries_Min_Fields = {
  __typename?: 'countries_min_fields';
  /** Two-letter country code (ISO 3166-1 alpha-2) */
  code?: Maybe<Scalars['bpchar']>;
  continentCode?: Maybe<Scalars['bpchar']>;
  emojiFlag?: Maybe<Scalars['String']>;
  /** Full English country name */
  fullName?: Maybe<Scalars['String']>;
  /** Three-letter country code (ISO 3166-1 alpha-3) */
  iso3?: Maybe<Scalars['bpchar']>;
  /** Three-letter country code (ISO 3166-1 numeric) */
  isoNumber?: Maybe<Scalars['smallint']>;
  /** English country name */
  name?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "countries" */
export type Countries_Min_Order_By = {
  /** Two-letter country code (ISO 3166-1 alpha-2) */
  code?: InputMaybe<Order_By>;
  continentCode?: InputMaybe<Order_By>;
  emojiFlag?: InputMaybe<Order_By>;
  /** Full English country name */
  fullName?: InputMaybe<Order_By>;
  /** Three-letter country code (ISO 3166-1 alpha-3) */
  iso3?: InputMaybe<Order_By>;
  /** Three-letter country code (ISO 3166-1 numeric) */
  isoNumber?: InputMaybe<Order_By>;
  /** English country name */
  name?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "countries" */
export type Countries_Mutation_Response = {
  __typename?: 'countries_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Countries>;
};

/** input type for inserting object relation for remote table "countries" */
export type Countries_Obj_Rel_Insert_Input = {
  data: Countries_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Countries_On_Conflict>;
};

/** on_conflict condition type for table "countries" */
export type Countries_On_Conflict = {
  constraint: Countries_Constraint;
  update_columns?: Array<Countries_Update_Column>;
  where?: InputMaybe<Countries_Bool_Exp>;
};

/** Ordering options when selecting data from "countries". */
export type Countries_Order_By = {
  code?: InputMaybe<Order_By>;
  continent?: InputMaybe<Continents_Order_By>;
  continentCode?: InputMaybe<Order_By>;
  emojiFlag?: InputMaybe<Order_By>;
  fullName?: InputMaybe<Order_By>;
  iso3?: InputMaybe<Order_By>;
  isoNumber?: InputMaybe<Order_By>;
  locations_aggregate?: InputMaybe<Regions_Aggregate_Order_By>;
  name?: InputMaybe<Order_By>;
  workspaces_aggregate?: InputMaybe<Workspaces_Aggregate_Order_By>;
};

/** primary key columns input for table: countries */
export type Countries_Pk_Columns_Input = {
  /** Two-letter country code (ISO 3166-1 alpha-2) */
  code: Scalars['bpchar'];
};

/** select columns of table "countries" */
export enum Countries_Select_Column {
  /** column name */
  Code = 'code',
  /** column name */
  ContinentCode = 'continentCode',
  /** column name */
  EmojiFlag = 'emojiFlag',
  /** column name */
  FullName = 'fullName',
  /** column name */
  Iso3 = 'iso3',
  /** column name */
  IsoNumber = 'isoNumber',
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "countries" */
export type Countries_Set_Input = {
  /** Two-letter country code (ISO 3166-1 alpha-2) */
  code?: InputMaybe<Scalars['bpchar']>;
  continentCode?: InputMaybe<Scalars['bpchar']>;
  emojiFlag?: InputMaybe<Scalars['String']>;
  /** Full English country name */
  fullName?: InputMaybe<Scalars['String']>;
  /** Three-letter country code (ISO 3166-1 alpha-3) */
  iso3?: InputMaybe<Scalars['bpchar']>;
  /** Three-letter country code (ISO 3166-1 numeric) */
  isoNumber?: InputMaybe<Scalars['smallint']>;
  /** English country name */
  name?: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type Countries_Stddev_Fields = {
  __typename?: 'countries_stddev_fields';
  /** Three-letter country code (ISO 3166-1 numeric) */
  isoNumber?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "countries" */
export type Countries_Stddev_Order_By = {
  /** Three-letter country code (ISO 3166-1 numeric) */
  isoNumber?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Countries_Stddev_Pop_Fields = {
  __typename?: 'countries_stddev_pop_fields';
  /** Three-letter country code (ISO 3166-1 numeric) */
  isoNumber?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "countries" */
export type Countries_Stddev_Pop_Order_By = {
  /** Three-letter country code (ISO 3166-1 numeric) */
  isoNumber?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Countries_Stddev_Samp_Fields = {
  __typename?: 'countries_stddev_samp_fields';
  /** Three-letter country code (ISO 3166-1 numeric) */
  isoNumber?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "countries" */
export type Countries_Stddev_Samp_Order_By = {
  /** Three-letter country code (ISO 3166-1 numeric) */
  isoNumber?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "countries" */
export type Countries_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Countries_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Countries_Stream_Cursor_Value_Input = {
  /** Two-letter country code (ISO 3166-1 alpha-2) */
  code?: InputMaybe<Scalars['bpchar']>;
  continentCode?: InputMaybe<Scalars['bpchar']>;
  emojiFlag?: InputMaybe<Scalars['String']>;
  /** Full English country name */
  fullName?: InputMaybe<Scalars['String']>;
  /** Three-letter country code (ISO 3166-1 alpha-3) */
  iso3?: InputMaybe<Scalars['bpchar']>;
  /** Three-letter country code (ISO 3166-1 numeric) */
  isoNumber?: InputMaybe<Scalars['smallint']>;
  /** English country name */
  name?: InputMaybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type Countries_Sum_Fields = {
  __typename?: 'countries_sum_fields';
  /** Three-letter country code (ISO 3166-1 numeric) */
  isoNumber?: Maybe<Scalars['smallint']>;
};

/** order by sum() on columns of table "countries" */
export type Countries_Sum_Order_By = {
  /** Three-letter country code (ISO 3166-1 numeric) */
  isoNumber?: InputMaybe<Order_By>;
};

/** update columns of table "countries" */
export enum Countries_Update_Column {
  /** column name */
  Code = 'code',
  /** column name */
  ContinentCode = 'continentCode',
  /** column name */
  EmojiFlag = 'emojiFlag',
  /** column name */
  FullName = 'fullName',
  /** column name */
  Iso3 = 'iso3',
  /** column name */
  IsoNumber = 'isoNumber',
  /** column name */
  Name = 'name'
}

export type Countries_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Countries_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Countries_Set_Input>;
  /** filter the rows which have to be updated */
  where: Countries_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Countries_Var_Pop_Fields = {
  __typename?: 'countries_var_pop_fields';
  /** Three-letter country code (ISO 3166-1 numeric) */
  isoNumber?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "countries" */
export type Countries_Var_Pop_Order_By = {
  /** Three-letter country code (ISO 3166-1 numeric) */
  isoNumber?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Countries_Var_Samp_Fields = {
  __typename?: 'countries_var_samp_fields';
  /** Three-letter country code (ISO 3166-1 numeric) */
  isoNumber?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "countries" */
export type Countries_Var_Samp_Order_By = {
  /** Three-letter country code (ISO 3166-1 numeric) */
  isoNumber?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Countries_Variance_Fields = {
  __typename?: 'countries_variance_fields';
  /** Three-letter country code (ISO 3166-1 numeric) */
  isoNumber?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "countries" */
export type Countries_Variance_Order_By = {
  /** Three-letter country code (ISO 3166-1 numeric) */
  isoNumber?: InputMaybe<Order_By>;
};

/** ordering argument of a cursor */
export enum Cursor_Ordering {
  /** ascending ordering of the cursor */
  Asc = 'ASC',
  /** descending ordering of the cursor */
  Desc = 'DESC'
}

/** columns and relationships of "deployment_logs" */
export type DeploymentLogs = {
  __typename?: 'deploymentLogs';
  createdAt: Scalars['timestamptz'];
  /** An object relationship */
  deployment: Deployments;
  deploymentId: Scalars['uuid'];
  id: Scalars['uuid'];
  message: Scalars['String'];
};

/** aggregated selection of "deployment_logs" */
export type DeploymentLogs_Aggregate = {
  __typename?: 'deploymentLogs_aggregate';
  aggregate?: Maybe<DeploymentLogs_Aggregate_Fields>;
  nodes: Array<DeploymentLogs>;
};

export type DeploymentLogs_Aggregate_Bool_Exp = {
  count?: InputMaybe<DeploymentLogs_Aggregate_Bool_Exp_Count>;
};

export type DeploymentLogs_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<DeploymentLogs_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<DeploymentLogs_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "deployment_logs" */
export type DeploymentLogs_Aggregate_Fields = {
  __typename?: 'deploymentLogs_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<DeploymentLogs_Max_Fields>;
  min?: Maybe<DeploymentLogs_Min_Fields>;
};


/** aggregate fields of "deployment_logs" */
export type DeploymentLogs_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<DeploymentLogs_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "deployment_logs" */
export type DeploymentLogs_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<DeploymentLogs_Max_Order_By>;
  min?: InputMaybe<DeploymentLogs_Min_Order_By>;
};

/** input type for inserting array relation for remote table "deployment_logs" */
export type DeploymentLogs_Arr_Rel_Insert_Input = {
  data: Array<DeploymentLogs_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<DeploymentLogs_On_Conflict>;
};

/** Boolean expression to filter rows from the table "deployment_logs". All fields are combined with a logical 'AND'. */
export type DeploymentLogs_Bool_Exp = {
  _and?: InputMaybe<Array<DeploymentLogs_Bool_Exp>>;
  _not?: InputMaybe<DeploymentLogs_Bool_Exp>;
  _or?: InputMaybe<Array<DeploymentLogs_Bool_Exp>>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  deployment?: InputMaybe<Deployments_Bool_Exp>;
  deploymentId?: InputMaybe<Uuid_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  message?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "deployment_logs" */
export enum DeploymentLogs_Constraint {
  /** unique or primary key constraint on columns "id" */
  DeploymentLogsPkey = 'deployment_logs_pkey'
}

/** input type for inserting data into table "deployment_logs" */
export type DeploymentLogs_Insert_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deployment?: InputMaybe<Deployments_Obj_Rel_Insert_Input>;
  deploymentId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  message?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type DeploymentLogs_Max_Fields = {
  __typename?: 'deploymentLogs_max_fields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deploymentId?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  message?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "deployment_logs" */
export type DeploymentLogs_Max_Order_By = {
  createdAt?: InputMaybe<Order_By>;
  deploymentId?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  message?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type DeploymentLogs_Min_Fields = {
  __typename?: 'deploymentLogs_min_fields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  deploymentId?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  message?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "deployment_logs" */
export type DeploymentLogs_Min_Order_By = {
  createdAt?: InputMaybe<Order_By>;
  deploymentId?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  message?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "deployment_logs" */
export type DeploymentLogs_Mutation_Response = {
  __typename?: 'deploymentLogs_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<DeploymentLogs>;
};

/** on_conflict condition type for table "deployment_logs" */
export type DeploymentLogs_On_Conflict = {
  constraint: DeploymentLogs_Constraint;
  update_columns?: Array<DeploymentLogs_Update_Column>;
  where?: InputMaybe<DeploymentLogs_Bool_Exp>;
};

/** Ordering options when selecting data from "deployment_logs". */
export type DeploymentLogs_Order_By = {
  createdAt?: InputMaybe<Order_By>;
  deployment?: InputMaybe<Deployments_Order_By>;
  deploymentId?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  message?: InputMaybe<Order_By>;
};

/** primary key columns input for table: deployment_logs */
export type DeploymentLogs_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "deployment_logs" */
export enum DeploymentLogs_Select_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeploymentId = 'deploymentId',
  /** column name */
  Id = 'id',
  /** column name */
  Message = 'message'
}

/** input type for updating data in table "deployment_logs" */
export type DeploymentLogs_Set_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deploymentId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  message?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "deploymentLogs" */
export type DeploymentLogs_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: DeploymentLogs_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type DeploymentLogs_Stream_Cursor_Value_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deploymentId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  message?: InputMaybe<Scalars['String']>;
};

/** update columns of table "deployment_logs" */
export enum DeploymentLogs_Update_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeploymentId = 'deploymentId',
  /** column name */
  Id = 'id',
  /** column name */
  Message = 'message'
}

export type DeploymentLogs_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<DeploymentLogs_Set_Input>;
  /** filter the rows which have to be updated */
  where: DeploymentLogs_Bool_Exp;
};

/** Table that keeps track of deployments done by watchtower */
export type Deployments = {
  __typename?: 'deployments';
  /** An object relationship */
  app: Apps;
  appId: Scalars['uuid'];
  commitMessage?: Maybe<Scalars['String']>;
  commitSHA: Scalars['String'];
  commitUserAvatarUrl?: Maybe<Scalars['String']>;
  commitUserName?: Maybe<Scalars['String']>;
  deploymentEndedAt?: Maybe<Scalars['timestamptz']>;
  /** An array relationship */
  deploymentLogs: Array<DeploymentLogs>;
  /** An aggregate relationship */
  deploymentLogs_aggregate: DeploymentLogs_Aggregate;
  deploymentStartedAt?: Maybe<Scalars['timestamptz']>;
  deploymentStatus?: Maybe<Scalars['String']>;
  functionsEndedAt?: Maybe<Scalars['timestamptz']>;
  functionsStartedAt?: Maybe<Scalars['timestamptz']>;
  functionsStatus?: Maybe<Scalars['String']>;
  id: Scalars['uuid'];
  metadataEndedAt?: Maybe<Scalars['timestamptz']>;
  metadataStartedAt?: Maybe<Scalars['timestamptz']>;
  metadataStatus?: Maybe<Scalars['String']>;
  migrationsEndedAt?: Maybe<Scalars['timestamptz']>;
  migrationsStartedAt?: Maybe<Scalars['timestamptz']>;
  migrationsStatus?: Maybe<Scalars['String']>;
};


/** Table that keeps track of deployments done by watchtower */
export type DeploymentsDeploymentLogsArgs = {
  distinct_on?: InputMaybe<Array<DeploymentLogs_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<DeploymentLogs_Order_By>>;
  where?: InputMaybe<DeploymentLogs_Bool_Exp>;
};


/** Table that keeps track of deployments done by watchtower */
export type DeploymentsDeploymentLogs_AggregateArgs = {
  distinct_on?: InputMaybe<Array<DeploymentLogs_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<DeploymentLogs_Order_By>>;
  where?: InputMaybe<DeploymentLogs_Bool_Exp>;
};

/** aggregated selection of "deployments" */
export type Deployments_Aggregate = {
  __typename?: 'deployments_aggregate';
  aggregate?: Maybe<Deployments_Aggregate_Fields>;
  nodes: Array<Deployments>;
};

export type Deployments_Aggregate_Bool_Exp = {
  count?: InputMaybe<Deployments_Aggregate_Bool_Exp_Count>;
};

export type Deployments_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Deployments_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<Deployments_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "deployments" */
export type Deployments_Aggregate_Fields = {
  __typename?: 'deployments_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Deployments_Max_Fields>;
  min?: Maybe<Deployments_Min_Fields>;
};


/** aggregate fields of "deployments" */
export type Deployments_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Deployments_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "deployments" */
export type Deployments_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Deployments_Max_Order_By>;
  min?: InputMaybe<Deployments_Min_Order_By>;
};

/** input type for inserting array relation for remote table "deployments" */
export type Deployments_Arr_Rel_Insert_Input = {
  data: Array<Deployments_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Deployments_On_Conflict>;
};

/** Boolean expression to filter rows from the table "deployments". All fields are combined with a logical 'AND'. */
export type Deployments_Bool_Exp = {
  _and?: InputMaybe<Array<Deployments_Bool_Exp>>;
  _not?: InputMaybe<Deployments_Bool_Exp>;
  _or?: InputMaybe<Array<Deployments_Bool_Exp>>;
  app?: InputMaybe<Apps_Bool_Exp>;
  appId?: InputMaybe<Uuid_Comparison_Exp>;
  commitMessage?: InputMaybe<String_Comparison_Exp>;
  commitSHA?: InputMaybe<String_Comparison_Exp>;
  commitUserAvatarUrl?: InputMaybe<String_Comparison_Exp>;
  commitUserName?: InputMaybe<String_Comparison_Exp>;
  deploymentEndedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  deploymentLogs?: InputMaybe<DeploymentLogs_Bool_Exp>;
  deploymentLogs_aggregate?: InputMaybe<DeploymentLogs_Aggregate_Bool_Exp>;
  deploymentStartedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  deploymentStatus?: InputMaybe<String_Comparison_Exp>;
  functionsEndedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  functionsStartedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  functionsStatus?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  metadataEndedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  metadataStartedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  metadataStatus?: InputMaybe<String_Comparison_Exp>;
  migrationsEndedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  migrationsStartedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  migrationsStatus?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "deployments" */
export enum Deployments_Constraint {
  /** unique or primary key constraint on columns "id" */
  DeploymentsPkey = 'deployments_pkey'
}

/** input type for inserting data into table "deployments" */
export type Deployments_Insert_Input = {
  app?: InputMaybe<Apps_Obj_Rel_Insert_Input>;
  appId?: InputMaybe<Scalars['uuid']>;
  commitMessage?: InputMaybe<Scalars['String']>;
  commitSHA?: InputMaybe<Scalars['String']>;
  commitUserAvatarUrl?: InputMaybe<Scalars['String']>;
  commitUserName?: InputMaybe<Scalars['String']>;
  deploymentEndedAt?: InputMaybe<Scalars['timestamptz']>;
  deploymentLogs?: InputMaybe<DeploymentLogs_Arr_Rel_Insert_Input>;
  deploymentStartedAt?: InputMaybe<Scalars['timestamptz']>;
  deploymentStatus?: InputMaybe<Scalars['String']>;
  functionsEndedAt?: InputMaybe<Scalars['timestamptz']>;
  functionsStartedAt?: InputMaybe<Scalars['timestamptz']>;
  functionsStatus?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  metadataEndedAt?: InputMaybe<Scalars['timestamptz']>;
  metadataStartedAt?: InputMaybe<Scalars['timestamptz']>;
  metadataStatus?: InputMaybe<Scalars['String']>;
  migrationsEndedAt?: InputMaybe<Scalars['timestamptz']>;
  migrationsStartedAt?: InputMaybe<Scalars['timestamptz']>;
  migrationsStatus?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Deployments_Max_Fields = {
  __typename?: 'deployments_max_fields';
  appId?: Maybe<Scalars['uuid']>;
  commitMessage?: Maybe<Scalars['String']>;
  commitSHA?: Maybe<Scalars['String']>;
  commitUserAvatarUrl?: Maybe<Scalars['String']>;
  commitUserName?: Maybe<Scalars['String']>;
  deploymentEndedAt?: Maybe<Scalars['timestamptz']>;
  deploymentStartedAt?: Maybe<Scalars['timestamptz']>;
  deploymentStatus?: Maybe<Scalars['String']>;
  functionsEndedAt?: Maybe<Scalars['timestamptz']>;
  functionsStartedAt?: Maybe<Scalars['timestamptz']>;
  functionsStatus?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  metadataEndedAt?: Maybe<Scalars['timestamptz']>;
  metadataStartedAt?: Maybe<Scalars['timestamptz']>;
  metadataStatus?: Maybe<Scalars['String']>;
  migrationsEndedAt?: Maybe<Scalars['timestamptz']>;
  migrationsStartedAt?: Maybe<Scalars['timestamptz']>;
  migrationsStatus?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "deployments" */
export type Deployments_Max_Order_By = {
  appId?: InputMaybe<Order_By>;
  commitMessage?: InputMaybe<Order_By>;
  commitSHA?: InputMaybe<Order_By>;
  commitUserAvatarUrl?: InputMaybe<Order_By>;
  commitUserName?: InputMaybe<Order_By>;
  deploymentEndedAt?: InputMaybe<Order_By>;
  deploymentStartedAt?: InputMaybe<Order_By>;
  deploymentStatus?: InputMaybe<Order_By>;
  functionsEndedAt?: InputMaybe<Order_By>;
  functionsStartedAt?: InputMaybe<Order_By>;
  functionsStatus?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  metadataEndedAt?: InputMaybe<Order_By>;
  metadataStartedAt?: InputMaybe<Order_By>;
  metadataStatus?: InputMaybe<Order_By>;
  migrationsEndedAt?: InputMaybe<Order_By>;
  migrationsStartedAt?: InputMaybe<Order_By>;
  migrationsStatus?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Deployments_Min_Fields = {
  __typename?: 'deployments_min_fields';
  appId?: Maybe<Scalars['uuid']>;
  commitMessage?: Maybe<Scalars['String']>;
  commitSHA?: Maybe<Scalars['String']>;
  commitUserAvatarUrl?: Maybe<Scalars['String']>;
  commitUserName?: Maybe<Scalars['String']>;
  deploymentEndedAt?: Maybe<Scalars['timestamptz']>;
  deploymentStartedAt?: Maybe<Scalars['timestamptz']>;
  deploymentStatus?: Maybe<Scalars['String']>;
  functionsEndedAt?: Maybe<Scalars['timestamptz']>;
  functionsStartedAt?: Maybe<Scalars['timestamptz']>;
  functionsStatus?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  metadataEndedAt?: Maybe<Scalars['timestamptz']>;
  metadataStartedAt?: Maybe<Scalars['timestamptz']>;
  metadataStatus?: Maybe<Scalars['String']>;
  migrationsEndedAt?: Maybe<Scalars['timestamptz']>;
  migrationsStartedAt?: Maybe<Scalars['timestamptz']>;
  migrationsStatus?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "deployments" */
export type Deployments_Min_Order_By = {
  appId?: InputMaybe<Order_By>;
  commitMessage?: InputMaybe<Order_By>;
  commitSHA?: InputMaybe<Order_By>;
  commitUserAvatarUrl?: InputMaybe<Order_By>;
  commitUserName?: InputMaybe<Order_By>;
  deploymentEndedAt?: InputMaybe<Order_By>;
  deploymentStartedAt?: InputMaybe<Order_By>;
  deploymentStatus?: InputMaybe<Order_By>;
  functionsEndedAt?: InputMaybe<Order_By>;
  functionsStartedAt?: InputMaybe<Order_By>;
  functionsStatus?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  metadataEndedAt?: InputMaybe<Order_By>;
  metadataStartedAt?: InputMaybe<Order_By>;
  metadataStatus?: InputMaybe<Order_By>;
  migrationsEndedAt?: InputMaybe<Order_By>;
  migrationsStartedAt?: InputMaybe<Order_By>;
  migrationsStatus?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "deployments" */
export type Deployments_Mutation_Response = {
  __typename?: 'deployments_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Deployments>;
};

/** input type for inserting object relation for remote table "deployments" */
export type Deployments_Obj_Rel_Insert_Input = {
  data: Deployments_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Deployments_On_Conflict>;
};

/** on_conflict condition type for table "deployments" */
export type Deployments_On_Conflict = {
  constraint: Deployments_Constraint;
  update_columns?: Array<Deployments_Update_Column>;
  where?: InputMaybe<Deployments_Bool_Exp>;
};

/** Ordering options when selecting data from "deployments". */
export type Deployments_Order_By = {
  app?: InputMaybe<Apps_Order_By>;
  appId?: InputMaybe<Order_By>;
  commitMessage?: InputMaybe<Order_By>;
  commitSHA?: InputMaybe<Order_By>;
  commitUserAvatarUrl?: InputMaybe<Order_By>;
  commitUserName?: InputMaybe<Order_By>;
  deploymentEndedAt?: InputMaybe<Order_By>;
  deploymentLogs_aggregate?: InputMaybe<DeploymentLogs_Aggregate_Order_By>;
  deploymentStartedAt?: InputMaybe<Order_By>;
  deploymentStatus?: InputMaybe<Order_By>;
  functionsEndedAt?: InputMaybe<Order_By>;
  functionsStartedAt?: InputMaybe<Order_By>;
  functionsStatus?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  metadataEndedAt?: InputMaybe<Order_By>;
  metadataStartedAt?: InputMaybe<Order_By>;
  metadataStatus?: InputMaybe<Order_By>;
  migrationsEndedAt?: InputMaybe<Order_By>;
  migrationsStartedAt?: InputMaybe<Order_By>;
  migrationsStatus?: InputMaybe<Order_By>;
};

/** primary key columns input for table: deployments */
export type Deployments_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "deployments" */
export enum Deployments_Select_Column {
  /** column name */
  AppId = 'appId',
  /** column name */
  CommitMessage = 'commitMessage',
  /** column name */
  CommitSha = 'commitSHA',
  /** column name */
  CommitUserAvatarUrl = 'commitUserAvatarUrl',
  /** column name */
  CommitUserName = 'commitUserName',
  /** column name */
  DeploymentEndedAt = 'deploymentEndedAt',
  /** column name */
  DeploymentStartedAt = 'deploymentStartedAt',
  /** column name */
  DeploymentStatus = 'deploymentStatus',
  /** column name */
  FunctionsEndedAt = 'functionsEndedAt',
  /** column name */
  FunctionsStartedAt = 'functionsStartedAt',
  /** column name */
  FunctionsStatus = 'functionsStatus',
  /** column name */
  Id = 'id',
  /** column name */
  MetadataEndedAt = 'metadataEndedAt',
  /** column name */
  MetadataStartedAt = 'metadataStartedAt',
  /** column name */
  MetadataStatus = 'metadataStatus',
  /** column name */
  MigrationsEndedAt = 'migrationsEndedAt',
  /** column name */
  MigrationsStartedAt = 'migrationsStartedAt',
  /** column name */
  MigrationsStatus = 'migrationsStatus'
}

/** input type for updating data in table "deployments" */
export type Deployments_Set_Input = {
  appId?: InputMaybe<Scalars['uuid']>;
  commitMessage?: InputMaybe<Scalars['String']>;
  commitSHA?: InputMaybe<Scalars['String']>;
  commitUserAvatarUrl?: InputMaybe<Scalars['String']>;
  commitUserName?: InputMaybe<Scalars['String']>;
  deploymentEndedAt?: InputMaybe<Scalars['timestamptz']>;
  deploymentStartedAt?: InputMaybe<Scalars['timestamptz']>;
  deploymentStatus?: InputMaybe<Scalars['String']>;
  functionsEndedAt?: InputMaybe<Scalars['timestamptz']>;
  functionsStartedAt?: InputMaybe<Scalars['timestamptz']>;
  functionsStatus?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  metadataEndedAt?: InputMaybe<Scalars['timestamptz']>;
  metadataStartedAt?: InputMaybe<Scalars['timestamptz']>;
  metadataStatus?: InputMaybe<Scalars['String']>;
  migrationsEndedAt?: InputMaybe<Scalars['timestamptz']>;
  migrationsStartedAt?: InputMaybe<Scalars['timestamptz']>;
  migrationsStatus?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "deployments" */
export type Deployments_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Deployments_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Deployments_Stream_Cursor_Value_Input = {
  appId?: InputMaybe<Scalars['uuid']>;
  commitMessage?: InputMaybe<Scalars['String']>;
  commitSHA?: InputMaybe<Scalars['String']>;
  commitUserAvatarUrl?: InputMaybe<Scalars['String']>;
  commitUserName?: InputMaybe<Scalars['String']>;
  deploymentEndedAt?: InputMaybe<Scalars['timestamptz']>;
  deploymentStartedAt?: InputMaybe<Scalars['timestamptz']>;
  deploymentStatus?: InputMaybe<Scalars['String']>;
  functionsEndedAt?: InputMaybe<Scalars['timestamptz']>;
  functionsStartedAt?: InputMaybe<Scalars['timestamptz']>;
  functionsStatus?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  metadataEndedAt?: InputMaybe<Scalars['timestamptz']>;
  metadataStartedAt?: InputMaybe<Scalars['timestamptz']>;
  metadataStatus?: InputMaybe<Scalars['String']>;
  migrationsEndedAt?: InputMaybe<Scalars['timestamptz']>;
  migrationsStartedAt?: InputMaybe<Scalars['timestamptz']>;
  migrationsStatus?: InputMaybe<Scalars['String']>;
};

/** update columns of table "deployments" */
export enum Deployments_Update_Column {
  /** column name */
  AppId = 'appId',
  /** column name */
  CommitMessage = 'commitMessage',
  /** column name */
  CommitSha = 'commitSHA',
  /** column name */
  CommitUserAvatarUrl = 'commitUserAvatarUrl',
  /** column name */
  CommitUserName = 'commitUserName',
  /** column name */
  DeploymentEndedAt = 'deploymentEndedAt',
  /** column name */
  DeploymentStartedAt = 'deploymentStartedAt',
  /** column name */
  DeploymentStatus = 'deploymentStatus',
  /** column name */
  FunctionsEndedAt = 'functionsEndedAt',
  /** column name */
  FunctionsStartedAt = 'functionsStartedAt',
  /** column name */
  FunctionsStatus = 'functionsStatus',
  /** column name */
  Id = 'id',
  /** column name */
  MetadataEndedAt = 'metadataEndedAt',
  /** column name */
  MetadataStartedAt = 'metadataStartedAt',
  /** column name */
  MetadataStatus = 'metadataStatus',
  /** column name */
  MigrationsEndedAt = 'migrationsEndedAt',
  /** column name */
  MigrationsStartedAt = 'migrationsStartedAt',
  /** column name */
  MigrationsStatus = 'migrationsStatus'
}

export type Deployments_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Deployments_Set_Input>;
  /** filter the rows which have to be updated */
  where: Deployments_Bool_Exp;
};

/** columns and relationships of "feature_flags" */
export type FeatureFlags = {
  __typename?: 'featureFlags';
  /** An object relationship */
  app: Apps;
  appId: Scalars['uuid'];
  description: Scalars['String'];
  id: Scalars['uuid'];
  name: Scalars['String'];
  value: Scalars['String'];
};

/** aggregated selection of "feature_flags" */
export type FeatureFlags_Aggregate = {
  __typename?: 'featureFlags_aggregate';
  aggregate?: Maybe<FeatureFlags_Aggregate_Fields>;
  nodes: Array<FeatureFlags>;
};

export type FeatureFlags_Aggregate_Bool_Exp = {
  count?: InputMaybe<FeatureFlags_Aggregate_Bool_Exp_Count>;
};

export type FeatureFlags_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<FeatureFlags_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<FeatureFlags_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "feature_flags" */
export type FeatureFlags_Aggregate_Fields = {
  __typename?: 'featureFlags_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<FeatureFlags_Max_Fields>;
  min?: Maybe<FeatureFlags_Min_Fields>;
};


/** aggregate fields of "feature_flags" */
export type FeatureFlags_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<FeatureFlags_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "feature_flags" */
export type FeatureFlags_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<FeatureFlags_Max_Order_By>;
  min?: InputMaybe<FeatureFlags_Min_Order_By>;
};

/** input type for inserting array relation for remote table "feature_flags" */
export type FeatureFlags_Arr_Rel_Insert_Input = {
  data: Array<FeatureFlags_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<FeatureFlags_On_Conflict>;
};

/** Boolean expression to filter rows from the table "feature_flags". All fields are combined with a logical 'AND'. */
export type FeatureFlags_Bool_Exp = {
  _and?: InputMaybe<Array<FeatureFlags_Bool_Exp>>;
  _not?: InputMaybe<FeatureFlags_Bool_Exp>;
  _or?: InputMaybe<Array<FeatureFlags_Bool_Exp>>;
  app?: InputMaybe<Apps_Bool_Exp>;
  appId?: InputMaybe<Uuid_Comparison_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  value?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "feature_flags" */
export enum FeatureFlags_Constraint {
  /** unique or primary key constraint on columns "id" */
  FeatureFlagsPkey = 'feature_flags_pkey'
}

/** input type for inserting data into table "feature_flags" */
export type FeatureFlags_Insert_Input = {
  app?: InputMaybe<Apps_Obj_Rel_Insert_Input>;
  appId?: InputMaybe<Scalars['uuid']>;
  description?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  name?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type FeatureFlags_Max_Fields = {
  __typename?: 'featureFlags_max_fields';
  appId?: Maybe<Scalars['uuid']>;
  description?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "feature_flags" */
export type FeatureFlags_Max_Order_By = {
  appId?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  value?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type FeatureFlags_Min_Fields = {
  __typename?: 'featureFlags_min_fields';
  appId?: Maybe<Scalars['uuid']>;
  description?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "feature_flags" */
export type FeatureFlags_Min_Order_By = {
  appId?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  value?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "feature_flags" */
export type FeatureFlags_Mutation_Response = {
  __typename?: 'featureFlags_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<FeatureFlags>;
};

/** on_conflict condition type for table "feature_flags" */
export type FeatureFlags_On_Conflict = {
  constraint: FeatureFlags_Constraint;
  update_columns?: Array<FeatureFlags_Update_Column>;
  where?: InputMaybe<FeatureFlags_Bool_Exp>;
};

/** Ordering options when selecting data from "feature_flags". */
export type FeatureFlags_Order_By = {
  app?: InputMaybe<Apps_Order_By>;
  appId?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  value?: InputMaybe<Order_By>;
};

/** primary key columns input for table: feature_flags */
export type FeatureFlags_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "feature_flags" */
export enum FeatureFlags_Select_Column {
  /** column name */
  AppId = 'appId',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "feature_flags" */
export type FeatureFlags_Set_Input = {
  appId?: InputMaybe<Scalars['uuid']>;
  description?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  name?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "featureFlags" */
export type FeatureFlags_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: FeatureFlags_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type FeatureFlags_Stream_Cursor_Value_Input = {
  appId?: InputMaybe<Scalars['uuid']>;
  description?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  name?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** update columns of table "feature_flags" */
export enum FeatureFlags_Update_Column {
  /** column name */
  AppId = 'appId',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Value = 'value'
}

export type FeatureFlags_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<FeatureFlags_Set_Input>;
  /** filter the rows which have to be updated */
  where: FeatureFlags_Bool_Exp;
};

/** columns and relationships of "storage.files" */
export type Files = {
  __typename?: 'files';
  /** An object relationship */
  bucket: Buckets;
  bucketId: Scalars['String'];
  createdAt: Scalars['timestamptz'];
  etag?: Maybe<Scalars['String']>;
  id: Scalars['uuid'];
  isUploaded?: Maybe<Scalars['Boolean']>;
  metadata?: Maybe<Scalars['jsonb']>;
  mimeType?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['Int']>;
  updatedAt: Scalars['timestamptz'];
  uploadedByUserId?: Maybe<Scalars['uuid']>;
};


/** columns and relationships of "storage.files" */
export type FilesMetadataArgs = {
  path?: InputMaybe<Scalars['String']>;
};

/** aggregated selection of "storage.files" */
export type Files_Aggregate = {
  __typename?: 'files_aggregate';
  aggregate?: Maybe<Files_Aggregate_Fields>;
  nodes: Array<Files>;
};

export type Files_Aggregate_Bool_Exp = {
  bool_and?: InputMaybe<Files_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: InputMaybe<Files_Aggregate_Bool_Exp_Bool_Or>;
  count?: InputMaybe<Files_Aggregate_Bool_Exp_Count>;
};

export type Files_Aggregate_Bool_Exp_Bool_And = {
  arguments: Files_Select_Column_Files_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<Files_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Files_Aggregate_Bool_Exp_Bool_Or = {
  arguments: Files_Select_Column_Files_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<Files_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Files_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Files_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<Files_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "storage.files" */
export type Files_Aggregate_Fields = {
  __typename?: 'files_aggregate_fields';
  avg?: Maybe<Files_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Files_Max_Fields>;
  min?: Maybe<Files_Min_Fields>;
  stddev?: Maybe<Files_Stddev_Fields>;
  stddev_pop?: Maybe<Files_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Files_Stddev_Samp_Fields>;
  sum?: Maybe<Files_Sum_Fields>;
  var_pop?: Maybe<Files_Var_Pop_Fields>;
  var_samp?: Maybe<Files_Var_Samp_Fields>;
  variance?: Maybe<Files_Variance_Fields>;
};


/** aggregate fields of "storage.files" */
export type Files_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Files_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "storage.files" */
export type Files_Aggregate_Order_By = {
  avg?: InputMaybe<Files_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Files_Max_Order_By>;
  min?: InputMaybe<Files_Min_Order_By>;
  stddev?: InputMaybe<Files_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Files_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Files_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Files_Sum_Order_By>;
  var_pop?: InputMaybe<Files_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Files_Var_Samp_Order_By>;
  variance?: InputMaybe<Files_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Files_Append_Input = {
  metadata?: InputMaybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "storage.files" */
export type Files_Arr_Rel_Insert_Input = {
  data: Array<Files_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Files_On_Conflict>;
};

/** aggregate avg on columns */
export type Files_Avg_Fields = {
  __typename?: 'files_avg_fields';
  size?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "storage.files" */
export type Files_Avg_Order_By = {
  size?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "storage.files". All fields are combined with a logical 'AND'. */
export type Files_Bool_Exp = {
  _and?: InputMaybe<Array<Files_Bool_Exp>>;
  _not?: InputMaybe<Files_Bool_Exp>;
  _or?: InputMaybe<Array<Files_Bool_Exp>>;
  bucket?: InputMaybe<Buckets_Bool_Exp>;
  bucketId?: InputMaybe<String_Comparison_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  etag?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  isUploaded?: InputMaybe<Boolean_Comparison_Exp>;
  metadata?: InputMaybe<Jsonb_Comparison_Exp>;
  mimeType?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  size?: InputMaybe<Int_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  uploadedByUserId?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "storage.files" */
export enum Files_Constraint {
  /** unique or primary key constraint on columns "id" */
  FilesPkey = 'files_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Files_Delete_At_Path_Input = {
  metadata?: InputMaybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Files_Delete_Elem_Input = {
  metadata?: InputMaybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Files_Delete_Key_Input = {
  metadata?: InputMaybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "storage.files" */
export type Files_Inc_Input = {
  size?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "storage.files" */
export type Files_Insert_Input = {
  bucket?: InputMaybe<Buckets_Obj_Rel_Insert_Input>;
  bucketId?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  etag?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  isUploaded?: InputMaybe<Scalars['Boolean']>;
  metadata?: InputMaybe<Scalars['jsonb']>;
  mimeType?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
  size?: InputMaybe<Scalars['Int']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  uploadedByUserId?: InputMaybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type Files_Max_Fields = {
  __typename?: 'files_max_fields';
  bucketId?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  etag?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  mimeType?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  uploadedByUserId?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "storage.files" */
export type Files_Max_Order_By = {
  bucketId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  etag?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  mimeType?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  size?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  uploadedByUserId?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Files_Min_Fields = {
  __typename?: 'files_min_fields';
  bucketId?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  etag?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  mimeType?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  uploadedByUserId?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "storage.files" */
export type Files_Min_Order_By = {
  bucketId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  etag?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  mimeType?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  size?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  uploadedByUserId?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "storage.files" */
export type Files_Mutation_Response = {
  __typename?: 'files_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Files>;
};

/** input type for inserting object relation for remote table "storage.files" */
export type Files_Obj_Rel_Insert_Input = {
  data: Files_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Files_On_Conflict>;
};

/** on_conflict condition type for table "storage.files" */
export type Files_On_Conflict = {
  constraint: Files_Constraint;
  update_columns?: Array<Files_Update_Column>;
  where?: InputMaybe<Files_Bool_Exp>;
};

/** Ordering options when selecting data from "storage.files". */
export type Files_Order_By = {
  bucket?: InputMaybe<Buckets_Order_By>;
  bucketId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  etag?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  isUploaded?: InputMaybe<Order_By>;
  metadata?: InputMaybe<Order_By>;
  mimeType?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  size?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  uploadedByUserId?: InputMaybe<Order_By>;
};

/** primary key columns input for table: storage.files */
export type Files_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Files_Prepend_Input = {
  metadata?: InputMaybe<Scalars['jsonb']>;
};

/** select columns of table "storage.files" */
export enum Files_Select_Column {
  /** column name */
  BucketId = 'bucketId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Etag = 'etag',
  /** column name */
  Id = 'id',
  /** column name */
  IsUploaded = 'isUploaded',
  /** column name */
  Metadata = 'metadata',
  /** column name */
  MimeType = 'mimeType',
  /** column name */
  Name = 'name',
  /** column name */
  Size = 'size',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UploadedByUserId = 'uploadedByUserId'
}

/** select "files_aggregate_bool_exp_bool_and_arguments_columns" columns of table "storage.files" */
export enum Files_Select_Column_Files_Aggregate_Bool_Exp_Bool_And_Arguments_Columns {
  /** column name */
  IsUploaded = 'isUploaded'
}

/** select "files_aggregate_bool_exp_bool_or_arguments_columns" columns of table "storage.files" */
export enum Files_Select_Column_Files_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns {
  /** column name */
  IsUploaded = 'isUploaded'
}

/** input type for updating data in table "storage.files" */
export type Files_Set_Input = {
  bucketId?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  etag?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  isUploaded?: InputMaybe<Scalars['Boolean']>;
  metadata?: InputMaybe<Scalars['jsonb']>;
  mimeType?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
  size?: InputMaybe<Scalars['Int']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  uploadedByUserId?: InputMaybe<Scalars['uuid']>;
};

/** aggregate stddev on columns */
export type Files_Stddev_Fields = {
  __typename?: 'files_stddev_fields';
  size?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "storage.files" */
export type Files_Stddev_Order_By = {
  size?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Files_Stddev_Pop_Fields = {
  __typename?: 'files_stddev_pop_fields';
  size?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "storage.files" */
export type Files_Stddev_Pop_Order_By = {
  size?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Files_Stddev_Samp_Fields = {
  __typename?: 'files_stddev_samp_fields';
  size?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "storage.files" */
export type Files_Stddev_Samp_Order_By = {
  size?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "files" */
export type Files_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Files_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Files_Stream_Cursor_Value_Input = {
  bucketId?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  etag?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  isUploaded?: InputMaybe<Scalars['Boolean']>;
  metadata?: InputMaybe<Scalars['jsonb']>;
  mimeType?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
  size?: InputMaybe<Scalars['Int']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  uploadedByUserId?: InputMaybe<Scalars['uuid']>;
};

/** aggregate sum on columns */
export type Files_Sum_Fields = {
  __typename?: 'files_sum_fields';
  size?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "storage.files" */
export type Files_Sum_Order_By = {
  size?: InputMaybe<Order_By>;
};

/** update columns of table "storage.files" */
export enum Files_Update_Column {
  /** column name */
  BucketId = 'bucketId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Etag = 'etag',
  /** column name */
  Id = 'id',
  /** column name */
  IsUploaded = 'isUploaded',
  /** column name */
  Metadata = 'metadata',
  /** column name */
  MimeType = 'mimeType',
  /** column name */
  Name = 'name',
  /** column name */
  Size = 'size',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UploadedByUserId = 'uploadedByUserId'
}

export type Files_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<Files_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<Files_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<Files_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<Files_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Files_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<Files_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Files_Set_Input>;
  /** filter the rows which have to be updated */
  where: Files_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Files_Var_Pop_Fields = {
  __typename?: 'files_var_pop_fields';
  size?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "storage.files" */
export type Files_Var_Pop_Order_By = {
  size?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Files_Var_Samp_Fields = {
  __typename?: 'files_var_samp_fields';
  size?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "storage.files" */
export type Files_Var_Samp_Order_By = {
  size?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Files_Variance_Fields = {
  __typename?: 'files_variance_fields';
  size?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "storage.files" */
export type Files_Variance_Order_By = {
  size?: InputMaybe<Order_By>;
};

/** columns and relationships of "github_app_installations" */
export type GithubAppInstallations = {
  __typename?: 'githubAppInstallations';
  accountAvatarUrl?: Maybe<Scalars['String']>;
  accountLogin?: Maybe<Scalars['String']>;
  accountNodeId?: Maybe<Scalars['String']>;
  accountType?: Maybe<Scalars['String']>;
  createdAt: Scalars['timestamptz'];
  externalGithubAppInstallationId?: Maybe<Scalars['Int']>;
  githubData?: Maybe<Scalars['jsonb']>;
  /** An array relationship */
  githubRepositories: Array<GithubRepositories>;
  /** An aggregate relationship */
  githubRepositories_aggregate: GithubRepositories_Aggregate;
  id: Scalars['uuid'];
  updatedAt: Scalars['timestamptz'];
  /** An object relationship */
  user?: Maybe<Users>;
  userId?: Maybe<Scalars['uuid']>;
};


/** columns and relationships of "github_app_installations" */
export type GithubAppInstallationsGithubDataArgs = {
  path?: InputMaybe<Scalars['String']>;
};


/** columns and relationships of "github_app_installations" */
export type GithubAppInstallationsGithubRepositoriesArgs = {
  distinct_on?: InputMaybe<Array<GithubRepositories_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<GithubRepositories_Order_By>>;
  where?: InputMaybe<GithubRepositories_Bool_Exp>;
};


/** columns and relationships of "github_app_installations" */
export type GithubAppInstallationsGithubRepositories_AggregateArgs = {
  distinct_on?: InputMaybe<Array<GithubRepositories_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<GithubRepositories_Order_By>>;
  where?: InputMaybe<GithubRepositories_Bool_Exp>;
};

/** aggregated selection of "github_app_installations" */
export type GithubAppInstallations_Aggregate = {
  __typename?: 'githubAppInstallations_aggregate';
  aggregate?: Maybe<GithubAppInstallations_Aggregate_Fields>;
  nodes: Array<GithubAppInstallations>;
};

export type GithubAppInstallations_Aggregate_Bool_Exp = {
  count?: InputMaybe<GithubAppInstallations_Aggregate_Bool_Exp_Count>;
};

export type GithubAppInstallations_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<GithubAppInstallations_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<GithubAppInstallations_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "github_app_installations" */
export type GithubAppInstallations_Aggregate_Fields = {
  __typename?: 'githubAppInstallations_aggregate_fields';
  avg?: Maybe<GithubAppInstallations_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<GithubAppInstallations_Max_Fields>;
  min?: Maybe<GithubAppInstallations_Min_Fields>;
  stddev?: Maybe<GithubAppInstallations_Stddev_Fields>;
  stddev_pop?: Maybe<GithubAppInstallations_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<GithubAppInstallations_Stddev_Samp_Fields>;
  sum?: Maybe<GithubAppInstallations_Sum_Fields>;
  var_pop?: Maybe<GithubAppInstallations_Var_Pop_Fields>;
  var_samp?: Maybe<GithubAppInstallations_Var_Samp_Fields>;
  variance?: Maybe<GithubAppInstallations_Variance_Fields>;
};


/** aggregate fields of "github_app_installations" */
export type GithubAppInstallations_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<GithubAppInstallations_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "github_app_installations" */
export type GithubAppInstallations_Aggregate_Order_By = {
  avg?: InputMaybe<GithubAppInstallations_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<GithubAppInstallations_Max_Order_By>;
  min?: InputMaybe<GithubAppInstallations_Min_Order_By>;
  stddev?: InputMaybe<GithubAppInstallations_Stddev_Order_By>;
  stddev_pop?: InputMaybe<GithubAppInstallations_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<GithubAppInstallations_Stddev_Samp_Order_By>;
  sum?: InputMaybe<GithubAppInstallations_Sum_Order_By>;
  var_pop?: InputMaybe<GithubAppInstallations_Var_Pop_Order_By>;
  var_samp?: InputMaybe<GithubAppInstallations_Var_Samp_Order_By>;
  variance?: InputMaybe<GithubAppInstallations_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type GithubAppInstallations_Append_Input = {
  githubData?: InputMaybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "github_app_installations" */
export type GithubAppInstallations_Arr_Rel_Insert_Input = {
  data: Array<GithubAppInstallations_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<GithubAppInstallations_On_Conflict>;
};

/** aggregate avg on columns */
export type GithubAppInstallations_Avg_Fields = {
  __typename?: 'githubAppInstallations_avg_fields';
  externalGithubAppInstallationId?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "github_app_installations" */
export type GithubAppInstallations_Avg_Order_By = {
  externalGithubAppInstallationId?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "github_app_installations". All fields are combined with a logical 'AND'. */
export type GithubAppInstallations_Bool_Exp = {
  _and?: InputMaybe<Array<GithubAppInstallations_Bool_Exp>>;
  _not?: InputMaybe<GithubAppInstallations_Bool_Exp>;
  _or?: InputMaybe<Array<GithubAppInstallations_Bool_Exp>>;
  accountAvatarUrl?: InputMaybe<String_Comparison_Exp>;
  accountLogin?: InputMaybe<String_Comparison_Exp>;
  accountNodeId?: InputMaybe<String_Comparison_Exp>;
  accountType?: InputMaybe<String_Comparison_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  externalGithubAppInstallationId?: InputMaybe<Int_Comparison_Exp>;
  githubData?: InputMaybe<Jsonb_Comparison_Exp>;
  githubRepositories?: InputMaybe<GithubRepositories_Bool_Exp>;
  githubRepositories_aggregate?: InputMaybe<GithubRepositories_Aggregate_Bool_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  user?: InputMaybe<Users_Bool_Exp>;
  userId?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "github_app_installations" */
export enum GithubAppInstallations_Constraint {
  /** unique or primary key constraint on columns "external_github_app_installation_id" */
  GithubAppInstallationsExternalGithubAppInstallationIKey = 'github_app_installations_external_github_app_installation_i_key',
  /** unique or primary key constraint on columns "id" */
  GithubAppInstallationsPkey = 'github_app_installations_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type GithubAppInstallations_Delete_At_Path_Input = {
  githubData?: InputMaybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type GithubAppInstallations_Delete_Elem_Input = {
  githubData?: InputMaybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type GithubAppInstallations_Delete_Key_Input = {
  githubData?: InputMaybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "github_app_installations" */
export type GithubAppInstallations_Inc_Input = {
  externalGithubAppInstallationId?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "github_app_installations" */
export type GithubAppInstallations_Insert_Input = {
  accountAvatarUrl?: InputMaybe<Scalars['String']>;
  accountLogin?: InputMaybe<Scalars['String']>;
  accountNodeId?: InputMaybe<Scalars['String']>;
  accountType?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  externalGithubAppInstallationId?: InputMaybe<Scalars['Int']>;
  githubData?: InputMaybe<Scalars['jsonb']>;
  githubRepositories?: InputMaybe<GithubRepositories_Arr_Rel_Insert_Input>;
  id?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  user?: InputMaybe<Users_Obj_Rel_Insert_Input>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type GithubAppInstallations_Max_Fields = {
  __typename?: 'githubAppInstallations_max_fields';
  accountAvatarUrl?: Maybe<Scalars['String']>;
  accountLogin?: Maybe<Scalars['String']>;
  accountNodeId?: Maybe<Scalars['String']>;
  accountType?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  externalGithubAppInstallationId?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userId?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "github_app_installations" */
export type GithubAppInstallations_Max_Order_By = {
  accountAvatarUrl?: InputMaybe<Order_By>;
  accountLogin?: InputMaybe<Order_By>;
  accountNodeId?: InputMaybe<Order_By>;
  accountType?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  externalGithubAppInstallationId?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  userId?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type GithubAppInstallations_Min_Fields = {
  __typename?: 'githubAppInstallations_min_fields';
  accountAvatarUrl?: Maybe<Scalars['String']>;
  accountLogin?: Maybe<Scalars['String']>;
  accountNodeId?: Maybe<Scalars['String']>;
  accountType?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  externalGithubAppInstallationId?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userId?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "github_app_installations" */
export type GithubAppInstallations_Min_Order_By = {
  accountAvatarUrl?: InputMaybe<Order_By>;
  accountLogin?: InputMaybe<Order_By>;
  accountNodeId?: InputMaybe<Order_By>;
  accountType?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  externalGithubAppInstallationId?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  userId?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "github_app_installations" */
export type GithubAppInstallations_Mutation_Response = {
  __typename?: 'githubAppInstallations_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<GithubAppInstallations>;
};

/** input type for inserting object relation for remote table "github_app_installations" */
export type GithubAppInstallations_Obj_Rel_Insert_Input = {
  data: GithubAppInstallations_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<GithubAppInstallations_On_Conflict>;
};

/** on_conflict condition type for table "github_app_installations" */
export type GithubAppInstallations_On_Conflict = {
  constraint: GithubAppInstallations_Constraint;
  update_columns?: Array<GithubAppInstallations_Update_Column>;
  where?: InputMaybe<GithubAppInstallations_Bool_Exp>;
};

/** Ordering options when selecting data from "github_app_installations". */
export type GithubAppInstallations_Order_By = {
  accountAvatarUrl?: InputMaybe<Order_By>;
  accountLogin?: InputMaybe<Order_By>;
  accountNodeId?: InputMaybe<Order_By>;
  accountType?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  externalGithubAppInstallationId?: InputMaybe<Order_By>;
  githubData?: InputMaybe<Order_By>;
  githubRepositories_aggregate?: InputMaybe<GithubRepositories_Aggregate_Order_By>;
  id?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  user?: InputMaybe<Users_Order_By>;
  userId?: InputMaybe<Order_By>;
};

/** primary key columns input for table: github_app_installations */
export type GithubAppInstallations_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type GithubAppInstallations_Prepend_Input = {
  githubData?: InputMaybe<Scalars['jsonb']>;
};

/** select columns of table "github_app_installations" */
export enum GithubAppInstallations_Select_Column {
  /** column name */
  AccountAvatarUrl = 'accountAvatarUrl',
  /** column name */
  AccountLogin = 'accountLogin',
  /** column name */
  AccountNodeId = 'accountNodeId',
  /** column name */
  AccountType = 'accountType',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  ExternalGithubAppInstallationId = 'externalGithubAppInstallationId',
  /** column name */
  GithubData = 'githubData',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

/** input type for updating data in table "github_app_installations" */
export type GithubAppInstallations_Set_Input = {
  accountAvatarUrl?: InputMaybe<Scalars['String']>;
  accountLogin?: InputMaybe<Scalars['String']>;
  accountNodeId?: InputMaybe<Scalars['String']>;
  accountType?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  externalGithubAppInstallationId?: InputMaybe<Scalars['Int']>;
  githubData?: InputMaybe<Scalars['jsonb']>;
  id?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** aggregate stddev on columns */
export type GithubAppInstallations_Stddev_Fields = {
  __typename?: 'githubAppInstallations_stddev_fields';
  externalGithubAppInstallationId?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "github_app_installations" */
export type GithubAppInstallations_Stddev_Order_By = {
  externalGithubAppInstallationId?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type GithubAppInstallations_Stddev_Pop_Fields = {
  __typename?: 'githubAppInstallations_stddev_pop_fields';
  externalGithubAppInstallationId?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "github_app_installations" */
export type GithubAppInstallations_Stddev_Pop_Order_By = {
  externalGithubAppInstallationId?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type GithubAppInstallations_Stddev_Samp_Fields = {
  __typename?: 'githubAppInstallations_stddev_samp_fields';
  externalGithubAppInstallationId?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "github_app_installations" */
export type GithubAppInstallations_Stddev_Samp_Order_By = {
  externalGithubAppInstallationId?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "githubAppInstallations" */
export type GithubAppInstallations_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: GithubAppInstallations_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type GithubAppInstallations_Stream_Cursor_Value_Input = {
  accountAvatarUrl?: InputMaybe<Scalars['String']>;
  accountLogin?: InputMaybe<Scalars['String']>;
  accountNodeId?: InputMaybe<Scalars['String']>;
  accountType?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  externalGithubAppInstallationId?: InputMaybe<Scalars['Int']>;
  githubData?: InputMaybe<Scalars['jsonb']>;
  id?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userId?: InputMaybe<Scalars['uuid']>;
};

/** aggregate sum on columns */
export type GithubAppInstallations_Sum_Fields = {
  __typename?: 'githubAppInstallations_sum_fields';
  externalGithubAppInstallationId?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "github_app_installations" */
export type GithubAppInstallations_Sum_Order_By = {
  externalGithubAppInstallationId?: InputMaybe<Order_By>;
};

/** update columns of table "github_app_installations" */
export enum GithubAppInstallations_Update_Column {
  /** column name */
  AccountAvatarUrl = 'accountAvatarUrl',
  /** column name */
  AccountLogin = 'accountLogin',
  /** column name */
  AccountNodeId = 'accountNodeId',
  /** column name */
  AccountType = 'accountType',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  ExternalGithubAppInstallationId = 'externalGithubAppInstallationId',
  /** column name */
  GithubData = 'githubData',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

export type GithubAppInstallations_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<GithubAppInstallations_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<GithubAppInstallations_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<GithubAppInstallations_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<GithubAppInstallations_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<GithubAppInstallations_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<GithubAppInstallations_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<GithubAppInstallations_Set_Input>;
  /** filter the rows which have to be updated */
  where: GithubAppInstallations_Bool_Exp;
};

/** aggregate var_pop on columns */
export type GithubAppInstallations_Var_Pop_Fields = {
  __typename?: 'githubAppInstallations_var_pop_fields';
  externalGithubAppInstallationId?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "github_app_installations" */
export type GithubAppInstallations_Var_Pop_Order_By = {
  externalGithubAppInstallationId?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type GithubAppInstallations_Var_Samp_Fields = {
  __typename?: 'githubAppInstallations_var_samp_fields';
  externalGithubAppInstallationId?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "github_app_installations" */
export type GithubAppInstallations_Var_Samp_Order_By = {
  externalGithubAppInstallationId?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type GithubAppInstallations_Variance_Fields = {
  __typename?: 'githubAppInstallations_variance_fields';
  externalGithubAppInstallationId?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "github_app_installations" */
export type GithubAppInstallations_Variance_Order_By = {
  externalGithubAppInstallationId?: InputMaybe<Order_By>;
};

/** columns and relationships of "github_repositories" */
export type GithubRepositories = {
  __typename?: 'githubRepositories';
  /** An array relationship */
  apps: Array<Apps>;
  /** An aggregate relationship */
  apps_aggregate: Apps_Aggregate;
  createdAt: Scalars['timestamptz'];
  externalGithubAppRepositoryNodeId: Scalars['String'];
  fullName: Scalars['String'];
  /** An object relationship */
  githubAppInstallation: GithubAppInstallations;
  githubAppInstallationId: Scalars['uuid'];
  id: Scalars['uuid'];
  name: Scalars['String'];
  private: Scalars['Boolean'];
  updatedAt: Scalars['timestamptz'];
};


/** columns and relationships of "github_repositories" */
export type GithubRepositoriesAppsArgs = {
  distinct_on?: InputMaybe<Array<Apps_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Apps_Order_By>>;
  where?: InputMaybe<Apps_Bool_Exp>;
};


/** columns and relationships of "github_repositories" */
export type GithubRepositoriesApps_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Apps_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Apps_Order_By>>;
  where?: InputMaybe<Apps_Bool_Exp>;
};

/** aggregated selection of "github_repositories" */
export type GithubRepositories_Aggregate = {
  __typename?: 'githubRepositories_aggregate';
  aggregate?: Maybe<GithubRepositories_Aggregate_Fields>;
  nodes: Array<GithubRepositories>;
};

export type GithubRepositories_Aggregate_Bool_Exp = {
  bool_and?: InputMaybe<GithubRepositories_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: InputMaybe<GithubRepositories_Aggregate_Bool_Exp_Bool_Or>;
  count?: InputMaybe<GithubRepositories_Aggregate_Bool_Exp_Count>;
};

export type GithubRepositories_Aggregate_Bool_Exp_Bool_And = {
  arguments: GithubRepositories_Select_Column_GithubRepositories_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<GithubRepositories_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type GithubRepositories_Aggregate_Bool_Exp_Bool_Or = {
  arguments: GithubRepositories_Select_Column_GithubRepositories_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<GithubRepositories_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type GithubRepositories_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<GithubRepositories_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<GithubRepositories_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "github_repositories" */
export type GithubRepositories_Aggregate_Fields = {
  __typename?: 'githubRepositories_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<GithubRepositories_Max_Fields>;
  min?: Maybe<GithubRepositories_Min_Fields>;
};


/** aggregate fields of "github_repositories" */
export type GithubRepositories_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<GithubRepositories_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "github_repositories" */
export type GithubRepositories_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<GithubRepositories_Max_Order_By>;
  min?: InputMaybe<GithubRepositories_Min_Order_By>;
};

/** input type for inserting array relation for remote table "github_repositories" */
export type GithubRepositories_Arr_Rel_Insert_Input = {
  data: Array<GithubRepositories_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<GithubRepositories_On_Conflict>;
};

/** Boolean expression to filter rows from the table "github_repositories". All fields are combined with a logical 'AND'. */
export type GithubRepositories_Bool_Exp = {
  _and?: InputMaybe<Array<GithubRepositories_Bool_Exp>>;
  _not?: InputMaybe<GithubRepositories_Bool_Exp>;
  _or?: InputMaybe<Array<GithubRepositories_Bool_Exp>>;
  apps?: InputMaybe<Apps_Bool_Exp>;
  apps_aggregate?: InputMaybe<Apps_Aggregate_Bool_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  externalGithubAppRepositoryNodeId?: InputMaybe<String_Comparison_Exp>;
  fullName?: InputMaybe<String_Comparison_Exp>;
  githubAppInstallation?: InputMaybe<GithubAppInstallations_Bool_Exp>;
  githubAppInstallationId?: InputMaybe<Uuid_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  private?: InputMaybe<Boolean_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "github_repositories" */
export enum GithubRepositories_Constraint {
  /** unique or primary key constraint on columns "id" */
  GithubRepositoriesPkey = 'github_repositories_pkey'
}

/** input type for inserting data into table "github_repositories" */
export type GithubRepositories_Insert_Input = {
  apps?: InputMaybe<Apps_Arr_Rel_Insert_Input>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  externalGithubAppRepositoryNodeId?: InputMaybe<Scalars['String']>;
  fullName?: InputMaybe<Scalars['String']>;
  githubAppInstallation?: InputMaybe<GithubAppInstallations_Obj_Rel_Insert_Input>;
  githubAppInstallationId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  name?: InputMaybe<Scalars['String']>;
  private?: InputMaybe<Scalars['Boolean']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type GithubRepositories_Max_Fields = {
  __typename?: 'githubRepositories_max_fields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  externalGithubAppRepositoryNodeId?: Maybe<Scalars['String']>;
  fullName?: Maybe<Scalars['String']>;
  githubAppInstallationId?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "github_repositories" */
export type GithubRepositories_Max_Order_By = {
  createdAt?: InputMaybe<Order_By>;
  externalGithubAppRepositoryNodeId?: InputMaybe<Order_By>;
  fullName?: InputMaybe<Order_By>;
  githubAppInstallationId?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type GithubRepositories_Min_Fields = {
  __typename?: 'githubRepositories_min_fields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  externalGithubAppRepositoryNodeId?: Maybe<Scalars['String']>;
  fullName?: Maybe<Scalars['String']>;
  githubAppInstallationId?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "github_repositories" */
export type GithubRepositories_Min_Order_By = {
  createdAt?: InputMaybe<Order_By>;
  externalGithubAppRepositoryNodeId?: InputMaybe<Order_By>;
  fullName?: InputMaybe<Order_By>;
  githubAppInstallationId?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "github_repositories" */
export type GithubRepositories_Mutation_Response = {
  __typename?: 'githubRepositories_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<GithubRepositories>;
};

/** input type for inserting object relation for remote table "github_repositories" */
export type GithubRepositories_Obj_Rel_Insert_Input = {
  data: GithubRepositories_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<GithubRepositories_On_Conflict>;
};

/** on_conflict condition type for table "github_repositories" */
export type GithubRepositories_On_Conflict = {
  constraint: GithubRepositories_Constraint;
  update_columns?: Array<GithubRepositories_Update_Column>;
  where?: InputMaybe<GithubRepositories_Bool_Exp>;
};

/** Ordering options when selecting data from "github_repositories". */
export type GithubRepositories_Order_By = {
  apps_aggregate?: InputMaybe<Apps_Aggregate_Order_By>;
  createdAt?: InputMaybe<Order_By>;
  externalGithubAppRepositoryNodeId?: InputMaybe<Order_By>;
  fullName?: InputMaybe<Order_By>;
  githubAppInstallation?: InputMaybe<GithubAppInstallations_Order_By>;
  githubAppInstallationId?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  private?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
};

/** primary key columns input for table: github_repositories */
export type GithubRepositories_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "github_repositories" */
export enum GithubRepositories_Select_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  ExternalGithubAppRepositoryNodeId = 'externalGithubAppRepositoryNodeId',
  /** column name */
  FullName = 'fullName',
  /** column name */
  GithubAppInstallationId = 'githubAppInstallationId',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Private = 'private',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** select "githubRepositories_aggregate_bool_exp_bool_and_arguments_columns" columns of table "github_repositories" */
export enum GithubRepositories_Select_Column_GithubRepositories_Aggregate_Bool_Exp_Bool_And_Arguments_Columns {
  /** column name */
  Private = 'private'
}

/** select "githubRepositories_aggregate_bool_exp_bool_or_arguments_columns" columns of table "github_repositories" */
export enum GithubRepositories_Select_Column_GithubRepositories_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns {
  /** column name */
  Private = 'private'
}

/** input type for updating data in table "github_repositories" */
export type GithubRepositories_Set_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  externalGithubAppRepositoryNodeId?: InputMaybe<Scalars['String']>;
  fullName?: InputMaybe<Scalars['String']>;
  githubAppInstallationId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  name?: InputMaybe<Scalars['String']>;
  private?: InputMaybe<Scalars['Boolean']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** Streaming cursor of the table "githubRepositories" */
export type GithubRepositories_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: GithubRepositories_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type GithubRepositories_Stream_Cursor_Value_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  externalGithubAppRepositoryNodeId?: InputMaybe<Scalars['String']>;
  fullName?: InputMaybe<Scalars['String']>;
  githubAppInstallationId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  name?: InputMaybe<Scalars['String']>;
  private?: InputMaybe<Scalars['Boolean']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** update columns of table "github_repositories" */
export enum GithubRepositories_Update_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  ExternalGithubAppRepositoryNodeId = 'externalGithubAppRepositoryNodeId',
  /** column name */
  FullName = 'fullName',
  /** column name */
  GithubAppInstallationId = 'githubAppInstallationId',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Private = 'private',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type GithubRepositories_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<GithubRepositories_Set_Input>;
  /** filter the rows which have to be updated */
  where: GithubRepositories_Bool_Exp;
};

export type Jsonb_Cast_Exp = {
  String?: InputMaybe<String_Comparison_Exp>;
};

/** Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'. */
export type Jsonb_Comparison_Exp = {
  _cast?: InputMaybe<Jsonb_Cast_Exp>;
  /** is the column contained in the given json value */
  _contained_in?: InputMaybe<Scalars['jsonb']>;
  /** does the column contain the given json value at the top level */
  _contains?: InputMaybe<Scalars['jsonb']>;
  _eq?: InputMaybe<Scalars['jsonb']>;
  _gt?: InputMaybe<Scalars['jsonb']>;
  _gte?: InputMaybe<Scalars['jsonb']>;
  /** does the string exist as a top-level key in the column */
  _has_key?: InputMaybe<Scalars['String']>;
  /** do all of these strings exist as top-level keys in the column */
  _has_keys_all?: InputMaybe<Array<Scalars['String']>>;
  /** do any of these strings exist as top-level keys in the column */
  _has_keys_any?: InputMaybe<Array<Scalars['String']>>;
  _in?: InputMaybe<Array<Scalars['jsonb']>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _lt?: InputMaybe<Scalars['jsonb']>;
  _lte?: InputMaybe<Scalars['jsonb']>;
  _neq?: InputMaybe<Scalars['jsonb']>;
  _nin?: InputMaybe<Array<Scalars['jsonb']>>;
};

/** mutation root */
export type Mutation_Root = {
  __typename?: 'mutation_root';
  backupAllApplicationsDatabase: Array<Maybe<BackupResultsItem>>;
  backupApplicationDatabase: BackupResult;
  billingCreateOrganizationRequest: Scalars['String'];
  billingFinishSubscription: Scalars['Boolean'];
  billingFixSubscriptions: Scalars['Boolean'];
  billingFullReportWorkflow: Scalars['Boolean'];
  billingMigrateProjectToOrganization: Scalars['Boolean'];
  billingPostOrganizationRequest: PostOrganizationRequestResponse;
  billingUpdateCustomDomains: Scalars['Boolean'];
  billingUpdateDedicatedCompute: Scalars['Boolean'];
  billingUpdateFunctionsAmount: Scalars['Boolean'];
  billingUpdatePersistentVolume: Scalars['Boolean'];
  billingUpdateReports: Scalars['Boolean'];
  billingUploadReports: Scalars['Boolean'];
  changeDatabaseVersion: Scalars['Boolean'];
  /** delete single row from the table: "apps" */
  deleteApp?: Maybe<Apps>;
  /** delete single row from the table: "app_states" */
  deleteAppState?: Maybe<AppStates>;
  /** delete data from the table: "app_state_history" */
  deleteAppStateHistories?: Maybe<AppStateHistory_Mutation_Response>;
  /** delete single row from the table: "app_state_history" */
  deleteAppStateHistory?: Maybe<AppStateHistory>;
  /** delete data from the table: "app_states" */
  deleteAppStates?: Maybe<AppStates_Mutation_Response>;
  /** delete data from the table: "apps" */
  deleteApps?: Maybe<Apps_Mutation_Response>;
  /** delete single row from the table: "auth.providers" */
  deleteAuthProvider?: Maybe<AuthProviders>;
  /** delete single row from the table: "auth.provider_requests" */
  deleteAuthProviderRequest?: Maybe<AuthProviderRequests>;
  /** delete data from the table: "auth.provider_requests" */
  deleteAuthProviderRequests?: Maybe<AuthProviderRequests_Mutation_Response>;
  /** delete data from the table: "auth.providers" */
  deleteAuthProviders?: Maybe<AuthProviders_Mutation_Response>;
  /** delete single row from the table: "auth.refresh_tokens" */
  deleteAuthRefreshToken?: Maybe<AuthRefreshTokens>;
  /** delete single row from the table: "auth.refresh_token_types" */
  deleteAuthRefreshTokenType?: Maybe<AuthRefreshTokenTypes>;
  /** delete data from the table: "auth.refresh_token_types" */
  deleteAuthRefreshTokenTypes?: Maybe<AuthRefreshTokenTypes_Mutation_Response>;
  /** delete data from the table: "auth.refresh_tokens" */
  deleteAuthRefreshTokens?: Maybe<AuthRefreshTokens_Mutation_Response>;
  /** delete single row from the table: "auth.roles" */
  deleteAuthRole?: Maybe<AuthRoles>;
  /** delete data from the table: "auth.roles" */
  deleteAuthRoles?: Maybe<AuthRoles_Mutation_Response>;
  /** delete single row from the table: "auth.user_providers" */
  deleteAuthUserProvider?: Maybe<AuthUserProviders>;
  /** delete data from the table: "auth.user_providers" */
  deleteAuthUserProviders?: Maybe<AuthUserProviders_Mutation_Response>;
  /** delete single row from the table: "auth.user_roles" */
  deleteAuthUserRole?: Maybe<AuthUserRoles>;
  /** delete data from the table: "auth.user_roles" */
  deleteAuthUserRoles?: Maybe<AuthUserRoles_Mutation_Response>;
  /** delete single row from the table: "auth.user_security_keys" */
  deleteAuthUserSecurityKey?: Maybe<AuthUserSecurityKeys>;
  /** delete data from the table: "auth.user_security_keys" */
  deleteAuthUserSecurityKeys?: Maybe<AuthUserSecurityKeys_Mutation_Response>;
  /** delete single row from the table: "backups" */
  deleteBackup?: Maybe<Backups>;
  /** delete data from the table: "backups" */
  deleteBackups?: Maybe<Backups_Mutation_Response>;
  /** delete single row from the table: "billing.dedicated_compute" */
  deleteBillingDedicatedCompute?: Maybe<Billing_Dedicated_Compute>;
  /** delete data from the table: "billing.dedicated_compute" */
  deleteBillingDedicatedComputes?: Maybe<Billing_Dedicated_Compute_Mutation_Response>;
  /** delete single row from the table: "billing.reports" */
  deleteBillingReport?: Maybe<Billing_Reports>;
  /** delete data from the table: "billing.reports" */
  deleteBillingReports?: Maybe<Billing_Reports_Mutation_Response>;
  /** delete single row from the table: "billing.resources" */
  deleteBillingResource?: Maybe<Billing_Resources>;
  /** delete data from the table: "billing.resources" */
  deleteBillingResources?: Maybe<Billing_Resources_Mutation_Response>;
  /** delete data from the table: "billing.subscriptions" */
  deleteBillingSubscription?: Maybe<Billing_Subscriptions_Mutation_Response>;
  /** delete single row from the table: "billing.subscriptions" */
  deleteBillingSubscriptions?: Maybe<Billing_Subscriptions>;
  /** delete single row from the table: "storage.buckets" */
  deleteBucket?: Maybe<Buckets>;
  /** delete data from the table: "storage.buckets" */
  deleteBuckets?: Maybe<Buckets_Mutation_Response>;
  /** delete single row from the table: "cli_tokens" */
  deleteCliToken?: Maybe<CliTokens>;
  /** delete data from the table: "cli_tokens" */
  deleteCliTokens?: Maybe<CliTokens_Mutation_Response>;
  deleteConfig?: Maybe<ConfigConfig>;
  /** delete single row from the table: "deployments" */
  deleteDeployment?: Maybe<Deployments>;
  /** delete single row from the table: "deployment_logs" */
  deleteDeploymentLog?: Maybe<DeploymentLogs>;
  /** delete data from the table: "deployment_logs" */
  deleteDeploymentLogs?: Maybe<DeploymentLogs_Mutation_Response>;
  /** delete data from the table: "deployments" */
  deleteDeployments?: Maybe<Deployments_Mutation_Response>;
  /** delete single row from the table: "feature_flags" */
  deleteFeatureFlag?: Maybe<FeatureFlags>;
  /** delete data from the table: "feature_flags" */
  deleteFeatureFlags?: Maybe<FeatureFlags_Mutation_Response>;
  /** delete single row from the table: "storage.files" */
  deleteFile?: Maybe<Files>;
  /** delete data from the table: "storage.files" */
  deleteFiles?: Maybe<Files_Mutation_Response>;
  /** delete single row from the table: "github_app_installations" */
  deleteGithubAppInstallation?: Maybe<GithubAppInstallations>;
  /** delete data from the table: "github_app_installations" */
  deleteGithubAppInstallations?: Maybe<GithubAppInstallations_Mutation_Response>;
  /** delete data from the table: "github_repositories" */
  deleteGithubRepositories?: Maybe<GithubRepositories_Mutation_Response>;
  /** delete single row from the table: "github_repositories" */
  deleteGithubRepository?: Maybe<GithubRepositories>;
  /** delete single row from the table: "organizations" */
  deleteOrganization?: Maybe<Organizations>;
  /** delete single row from the table: "organizations_free_usage" */
  deleteOrganizationFreeUsage?: Maybe<Organizations_Free_Usage>;
  /** delete data from the table: "organizations_free_usage" */
  deleteOrganizationFreeUsages?: Maybe<Organizations_Free_Usage_Mutation_Response>;
  /** delete single row from the table: "organization_members" */
  deleteOrganizationMember?: Maybe<Organization_Members>;
  /** delete single row from the table: "organization_member_invites" */
  deleteOrganizationMemberInvite?: Maybe<Organization_Member_Invites>;
  /** delete data from the table: "organization_member_invites" */
  deleteOrganizationMemberInvites?: Maybe<Organization_Member_Invites_Mutation_Response>;
  /** delete data from the table: "organization_members" */
  deleteOrganizationMembers?: Maybe<Organization_Members_Mutation_Response>;
  /** delete single row from the table: "organization_new_request" */
  deleteOrganizationNewRequest?: Maybe<Organization_New_Request>;
  /** delete data from the table: "organization_new_request" */
  deleteOrganizationNewRequests?: Maybe<Organization_New_Request_Mutation_Response>;
  /** delete data from the table: "organizations" */
  deleteOrganizations?: Maybe<Organizations_Mutation_Response>;
  /** delete single row from the table: "payment_methods" */
  deletePaymentMethod?: Maybe<PaymentMethods>;
  /** delete data from the table: "payment_methods" */
  deletePaymentMethods?: Maybe<PaymentMethods_Mutation_Response>;
  /** delete single row from the table: "plans" */
  deletePlan?: Maybe<Plans>;
  /** delete data from the table: "plans" */
  deletePlans?: Maybe<Plans_Mutation_Response>;
  /** delete single row from the table: "regions_allowed_organization" */
  deleteRegionsAllowedOrganization?: Maybe<Regions_Allowed_Organization>;
  /** delete data from the table: "regions_allowed_organization" */
  deleteRegionsAllowedOrganizations?: Maybe<Regions_Allowed_Organization_Mutation_Response>;
  /** delete single row from the table: "regions_allowed_workspace" */
  deleteRegionsAllowedWorkspace?: Maybe<Regions_Allowed_Workspace>;
  /** delete data from the table: "regions_allowed_workspace" */
  deleteRegionsAllowedWorkspaces?: Maybe<Regions_Allowed_Workspace_Mutation_Response>;
  /** delete single row from the table: "run_service" */
  deleteRunService?: Maybe<Run_Service>;
  deleteRunServiceConfig?: Maybe<ConfigRunServiceConfig>;
  /** delete data from the table: "run_service" */
  deleteRunServices?: Maybe<Run_Service_Mutation_Response>;
  deleteSecret?: Maybe<ConfigEnvironmentVariable>;
  /** delete single row from the table: "software_type" */
  deleteSoftwareType?: Maybe<Software_Type>;
  /** delete data from the table: "software_type" */
  deleteSoftwareTypes?: Maybe<Software_Type_Mutation_Response>;
  /** delete single row from the table: "software_versions" */
  deleteSoftwareVersion?: Maybe<Software_Versions>;
  /** delete data from the table: "software_versions" */
  deleteSoftwareVersions?: Maybe<Software_Versions_Mutation_Response>;
  /** delete single row from the table: "auth.users" */
  deleteUser?: Maybe<Users>;
  /** delete data from the table: "auth.users" */
  deleteUsers?: Maybe<Users_Mutation_Response>;
  /** delete single row from the table: "storage.virus" */
  deleteVirus?: Maybe<Virus>;
  /** delete data from the table: "storage.virus" */
  deleteViruses?: Maybe<Virus_Mutation_Response>;
  /** delete single row from the table: "workspaces" */
  deleteWorkspace?: Maybe<Workspaces>;
  /** delete single row from the table: "workspace_members" */
  deleteWorkspaceMember?: Maybe<WorkspaceMembers>;
  /** delete single row from the table: "workspace_member_invites" */
  deleteWorkspaceMemberInvite?: Maybe<WorkspaceMemberInvites>;
  /** delete data from the table: "workspace_member_invites" */
  deleteWorkspaceMemberInvites?: Maybe<WorkspaceMemberInvites_Mutation_Response>;
  /** delete data from the table: "workspace_members" */
  deleteWorkspaceMembers?: Maybe<WorkspaceMembers_Mutation_Response>;
  /** delete data from the table: "workspaces" */
  deleteWorkspaces?: Maybe<Workspaces_Mutation_Response>;
  /** delete data from the table: "announcements" */
  delete_announcements?: Maybe<Announcements_Mutation_Response>;
  /** delete single row from the table: "announcements" */
  delete_announcements_by_pk?: Maybe<Announcements>;
  /** delete data from the table: "auth.migrations" */
  delete_auth_migrations?: Maybe<Auth_Migrations_Mutation_Response>;
  /** delete single row from the table: "auth.migrations" */
  delete_auth_migrations_by_pk?: Maybe<Auth_Migrations>;
  /** delete data from the table: "billing.report_type" */
  delete_billing_report_type?: Maybe<Billing_Report_Type_Mutation_Response>;
  /** delete single row from the table: "billing.report_type" */
  delete_billing_report_type_by_pk?: Maybe<Billing_Report_Type>;
  /** delete data from the table: "continents" */
  delete_continents?: Maybe<Continents_Mutation_Response>;
  /** delete single row from the table: "continents" */
  delete_continents_by_pk?: Maybe<Continents>;
  /** delete data from the table: "countries" */
  delete_countries?: Maybe<Countries_Mutation_Response>;
  /** delete single row from the table: "countries" */
  delete_countries_by_pk?: Maybe<Countries>;
  /** delete data from the table: "organization_members_role" */
  delete_organization_members_role?: Maybe<Organization_Members_Role_Mutation_Response>;
  /** delete single row from the table: "organization_members_role" */
  delete_organization_members_role_by_pk?: Maybe<Organization_Members_Role>;
  /** delete data from the table: "organization_status" */
  delete_organization_status?: Maybe<Organization_Status_Mutation_Response>;
  /** delete single row from the table: "organization_status" */
  delete_organization_status_by_pk?: Maybe<Organization_Status>;
  /** delete data from the table: "region_type" */
  delete_region_type?: Maybe<Region_Type_Mutation_Response>;
  /** delete single row from the table: "region_type" */
  delete_region_type_by_pk?: Maybe<Region_Type>;
  /** delete data from the table: "regions" */
  delete_regions?: Maybe<Regions_Mutation_Response>;
  /** delete single row from the table: "regions" */
  delete_regions_by_pk?: Maybe<Regions>;
  /** insert a single row into the table: "apps" */
  insertApp?: Maybe<Apps>;
  /** insert a single row into the table: "app_states" */
  insertAppState?: Maybe<AppStates>;
  /** insert data into the table: "app_state_history" */
  insertAppStateHistories?: Maybe<AppStateHistory_Mutation_Response>;
  /** insert a single row into the table: "app_state_history" */
  insertAppStateHistory?: Maybe<AppStateHistory>;
  /** insert data into the table: "app_states" */
  insertAppStates?: Maybe<AppStates_Mutation_Response>;
  /** insert data into the table: "apps" */
  insertApps?: Maybe<Apps_Mutation_Response>;
  /** insert a single row into the table: "auth.providers" */
  insertAuthProvider?: Maybe<AuthProviders>;
  /** insert a single row into the table: "auth.provider_requests" */
  insertAuthProviderRequest?: Maybe<AuthProviderRequests>;
  /** insert data into the table: "auth.provider_requests" */
  insertAuthProviderRequests?: Maybe<AuthProviderRequests_Mutation_Response>;
  /** insert data into the table: "auth.providers" */
  insertAuthProviders?: Maybe<AuthProviders_Mutation_Response>;
  /** insert a single row into the table: "auth.refresh_tokens" */
  insertAuthRefreshToken?: Maybe<AuthRefreshTokens>;
  /** insert a single row into the table: "auth.refresh_token_types" */
  insertAuthRefreshTokenType?: Maybe<AuthRefreshTokenTypes>;
  /** insert data into the table: "auth.refresh_token_types" */
  insertAuthRefreshTokenTypes?: Maybe<AuthRefreshTokenTypes_Mutation_Response>;
  /** insert data into the table: "auth.refresh_tokens" */
  insertAuthRefreshTokens?: Maybe<AuthRefreshTokens_Mutation_Response>;
  /** insert a single row into the table: "auth.roles" */
  insertAuthRole?: Maybe<AuthRoles>;
  /** insert data into the table: "auth.roles" */
  insertAuthRoles?: Maybe<AuthRoles_Mutation_Response>;
  /** insert a single row into the table: "auth.user_providers" */
  insertAuthUserProvider?: Maybe<AuthUserProviders>;
  /** insert data into the table: "auth.user_providers" */
  insertAuthUserProviders?: Maybe<AuthUserProviders_Mutation_Response>;
  /** insert a single row into the table: "auth.user_roles" */
  insertAuthUserRole?: Maybe<AuthUserRoles>;
  /** insert data into the table: "auth.user_roles" */
  insertAuthUserRoles?: Maybe<AuthUserRoles_Mutation_Response>;
  /** insert a single row into the table: "auth.user_security_keys" */
  insertAuthUserSecurityKey?: Maybe<AuthUserSecurityKeys>;
  /** insert data into the table: "auth.user_security_keys" */
  insertAuthUserSecurityKeys?: Maybe<AuthUserSecurityKeys_Mutation_Response>;
  /** insert a single row into the table: "backups" */
  insertBackup?: Maybe<Backups>;
  /** insert data into the table: "backups" */
  insertBackups?: Maybe<Backups_Mutation_Response>;
  /** insert a single row into the table: "billing.dedicated_compute" */
  insertBillingDedicatedCompute?: Maybe<Billing_Dedicated_Compute>;
  /** insert data into the table: "billing.dedicated_compute" */
  insertBillingDedicatedComputes?: Maybe<Billing_Dedicated_Compute_Mutation_Response>;
  /** insert a single row into the table: "billing.reports" */
  insertBillingReport?: Maybe<Billing_Reports>;
  /** insert data into the table: "billing.reports" */
  insertBillingReports?: Maybe<Billing_Reports_Mutation_Response>;
  /** insert a single row into the table: "billing.resources" */
  insertBillingResource?: Maybe<Billing_Resources>;
  /** insert data into the table: "billing.resources" */
  insertBillingResources?: Maybe<Billing_Resources_Mutation_Response>;
  /** insert data into the table: "billing.subscriptions" */
  insertBillingSubscription?: Maybe<Billing_Subscriptions_Mutation_Response>;
  /** insert a single row into the table: "billing.subscriptions" */
  insertBillingSubscriptions?: Maybe<Billing_Subscriptions>;
  /** insert a single row into the table: "storage.buckets" */
  insertBucket?: Maybe<Buckets>;
  /** insert data into the table: "storage.buckets" */
  insertBuckets?: Maybe<Buckets_Mutation_Response>;
  /** insert a single row into the table: "cli_tokens" */
  insertCliToken?: Maybe<CliTokens>;
  /** insert data into the table: "cli_tokens" */
  insertCliTokens?: Maybe<CliTokens_Mutation_Response>;
  insertConfig: ConfigInsertConfigResponse;
  /** insert a single row into the table: "deployments" */
  insertDeployment?: Maybe<Deployments>;
  /** insert a single row into the table: "deployment_logs" */
  insertDeploymentLog?: Maybe<DeploymentLogs>;
  /** insert data into the table: "deployment_logs" */
  insertDeploymentLogs?: Maybe<DeploymentLogs_Mutation_Response>;
  /** insert data into the table: "deployments" */
  insertDeployments?: Maybe<Deployments_Mutation_Response>;
  /** insert a single row into the table: "feature_flags" */
  insertFeatureFlag?: Maybe<FeatureFlags>;
  /** insert data into the table: "feature_flags" */
  insertFeatureFlags?: Maybe<FeatureFlags_Mutation_Response>;
  /** insert a single row into the table: "storage.files" */
  insertFile?: Maybe<Files>;
  /** insert data into the table: "storage.files" */
  insertFiles?: Maybe<Files_Mutation_Response>;
  /** insert a single row into the table: "github_app_installations" */
  insertGithubAppInstallation?: Maybe<GithubAppInstallations>;
  /** insert data into the table: "github_app_installations" */
  insertGithubAppInstallations?: Maybe<GithubAppInstallations_Mutation_Response>;
  /** insert data into the table: "github_repositories" */
  insertGithubRepositories?: Maybe<GithubRepositories_Mutation_Response>;
  /** insert a single row into the table: "github_repositories" */
  insertGithubRepository?: Maybe<GithubRepositories>;
  /** insert a single row into the table: "organizations" */
  insertOrganization?: Maybe<Organizations>;
  /** insert a single row into the table: "organizations_free_usage" */
  insertOrganizationFreeUsage?: Maybe<Organizations_Free_Usage>;
  /** insert data into the table: "organizations_free_usage" */
  insertOrganizationFreeUsages?: Maybe<Organizations_Free_Usage_Mutation_Response>;
  /** insert a single row into the table: "organization_members" */
  insertOrganizationMember?: Maybe<Organization_Members>;
  /** insert a single row into the table: "organization_member_invites" */
  insertOrganizationMemberInvite?: Maybe<Organization_Member_Invites>;
  /** insert data into the table: "organization_member_invites" */
  insertOrganizationMemberInvites?: Maybe<Organization_Member_Invites_Mutation_Response>;
  /** insert data into the table: "organization_members" */
  insertOrganizationMembers?: Maybe<Organization_Members_Mutation_Response>;
  /** insert a single row into the table: "organization_new_request" */
  insertOrganizationNewRequest?: Maybe<Organization_New_Request>;
  /** insert data into the table: "organization_new_request" */
  insertOrganizationNewRequests?: Maybe<Organization_New_Request_Mutation_Response>;
  /** insert data into the table: "organizations" */
  insertOrganizations?: Maybe<Organizations_Mutation_Response>;
  /** insert a single row into the table: "payment_methods" */
  insertPaymentMethod?: Maybe<PaymentMethods>;
  /** insert data into the table: "payment_methods" */
  insertPaymentMethods?: Maybe<PaymentMethods_Mutation_Response>;
  /** insert a single row into the table: "plans" */
  insertPlan?: Maybe<Plans>;
  /** insert data into the table: "plans" */
  insertPlans?: Maybe<Plans_Mutation_Response>;
  /** insert a single row into the table: "regions_allowed_organization" */
  insertRegionsAllowedOrganization?: Maybe<Regions_Allowed_Organization>;
  /** insert data into the table: "regions_allowed_organization" */
  insertRegionsAllowedOrganizations?: Maybe<Regions_Allowed_Organization_Mutation_Response>;
  /** insert a single row into the table: "regions_allowed_workspace" */
  insertRegionsAllowedWorkspace?: Maybe<Regions_Allowed_Workspace>;
  /** insert data into the table: "regions_allowed_workspace" */
  insertRegionsAllowedWorkspaces?: Maybe<Regions_Allowed_Workspace_Mutation_Response>;
  /** insert a single row into the table: "run_service" */
  insertRunService?: Maybe<Run_Service>;
  insertRunServiceConfig: ConfigRunServiceConfig;
  /** insert data into the table: "run_service" */
  insertRunServices?: Maybe<Run_Service_Mutation_Response>;
  insertSecret: ConfigEnvironmentVariable;
  /** insert a single row into the table: "software_type" */
  insertSoftwareType?: Maybe<Software_Type>;
  /** insert data into the table: "software_type" */
  insertSoftwareTypes?: Maybe<Software_Type_Mutation_Response>;
  /** insert a single row into the table: "software_versions" */
  insertSoftwareVersion?: Maybe<Software_Versions>;
  /** insert data into the table: "software_versions" */
  insertSoftwareVersions?: Maybe<Software_Versions_Mutation_Response>;
  /** insert a single row into the table: "auth.users" */
  insertUser?: Maybe<Users>;
  /** insert data into the table: "auth.users" */
  insertUsers?: Maybe<Users_Mutation_Response>;
  /** insert a single row into the table: "storage.virus" */
  insertVirus?: Maybe<Virus>;
  /** insert data into the table: "storage.virus" */
  insertViruses?: Maybe<Virus_Mutation_Response>;
  /** insert a single row into the table: "workspaces" */
  insertWorkspace?: Maybe<Workspaces>;
  /** insert a single row into the table: "workspace_members" */
  insertWorkspaceMember?: Maybe<WorkspaceMembers>;
  /** insert a single row into the table: "workspace_member_invites" */
  insertWorkspaceMemberInvite?: Maybe<WorkspaceMemberInvites>;
  /** insert data into the table: "workspace_member_invites" */
  insertWorkspaceMemberInvites?: Maybe<WorkspaceMemberInvites_Mutation_Response>;
  /** insert data into the table: "workspace_members" */
  insertWorkspaceMembers?: Maybe<WorkspaceMembers_Mutation_Response>;
  /** insert data into the table: "workspaces" */
  insertWorkspaces?: Maybe<Workspaces_Mutation_Response>;
  /** insert data into the table: "announcements" */
  insert_announcements?: Maybe<Announcements_Mutation_Response>;
  /** insert a single row into the table: "announcements" */
  insert_announcements_one?: Maybe<Announcements>;
  /** insert data into the table: "auth.migrations" */
  insert_auth_migrations?: Maybe<Auth_Migrations_Mutation_Response>;
  /** insert a single row into the table: "auth.migrations" */
  insert_auth_migrations_one?: Maybe<Auth_Migrations>;
  /** insert data into the table: "billing.report_type" */
  insert_billing_report_type?: Maybe<Billing_Report_Type_Mutation_Response>;
  /** insert a single row into the table: "billing.report_type" */
  insert_billing_report_type_one?: Maybe<Billing_Report_Type>;
  /** insert data into the table: "continents" */
  insert_continents?: Maybe<Continents_Mutation_Response>;
  /** insert a single row into the table: "continents" */
  insert_continents_one?: Maybe<Continents>;
  /** insert data into the table: "countries" */
  insert_countries?: Maybe<Countries_Mutation_Response>;
  /** insert a single row into the table: "countries" */
  insert_countries_one?: Maybe<Countries>;
  /** insert data into the table: "organization_members_role" */
  insert_organization_members_role?: Maybe<Organization_Members_Role_Mutation_Response>;
  /** insert a single row into the table: "organization_members_role" */
  insert_organization_members_role_one?: Maybe<Organization_Members_Role>;
  /** insert data into the table: "organization_status" */
  insert_organization_status?: Maybe<Organization_Status_Mutation_Response>;
  /** insert a single row into the table: "organization_status" */
  insert_organization_status_one?: Maybe<Organization_Status>;
  /** insert data into the table: "region_type" */
  insert_region_type?: Maybe<Region_Type_Mutation_Response>;
  /** insert a single row into the table: "region_type" */
  insert_region_type_one?: Maybe<Region_Type>;
  /** insert data into the table: "regions" */
  insert_regions?: Maybe<Regions_Mutation_Response>;
  /** insert a single row into the table: "regions" */
  insert_regions_one?: Maybe<Regions>;
  /** execute VOLATILE function "organization_member_invite_accept" which returns "organization_members" */
  organizationMemberInviteAccept: Array<Organization_Members>;
  pauseAppsExceedUsage: Array<Scalars['String']>;
  pauseInactiveApps: Array<Scalars['String']>;
  replaceConfig: ConfigConfig;
  replaceConfigRawJSON: Scalars['String'];
  replaceRunServiceConfig: ConfigRunServiceConfig;
  resetPostgresPassword: Scalars['Boolean'];
  restoreApplicationDatabase: Scalars['Boolean'];
  sendEmailTemplate: Scalars['Boolean'];
  /** update single row of the table: "apps" */
  updateApp?: Maybe<Apps>;
  /** update single row of the table: "app_states" */
  updateAppState?: Maybe<AppStates>;
  /** update data of the table: "app_state_history" */
  updateAppStateHistories?: Maybe<AppStateHistory_Mutation_Response>;
  /** update single row of the table: "app_state_history" */
  updateAppStateHistory?: Maybe<AppStateHistory>;
  /** update data of the table: "app_states" */
  updateAppStates?: Maybe<AppStates_Mutation_Response>;
  /** update data of the table: "apps" */
  updateApps?: Maybe<Apps_Mutation_Response>;
  /** update single row of the table: "auth.providers" */
  updateAuthProvider?: Maybe<AuthProviders>;
  /** update single row of the table: "auth.provider_requests" */
  updateAuthProviderRequest?: Maybe<AuthProviderRequests>;
  /** update data of the table: "auth.provider_requests" */
  updateAuthProviderRequests?: Maybe<AuthProviderRequests_Mutation_Response>;
  /** update data of the table: "auth.providers" */
  updateAuthProviders?: Maybe<AuthProviders_Mutation_Response>;
  /** update single row of the table: "auth.refresh_tokens" */
  updateAuthRefreshToken?: Maybe<AuthRefreshTokens>;
  /** update single row of the table: "auth.refresh_token_types" */
  updateAuthRefreshTokenType?: Maybe<AuthRefreshTokenTypes>;
  /** update data of the table: "auth.refresh_token_types" */
  updateAuthRefreshTokenTypes?: Maybe<AuthRefreshTokenTypes_Mutation_Response>;
  /** update data of the table: "auth.refresh_tokens" */
  updateAuthRefreshTokens?: Maybe<AuthRefreshTokens_Mutation_Response>;
  /** update single row of the table: "auth.roles" */
  updateAuthRole?: Maybe<AuthRoles>;
  /** update data of the table: "auth.roles" */
  updateAuthRoles?: Maybe<AuthRoles_Mutation_Response>;
  /** update single row of the table: "auth.user_providers" */
  updateAuthUserProvider?: Maybe<AuthUserProviders>;
  /** update data of the table: "auth.user_providers" */
  updateAuthUserProviders?: Maybe<AuthUserProviders_Mutation_Response>;
  /** update single row of the table: "auth.user_roles" */
  updateAuthUserRole?: Maybe<AuthUserRoles>;
  /** update data of the table: "auth.user_roles" */
  updateAuthUserRoles?: Maybe<AuthUserRoles_Mutation_Response>;
  /** update single row of the table: "auth.user_security_keys" */
  updateAuthUserSecurityKey?: Maybe<AuthUserSecurityKeys>;
  /** update data of the table: "auth.user_security_keys" */
  updateAuthUserSecurityKeys?: Maybe<AuthUserSecurityKeys_Mutation_Response>;
  /** update single row of the table: "backups" */
  updateBackup?: Maybe<Backups>;
  /** update data of the table: "backups" */
  updateBackups?: Maybe<Backups_Mutation_Response>;
  /** update single row of the table: "billing.dedicated_compute" */
  updateBillingDedicatedCompute?: Maybe<Billing_Dedicated_Compute>;
  /** update data of the table: "billing.dedicated_compute" */
  updateBillingDedicatedComputes?: Maybe<Billing_Dedicated_Compute_Mutation_Response>;
  /** update single row of the table: "billing.reports" */
  updateBillingReport?: Maybe<Billing_Reports>;
  /** update data of the table: "billing.reports" */
  updateBillingReports?: Maybe<Billing_Reports_Mutation_Response>;
  /** update single row of the table: "billing.resources" */
  updateBillingResource?: Maybe<Billing_Resources>;
  /** update data of the table: "billing.resources" */
  updateBillingResources?: Maybe<Billing_Resources_Mutation_Response>;
  /** update single row of the table: "billing.subscriptions" */
  updateBillingSubscription?: Maybe<Billing_Subscriptions>;
  /** update data of the table: "billing.subscriptions" */
  updateBillingSubscriptions?: Maybe<Billing_Subscriptions_Mutation_Response>;
  /** update single row of the table: "storage.buckets" */
  updateBucket?: Maybe<Buckets>;
  /** update data of the table: "storage.buckets" */
  updateBuckets?: Maybe<Buckets_Mutation_Response>;
  /** update single row of the table: "cli_tokens" */
  updateCliToken?: Maybe<CliTokens>;
  /** update data of the table: "cli_tokens" */
  updateCliTokens?: Maybe<CliTokens_Mutation_Response>;
  updateConfig: ConfigConfig;
  /** update single row of the table: "deployments" */
  updateDeployment?: Maybe<Deployments>;
  /** update single row of the table: "deployment_logs" */
  updateDeploymentLog?: Maybe<DeploymentLogs>;
  /** update data of the table: "deployment_logs" */
  updateDeploymentLogs?: Maybe<DeploymentLogs_Mutation_Response>;
  /** update data of the table: "deployments" */
  updateDeployments?: Maybe<Deployments_Mutation_Response>;
  /** update single row of the table: "feature_flags" */
  updateFeatureFlag?: Maybe<FeatureFlags>;
  /** update data of the table: "feature_flags" */
  updateFeatureFlags?: Maybe<FeatureFlags_Mutation_Response>;
  /** update single row of the table: "storage.files" */
  updateFile?: Maybe<Files>;
  /** update data of the table: "storage.files" */
  updateFiles?: Maybe<Files_Mutation_Response>;
  /** update single row of the table: "github_app_installations" */
  updateGithubAppInstallation?: Maybe<GithubAppInstallations>;
  /** update data of the table: "github_app_installations" */
  updateGithubAppInstallations?: Maybe<GithubAppInstallations_Mutation_Response>;
  /** update data of the table: "github_repositories" */
  updateGithubRepositories?: Maybe<GithubRepositories_Mutation_Response>;
  /** update single row of the table: "github_repositories" */
  updateGithubRepository?: Maybe<GithubRepositories>;
  /** update multiples rows of table: "billing.reports" */
  updateManyBillingReports?: Maybe<Array<Maybe<Billing_Reports_Mutation_Response>>>;
  /** update multiples rows of table: "billing.resources" */
  updateManyBillingResources?: Maybe<Array<Maybe<Billing_Resources_Mutation_Response>>>;
  /** update multiples rows of table: "software_type" */
  updateManySoftwareType?: Maybe<Array<Maybe<Software_Type_Mutation_Response>>>;
  /** update multiples rows of table: "software_versions" */
  updateManySoftwareVersions?: Maybe<Array<Maybe<Software_Versions_Mutation_Response>>>;
  /** update single row of the table: "organizations" */
  updateOrganization?: Maybe<Organizations>;
  /** update single row of the table: "organizations_free_usage" */
  updateOrganizationFreeUsage?: Maybe<Organizations_Free_Usage>;
  /** update multiples rows of table: "organizations_free_usage" */
  updateOrganizationFreeUsageMany?: Maybe<Array<Maybe<Organizations_Free_Usage_Mutation_Response>>>;
  /** update data of the table: "organizations_free_usage" */
  updateOrganizationFreeUsages?: Maybe<Organizations_Free_Usage_Mutation_Response>;
  /** update single row of the table: "organization_members" */
  updateOrganizationMember?: Maybe<Organization_Members>;
  /** update single row of the table: "organization_member_invites" */
  updateOrganizationMemberInvite?: Maybe<Organization_Member_Invites>;
  /** update data of the table: "organization_member_invites" */
  updateOrganizationMemberInvites?: Maybe<Organization_Member_Invites_Mutation_Response>;
  /** update multiples rows of table: "organization_member_invites" */
  updateOrganizationMemberInvitesMany?: Maybe<Array<Maybe<Organization_Member_Invites_Mutation_Response>>>;
  /** update data of the table: "organization_members" */
  updateOrganizationMembers?: Maybe<Organization_Members_Mutation_Response>;
  /** update multiples rows of table: "organization_members" */
  updateOrganizationMembersMany?: Maybe<Array<Maybe<Organization_Members_Mutation_Response>>>;
  /** update single row of the table: "organization_new_request" */
  updateOrganizationNewRequest?: Maybe<Organization_New_Request>;
  /** update data of the table: "organization_new_request" */
  updateOrganizationNewRequests?: Maybe<Organization_New_Request_Mutation_Response>;
  /** update multiples rows of table: "organization_new_request" */
  updateOrganizationNewRequestsMany?: Maybe<Array<Maybe<Organization_New_Request_Mutation_Response>>>;
  /** update data of the table: "organizations" */
  updateOrganizations?: Maybe<Organizations_Mutation_Response>;
  /** update multiples rows of table: "organizations" */
  updateOrganizationsMany?: Maybe<Array<Maybe<Organizations_Mutation_Response>>>;
  /** update single row of the table: "payment_methods" */
  updatePaymentMethod?: Maybe<PaymentMethods>;
  /** update data of the table: "payment_methods" */
  updatePaymentMethods?: Maybe<PaymentMethods_Mutation_Response>;
  /** update single row of the table: "plans" */
  updatePlan?: Maybe<Plans>;
  /** update data of the table: "plans" */
  updatePlans?: Maybe<Plans_Mutation_Response>;
  /** update single row of the table: "regions_allowed_organization" */
  updateRegionsAllowedOrganization?: Maybe<Regions_Allowed_Organization>;
  /** update data of the table: "regions_allowed_organization" */
  updateRegionsAllowedOrganizations?: Maybe<Regions_Allowed_Organization_Mutation_Response>;
  /** update multiples rows of table: "regions_allowed_organization" */
  updateRegionsAllowedOrganizationsMany?: Maybe<Array<Maybe<Regions_Allowed_Organization_Mutation_Response>>>;
  /** update single row of the table: "regions_allowed_workspace" */
  updateRegionsAllowedWorkspace?: Maybe<Regions_Allowed_Workspace>;
  /** update data of the table: "regions_allowed_workspace" */
  updateRegionsAllowedWorkspaces?: Maybe<Regions_Allowed_Workspace_Mutation_Response>;
  /** update single row of the table: "run_service" */
  updateRunService?: Maybe<Run_Service>;
  updateRunServiceConfig: ConfigRunServiceConfig;
  /** update data of the table: "run_service" */
  updateRunServices?: Maybe<Run_Service_Mutation_Response>;
  updateSecret: ConfigEnvironmentVariable;
  /** update single row of the table: "software_type" */
  updateSoftwareType?: Maybe<Software_Type>;
  /** update data of the table: "software_type" */
  updateSoftwareTypes?: Maybe<Software_Type_Mutation_Response>;
  /** update single row of the table: "software_versions" */
  updateSoftwareVersion?: Maybe<Software_Versions>;
  /** update data of the table: "software_versions" */
  updateSoftwareVersions?: Maybe<Software_Versions_Mutation_Response>;
  updateSystemConfig: ConfigSystemConfig;
  /** update single row of the table: "auth.users" */
  updateUser?: Maybe<Users>;
  /** update data of the table: "auth.users" */
  updateUsers?: Maybe<Users_Mutation_Response>;
  /** update single row of the table: "storage.virus" */
  updateVirus?: Maybe<Virus>;
  /** update data of the table: "storage.virus" */
  updateViruses?: Maybe<Virus_Mutation_Response>;
  /** update single row of the table: "workspaces" */
  updateWorkspace?: Maybe<Workspaces>;
  /** update single row of the table: "workspace_members" */
  updateWorkspaceMember?: Maybe<WorkspaceMembers>;
  /** update single row of the table: "workspace_member_invites" */
  updateWorkspaceMemberInvite?: Maybe<WorkspaceMemberInvites>;
  /** update data of the table: "workspace_member_invites" */
  updateWorkspaceMemberInvites?: Maybe<WorkspaceMemberInvites_Mutation_Response>;
  /** update data of the table: "workspace_members" */
  updateWorkspaceMembers?: Maybe<WorkspaceMembers_Mutation_Response>;
  /** update data of the table: "workspaces" */
  updateWorkspaces?: Maybe<Workspaces_Mutation_Response>;
  /** update data of the table: "announcements" */
  update_announcements?: Maybe<Announcements_Mutation_Response>;
  /** update single row of the table: "announcements" */
  update_announcements_by_pk?: Maybe<Announcements>;
  /** update multiples rows of table: "announcements" */
  update_announcements_many?: Maybe<Array<Maybe<Announcements_Mutation_Response>>>;
  /** update multiples rows of table: "app_state_history" */
  update_appStateHistory_many?: Maybe<Array<Maybe<AppStateHistory_Mutation_Response>>>;
  /** update multiples rows of table: "app_states" */
  update_appStates_many?: Maybe<Array<Maybe<AppStates_Mutation_Response>>>;
  /** update multiples rows of table: "apps" */
  update_apps_many?: Maybe<Array<Maybe<Apps_Mutation_Response>>>;
  /** update multiples rows of table: "auth.provider_requests" */
  update_authProviderRequests_many?: Maybe<Array<Maybe<AuthProviderRequests_Mutation_Response>>>;
  /** update multiples rows of table: "auth.providers" */
  update_authProviders_many?: Maybe<Array<Maybe<AuthProviders_Mutation_Response>>>;
  /** update multiples rows of table: "auth.refresh_token_types" */
  update_authRefreshTokenTypes_many?: Maybe<Array<Maybe<AuthRefreshTokenTypes_Mutation_Response>>>;
  /** update multiples rows of table: "auth.refresh_tokens" */
  update_authRefreshTokens_many?: Maybe<Array<Maybe<AuthRefreshTokens_Mutation_Response>>>;
  /** update multiples rows of table: "auth.roles" */
  update_authRoles_many?: Maybe<Array<Maybe<AuthRoles_Mutation_Response>>>;
  /** update multiples rows of table: "auth.user_providers" */
  update_authUserProviders_many?: Maybe<Array<Maybe<AuthUserProviders_Mutation_Response>>>;
  /** update multiples rows of table: "auth.user_roles" */
  update_authUserRoles_many?: Maybe<Array<Maybe<AuthUserRoles_Mutation_Response>>>;
  /** update multiples rows of table: "auth.user_security_keys" */
  update_authUserSecurityKeys_many?: Maybe<Array<Maybe<AuthUserSecurityKeys_Mutation_Response>>>;
  /** update data of the table: "auth.migrations" */
  update_auth_migrations?: Maybe<Auth_Migrations_Mutation_Response>;
  /** update single row of the table: "auth.migrations" */
  update_auth_migrations_by_pk?: Maybe<Auth_Migrations>;
  /** update multiples rows of table: "auth.migrations" */
  update_auth_migrations_many?: Maybe<Array<Maybe<Auth_Migrations_Mutation_Response>>>;
  /** update multiples rows of table: "backups" */
  update_backups_many?: Maybe<Array<Maybe<Backups_Mutation_Response>>>;
  /** update multiples rows of table: "billing.dedicated_compute" */
  update_billing_dedicated_compute_many?: Maybe<Array<Maybe<Billing_Dedicated_Compute_Mutation_Response>>>;
  /** update data of the table: "billing.report_type" */
  update_billing_report_type?: Maybe<Billing_Report_Type_Mutation_Response>;
  /** update single row of the table: "billing.report_type" */
  update_billing_report_type_by_pk?: Maybe<Billing_Report_Type>;
  /** update multiples rows of table: "billing.report_type" */
  update_billing_report_type_many?: Maybe<Array<Maybe<Billing_Report_Type_Mutation_Response>>>;
  /** update multiples rows of table: "storage.buckets" */
  update_buckets_many?: Maybe<Array<Maybe<Buckets_Mutation_Response>>>;
  /** update multiples rows of table: "cli_tokens" */
  update_cliTokens_many?: Maybe<Array<Maybe<CliTokens_Mutation_Response>>>;
  /** update data of the table: "continents" */
  update_continents?: Maybe<Continents_Mutation_Response>;
  /** update single row of the table: "continents" */
  update_continents_by_pk?: Maybe<Continents>;
  /** update multiples rows of table: "continents" */
  update_continents_many?: Maybe<Array<Maybe<Continents_Mutation_Response>>>;
  /** update data of the table: "countries" */
  update_countries?: Maybe<Countries_Mutation_Response>;
  /** update single row of the table: "countries" */
  update_countries_by_pk?: Maybe<Countries>;
  /** update multiples rows of table: "countries" */
  update_countries_many?: Maybe<Array<Maybe<Countries_Mutation_Response>>>;
  /** update multiples rows of table: "deployment_logs" */
  update_deploymentLogs_many?: Maybe<Array<Maybe<DeploymentLogs_Mutation_Response>>>;
  /** update multiples rows of table: "deployments" */
  update_deployments_many?: Maybe<Array<Maybe<Deployments_Mutation_Response>>>;
  /** update multiples rows of table: "feature_flags" */
  update_featureFlags_many?: Maybe<Array<Maybe<FeatureFlags_Mutation_Response>>>;
  /** update multiples rows of table: "storage.files" */
  update_files_many?: Maybe<Array<Maybe<Files_Mutation_Response>>>;
  /** update multiples rows of table: "github_app_installations" */
  update_githubAppInstallations_many?: Maybe<Array<Maybe<GithubAppInstallations_Mutation_Response>>>;
  /** update multiples rows of table: "github_repositories" */
  update_githubRepositories_many?: Maybe<Array<Maybe<GithubRepositories_Mutation_Response>>>;
  /** update multiples rows of table: "billing.subscriptions" */
  update_many_billing_subscriptions?: Maybe<Array<Maybe<Billing_Subscriptions_Mutation_Response>>>;
  /** update data of the table: "organization_members_role" */
  update_organization_members_role?: Maybe<Organization_Members_Role_Mutation_Response>;
  /** update single row of the table: "organization_members_role" */
  update_organization_members_role_by_pk?: Maybe<Organization_Members_Role>;
  /** update multiples rows of table: "organization_members_role" */
  update_organization_members_role_many?: Maybe<Array<Maybe<Organization_Members_Role_Mutation_Response>>>;
  /** update data of the table: "organization_status" */
  update_organization_status?: Maybe<Organization_Status_Mutation_Response>;
  /** update single row of the table: "organization_status" */
  update_organization_status_by_pk?: Maybe<Organization_Status>;
  /** update multiples rows of table: "organization_status" */
  update_organization_status_many?: Maybe<Array<Maybe<Organization_Status_Mutation_Response>>>;
  /** update multiples rows of table: "payment_methods" */
  update_paymentMethods_many?: Maybe<Array<Maybe<PaymentMethods_Mutation_Response>>>;
  /** update multiples rows of table: "plans" */
  update_plans_many?: Maybe<Array<Maybe<Plans_Mutation_Response>>>;
  /** update data of the table: "region_type" */
  update_region_type?: Maybe<Region_Type_Mutation_Response>;
  /** update single row of the table: "region_type" */
  update_region_type_by_pk?: Maybe<Region_Type>;
  /** update multiples rows of table: "region_type" */
  update_region_type_many?: Maybe<Array<Maybe<Region_Type_Mutation_Response>>>;
  /** update data of the table: "regions" */
  update_regions?: Maybe<Regions_Mutation_Response>;
  /** update multiples rows of table: "regions_allowed_workspace" */
  update_regions_allowed_workspace_many?: Maybe<Array<Maybe<Regions_Allowed_Workspace_Mutation_Response>>>;
  /** update single row of the table: "regions" */
  update_regions_by_pk?: Maybe<Regions>;
  /** update multiples rows of table: "regions" */
  update_regions_many?: Maybe<Array<Maybe<Regions_Mutation_Response>>>;
  /** update multiples rows of table: "run_service" */
  update_run_service_many?: Maybe<Array<Maybe<Run_Service_Mutation_Response>>>;
  /** update multiples rows of table: "auth.users" */
  update_users_many?: Maybe<Array<Maybe<Users_Mutation_Response>>>;
  /** update multiples rows of table: "storage.virus" */
  update_virus_many?: Maybe<Array<Maybe<Virus_Mutation_Response>>>;
  /** update multiples rows of table: "workspace_member_invites" */
  update_workspaceMemberInvites_many?: Maybe<Array<Maybe<WorkspaceMemberInvites_Mutation_Response>>>;
  /** update multiples rows of table: "workspace_members" */
  update_workspaceMembers_many?: Maybe<Array<Maybe<WorkspaceMembers_Mutation_Response>>>;
  /** update multiples rows of table: "workspaces" */
  update_workspaces_many?: Maybe<Array<Maybe<Workspaces_Mutation_Response>>>;
  /** delete single row from the table: "billing.dedicated_compute_reports" */
  zzzDONOTUSE_delete_billing_dedicated_compute_report?: Maybe<Billing_Dedicated_Compute_Reports>;
  /** delete data from the table: "billing.dedicated_compute_reports" */
  zzzDONOTUSE_delete_billing_dedicated_compute_reports?: Maybe<Billing_Dedicated_Compute_Reports_Mutation_Response>;
  /** insert a single row into the table: "billing.dedicated_compute_reports" */
  zzzDONOTUSE_insert_billing_dedicated_compute_report?: Maybe<Billing_Dedicated_Compute_Reports>;
  /** insert data into the table: "billing.dedicated_compute_reports" */
  zzzDONOTUSE_insert_billing_dedicated_compute_reports?: Maybe<Billing_Dedicated_Compute_Reports_Mutation_Response>;
  /** update single row of the table: "billing.dedicated_compute_reports" */
  zzzDONOTUSE_update_billing_dedicated_compute_report?: Maybe<Billing_Dedicated_Compute_Reports>;
  /** update data of the table: "billing.dedicated_compute_reports" */
  zzzDONOTUSE_update_billing_dedicated_compute_reports?: Maybe<Billing_Dedicated_Compute_Reports_Mutation_Response>;
  /** update multiples rows of table: "billing.dedicated_compute_reports" */
  zzzDONOTUSE_update_many_billing_dedicated_compute_reports?: Maybe<Array<Maybe<Billing_Dedicated_Compute_Reports_Mutation_Response>>>;
};


/** mutation root */
export type Mutation_RootBackupApplicationDatabaseArgs = {
  appID: Scalars['String'];
  expireInDays?: InputMaybe<Scalars['Int']>;
};


/** mutation root */
export type Mutation_RootBillingCreateOrganizationRequestArgs = {
  organizationName: Scalars['String'];
  planID: Scalars['uuid'];
  redirectURL: Scalars['String'];
};


/** mutation root */
export type Mutation_RootBillingFinishSubscriptionArgs = {
  appID: Scalars['uuid'];
  appName: Scalars['String'];
  planID: Scalars['uuid'];
  subdomain: Scalars['String'];
  subscriptionID: Scalars['String'];
};


/** mutation root */
export type Mutation_RootBillingFullReportWorkflowArgs = {
  reportTime?: InputMaybe<Scalars['Timestamp']>;
};


/** mutation root */
export type Mutation_RootBillingMigrateProjectToOrganizationArgs = {
  appID: Scalars['uuid'];
  organizationID: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootBillingPostOrganizationRequestArgs = {
  sessionID: Scalars['String'];
};


/** mutation root */
export type Mutation_RootBillingUpdateCustomDomainsArgs = {
  amount: Scalars['Int'];
  appID: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootBillingUpdateDedicatedComputeArgs = {
  appID: Scalars['uuid'];
  totalMillicores: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootBillingUpdateFunctionsAmountArgs = {
  amount: Scalars['Int'];
  appID: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootBillingUpdatePersistentVolumeArgs = {
  amount: Scalars['Int'];
  appID: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootBillingUpdateReportsArgs = {
  reportTime?: InputMaybe<Scalars['Timestamp']>;
};


/** mutation root */
export type Mutation_RootChangeDatabaseVersionArgs = {
  appID: Scalars['uuid'];
  force?: InputMaybe<Scalars['Boolean']>;
  version: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDeleteAppArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteAppStateArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDeleteAppStateHistoriesArgs = {
  where: AppStateHistory_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteAppStateHistoryArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteAppStatesArgs = {
  where: AppStates_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteAppsArgs = {
  where: Apps_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteAuthProviderArgs = {
  id: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDeleteAuthProviderRequestArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteAuthProviderRequestsArgs = {
  where: AuthProviderRequests_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteAuthProvidersArgs = {
  where: AuthProviders_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteAuthRefreshTokenArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteAuthRefreshTokenTypeArgs = {
  value: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDeleteAuthRefreshTokenTypesArgs = {
  where: AuthRefreshTokenTypes_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteAuthRefreshTokensArgs = {
  where: AuthRefreshTokens_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteAuthRoleArgs = {
  role: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDeleteAuthRolesArgs = {
  where: AuthRoles_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteAuthUserProviderArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteAuthUserProvidersArgs = {
  where: AuthUserProviders_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteAuthUserRoleArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteAuthUserRolesArgs = {
  where: AuthUserRoles_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteAuthUserSecurityKeyArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteAuthUserSecurityKeysArgs = {
  where: AuthUserSecurityKeys_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteBackupArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteBackupsArgs = {
  where: Backups_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteBillingDedicatedComputeArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteBillingDedicatedComputesArgs = {
  where: Billing_Dedicated_Compute_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteBillingReportArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteBillingReportsArgs = {
  where: Billing_Reports_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteBillingResourceArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteBillingResourcesArgs = {
  where: Billing_Resources_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteBillingSubscriptionArgs = {
  where: Billing_Subscriptions_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteBillingSubscriptionsArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteBucketArgs = {
  id: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDeleteBucketsArgs = {
  where: Buckets_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteCliTokenArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteCliTokensArgs = {
  where: CliTokens_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteConfigArgs = {
  appID: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteDeploymentArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteDeploymentLogArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteDeploymentLogsArgs = {
  where: DeploymentLogs_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteDeploymentsArgs = {
  where: Deployments_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteFeatureFlagArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteFeatureFlagsArgs = {
  where: FeatureFlags_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteFileArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteFilesArgs = {
  where: Files_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteGithubAppInstallationArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteGithubAppInstallationsArgs = {
  where: GithubAppInstallations_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteGithubRepositoriesArgs = {
  where: GithubRepositories_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteGithubRepositoryArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteOrganizationArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteOrganizationFreeUsageArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteOrganizationFreeUsagesArgs = {
  where: Organizations_Free_Usage_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteOrganizationMemberArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteOrganizationMemberInviteArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteOrganizationMemberInvitesArgs = {
  where: Organization_Member_Invites_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteOrganizationMembersArgs = {
  where: Organization_Members_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteOrganizationNewRequestArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteOrganizationNewRequestsArgs = {
  where: Organization_New_Request_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteOrganizationsArgs = {
  where: Organizations_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeletePaymentMethodArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeletePaymentMethodsArgs = {
  where: PaymentMethods_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeletePlanArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeletePlansArgs = {
  where: Plans_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteRegionsAllowedOrganizationArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteRegionsAllowedOrganizationsArgs = {
  where: Regions_Allowed_Organization_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteRegionsAllowedWorkspaceArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteRegionsAllowedWorkspacesArgs = {
  where: Regions_Allowed_Workspace_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteRunServiceArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteRunServiceConfigArgs = {
  appID: Scalars['uuid'];
  serviceID: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteRunServicesArgs = {
  where: Run_Service_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteSecretArgs = {
  appID: Scalars['uuid'];
  key: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDeleteSoftwareTypeArgs = {
  type: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDeleteSoftwareTypesArgs = {
  where: Software_Type_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteSoftwareVersionArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteSoftwareVersionsArgs = {
  where: Software_Versions_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteUserArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteUsersArgs = {
  where: Users_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteVirusArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteVirusesArgs = {
  where: Virus_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteWorkspaceArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteWorkspaceMemberArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteWorkspaceMemberInviteArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDeleteWorkspaceMemberInvitesArgs = {
  where: WorkspaceMemberInvites_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteWorkspaceMembersArgs = {
  where: WorkspaceMembers_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteWorkspacesArgs = {
  where: Workspaces_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_AnnouncementsArgs = {
  where: Announcements_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Announcements_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Auth_MigrationsArgs = {
  where: Auth_Migrations_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Auth_Migrations_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_Billing_Report_TypeArgs = {
  where: Billing_Report_Type_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Billing_Report_Type_By_PkArgs = {
  value: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_ContinentsArgs = {
  where: Continents_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Continents_By_PkArgs = {
  code: Scalars['bpchar'];
};


/** mutation root */
export type Mutation_RootDelete_CountriesArgs = {
  where: Countries_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Countries_By_PkArgs = {
  code: Scalars['bpchar'];
};


/** mutation root */
export type Mutation_RootDelete_Organization_Members_RoleArgs = {
  where: Organization_Members_Role_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Organization_Members_Role_By_PkArgs = {
  value: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Organization_StatusArgs = {
  where: Organization_Status_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Organization_Status_By_PkArgs = {
  value: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Region_TypeArgs = {
  where: Region_Type_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Region_Type_By_PkArgs = {
  type: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_RegionsArgs = {
  where: Regions_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Regions_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootInsertAppArgs = {
  object: Apps_Insert_Input;
  on_conflict?: InputMaybe<Apps_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertAppStateArgs = {
  object: AppStates_Insert_Input;
  on_conflict?: InputMaybe<AppStates_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertAppStateHistoriesArgs = {
  objects: Array<AppStateHistory_Insert_Input>;
  on_conflict?: InputMaybe<AppStateHistory_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertAppStateHistoryArgs = {
  object: AppStateHistory_Insert_Input;
  on_conflict?: InputMaybe<AppStateHistory_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertAppStatesArgs = {
  objects: Array<AppStates_Insert_Input>;
  on_conflict?: InputMaybe<AppStates_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertAppsArgs = {
  objects: Array<Apps_Insert_Input>;
  on_conflict?: InputMaybe<Apps_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertAuthProviderArgs = {
  object: AuthProviders_Insert_Input;
  on_conflict?: InputMaybe<AuthProviders_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertAuthProviderRequestArgs = {
  object: AuthProviderRequests_Insert_Input;
  on_conflict?: InputMaybe<AuthProviderRequests_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertAuthProviderRequestsArgs = {
  objects: Array<AuthProviderRequests_Insert_Input>;
  on_conflict?: InputMaybe<AuthProviderRequests_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertAuthProvidersArgs = {
  objects: Array<AuthProviders_Insert_Input>;
  on_conflict?: InputMaybe<AuthProviders_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertAuthRefreshTokenArgs = {
  object: AuthRefreshTokens_Insert_Input;
  on_conflict?: InputMaybe<AuthRefreshTokens_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertAuthRefreshTokenTypeArgs = {
  object: AuthRefreshTokenTypes_Insert_Input;
  on_conflict?: InputMaybe<AuthRefreshTokenTypes_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertAuthRefreshTokenTypesArgs = {
  objects: Array<AuthRefreshTokenTypes_Insert_Input>;
  on_conflict?: InputMaybe<AuthRefreshTokenTypes_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertAuthRefreshTokensArgs = {
  objects: Array<AuthRefreshTokens_Insert_Input>;
  on_conflict?: InputMaybe<AuthRefreshTokens_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertAuthRoleArgs = {
  object: AuthRoles_Insert_Input;
  on_conflict?: InputMaybe<AuthRoles_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertAuthRolesArgs = {
  objects: Array<AuthRoles_Insert_Input>;
  on_conflict?: InputMaybe<AuthRoles_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertAuthUserProviderArgs = {
  object: AuthUserProviders_Insert_Input;
  on_conflict?: InputMaybe<AuthUserProviders_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertAuthUserProvidersArgs = {
  objects: Array<AuthUserProviders_Insert_Input>;
  on_conflict?: InputMaybe<AuthUserProviders_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertAuthUserRoleArgs = {
  object: AuthUserRoles_Insert_Input;
  on_conflict?: InputMaybe<AuthUserRoles_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertAuthUserRolesArgs = {
  objects: Array<AuthUserRoles_Insert_Input>;
  on_conflict?: InputMaybe<AuthUserRoles_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertAuthUserSecurityKeyArgs = {
  object: AuthUserSecurityKeys_Insert_Input;
  on_conflict?: InputMaybe<AuthUserSecurityKeys_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertAuthUserSecurityKeysArgs = {
  objects: Array<AuthUserSecurityKeys_Insert_Input>;
  on_conflict?: InputMaybe<AuthUserSecurityKeys_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertBackupArgs = {
  object: Backups_Insert_Input;
  on_conflict?: InputMaybe<Backups_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertBackupsArgs = {
  objects: Array<Backups_Insert_Input>;
  on_conflict?: InputMaybe<Backups_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertBillingDedicatedComputeArgs = {
  object: Billing_Dedicated_Compute_Insert_Input;
  on_conflict?: InputMaybe<Billing_Dedicated_Compute_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertBillingDedicatedComputesArgs = {
  objects: Array<Billing_Dedicated_Compute_Insert_Input>;
  on_conflict?: InputMaybe<Billing_Dedicated_Compute_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertBillingReportArgs = {
  object: Billing_Reports_Insert_Input;
  on_conflict?: InputMaybe<Billing_Reports_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertBillingReportsArgs = {
  objects: Array<Billing_Reports_Insert_Input>;
  on_conflict?: InputMaybe<Billing_Reports_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertBillingResourceArgs = {
  object: Billing_Resources_Insert_Input;
  on_conflict?: InputMaybe<Billing_Resources_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertBillingResourcesArgs = {
  objects: Array<Billing_Resources_Insert_Input>;
  on_conflict?: InputMaybe<Billing_Resources_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertBillingSubscriptionArgs = {
  objects: Array<Billing_Subscriptions_Insert_Input>;
  on_conflict?: InputMaybe<Billing_Subscriptions_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertBillingSubscriptionsArgs = {
  object: Billing_Subscriptions_Insert_Input;
  on_conflict?: InputMaybe<Billing_Subscriptions_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertBucketArgs = {
  object: Buckets_Insert_Input;
  on_conflict?: InputMaybe<Buckets_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertBucketsArgs = {
  objects: Array<Buckets_Insert_Input>;
  on_conflict?: InputMaybe<Buckets_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertCliTokenArgs = {
  object: CliTokens_Insert_Input;
  on_conflict?: InputMaybe<CliTokens_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertCliTokensArgs = {
  objects: Array<CliTokens_Insert_Input>;
  on_conflict?: InputMaybe<CliTokens_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertConfigArgs = {
  appID: Scalars['uuid'];
  config: ConfigConfigInsertInput;
  secrets?: InputMaybe<Array<ConfigEnvironmentVariableInsertInput>>;
  systemConfig: ConfigSystemConfigInsertInput;
};


/** mutation root */
export type Mutation_RootInsertDeploymentArgs = {
  object: Deployments_Insert_Input;
  on_conflict?: InputMaybe<Deployments_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertDeploymentLogArgs = {
  object: DeploymentLogs_Insert_Input;
  on_conflict?: InputMaybe<DeploymentLogs_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertDeploymentLogsArgs = {
  objects: Array<DeploymentLogs_Insert_Input>;
  on_conflict?: InputMaybe<DeploymentLogs_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertDeploymentsArgs = {
  objects: Array<Deployments_Insert_Input>;
  on_conflict?: InputMaybe<Deployments_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertFeatureFlagArgs = {
  object: FeatureFlags_Insert_Input;
  on_conflict?: InputMaybe<FeatureFlags_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertFeatureFlagsArgs = {
  objects: Array<FeatureFlags_Insert_Input>;
  on_conflict?: InputMaybe<FeatureFlags_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertFileArgs = {
  object: Files_Insert_Input;
  on_conflict?: InputMaybe<Files_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertFilesArgs = {
  objects: Array<Files_Insert_Input>;
  on_conflict?: InputMaybe<Files_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertGithubAppInstallationArgs = {
  object: GithubAppInstallations_Insert_Input;
  on_conflict?: InputMaybe<GithubAppInstallations_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertGithubAppInstallationsArgs = {
  objects: Array<GithubAppInstallations_Insert_Input>;
  on_conflict?: InputMaybe<GithubAppInstallations_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertGithubRepositoriesArgs = {
  objects: Array<GithubRepositories_Insert_Input>;
  on_conflict?: InputMaybe<GithubRepositories_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertGithubRepositoryArgs = {
  object: GithubRepositories_Insert_Input;
  on_conflict?: InputMaybe<GithubRepositories_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertOrganizationArgs = {
  object: Organizations_Insert_Input;
  on_conflict?: InputMaybe<Organizations_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertOrganizationFreeUsageArgs = {
  object: Organizations_Free_Usage_Insert_Input;
  on_conflict?: InputMaybe<Organizations_Free_Usage_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertOrganizationFreeUsagesArgs = {
  objects: Array<Organizations_Free_Usage_Insert_Input>;
  on_conflict?: InputMaybe<Organizations_Free_Usage_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertOrganizationMemberArgs = {
  object: Organization_Members_Insert_Input;
  on_conflict?: InputMaybe<Organization_Members_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertOrganizationMemberInviteArgs = {
  object: Organization_Member_Invites_Insert_Input;
  on_conflict?: InputMaybe<Organization_Member_Invites_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertOrganizationMemberInvitesArgs = {
  objects: Array<Organization_Member_Invites_Insert_Input>;
  on_conflict?: InputMaybe<Organization_Member_Invites_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertOrganizationMembersArgs = {
  objects: Array<Organization_Members_Insert_Input>;
  on_conflict?: InputMaybe<Organization_Members_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertOrganizationNewRequestArgs = {
  object: Organization_New_Request_Insert_Input;
  on_conflict?: InputMaybe<Organization_New_Request_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertOrganizationNewRequestsArgs = {
  objects: Array<Organization_New_Request_Insert_Input>;
  on_conflict?: InputMaybe<Organization_New_Request_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertOrganizationsArgs = {
  objects: Array<Organizations_Insert_Input>;
  on_conflict?: InputMaybe<Organizations_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertPaymentMethodArgs = {
  object: PaymentMethods_Insert_Input;
  on_conflict?: InputMaybe<PaymentMethods_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertPaymentMethodsArgs = {
  objects: Array<PaymentMethods_Insert_Input>;
  on_conflict?: InputMaybe<PaymentMethods_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertPlanArgs = {
  object: Plans_Insert_Input;
  on_conflict?: InputMaybe<Plans_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertPlansArgs = {
  objects: Array<Plans_Insert_Input>;
  on_conflict?: InputMaybe<Plans_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertRegionsAllowedOrganizationArgs = {
  object: Regions_Allowed_Organization_Insert_Input;
  on_conflict?: InputMaybe<Regions_Allowed_Organization_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertRegionsAllowedOrganizationsArgs = {
  objects: Array<Regions_Allowed_Organization_Insert_Input>;
  on_conflict?: InputMaybe<Regions_Allowed_Organization_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertRegionsAllowedWorkspaceArgs = {
  object: Regions_Allowed_Workspace_Insert_Input;
  on_conflict?: InputMaybe<Regions_Allowed_Workspace_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertRegionsAllowedWorkspacesArgs = {
  objects: Array<Regions_Allowed_Workspace_Insert_Input>;
  on_conflict?: InputMaybe<Regions_Allowed_Workspace_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertRunServiceArgs = {
  object: Run_Service_Insert_Input;
  on_conflict?: InputMaybe<Run_Service_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertRunServiceConfigArgs = {
  appID: Scalars['uuid'];
  config: ConfigRunServiceConfigInsertInput;
  serviceID: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootInsertRunServicesArgs = {
  objects: Array<Run_Service_Insert_Input>;
  on_conflict?: InputMaybe<Run_Service_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertSecretArgs = {
  appID: Scalars['uuid'];
  secret: ConfigEnvironmentVariableInsertInput;
};


/** mutation root */
export type Mutation_RootInsertSoftwareTypeArgs = {
  object: Software_Type_Insert_Input;
  on_conflict?: InputMaybe<Software_Type_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertSoftwareTypesArgs = {
  objects: Array<Software_Type_Insert_Input>;
  on_conflict?: InputMaybe<Software_Type_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertSoftwareVersionArgs = {
  object: Software_Versions_Insert_Input;
  on_conflict?: InputMaybe<Software_Versions_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertSoftwareVersionsArgs = {
  objects: Array<Software_Versions_Insert_Input>;
  on_conflict?: InputMaybe<Software_Versions_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertUserArgs = {
  object: Users_Insert_Input;
  on_conflict?: InputMaybe<Users_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertUsersArgs = {
  objects: Array<Users_Insert_Input>;
  on_conflict?: InputMaybe<Users_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertVirusArgs = {
  object: Virus_Insert_Input;
  on_conflict?: InputMaybe<Virus_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertVirusesArgs = {
  objects: Array<Virus_Insert_Input>;
  on_conflict?: InputMaybe<Virus_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertWorkspaceArgs = {
  object: Workspaces_Insert_Input;
  on_conflict?: InputMaybe<Workspaces_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertWorkspaceMemberArgs = {
  object: WorkspaceMembers_Insert_Input;
  on_conflict?: InputMaybe<WorkspaceMembers_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertWorkspaceMemberInviteArgs = {
  object: WorkspaceMemberInvites_Insert_Input;
  on_conflict?: InputMaybe<WorkspaceMemberInvites_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertWorkspaceMemberInvitesArgs = {
  objects: Array<WorkspaceMemberInvites_Insert_Input>;
  on_conflict?: InputMaybe<WorkspaceMemberInvites_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertWorkspaceMembersArgs = {
  objects: Array<WorkspaceMembers_Insert_Input>;
  on_conflict?: InputMaybe<WorkspaceMembers_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertWorkspacesArgs = {
  objects: Array<Workspaces_Insert_Input>;
  on_conflict?: InputMaybe<Workspaces_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_AnnouncementsArgs = {
  objects: Array<Announcements_Insert_Input>;
  on_conflict?: InputMaybe<Announcements_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Announcements_OneArgs = {
  object: Announcements_Insert_Input;
  on_conflict?: InputMaybe<Announcements_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Auth_MigrationsArgs = {
  objects: Array<Auth_Migrations_Insert_Input>;
  on_conflict?: InputMaybe<Auth_Migrations_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Auth_Migrations_OneArgs = {
  object: Auth_Migrations_Insert_Input;
  on_conflict?: InputMaybe<Auth_Migrations_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Billing_Report_TypeArgs = {
  objects: Array<Billing_Report_Type_Insert_Input>;
  on_conflict?: InputMaybe<Billing_Report_Type_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Billing_Report_Type_OneArgs = {
  object: Billing_Report_Type_Insert_Input;
  on_conflict?: InputMaybe<Billing_Report_Type_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ContinentsArgs = {
  objects: Array<Continents_Insert_Input>;
  on_conflict?: InputMaybe<Continents_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Continents_OneArgs = {
  object: Continents_Insert_Input;
  on_conflict?: InputMaybe<Continents_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_CountriesArgs = {
  objects: Array<Countries_Insert_Input>;
  on_conflict?: InputMaybe<Countries_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Countries_OneArgs = {
  object: Countries_Insert_Input;
  on_conflict?: InputMaybe<Countries_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Organization_Members_RoleArgs = {
  objects: Array<Organization_Members_Role_Insert_Input>;
  on_conflict?: InputMaybe<Organization_Members_Role_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Organization_Members_Role_OneArgs = {
  object: Organization_Members_Role_Insert_Input;
  on_conflict?: InputMaybe<Organization_Members_Role_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Organization_StatusArgs = {
  objects: Array<Organization_Status_Insert_Input>;
  on_conflict?: InputMaybe<Organization_Status_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Organization_Status_OneArgs = {
  object: Organization_Status_Insert_Input;
  on_conflict?: InputMaybe<Organization_Status_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Region_TypeArgs = {
  objects: Array<Region_Type_Insert_Input>;
  on_conflict?: InputMaybe<Region_Type_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Region_Type_OneArgs = {
  object: Region_Type_Insert_Input;
  on_conflict?: InputMaybe<Region_Type_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_RegionsArgs = {
  objects: Array<Regions_Insert_Input>;
  on_conflict?: InputMaybe<Regions_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Regions_OneArgs = {
  object: Regions_Insert_Input;
  on_conflict?: InputMaybe<Regions_On_Conflict>;
};


/** mutation root */
export type Mutation_RootOrganizationMemberInviteAcceptArgs = {
  args: OrganizationMemberInviteAccept_Args;
  distinct_on?: InputMaybe<Array<Organization_Members_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Organization_Members_Order_By>>;
  where?: InputMaybe<Organization_Members_Bool_Exp>;
};


/** mutation root */
export type Mutation_RootReplaceConfigArgs = {
  appID: Scalars['uuid'];
  config: ConfigConfigInsertInput;
};


/** mutation root */
export type Mutation_RootReplaceConfigRawJsonArgs = {
  appID: Scalars['uuid'];
  rawJSON: Scalars['String'];
};


/** mutation root */
export type Mutation_RootReplaceRunServiceConfigArgs = {
  appID: Scalars['uuid'];
  config: ConfigRunServiceConfigInsertInput;
  serviceID: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootResetPostgresPasswordArgs = {
  appID: Scalars['String'];
  newPassword: Scalars['String'];
};


/** mutation root */
export type Mutation_RootRestoreApplicationDatabaseArgs = {
  appID: Scalars['String'];
  backupID: Scalars['String'];
};


/** mutation root */
export type Mutation_RootSendEmailTemplateArgs = {
  from: Scalars['String'];
  templateAlias: Scalars['String'];
  templateModel?: InputMaybe<Scalars['map']>;
  to: Scalars['String'];
};


/** mutation root */
export type Mutation_RootUpdateAppArgs = {
  _append?: InputMaybe<Apps_Append_Input>;
  _delete_at_path?: InputMaybe<Apps_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Apps_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Apps_Delete_Key_Input>;
  _inc?: InputMaybe<Apps_Inc_Input>;
  _prepend?: InputMaybe<Apps_Prepend_Input>;
  _set?: InputMaybe<Apps_Set_Input>;
  pk_columns: Apps_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateAppStateArgs = {
  _inc?: InputMaybe<AppStates_Inc_Input>;
  _set?: InputMaybe<AppStates_Set_Input>;
  pk_columns: AppStates_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateAppStateHistoriesArgs = {
  _inc?: InputMaybe<AppStateHistory_Inc_Input>;
  _set?: InputMaybe<AppStateHistory_Set_Input>;
  where: AppStateHistory_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateAppStateHistoryArgs = {
  _inc?: InputMaybe<AppStateHistory_Inc_Input>;
  _set?: InputMaybe<AppStateHistory_Set_Input>;
  pk_columns: AppStateHistory_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateAppStatesArgs = {
  _inc?: InputMaybe<AppStates_Inc_Input>;
  _set?: InputMaybe<AppStates_Set_Input>;
  where: AppStates_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateAppsArgs = {
  _append?: InputMaybe<Apps_Append_Input>;
  _delete_at_path?: InputMaybe<Apps_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Apps_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Apps_Delete_Key_Input>;
  _inc?: InputMaybe<Apps_Inc_Input>;
  _prepend?: InputMaybe<Apps_Prepend_Input>;
  _set?: InputMaybe<Apps_Set_Input>;
  where: Apps_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateAuthProviderArgs = {
  _set?: InputMaybe<AuthProviders_Set_Input>;
  pk_columns: AuthProviders_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateAuthProviderRequestArgs = {
  _append?: InputMaybe<AuthProviderRequests_Append_Input>;
  _delete_at_path?: InputMaybe<AuthProviderRequests_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<AuthProviderRequests_Delete_Elem_Input>;
  _delete_key?: InputMaybe<AuthProviderRequests_Delete_Key_Input>;
  _prepend?: InputMaybe<AuthProviderRequests_Prepend_Input>;
  _set?: InputMaybe<AuthProviderRequests_Set_Input>;
  pk_columns: AuthProviderRequests_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateAuthProviderRequestsArgs = {
  _append?: InputMaybe<AuthProviderRequests_Append_Input>;
  _delete_at_path?: InputMaybe<AuthProviderRequests_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<AuthProviderRequests_Delete_Elem_Input>;
  _delete_key?: InputMaybe<AuthProviderRequests_Delete_Key_Input>;
  _prepend?: InputMaybe<AuthProviderRequests_Prepend_Input>;
  _set?: InputMaybe<AuthProviderRequests_Set_Input>;
  where: AuthProviderRequests_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateAuthProvidersArgs = {
  _set?: InputMaybe<AuthProviders_Set_Input>;
  where: AuthProviders_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateAuthRefreshTokenArgs = {
  _append?: InputMaybe<AuthRefreshTokens_Append_Input>;
  _delete_at_path?: InputMaybe<AuthRefreshTokens_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<AuthRefreshTokens_Delete_Elem_Input>;
  _delete_key?: InputMaybe<AuthRefreshTokens_Delete_Key_Input>;
  _prepend?: InputMaybe<AuthRefreshTokens_Prepend_Input>;
  _set?: InputMaybe<AuthRefreshTokens_Set_Input>;
  pk_columns: AuthRefreshTokens_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateAuthRefreshTokenTypeArgs = {
  _set?: InputMaybe<AuthRefreshTokenTypes_Set_Input>;
  pk_columns: AuthRefreshTokenTypes_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateAuthRefreshTokenTypesArgs = {
  _set?: InputMaybe<AuthRefreshTokenTypes_Set_Input>;
  where: AuthRefreshTokenTypes_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateAuthRefreshTokensArgs = {
  _append?: InputMaybe<AuthRefreshTokens_Append_Input>;
  _delete_at_path?: InputMaybe<AuthRefreshTokens_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<AuthRefreshTokens_Delete_Elem_Input>;
  _delete_key?: InputMaybe<AuthRefreshTokens_Delete_Key_Input>;
  _prepend?: InputMaybe<AuthRefreshTokens_Prepend_Input>;
  _set?: InputMaybe<AuthRefreshTokens_Set_Input>;
  where: AuthRefreshTokens_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateAuthRoleArgs = {
  _set?: InputMaybe<AuthRoles_Set_Input>;
  pk_columns: AuthRoles_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateAuthRolesArgs = {
  _set?: InputMaybe<AuthRoles_Set_Input>;
  where: AuthRoles_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateAuthUserProviderArgs = {
  _set?: InputMaybe<AuthUserProviders_Set_Input>;
  pk_columns: AuthUserProviders_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateAuthUserProvidersArgs = {
  _set?: InputMaybe<AuthUserProviders_Set_Input>;
  where: AuthUserProviders_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateAuthUserRoleArgs = {
  _set?: InputMaybe<AuthUserRoles_Set_Input>;
  pk_columns: AuthUserRoles_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateAuthUserRolesArgs = {
  _set?: InputMaybe<AuthUserRoles_Set_Input>;
  where: AuthUserRoles_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateAuthUserSecurityKeyArgs = {
  _inc?: InputMaybe<AuthUserSecurityKeys_Inc_Input>;
  _set?: InputMaybe<AuthUserSecurityKeys_Set_Input>;
  pk_columns: AuthUserSecurityKeys_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateAuthUserSecurityKeysArgs = {
  _inc?: InputMaybe<AuthUserSecurityKeys_Inc_Input>;
  _set?: InputMaybe<AuthUserSecurityKeys_Set_Input>;
  where: AuthUserSecurityKeys_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateBackupArgs = {
  _inc?: InputMaybe<Backups_Inc_Input>;
  _set?: InputMaybe<Backups_Set_Input>;
  pk_columns: Backups_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateBackupsArgs = {
  _inc?: InputMaybe<Backups_Inc_Input>;
  _set?: InputMaybe<Backups_Set_Input>;
  where: Backups_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateBillingDedicatedComputeArgs = {
  _inc?: InputMaybe<Billing_Dedicated_Compute_Inc_Input>;
  _set?: InputMaybe<Billing_Dedicated_Compute_Set_Input>;
  pk_columns: Billing_Dedicated_Compute_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateBillingDedicatedComputesArgs = {
  _inc?: InputMaybe<Billing_Dedicated_Compute_Inc_Input>;
  _set?: InputMaybe<Billing_Dedicated_Compute_Set_Input>;
  where: Billing_Dedicated_Compute_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateBillingReportArgs = {
  _inc?: InputMaybe<Billing_Reports_Inc_Input>;
  _set?: InputMaybe<Billing_Reports_Set_Input>;
  pk_columns: Billing_Reports_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateBillingReportsArgs = {
  _inc?: InputMaybe<Billing_Reports_Inc_Input>;
  _set?: InputMaybe<Billing_Reports_Set_Input>;
  where: Billing_Reports_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateBillingResourceArgs = {
  _inc?: InputMaybe<Billing_Resources_Inc_Input>;
  _set?: InputMaybe<Billing_Resources_Set_Input>;
  pk_columns: Billing_Resources_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateBillingResourcesArgs = {
  _inc?: InputMaybe<Billing_Resources_Inc_Input>;
  _set?: InputMaybe<Billing_Resources_Set_Input>;
  where: Billing_Resources_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateBillingSubscriptionArgs = {
  _set?: InputMaybe<Billing_Subscriptions_Set_Input>;
  pk_columns: Billing_Subscriptions_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateBillingSubscriptionsArgs = {
  _set?: InputMaybe<Billing_Subscriptions_Set_Input>;
  where: Billing_Subscriptions_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateBucketArgs = {
  _inc?: InputMaybe<Buckets_Inc_Input>;
  _set?: InputMaybe<Buckets_Set_Input>;
  pk_columns: Buckets_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateBucketsArgs = {
  _inc?: InputMaybe<Buckets_Inc_Input>;
  _set?: InputMaybe<Buckets_Set_Input>;
  where: Buckets_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateCliTokenArgs = {
  _set?: InputMaybe<CliTokens_Set_Input>;
  pk_columns: CliTokens_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateCliTokensArgs = {
  _set?: InputMaybe<CliTokens_Set_Input>;
  where: CliTokens_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateConfigArgs = {
  appID: Scalars['uuid'];
  config: ConfigConfigUpdateInput;
};


/** mutation root */
export type Mutation_RootUpdateDeploymentArgs = {
  _set?: InputMaybe<Deployments_Set_Input>;
  pk_columns: Deployments_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateDeploymentLogArgs = {
  _set?: InputMaybe<DeploymentLogs_Set_Input>;
  pk_columns: DeploymentLogs_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateDeploymentLogsArgs = {
  _set?: InputMaybe<DeploymentLogs_Set_Input>;
  where: DeploymentLogs_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateDeploymentsArgs = {
  _set?: InputMaybe<Deployments_Set_Input>;
  where: Deployments_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateFeatureFlagArgs = {
  _set?: InputMaybe<FeatureFlags_Set_Input>;
  pk_columns: FeatureFlags_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateFeatureFlagsArgs = {
  _set?: InputMaybe<FeatureFlags_Set_Input>;
  where: FeatureFlags_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateFileArgs = {
  _append?: InputMaybe<Files_Append_Input>;
  _delete_at_path?: InputMaybe<Files_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Files_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Files_Delete_Key_Input>;
  _inc?: InputMaybe<Files_Inc_Input>;
  _prepend?: InputMaybe<Files_Prepend_Input>;
  _set?: InputMaybe<Files_Set_Input>;
  pk_columns: Files_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateFilesArgs = {
  _append?: InputMaybe<Files_Append_Input>;
  _delete_at_path?: InputMaybe<Files_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Files_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Files_Delete_Key_Input>;
  _inc?: InputMaybe<Files_Inc_Input>;
  _prepend?: InputMaybe<Files_Prepend_Input>;
  _set?: InputMaybe<Files_Set_Input>;
  where: Files_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateGithubAppInstallationArgs = {
  _append?: InputMaybe<GithubAppInstallations_Append_Input>;
  _delete_at_path?: InputMaybe<GithubAppInstallations_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<GithubAppInstallations_Delete_Elem_Input>;
  _delete_key?: InputMaybe<GithubAppInstallations_Delete_Key_Input>;
  _inc?: InputMaybe<GithubAppInstallations_Inc_Input>;
  _prepend?: InputMaybe<GithubAppInstallations_Prepend_Input>;
  _set?: InputMaybe<GithubAppInstallations_Set_Input>;
  pk_columns: GithubAppInstallations_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateGithubAppInstallationsArgs = {
  _append?: InputMaybe<GithubAppInstallations_Append_Input>;
  _delete_at_path?: InputMaybe<GithubAppInstallations_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<GithubAppInstallations_Delete_Elem_Input>;
  _delete_key?: InputMaybe<GithubAppInstallations_Delete_Key_Input>;
  _inc?: InputMaybe<GithubAppInstallations_Inc_Input>;
  _prepend?: InputMaybe<GithubAppInstallations_Prepend_Input>;
  _set?: InputMaybe<GithubAppInstallations_Set_Input>;
  where: GithubAppInstallations_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateGithubRepositoriesArgs = {
  _set?: InputMaybe<GithubRepositories_Set_Input>;
  where: GithubRepositories_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateGithubRepositoryArgs = {
  _set?: InputMaybe<GithubRepositories_Set_Input>;
  pk_columns: GithubRepositories_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateManyBillingReportsArgs = {
  updates: Array<Billing_Reports_Updates>;
};


/** mutation root */
export type Mutation_RootUpdateManyBillingResourcesArgs = {
  updates: Array<Billing_Resources_Updates>;
};


/** mutation root */
export type Mutation_RootUpdateManySoftwareTypeArgs = {
  updates: Array<Software_Type_Updates>;
};


/** mutation root */
export type Mutation_RootUpdateManySoftwareVersionsArgs = {
  updates: Array<Software_Versions_Updates>;
};


/** mutation root */
export type Mutation_RootUpdateOrganizationArgs = {
  _set?: InputMaybe<Organizations_Set_Input>;
  pk_columns: Organizations_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateOrganizationFreeUsageArgs = {
  _set?: InputMaybe<Organizations_Free_Usage_Set_Input>;
  pk_columns: Organizations_Free_Usage_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateOrganizationFreeUsageManyArgs = {
  updates: Array<Organizations_Free_Usage_Updates>;
};


/** mutation root */
export type Mutation_RootUpdateOrganizationFreeUsagesArgs = {
  _set?: InputMaybe<Organizations_Free_Usage_Set_Input>;
  where: Organizations_Free_Usage_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateOrganizationMemberArgs = {
  _set?: InputMaybe<Organization_Members_Set_Input>;
  pk_columns: Organization_Members_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateOrganizationMemberInviteArgs = {
  _set?: InputMaybe<Organization_Member_Invites_Set_Input>;
  pk_columns: Organization_Member_Invites_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateOrganizationMemberInvitesArgs = {
  _set?: InputMaybe<Organization_Member_Invites_Set_Input>;
  where: Organization_Member_Invites_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateOrganizationMemberInvitesManyArgs = {
  updates: Array<Organization_Member_Invites_Updates>;
};


/** mutation root */
export type Mutation_RootUpdateOrganizationMembersArgs = {
  _set?: InputMaybe<Organization_Members_Set_Input>;
  where: Organization_Members_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateOrganizationMembersManyArgs = {
  updates: Array<Organization_Members_Updates>;
};


/** mutation root */
export type Mutation_RootUpdateOrganizationNewRequestArgs = {
  _set?: InputMaybe<Organization_New_Request_Set_Input>;
  pk_columns: Organization_New_Request_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateOrganizationNewRequestsArgs = {
  _set?: InputMaybe<Organization_New_Request_Set_Input>;
  where: Organization_New_Request_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateOrganizationNewRequestsManyArgs = {
  updates: Array<Organization_New_Request_Updates>;
};


/** mutation root */
export type Mutation_RootUpdateOrganizationsArgs = {
  _set?: InputMaybe<Organizations_Set_Input>;
  where: Organizations_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateOrganizationsManyArgs = {
  updates: Array<Organizations_Updates>;
};


/** mutation root */
export type Mutation_RootUpdatePaymentMethodArgs = {
  _inc?: InputMaybe<PaymentMethods_Inc_Input>;
  _set?: InputMaybe<PaymentMethods_Set_Input>;
  pk_columns: PaymentMethods_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdatePaymentMethodsArgs = {
  _inc?: InputMaybe<PaymentMethods_Inc_Input>;
  _set?: InputMaybe<PaymentMethods_Set_Input>;
  where: PaymentMethods_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdatePlanArgs = {
  _inc?: InputMaybe<Plans_Inc_Input>;
  _set?: InputMaybe<Plans_Set_Input>;
  pk_columns: Plans_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdatePlansArgs = {
  _inc?: InputMaybe<Plans_Inc_Input>;
  _set?: InputMaybe<Plans_Set_Input>;
  where: Plans_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateRegionsAllowedOrganizationArgs = {
  _set?: InputMaybe<Regions_Allowed_Organization_Set_Input>;
  pk_columns: Regions_Allowed_Organization_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateRegionsAllowedOrganizationsArgs = {
  _set?: InputMaybe<Regions_Allowed_Organization_Set_Input>;
  where: Regions_Allowed_Organization_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateRegionsAllowedOrganizationsManyArgs = {
  updates: Array<Regions_Allowed_Organization_Updates>;
};


/** mutation root */
export type Mutation_RootUpdateRegionsAllowedWorkspaceArgs = {
  _set?: InputMaybe<Regions_Allowed_Workspace_Set_Input>;
  pk_columns: Regions_Allowed_Workspace_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateRegionsAllowedWorkspacesArgs = {
  _set?: InputMaybe<Regions_Allowed_Workspace_Set_Input>;
  where: Regions_Allowed_Workspace_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateRunServiceArgs = {
  _set?: InputMaybe<Run_Service_Set_Input>;
  pk_columns: Run_Service_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateRunServiceConfigArgs = {
  appID: Scalars['uuid'];
  config: ConfigRunServiceConfigUpdateInput;
  serviceID: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootUpdateRunServicesArgs = {
  _set?: InputMaybe<Run_Service_Set_Input>;
  where: Run_Service_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateSecretArgs = {
  appID: Scalars['uuid'];
  secret: ConfigEnvironmentVariableInsertInput;
};


/** mutation root */
export type Mutation_RootUpdateSoftwareTypeArgs = {
  _set?: InputMaybe<Software_Type_Set_Input>;
  pk_columns: Software_Type_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateSoftwareTypesArgs = {
  _set?: InputMaybe<Software_Type_Set_Input>;
  where: Software_Type_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateSoftwareVersionArgs = {
  _set?: InputMaybe<Software_Versions_Set_Input>;
  pk_columns: Software_Versions_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateSoftwareVersionsArgs = {
  _set?: InputMaybe<Software_Versions_Set_Input>;
  where: Software_Versions_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateSystemConfigArgs = {
  appID: Scalars['uuid'];
  systemConfig: ConfigSystemConfigUpdateInput;
};


/** mutation root */
export type Mutation_RootUpdateUserArgs = {
  _append?: InputMaybe<Users_Append_Input>;
  _delete_at_path?: InputMaybe<Users_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Users_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Users_Delete_Key_Input>;
  _prepend?: InputMaybe<Users_Prepend_Input>;
  _set?: InputMaybe<Users_Set_Input>;
  pk_columns: Users_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateUsersArgs = {
  _append?: InputMaybe<Users_Append_Input>;
  _delete_at_path?: InputMaybe<Users_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Users_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Users_Delete_Key_Input>;
  _prepend?: InputMaybe<Users_Prepend_Input>;
  _set?: InputMaybe<Users_Set_Input>;
  where: Users_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateVirusArgs = {
  _append?: InputMaybe<Virus_Append_Input>;
  _delete_at_path?: InputMaybe<Virus_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Virus_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Virus_Delete_Key_Input>;
  _prepend?: InputMaybe<Virus_Prepend_Input>;
  _set?: InputMaybe<Virus_Set_Input>;
  pk_columns: Virus_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateVirusesArgs = {
  _append?: InputMaybe<Virus_Append_Input>;
  _delete_at_path?: InputMaybe<Virus_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Virus_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Virus_Delete_Key_Input>;
  _prepend?: InputMaybe<Virus_Prepend_Input>;
  _set?: InputMaybe<Virus_Set_Input>;
  where: Virus_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateWorkspaceArgs = {
  _set?: InputMaybe<Workspaces_Set_Input>;
  pk_columns: Workspaces_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateWorkspaceMemberArgs = {
  _set?: InputMaybe<WorkspaceMembers_Set_Input>;
  pk_columns: WorkspaceMembers_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateWorkspaceMemberInviteArgs = {
  _set?: InputMaybe<WorkspaceMemberInvites_Set_Input>;
  pk_columns: WorkspaceMemberInvites_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateWorkspaceMemberInvitesArgs = {
  _set?: InputMaybe<WorkspaceMemberInvites_Set_Input>;
  where: WorkspaceMemberInvites_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateWorkspaceMembersArgs = {
  _set?: InputMaybe<WorkspaceMembers_Set_Input>;
  where: WorkspaceMembers_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateWorkspacesArgs = {
  _set?: InputMaybe<Workspaces_Set_Input>;
  where: Workspaces_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_AnnouncementsArgs = {
  _set?: InputMaybe<Announcements_Set_Input>;
  where: Announcements_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Announcements_By_PkArgs = {
  _set?: InputMaybe<Announcements_Set_Input>;
  pk_columns: Announcements_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Announcements_ManyArgs = {
  updates: Array<Announcements_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_AppStateHistory_ManyArgs = {
  updates: Array<AppStateHistory_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_AppStates_ManyArgs = {
  updates: Array<AppStates_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Apps_ManyArgs = {
  updates: Array<Apps_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_AuthProviderRequests_ManyArgs = {
  updates: Array<AuthProviderRequests_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_AuthProviders_ManyArgs = {
  updates: Array<AuthProviders_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_AuthRefreshTokenTypes_ManyArgs = {
  updates: Array<AuthRefreshTokenTypes_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_AuthRefreshTokens_ManyArgs = {
  updates: Array<AuthRefreshTokens_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_AuthRoles_ManyArgs = {
  updates: Array<AuthRoles_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_AuthUserProviders_ManyArgs = {
  updates: Array<AuthUserProviders_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_AuthUserRoles_ManyArgs = {
  updates: Array<AuthUserRoles_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_AuthUserSecurityKeys_ManyArgs = {
  updates: Array<AuthUserSecurityKeys_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Auth_MigrationsArgs = {
  _inc?: InputMaybe<Auth_Migrations_Inc_Input>;
  _set?: InputMaybe<Auth_Migrations_Set_Input>;
  where: Auth_Migrations_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Auth_Migrations_By_PkArgs = {
  _inc?: InputMaybe<Auth_Migrations_Inc_Input>;
  _set?: InputMaybe<Auth_Migrations_Set_Input>;
  pk_columns: Auth_Migrations_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Auth_Migrations_ManyArgs = {
  updates: Array<Auth_Migrations_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Backups_ManyArgs = {
  updates: Array<Backups_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Billing_Dedicated_Compute_ManyArgs = {
  updates: Array<Billing_Dedicated_Compute_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Billing_Report_TypeArgs = {
  _set?: InputMaybe<Billing_Report_Type_Set_Input>;
  where: Billing_Report_Type_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Billing_Report_Type_By_PkArgs = {
  _set?: InputMaybe<Billing_Report_Type_Set_Input>;
  pk_columns: Billing_Report_Type_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Billing_Report_Type_ManyArgs = {
  updates: Array<Billing_Report_Type_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Buckets_ManyArgs = {
  updates: Array<Buckets_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_CliTokens_ManyArgs = {
  updates: Array<CliTokens_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_ContinentsArgs = {
  _set?: InputMaybe<Continents_Set_Input>;
  where: Continents_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Continents_By_PkArgs = {
  _set?: InputMaybe<Continents_Set_Input>;
  pk_columns: Continents_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Continents_ManyArgs = {
  updates: Array<Continents_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_CountriesArgs = {
  _inc?: InputMaybe<Countries_Inc_Input>;
  _set?: InputMaybe<Countries_Set_Input>;
  where: Countries_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Countries_By_PkArgs = {
  _inc?: InputMaybe<Countries_Inc_Input>;
  _set?: InputMaybe<Countries_Set_Input>;
  pk_columns: Countries_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Countries_ManyArgs = {
  updates: Array<Countries_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_DeploymentLogs_ManyArgs = {
  updates: Array<DeploymentLogs_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Deployments_ManyArgs = {
  updates: Array<Deployments_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_FeatureFlags_ManyArgs = {
  updates: Array<FeatureFlags_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Files_ManyArgs = {
  updates: Array<Files_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_GithubAppInstallations_ManyArgs = {
  updates: Array<GithubAppInstallations_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_GithubRepositories_ManyArgs = {
  updates: Array<GithubRepositories_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Many_Billing_SubscriptionsArgs = {
  updates: Array<Billing_Subscriptions_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Organization_Members_RoleArgs = {
  _set?: InputMaybe<Organization_Members_Role_Set_Input>;
  where: Organization_Members_Role_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Organization_Members_Role_By_PkArgs = {
  _set?: InputMaybe<Organization_Members_Role_Set_Input>;
  pk_columns: Organization_Members_Role_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Organization_Members_Role_ManyArgs = {
  updates: Array<Organization_Members_Role_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Organization_StatusArgs = {
  _set?: InputMaybe<Organization_Status_Set_Input>;
  where: Organization_Status_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Organization_Status_By_PkArgs = {
  _set?: InputMaybe<Organization_Status_Set_Input>;
  pk_columns: Organization_Status_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Organization_Status_ManyArgs = {
  updates: Array<Organization_Status_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_PaymentMethods_ManyArgs = {
  updates: Array<PaymentMethods_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Plans_ManyArgs = {
  updates: Array<Plans_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Region_TypeArgs = {
  _set?: InputMaybe<Region_Type_Set_Input>;
  where: Region_Type_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Region_Type_By_PkArgs = {
  _set?: InputMaybe<Region_Type_Set_Input>;
  pk_columns: Region_Type_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Region_Type_ManyArgs = {
  updates: Array<Region_Type_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_RegionsArgs = {
  _set?: InputMaybe<Regions_Set_Input>;
  where: Regions_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Regions_Allowed_Workspace_ManyArgs = {
  updates: Array<Regions_Allowed_Workspace_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Regions_By_PkArgs = {
  _set?: InputMaybe<Regions_Set_Input>;
  pk_columns: Regions_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Regions_ManyArgs = {
  updates: Array<Regions_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Run_Service_ManyArgs = {
  updates: Array<Run_Service_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Users_ManyArgs = {
  updates: Array<Users_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Virus_ManyArgs = {
  updates: Array<Virus_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_WorkspaceMemberInvites_ManyArgs = {
  updates: Array<WorkspaceMemberInvites_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_WorkspaceMembers_ManyArgs = {
  updates: Array<WorkspaceMembers_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Workspaces_ManyArgs = {
  updates: Array<Workspaces_Updates>;
};


/** mutation root */
export type Mutation_RootZzzDonotuse_Delete_Billing_Dedicated_Compute_ReportArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootZzzDonotuse_Delete_Billing_Dedicated_Compute_ReportsArgs = {
  where: Billing_Dedicated_Compute_Reports_Bool_Exp;
};


/** mutation root */
export type Mutation_RootZzzDonotuse_Insert_Billing_Dedicated_Compute_ReportArgs = {
  object: Billing_Dedicated_Compute_Reports_Insert_Input;
  on_conflict?: InputMaybe<Billing_Dedicated_Compute_Reports_On_Conflict>;
};


/** mutation root */
export type Mutation_RootZzzDonotuse_Insert_Billing_Dedicated_Compute_ReportsArgs = {
  objects: Array<Billing_Dedicated_Compute_Reports_Insert_Input>;
  on_conflict?: InputMaybe<Billing_Dedicated_Compute_Reports_On_Conflict>;
};


/** mutation root */
export type Mutation_RootZzzDonotuse_Update_Billing_Dedicated_Compute_ReportArgs = {
  _inc?: InputMaybe<Billing_Dedicated_Compute_Reports_Inc_Input>;
  _set?: InputMaybe<Billing_Dedicated_Compute_Reports_Set_Input>;
  pk_columns: Billing_Dedicated_Compute_Reports_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootZzzDonotuse_Update_Billing_Dedicated_Compute_ReportsArgs = {
  _inc?: InputMaybe<Billing_Dedicated_Compute_Reports_Inc_Input>;
  _set?: InputMaybe<Billing_Dedicated_Compute_Reports_Set_Input>;
  where: Billing_Dedicated_Compute_Reports_Bool_Exp;
};


/** mutation root */
export type Mutation_RootZzzDonotuse_Update_Many_Billing_Dedicated_Compute_ReportsArgs = {
  updates: Array<Billing_Dedicated_Compute_Reports_Updates>;
};

/** column ordering options */
export enum Order_By {
  /** in ascending order, nulls last */
  Asc = 'asc',
  /** in ascending order, nulls first */
  AscNullsFirst = 'asc_nulls_first',
  /** in ascending order, nulls last */
  AscNullsLast = 'asc_nulls_last',
  /** in descending order, nulls first */
  Desc = 'desc',
  /** in descending order, nulls first */
  DescNullsFirst = 'desc_nulls_first',
  /** in descending order, nulls last */
  DescNullsLast = 'desc_nulls_last'
}

export type OrganizationMemberInviteAccept_Args = {
  id?: InputMaybe<Scalars['uuid']>;
};

/** columns and relationships of "organization_member_invites" */
export type Organization_Member_Invites = {
  __typename?: 'organization_member_invites';
  createdAt: Scalars['timestamptz'];
  email: Scalars['citext'];
  id: Scalars['uuid'];
  /** An object relationship */
  organization: Organizations;
  organizationID: Scalars['uuid'];
  role: Organization_Members_Role_Enum;
  updateAt: Scalars['timestamptz'];
  /** An object relationship */
  user: Users;
};

/** aggregated selection of "organization_member_invites" */
export type Organization_Member_Invites_Aggregate = {
  __typename?: 'organization_member_invites_aggregate';
  aggregate?: Maybe<Organization_Member_Invites_Aggregate_Fields>;
  nodes: Array<Organization_Member_Invites>;
};

export type Organization_Member_Invites_Aggregate_Bool_Exp = {
  count?: InputMaybe<Organization_Member_Invites_Aggregate_Bool_Exp_Count>;
};

export type Organization_Member_Invites_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Organization_Member_Invites_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<Organization_Member_Invites_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "organization_member_invites" */
export type Organization_Member_Invites_Aggregate_Fields = {
  __typename?: 'organization_member_invites_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Organization_Member_Invites_Max_Fields>;
  min?: Maybe<Organization_Member_Invites_Min_Fields>;
};


/** aggregate fields of "organization_member_invites" */
export type Organization_Member_Invites_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Organization_Member_Invites_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "organization_member_invites" */
export type Organization_Member_Invites_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Organization_Member_Invites_Max_Order_By>;
  min?: InputMaybe<Organization_Member_Invites_Min_Order_By>;
};

/** input type for inserting array relation for remote table "organization_member_invites" */
export type Organization_Member_Invites_Arr_Rel_Insert_Input = {
  data: Array<Organization_Member_Invites_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Organization_Member_Invites_On_Conflict>;
};

/** Boolean expression to filter rows from the table "organization_member_invites". All fields are combined with a logical 'AND'. */
export type Organization_Member_Invites_Bool_Exp = {
  _and?: InputMaybe<Array<Organization_Member_Invites_Bool_Exp>>;
  _not?: InputMaybe<Organization_Member_Invites_Bool_Exp>;
  _or?: InputMaybe<Array<Organization_Member_Invites_Bool_Exp>>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  email?: InputMaybe<Citext_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  organization?: InputMaybe<Organizations_Bool_Exp>;
  organizationID?: InputMaybe<Uuid_Comparison_Exp>;
  role?: InputMaybe<Organization_Members_Role_Enum_Comparison_Exp>;
  updateAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  user?: InputMaybe<Users_Bool_Exp>;
};

/** unique or primary key constraints on table "organization_member_invites" */
export enum Organization_Member_Invites_Constraint {
  /** unique or primary key constraint on columns "email", "organization_id" */
  OrganizationMemberInvitesOrganizationIdEmailKey = 'organization_member_invites_organization_id_email_key',
  /** unique or primary key constraint on columns "id" */
  OrganizationMemberInvitesPkey = 'organization_member_invites_pkey'
}

/** input type for inserting data into table "organization_member_invites" */
export type Organization_Member_Invites_Insert_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  email?: InputMaybe<Scalars['citext']>;
  id?: InputMaybe<Scalars['uuid']>;
  organization?: InputMaybe<Organizations_Obj_Rel_Insert_Input>;
  organizationID?: InputMaybe<Scalars['uuid']>;
  role?: InputMaybe<Organization_Members_Role_Enum>;
  updateAt?: InputMaybe<Scalars['timestamptz']>;
  user?: InputMaybe<Users_Obj_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Organization_Member_Invites_Max_Fields = {
  __typename?: 'organization_member_invites_max_fields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  email?: Maybe<Scalars['citext']>;
  id?: Maybe<Scalars['uuid']>;
  organizationID?: Maybe<Scalars['uuid']>;
  updateAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "organization_member_invites" */
export type Organization_Member_Invites_Max_Order_By = {
  createdAt?: InputMaybe<Order_By>;
  email?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  organizationID?: InputMaybe<Order_By>;
  updateAt?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Organization_Member_Invites_Min_Fields = {
  __typename?: 'organization_member_invites_min_fields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  email?: Maybe<Scalars['citext']>;
  id?: Maybe<Scalars['uuid']>;
  organizationID?: Maybe<Scalars['uuid']>;
  updateAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "organization_member_invites" */
export type Organization_Member_Invites_Min_Order_By = {
  createdAt?: InputMaybe<Order_By>;
  email?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  organizationID?: InputMaybe<Order_By>;
  updateAt?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "organization_member_invites" */
export type Organization_Member_Invites_Mutation_Response = {
  __typename?: 'organization_member_invites_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Organization_Member_Invites>;
};

/** on_conflict condition type for table "organization_member_invites" */
export type Organization_Member_Invites_On_Conflict = {
  constraint: Organization_Member_Invites_Constraint;
  update_columns?: Array<Organization_Member_Invites_Update_Column>;
  where?: InputMaybe<Organization_Member_Invites_Bool_Exp>;
};

/** Ordering options when selecting data from "organization_member_invites". */
export type Organization_Member_Invites_Order_By = {
  createdAt?: InputMaybe<Order_By>;
  email?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  organization?: InputMaybe<Organizations_Order_By>;
  organizationID?: InputMaybe<Order_By>;
  role?: InputMaybe<Order_By>;
  updateAt?: InputMaybe<Order_By>;
  user?: InputMaybe<Users_Order_By>;
};

/** primary key columns input for table: organization_member_invites */
export type Organization_Member_Invites_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "organization_member_invites" */
export enum Organization_Member_Invites_Select_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Email = 'email',
  /** column name */
  Id = 'id',
  /** column name */
  OrganizationId = 'organizationID',
  /** column name */
  Role = 'role',
  /** column name */
  UpdateAt = 'updateAt'
}

/** input type for updating data in table "organization_member_invites" */
export type Organization_Member_Invites_Set_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  email?: InputMaybe<Scalars['citext']>;
  id?: InputMaybe<Scalars['uuid']>;
  organizationID?: InputMaybe<Scalars['uuid']>;
  role?: InputMaybe<Organization_Members_Role_Enum>;
  updateAt?: InputMaybe<Scalars['timestamptz']>;
};

/** Streaming cursor of the table "organization_member_invites" */
export type Organization_Member_Invites_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Organization_Member_Invites_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Organization_Member_Invites_Stream_Cursor_Value_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  email?: InputMaybe<Scalars['citext']>;
  id?: InputMaybe<Scalars['uuid']>;
  organizationID?: InputMaybe<Scalars['uuid']>;
  role?: InputMaybe<Organization_Members_Role_Enum>;
  updateAt?: InputMaybe<Scalars['timestamptz']>;
};

/** update columns of table "organization_member_invites" */
export enum Organization_Member_Invites_Update_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Email = 'email',
  /** column name */
  Id = 'id',
  /** column name */
  OrganizationId = 'organizationID',
  /** column name */
  Role = 'role',
  /** column name */
  UpdateAt = 'updateAt'
}

export type Organization_Member_Invites_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Organization_Member_Invites_Set_Input>;
  /** filter the rows which have to be updated */
  where: Organization_Member_Invites_Bool_Exp;
};

/** columns and relationships of "organization_members" */
export type Organization_Members = {
  __typename?: 'organization_members';
  createdAt: Scalars['timestamptz'];
  id: Scalars['uuid'];
  /** An object relationship */
  organization: Organizations;
  organizatonID: Scalars['uuid'];
  role: Organization_Members_Role_Enum;
  updatedAt: Scalars['timestamptz'];
  /** An object relationship */
  user: Users;
  userID: Scalars['uuid'];
};

/** aggregated selection of "organization_members" */
export type Organization_Members_Aggregate = {
  __typename?: 'organization_members_aggregate';
  aggregate?: Maybe<Organization_Members_Aggregate_Fields>;
  nodes: Array<Organization_Members>;
};

export type Organization_Members_Aggregate_Bool_Exp = {
  count?: InputMaybe<Organization_Members_Aggregate_Bool_Exp_Count>;
};

export type Organization_Members_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Organization_Members_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<Organization_Members_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "organization_members" */
export type Organization_Members_Aggregate_Fields = {
  __typename?: 'organization_members_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Organization_Members_Max_Fields>;
  min?: Maybe<Organization_Members_Min_Fields>;
};


/** aggregate fields of "organization_members" */
export type Organization_Members_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Organization_Members_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "organization_members" */
export type Organization_Members_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Organization_Members_Max_Order_By>;
  min?: InputMaybe<Organization_Members_Min_Order_By>;
};

/** input type for inserting array relation for remote table "organization_members" */
export type Organization_Members_Arr_Rel_Insert_Input = {
  data: Array<Organization_Members_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Organization_Members_On_Conflict>;
};

/** Boolean expression to filter rows from the table "organization_members". All fields are combined with a logical 'AND'. */
export type Organization_Members_Bool_Exp = {
  _and?: InputMaybe<Array<Organization_Members_Bool_Exp>>;
  _not?: InputMaybe<Organization_Members_Bool_Exp>;
  _or?: InputMaybe<Array<Organization_Members_Bool_Exp>>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  organization?: InputMaybe<Organizations_Bool_Exp>;
  organizatonID?: InputMaybe<Uuid_Comparison_Exp>;
  role?: InputMaybe<Organization_Members_Role_Enum_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  user?: InputMaybe<Users_Bool_Exp>;
  userID?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "organization_members" */
export enum Organization_Members_Constraint {
  /** unique or primary key constraint on columns "user_id", "organization_id" */
  OrganizationMembersOrganizationIdUserIdKey = 'organization_members_organization_id_user_id_key',
  /** unique or primary key constraint on columns "id" */
  OrganizationMembersPkey = 'organization_members_pkey'
}

/** input type for inserting data into table "organization_members" */
export type Organization_Members_Insert_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  organization?: InputMaybe<Organizations_Obj_Rel_Insert_Input>;
  organizatonID?: InputMaybe<Scalars['uuid']>;
  role?: InputMaybe<Organization_Members_Role_Enum>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  user?: InputMaybe<Users_Obj_Rel_Insert_Input>;
  userID?: InputMaybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type Organization_Members_Max_Fields = {
  __typename?: 'organization_members_max_fields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  organizatonID?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userID?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "organization_members" */
export type Organization_Members_Max_Order_By = {
  createdAt?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  organizatonID?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  userID?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Organization_Members_Min_Fields = {
  __typename?: 'organization_members_min_fields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  organizatonID?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userID?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "organization_members" */
export type Organization_Members_Min_Order_By = {
  createdAt?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  organizatonID?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  userID?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "organization_members" */
export type Organization_Members_Mutation_Response = {
  __typename?: 'organization_members_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Organization_Members>;
};

/** on_conflict condition type for table "organization_members" */
export type Organization_Members_On_Conflict = {
  constraint: Organization_Members_Constraint;
  update_columns?: Array<Organization_Members_Update_Column>;
  where?: InputMaybe<Organization_Members_Bool_Exp>;
};

/** Ordering options when selecting data from "organization_members". */
export type Organization_Members_Order_By = {
  createdAt?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  organization?: InputMaybe<Organizations_Order_By>;
  organizatonID?: InputMaybe<Order_By>;
  role?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  user?: InputMaybe<Users_Order_By>;
  userID?: InputMaybe<Order_By>;
};

/** primary key columns input for table: organization_members */
export type Organization_Members_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** columns and relationships of "organization_members_role" */
export type Organization_Members_Role = {
  __typename?: 'organization_members_role';
  comment: Scalars['String'];
  value: Scalars['String'];
};

/** aggregated selection of "organization_members_role" */
export type Organization_Members_Role_Aggregate = {
  __typename?: 'organization_members_role_aggregate';
  aggregate?: Maybe<Organization_Members_Role_Aggregate_Fields>;
  nodes: Array<Organization_Members_Role>;
};

/** aggregate fields of "organization_members_role" */
export type Organization_Members_Role_Aggregate_Fields = {
  __typename?: 'organization_members_role_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Organization_Members_Role_Max_Fields>;
  min?: Maybe<Organization_Members_Role_Min_Fields>;
};


/** aggregate fields of "organization_members_role" */
export type Organization_Members_Role_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Organization_Members_Role_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "organization_members_role". All fields are combined with a logical 'AND'. */
export type Organization_Members_Role_Bool_Exp = {
  _and?: InputMaybe<Array<Organization_Members_Role_Bool_Exp>>;
  _not?: InputMaybe<Organization_Members_Role_Bool_Exp>;
  _or?: InputMaybe<Array<Organization_Members_Role_Bool_Exp>>;
  comment?: InputMaybe<String_Comparison_Exp>;
  value?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "organization_members_role" */
export enum Organization_Members_Role_Constraint {
  /** unique or primary key constraint on columns "value" */
  OrganizationMembersRolePkey = 'organization_members_role_pkey'
}

export enum Organization_Members_Role_Enum {
  /** Administrator */
  Admin = 'ADMIN',
  /** User */
  User = 'USER'
}

/** Boolean expression to compare columns of type "organization_members_role_enum". All fields are combined with logical 'AND'. */
export type Organization_Members_Role_Enum_Comparison_Exp = {
  _eq?: InputMaybe<Organization_Members_Role_Enum>;
  _in?: InputMaybe<Array<Organization_Members_Role_Enum>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<Organization_Members_Role_Enum>;
  _nin?: InputMaybe<Array<Organization_Members_Role_Enum>>;
};

/** input type for inserting data into table "organization_members_role" */
export type Organization_Members_Role_Insert_Input = {
  comment?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Organization_Members_Role_Max_Fields = {
  __typename?: 'organization_members_role_max_fields';
  comment?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Organization_Members_Role_Min_Fields = {
  __typename?: 'organization_members_role_min_fields';
  comment?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "organization_members_role" */
export type Organization_Members_Role_Mutation_Response = {
  __typename?: 'organization_members_role_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Organization_Members_Role>;
};

/** on_conflict condition type for table "organization_members_role" */
export type Organization_Members_Role_On_Conflict = {
  constraint: Organization_Members_Role_Constraint;
  update_columns?: Array<Organization_Members_Role_Update_Column>;
  where?: InputMaybe<Organization_Members_Role_Bool_Exp>;
};

/** Ordering options when selecting data from "organization_members_role". */
export type Organization_Members_Role_Order_By = {
  comment?: InputMaybe<Order_By>;
  value?: InputMaybe<Order_By>;
};

/** primary key columns input for table: organization_members_role */
export type Organization_Members_Role_Pk_Columns_Input = {
  value: Scalars['String'];
};

/** select columns of table "organization_members_role" */
export enum Organization_Members_Role_Select_Column {
  /** column name */
  Comment = 'comment',
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "organization_members_role" */
export type Organization_Members_Role_Set_Input = {
  comment?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "organization_members_role" */
export type Organization_Members_Role_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Organization_Members_Role_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Organization_Members_Role_Stream_Cursor_Value_Input = {
  comment?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** update columns of table "organization_members_role" */
export enum Organization_Members_Role_Update_Column {
  /** column name */
  Comment = 'comment',
  /** column name */
  Value = 'value'
}

export type Organization_Members_Role_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Organization_Members_Role_Set_Input>;
  /** filter the rows which have to be updated */
  where: Organization_Members_Role_Bool_Exp;
};

/** select columns of table "organization_members" */
export enum Organization_Members_Select_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  OrganizatonId = 'organizatonID',
  /** column name */
  Role = 'role',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userID'
}

/** input type for updating data in table "organization_members" */
export type Organization_Members_Set_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  organizatonID?: InputMaybe<Scalars['uuid']>;
  role?: InputMaybe<Organization_Members_Role_Enum>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userID?: InputMaybe<Scalars['uuid']>;
};

/** Streaming cursor of the table "organization_members" */
export type Organization_Members_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Organization_Members_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Organization_Members_Stream_Cursor_Value_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  organizatonID?: InputMaybe<Scalars['uuid']>;
  role?: InputMaybe<Organization_Members_Role_Enum>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userID?: InputMaybe<Scalars['uuid']>;
};

/** update columns of table "organization_members" */
export enum Organization_Members_Update_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  OrganizatonId = 'organizatonID',
  /** column name */
  Role = 'role',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userID'
}

export type Organization_Members_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Organization_Members_Set_Input>;
  /** filter the rows which have to be updated */
  where: Organization_Members_Bool_Exp;
};

/** columns and relationships of "organization_new_request" */
export type Organization_New_Request = {
  __typename?: 'organization_new_request';
  createdAt: Scalars['timestamptz'];
  id: Scalars['uuid'];
  name: Scalars['String'];
  /** An object relationship */
  plan: Plans;
  planID: Scalars['uuid'];
  sessionID: Scalars['String'];
  slug: Scalars['String'];
  /** An object relationship */
  user: Users;
  userID: Scalars['uuid'];
};

/** aggregated selection of "organization_new_request" */
export type Organization_New_Request_Aggregate = {
  __typename?: 'organization_new_request_aggregate';
  aggregate?: Maybe<Organization_New_Request_Aggregate_Fields>;
  nodes: Array<Organization_New_Request>;
};

/** aggregate fields of "organization_new_request" */
export type Organization_New_Request_Aggregate_Fields = {
  __typename?: 'organization_new_request_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Organization_New_Request_Max_Fields>;
  min?: Maybe<Organization_New_Request_Min_Fields>;
};


/** aggregate fields of "organization_new_request" */
export type Organization_New_Request_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Organization_New_Request_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "organization_new_request". All fields are combined with a logical 'AND'. */
export type Organization_New_Request_Bool_Exp = {
  _and?: InputMaybe<Array<Organization_New_Request_Bool_Exp>>;
  _not?: InputMaybe<Organization_New_Request_Bool_Exp>;
  _or?: InputMaybe<Array<Organization_New_Request_Bool_Exp>>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  plan?: InputMaybe<Plans_Bool_Exp>;
  planID?: InputMaybe<Uuid_Comparison_Exp>;
  sessionID?: InputMaybe<String_Comparison_Exp>;
  slug?: InputMaybe<String_Comparison_Exp>;
  user?: InputMaybe<Users_Bool_Exp>;
  userID?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "organization_new_request" */
export enum Organization_New_Request_Constraint {
  /** unique or primary key constraint on columns "id" */
  OrganizationNewRequestPkey = 'organization_new_request_pkey',
  /** unique or primary key constraint on columns "session_id" */
  OrganizationNewRequestSessionIdKey = 'organization_new_request_session_id_key'
}

/** input type for inserting data into table "organization_new_request" */
export type Organization_New_Request_Insert_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  name?: InputMaybe<Scalars['String']>;
  plan?: InputMaybe<Plans_Obj_Rel_Insert_Input>;
  planID?: InputMaybe<Scalars['uuid']>;
  sessionID?: InputMaybe<Scalars['String']>;
  slug?: InputMaybe<Scalars['String']>;
  user?: InputMaybe<Users_Obj_Rel_Insert_Input>;
  userID?: InputMaybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type Organization_New_Request_Max_Fields = {
  __typename?: 'organization_new_request_max_fields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
  planID?: Maybe<Scalars['uuid']>;
  sessionID?: Maybe<Scalars['String']>;
  slug?: Maybe<Scalars['String']>;
  userID?: Maybe<Scalars['uuid']>;
};

/** aggregate min on columns */
export type Organization_New_Request_Min_Fields = {
  __typename?: 'organization_new_request_min_fields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
  planID?: Maybe<Scalars['uuid']>;
  sessionID?: Maybe<Scalars['String']>;
  slug?: Maybe<Scalars['String']>;
  userID?: Maybe<Scalars['uuid']>;
};

/** response of any mutation on the table "organization_new_request" */
export type Organization_New_Request_Mutation_Response = {
  __typename?: 'organization_new_request_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Organization_New_Request>;
};

/** on_conflict condition type for table "organization_new_request" */
export type Organization_New_Request_On_Conflict = {
  constraint: Organization_New_Request_Constraint;
  update_columns?: Array<Organization_New_Request_Update_Column>;
  where?: InputMaybe<Organization_New_Request_Bool_Exp>;
};

/** Ordering options when selecting data from "organization_new_request". */
export type Organization_New_Request_Order_By = {
  createdAt?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  plan?: InputMaybe<Plans_Order_By>;
  planID?: InputMaybe<Order_By>;
  sessionID?: InputMaybe<Order_By>;
  slug?: InputMaybe<Order_By>;
  user?: InputMaybe<Users_Order_By>;
  userID?: InputMaybe<Order_By>;
};

/** primary key columns input for table: organization_new_request */
export type Organization_New_Request_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "organization_new_request" */
export enum Organization_New_Request_Select_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  PlanId = 'planID',
  /** column name */
  SessionId = 'sessionID',
  /** column name */
  Slug = 'slug',
  /** column name */
  UserId = 'userID'
}

/** input type for updating data in table "organization_new_request" */
export type Organization_New_Request_Set_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  name?: InputMaybe<Scalars['String']>;
  planID?: InputMaybe<Scalars['uuid']>;
  sessionID?: InputMaybe<Scalars['String']>;
  slug?: InputMaybe<Scalars['String']>;
  userID?: InputMaybe<Scalars['uuid']>;
};

/** Streaming cursor of the table "organization_new_request" */
export type Organization_New_Request_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Organization_New_Request_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Organization_New_Request_Stream_Cursor_Value_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  name?: InputMaybe<Scalars['String']>;
  planID?: InputMaybe<Scalars['uuid']>;
  sessionID?: InputMaybe<Scalars['String']>;
  slug?: InputMaybe<Scalars['String']>;
  userID?: InputMaybe<Scalars['uuid']>;
};

/** update columns of table "organization_new_request" */
export enum Organization_New_Request_Update_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  PlanId = 'planID',
  /** column name */
  SessionId = 'sessionID',
  /** column name */
  Slug = 'slug',
  /** column name */
  UserId = 'userID'
}

export type Organization_New_Request_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Organization_New_Request_Set_Input>;
  /** filter the rows which have to be updated */
  where: Organization_New_Request_Bool_Exp;
};

/** columns and relationships of "organization_status" */
export type Organization_Status = {
  __typename?: 'organization_status';
  comment: Scalars['String'];
  value: Scalars['String'];
};

/** aggregated selection of "organization_status" */
export type Organization_Status_Aggregate = {
  __typename?: 'organization_status_aggregate';
  aggregate?: Maybe<Organization_Status_Aggregate_Fields>;
  nodes: Array<Organization_Status>;
};

/** aggregate fields of "organization_status" */
export type Organization_Status_Aggregate_Fields = {
  __typename?: 'organization_status_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Organization_Status_Max_Fields>;
  min?: Maybe<Organization_Status_Min_Fields>;
};


/** aggregate fields of "organization_status" */
export type Organization_Status_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Organization_Status_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "organization_status". All fields are combined with a logical 'AND'. */
export type Organization_Status_Bool_Exp = {
  _and?: InputMaybe<Array<Organization_Status_Bool_Exp>>;
  _not?: InputMaybe<Organization_Status_Bool_Exp>;
  _or?: InputMaybe<Array<Organization_Status_Bool_Exp>>;
  comment?: InputMaybe<String_Comparison_Exp>;
  value?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "organization_status" */
export enum Organization_Status_Constraint {
  /** unique or primary key constraint on columns "value" */
  OrganizationStatusPkey = 'organization_status_pkey'
}

export enum Organization_Status_Enum {
  /** Organization has been disabled and all resources have been suspended */
  Disabled = 'DISABLED',
  /** Organization is healthy */
  Ok = 'OK',
  /** Organization has warnings and is not allowed to make changes */
  Warning = 'WARNING'
}

/** Boolean expression to compare columns of type "organization_status_enum". All fields are combined with logical 'AND'. */
export type Organization_Status_Enum_Comparison_Exp = {
  _eq?: InputMaybe<Organization_Status_Enum>;
  _in?: InputMaybe<Array<Organization_Status_Enum>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<Organization_Status_Enum>;
  _nin?: InputMaybe<Array<Organization_Status_Enum>>;
};

/** input type for inserting data into table "organization_status" */
export type Organization_Status_Insert_Input = {
  comment?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Organization_Status_Max_Fields = {
  __typename?: 'organization_status_max_fields';
  comment?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Organization_Status_Min_Fields = {
  __typename?: 'organization_status_min_fields';
  comment?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "organization_status" */
export type Organization_Status_Mutation_Response = {
  __typename?: 'organization_status_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Organization_Status>;
};

/** on_conflict condition type for table "organization_status" */
export type Organization_Status_On_Conflict = {
  constraint: Organization_Status_Constraint;
  update_columns?: Array<Organization_Status_Update_Column>;
  where?: InputMaybe<Organization_Status_Bool_Exp>;
};

/** Ordering options when selecting data from "organization_status". */
export type Organization_Status_Order_By = {
  comment?: InputMaybe<Order_By>;
  value?: InputMaybe<Order_By>;
};

/** primary key columns input for table: organization_status */
export type Organization_Status_Pk_Columns_Input = {
  value: Scalars['String'];
};

/** select columns of table "organization_status" */
export enum Organization_Status_Select_Column {
  /** column name */
  Comment = 'comment',
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "organization_status" */
export type Organization_Status_Set_Input = {
  comment?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "organization_status" */
export type Organization_Status_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Organization_Status_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Organization_Status_Stream_Cursor_Value_Input = {
  comment?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
};

/** update columns of table "organization_status" */
export enum Organization_Status_Update_Column {
  /** column name */
  Comment = 'comment',
  /** column name */
  Value = 'value'
}

export type Organization_Status_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Organization_Status_Set_Input>;
  /** filter the rows which have to be updated */
  where: Organization_Status_Bool_Exp;
};

/** columns and relationships of "organizations" */
export type Organizations = {
  __typename?: 'organizations';
  /** An array relationship */
  allowedPrivateRegions: Array<Regions_Allowed_Organization>;
  /** An aggregate relationship */
  allowedPrivateRegions_aggregate: Regions_Allowed_Organization_Aggregate;
  /** An array relationship */
  apps: Array<Apps>;
  /** An aggregate relationship */
  apps_aggregate: Apps_Aggregate;
  createdAt: Scalars['timestamptz'];
  id: Scalars['uuid'];
  /** An array relationship */
  invites: Array<Organization_Member_Invites>;
  /** An aggregate relationship */
  invites_aggregate: Organization_Member_Invites_Aggregate;
  /** An array relationship */
  members: Array<Organization_Members>;
  /** An aggregate relationship */
  members_aggregate: Organization_Members_Aggregate;
  name: Scalars['String'];
  /** An object relationship */
  plan: Plans;
  planID: Scalars['uuid'];
  slug: Scalars['String'];
  status: Organization_Status_Enum;
  status_comment?: Maybe<Scalars['String']>;
  stripeCustomerID?: Maybe<Scalars['String']>;
  stripeSubscriptionID?: Maybe<Scalars['String']>;
  updatedAt: Scalars['timestamptz'];
};


/** columns and relationships of "organizations" */
export type OrganizationsAllowedPrivateRegionsArgs = {
  distinct_on?: InputMaybe<Array<Regions_Allowed_Organization_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Regions_Allowed_Organization_Order_By>>;
  where?: InputMaybe<Regions_Allowed_Organization_Bool_Exp>;
};


/** columns and relationships of "organizations" */
export type OrganizationsAllowedPrivateRegions_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Regions_Allowed_Organization_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Regions_Allowed_Organization_Order_By>>;
  where?: InputMaybe<Regions_Allowed_Organization_Bool_Exp>;
};


/** columns and relationships of "organizations" */
export type OrganizationsAppsArgs = {
  distinct_on?: InputMaybe<Array<Apps_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Apps_Order_By>>;
  where?: InputMaybe<Apps_Bool_Exp>;
};


/** columns and relationships of "organizations" */
export type OrganizationsApps_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Apps_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Apps_Order_By>>;
  where?: InputMaybe<Apps_Bool_Exp>;
};


/** columns and relationships of "organizations" */
export type OrganizationsInvitesArgs = {
  distinct_on?: InputMaybe<Array<Organization_Member_Invites_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Organization_Member_Invites_Order_By>>;
  where?: InputMaybe<Organization_Member_Invites_Bool_Exp>;
};


/** columns and relationships of "organizations" */
export type OrganizationsInvites_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Organization_Member_Invites_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Organization_Member_Invites_Order_By>>;
  where?: InputMaybe<Organization_Member_Invites_Bool_Exp>;
};


/** columns and relationships of "organizations" */
export type OrganizationsMembersArgs = {
  distinct_on?: InputMaybe<Array<Organization_Members_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Organization_Members_Order_By>>;
  where?: InputMaybe<Organization_Members_Bool_Exp>;
};


/** columns and relationships of "organizations" */
export type OrganizationsMembers_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Organization_Members_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Organization_Members_Order_By>>;
  where?: InputMaybe<Organization_Members_Bool_Exp>;
};

/** aggregated selection of "organizations" */
export type Organizations_Aggregate = {
  __typename?: 'organizations_aggregate';
  aggregate?: Maybe<Organizations_Aggregate_Fields>;
  nodes: Array<Organizations>;
};

export type Organizations_Aggregate_Bool_Exp = {
  count?: InputMaybe<Organizations_Aggregate_Bool_Exp_Count>;
};

export type Organizations_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Organizations_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<Organizations_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "organizations" */
export type Organizations_Aggregate_Fields = {
  __typename?: 'organizations_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Organizations_Max_Fields>;
  min?: Maybe<Organizations_Min_Fields>;
};


/** aggregate fields of "organizations" */
export type Organizations_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Organizations_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "organizations" */
export type Organizations_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Organizations_Max_Order_By>;
  min?: InputMaybe<Organizations_Min_Order_By>;
};

/** input type for inserting array relation for remote table "organizations" */
export type Organizations_Arr_Rel_Insert_Input = {
  data: Array<Organizations_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Organizations_On_Conflict>;
};

/** Boolean expression to filter rows from the table "organizations". All fields are combined with a logical 'AND'. */
export type Organizations_Bool_Exp = {
  _and?: InputMaybe<Array<Organizations_Bool_Exp>>;
  _not?: InputMaybe<Organizations_Bool_Exp>;
  _or?: InputMaybe<Array<Organizations_Bool_Exp>>;
  allowedPrivateRegions?: InputMaybe<Regions_Allowed_Organization_Bool_Exp>;
  allowedPrivateRegions_aggregate?: InputMaybe<Regions_Allowed_Organization_Aggregate_Bool_Exp>;
  apps?: InputMaybe<Apps_Bool_Exp>;
  apps_aggregate?: InputMaybe<Apps_Aggregate_Bool_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  invites?: InputMaybe<Organization_Member_Invites_Bool_Exp>;
  invites_aggregate?: InputMaybe<Organization_Member_Invites_Aggregate_Bool_Exp>;
  members?: InputMaybe<Organization_Members_Bool_Exp>;
  members_aggregate?: InputMaybe<Organization_Members_Aggregate_Bool_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  plan?: InputMaybe<Plans_Bool_Exp>;
  planID?: InputMaybe<Uuid_Comparison_Exp>;
  slug?: InputMaybe<String_Comparison_Exp>;
  status?: InputMaybe<Organization_Status_Enum_Comparison_Exp>;
  status_comment?: InputMaybe<String_Comparison_Exp>;
  stripeCustomerID?: InputMaybe<String_Comparison_Exp>;
  stripeSubscriptionID?: InputMaybe<String_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "organizations" */
export enum Organizations_Constraint {
  /** unique or primary key constraint on columns "id" */
  OrganizationsPkey = 'organizations_pkey',
  /** unique or primary key constraint on columns "slug" */
  OrganizationsSlugKey = 'organizations_slug_key'
}

/** columns and relationships of "organizations_free_usage" */
export type Organizations_Free_Usage = {
  __typename?: 'organizations_free_usage';
  createdAt: Scalars['timestamptz'];
  freeAllowanceExceeded: Scalars['Boolean'];
  id: Scalars['uuid'];
  organizationID: Scalars['uuid'];
  updated_at: Scalars['timestamptz'];
};

/** aggregated selection of "organizations_free_usage" */
export type Organizations_Free_Usage_Aggregate = {
  __typename?: 'organizations_free_usage_aggregate';
  aggregate?: Maybe<Organizations_Free_Usage_Aggregate_Fields>;
  nodes: Array<Organizations_Free_Usage>;
};

/** aggregate fields of "organizations_free_usage" */
export type Organizations_Free_Usage_Aggregate_Fields = {
  __typename?: 'organizations_free_usage_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Organizations_Free_Usage_Max_Fields>;
  min?: Maybe<Organizations_Free_Usage_Min_Fields>;
};


/** aggregate fields of "organizations_free_usage" */
export type Organizations_Free_Usage_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Organizations_Free_Usage_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "organizations_free_usage". All fields are combined with a logical 'AND'. */
export type Organizations_Free_Usage_Bool_Exp = {
  _and?: InputMaybe<Array<Organizations_Free_Usage_Bool_Exp>>;
  _not?: InputMaybe<Organizations_Free_Usage_Bool_Exp>;
  _or?: InputMaybe<Array<Organizations_Free_Usage_Bool_Exp>>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  freeAllowanceExceeded?: InputMaybe<Boolean_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  organizationID?: InputMaybe<Uuid_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "organizations_free_usage" */
export enum Organizations_Free_Usage_Constraint {
  /** unique or primary key constraint on columns "organization_id" */
  OrganizationsFreeUsageOrganizationIdKey = 'organizations_free_usage_organization_id_key',
  /** unique or primary key constraint on columns "id" */
  OrganizationsFreeUsagePkey = 'organizations_free_usage_pkey'
}

/** input type for inserting data into table "organizations_free_usage" */
export type Organizations_Free_Usage_Insert_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  freeAllowanceExceeded?: InputMaybe<Scalars['Boolean']>;
  id?: InputMaybe<Scalars['uuid']>;
  organizationID?: InputMaybe<Scalars['uuid']>;
  updated_at?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Organizations_Free_Usage_Max_Fields = {
  __typename?: 'organizations_free_usage_max_fields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  organizationID?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Organizations_Free_Usage_Min_Fields = {
  __typename?: 'organizations_free_usage_min_fields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  organizationID?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "organizations_free_usage" */
export type Organizations_Free_Usage_Mutation_Response = {
  __typename?: 'organizations_free_usage_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Organizations_Free_Usage>;
};

/** on_conflict condition type for table "organizations_free_usage" */
export type Organizations_Free_Usage_On_Conflict = {
  constraint: Organizations_Free_Usage_Constraint;
  update_columns?: Array<Organizations_Free_Usage_Update_Column>;
  where?: InputMaybe<Organizations_Free_Usage_Bool_Exp>;
};

/** Ordering options when selecting data from "organizations_free_usage". */
export type Organizations_Free_Usage_Order_By = {
  createdAt?: InputMaybe<Order_By>;
  freeAllowanceExceeded?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  organizationID?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: organizations_free_usage */
export type Organizations_Free_Usage_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "organizations_free_usage" */
export enum Organizations_Free_Usage_Select_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  FreeAllowanceExceeded = 'freeAllowanceExceeded',
  /** column name */
  Id = 'id',
  /** column name */
  OrganizationId = 'organizationID',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "organizations_free_usage" */
export type Organizations_Free_Usage_Set_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  freeAllowanceExceeded?: InputMaybe<Scalars['Boolean']>;
  id?: InputMaybe<Scalars['uuid']>;
  organizationID?: InputMaybe<Scalars['uuid']>;
  updated_at?: InputMaybe<Scalars['timestamptz']>;
};

/** Streaming cursor of the table "organizations_free_usage" */
export type Organizations_Free_Usage_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Organizations_Free_Usage_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Organizations_Free_Usage_Stream_Cursor_Value_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  freeAllowanceExceeded?: InputMaybe<Scalars['Boolean']>;
  id?: InputMaybe<Scalars['uuid']>;
  organizationID?: InputMaybe<Scalars['uuid']>;
  updated_at?: InputMaybe<Scalars['timestamptz']>;
};

/** update columns of table "organizations_free_usage" */
export enum Organizations_Free_Usage_Update_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  FreeAllowanceExceeded = 'freeAllowanceExceeded',
  /** column name */
  Id = 'id',
  /** column name */
  OrganizationId = 'organizationID',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Organizations_Free_Usage_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Organizations_Free_Usage_Set_Input>;
  /** filter the rows which have to be updated */
  where: Organizations_Free_Usage_Bool_Exp;
};

/** input type for inserting data into table "organizations" */
export type Organizations_Insert_Input = {
  allowedPrivateRegions?: InputMaybe<Regions_Allowed_Organization_Arr_Rel_Insert_Input>;
  apps?: InputMaybe<Apps_Arr_Rel_Insert_Input>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  invites?: InputMaybe<Organization_Member_Invites_Arr_Rel_Insert_Input>;
  members?: InputMaybe<Organization_Members_Arr_Rel_Insert_Input>;
  name?: InputMaybe<Scalars['String']>;
  plan?: InputMaybe<Plans_Obj_Rel_Insert_Input>;
  planID?: InputMaybe<Scalars['uuid']>;
  slug?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<Organization_Status_Enum>;
  status_comment?: InputMaybe<Scalars['String']>;
  stripeCustomerID?: InputMaybe<Scalars['String']>;
  stripeSubscriptionID?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Organizations_Max_Fields = {
  __typename?: 'organizations_max_fields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
  planID?: Maybe<Scalars['uuid']>;
  slug?: Maybe<Scalars['String']>;
  status_comment?: Maybe<Scalars['String']>;
  stripeCustomerID?: Maybe<Scalars['String']>;
  stripeSubscriptionID?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "organizations" */
export type Organizations_Max_Order_By = {
  createdAt?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  planID?: InputMaybe<Order_By>;
  slug?: InputMaybe<Order_By>;
  status_comment?: InputMaybe<Order_By>;
  stripeCustomerID?: InputMaybe<Order_By>;
  stripeSubscriptionID?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Organizations_Min_Fields = {
  __typename?: 'organizations_min_fields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
  planID?: Maybe<Scalars['uuid']>;
  slug?: Maybe<Scalars['String']>;
  status_comment?: Maybe<Scalars['String']>;
  stripeCustomerID?: Maybe<Scalars['String']>;
  stripeSubscriptionID?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "organizations" */
export type Organizations_Min_Order_By = {
  createdAt?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  planID?: InputMaybe<Order_By>;
  slug?: InputMaybe<Order_By>;
  status_comment?: InputMaybe<Order_By>;
  stripeCustomerID?: InputMaybe<Order_By>;
  stripeSubscriptionID?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "organizations" */
export type Organizations_Mutation_Response = {
  __typename?: 'organizations_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Organizations>;
};

/** input type for inserting object relation for remote table "organizations" */
export type Organizations_Obj_Rel_Insert_Input = {
  data: Organizations_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Organizations_On_Conflict>;
};

/** on_conflict condition type for table "organizations" */
export type Organizations_On_Conflict = {
  constraint: Organizations_Constraint;
  update_columns?: Array<Organizations_Update_Column>;
  where?: InputMaybe<Organizations_Bool_Exp>;
};

/** Ordering options when selecting data from "organizations". */
export type Organizations_Order_By = {
  allowedPrivateRegions_aggregate?: InputMaybe<Regions_Allowed_Organization_Aggregate_Order_By>;
  apps_aggregate?: InputMaybe<Apps_Aggregate_Order_By>;
  createdAt?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  invites_aggregate?: InputMaybe<Organization_Member_Invites_Aggregate_Order_By>;
  members_aggregate?: InputMaybe<Organization_Members_Aggregate_Order_By>;
  name?: InputMaybe<Order_By>;
  plan?: InputMaybe<Plans_Order_By>;
  planID?: InputMaybe<Order_By>;
  slug?: InputMaybe<Order_By>;
  status?: InputMaybe<Order_By>;
  status_comment?: InputMaybe<Order_By>;
  stripeCustomerID?: InputMaybe<Order_By>;
  stripeSubscriptionID?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
};

/** primary key columns input for table: organizations */
export type Organizations_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "organizations" */
export enum Organizations_Select_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  PlanId = 'planID',
  /** column name */
  Slug = 'slug',
  /** column name */
  Status = 'status',
  /** column name */
  StatusComment = 'status_comment',
  /** column name */
  StripeCustomerId = 'stripeCustomerID',
  /** column name */
  StripeSubscriptionId = 'stripeSubscriptionID',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "organizations" */
export type Organizations_Set_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  name?: InputMaybe<Scalars['String']>;
  planID?: InputMaybe<Scalars['uuid']>;
  slug?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<Organization_Status_Enum>;
  status_comment?: InputMaybe<Scalars['String']>;
  stripeCustomerID?: InputMaybe<Scalars['String']>;
  stripeSubscriptionID?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** Streaming cursor of the table "organizations" */
export type Organizations_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Organizations_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Organizations_Stream_Cursor_Value_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  name?: InputMaybe<Scalars['String']>;
  planID?: InputMaybe<Scalars['uuid']>;
  slug?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<Organization_Status_Enum>;
  status_comment?: InputMaybe<Scalars['String']>;
  stripeCustomerID?: InputMaybe<Scalars['String']>;
  stripeSubscriptionID?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** update columns of table "organizations" */
export enum Organizations_Update_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  PlanId = 'planID',
  /** column name */
  Slug = 'slug',
  /** column name */
  Status = 'status',
  /** column name */
  StatusComment = 'status_comment',
  /** column name */
  StripeCustomerId = 'stripeCustomerID',
  /** column name */
  StripeSubscriptionId = 'stripeSubscriptionID',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type Organizations_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Organizations_Set_Input>;
  /** filter the rows which have to be updated */
  where: Organizations_Bool_Exp;
};

/** columns and relationships of "payment_methods" */
export type PaymentMethods = {
  __typename?: 'paymentMethods';
  addedByUserId: Scalars['uuid'];
  cardBrand: Scalars['String'];
  cardExpMonth: Scalars['Int'];
  cardExpYear: Scalars['Int'];
  cardLast4: Scalars['String'];
  createdAt: Scalars['timestamptz'];
  id: Scalars['uuid'];
  isDefault: Scalars['Boolean'];
  stripePaymentMethodId: Scalars['String'];
  /** An object relationship */
  user: Users;
  /** An object relationship */
  workspace: Workspaces;
  workspaceId: Scalars['uuid'];
};

/** aggregated selection of "payment_methods" */
export type PaymentMethods_Aggregate = {
  __typename?: 'paymentMethods_aggregate';
  aggregate?: Maybe<PaymentMethods_Aggregate_Fields>;
  nodes: Array<PaymentMethods>;
};

export type PaymentMethods_Aggregate_Bool_Exp = {
  bool_and?: InputMaybe<PaymentMethods_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: InputMaybe<PaymentMethods_Aggregate_Bool_Exp_Bool_Or>;
  count?: InputMaybe<PaymentMethods_Aggregate_Bool_Exp_Count>;
};

export type PaymentMethods_Aggregate_Bool_Exp_Bool_And = {
  arguments: PaymentMethods_Select_Column_PaymentMethods_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<PaymentMethods_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type PaymentMethods_Aggregate_Bool_Exp_Bool_Or = {
  arguments: PaymentMethods_Select_Column_PaymentMethods_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<PaymentMethods_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type PaymentMethods_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<PaymentMethods_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<PaymentMethods_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "payment_methods" */
export type PaymentMethods_Aggregate_Fields = {
  __typename?: 'paymentMethods_aggregate_fields';
  avg?: Maybe<PaymentMethods_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<PaymentMethods_Max_Fields>;
  min?: Maybe<PaymentMethods_Min_Fields>;
  stddev?: Maybe<PaymentMethods_Stddev_Fields>;
  stddev_pop?: Maybe<PaymentMethods_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<PaymentMethods_Stddev_Samp_Fields>;
  sum?: Maybe<PaymentMethods_Sum_Fields>;
  var_pop?: Maybe<PaymentMethods_Var_Pop_Fields>;
  var_samp?: Maybe<PaymentMethods_Var_Samp_Fields>;
  variance?: Maybe<PaymentMethods_Variance_Fields>;
};


/** aggregate fields of "payment_methods" */
export type PaymentMethods_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<PaymentMethods_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "payment_methods" */
export type PaymentMethods_Aggregate_Order_By = {
  avg?: InputMaybe<PaymentMethods_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<PaymentMethods_Max_Order_By>;
  min?: InputMaybe<PaymentMethods_Min_Order_By>;
  stddev?: InputMaybe<PaymentMethods_Stddev_Order_By>;
  stddev_pop?: InputMaybe<PaymentMethods_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<PaymentMethods_Stddev_Samp_Order_By>;
  sum?: InputMaybe<PaymentMethods_Sum_Order_By>;
  var_pop?: InputMaybe<PaymentMethods_Var_Pop_Order_By>;
  var_samp?: InputMaybe<PaymentMethods_Var_Samp_Order_By>;
  variance?: InputMaybe<PaymentMethods_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "payment_methods" */
export type PaymentMethods_Arr_Rel_Insert_Input = {
  data: Array<PaymentMethods_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<PaymentMethods_On_Conflict>;
};

/** aggregate avg on columns */
export type PaymentMethods_Avg_Fields = {
  __typename?: 'paymentMethods_avg_fields';
  cardExpMonth?: Maybe<Scalars['Float']>;
  cardExpYear?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "payment_methods" */
export type PaymentMethods_Avg_Order_By = {
  cardExpMonth?: InputMaybe<Order_By>;
  cardExpYear?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "payment_methods". All fields are combined with a logical 'AND'. */
export type PaymentMethods_Bool_Exp = {
  _and?: InputMaybe<Array<PaymentMethods_Bool_Exp>>;
  _not?: InputMaybe<PaymentMethods_Bool_Exp>;
  _or?: InputMaybe<Array<PaymentMethods_Bool_Exp>>;
  addedByUserId?: InputMaybe<Uuid_Comparison_Exp>;
  cardBrand?: InputMaybe<String_Comparison_Exp>;
  cardExpMonth?: InputMaybe<Int_Comparison_Exp>;
  cardExpYear?: InputMaybe<Int_Comparison_Exp>;
  cardLast4?: InputMaybe<String_Comparison_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  isDefault?: InputMaybe<Boolean_Comparison_Exp>;
  stripePaymentMethodId?: InputMaybe<String_Comparison_Exp>;
  user?: InputMaybe<Users_Bool_Exp>;
  workspace?: InputMaybe<Workspaces_Bool_Exp>;
  workspaceId?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "payment_methods" */
export enum PaymentMethods_Constraint {
  /** unique or primary key constraint on columns "id" */
  PaymentMethodsPkey = 'payment_methods_pkey'
}

/** input type for incrementing numeric columns in table "payment_methods" */
export type PaymentMethods_Inc_Input = {
  cardExpMonth?: InputMaybe<Scalars['Int']>;
  cardExpYear?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "payment_methods" */
export type PaymentMethods_Insert_Input = {
  addedByUserId?: InputMaybe<Scalars['uuid']>;
  cardBrand?: InputMaybe<Scalars['String']>;
  cardExpMonth?: InputMaybe<Scalars['Int']>;
  cardExpYear?: InputMaybe<Scalars['Int']>;
  cardLast4?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  isDefault?: InputMaybe<Scalars['Boolean']>;
  stripePaymentMethodId?: InputMaybe<Scalars['String']>;
  user?: InputMaybe<Users_Obj_Rel_Insert_Input>;
  workspace?: InputMaybe<Workspaces_Obj_Rel_Insert_Input>;
  workspaceId?: InputMaybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type PaymentMethods_Max_Fields = {
  __typename?: 'paymentMethods_max_fields';
  addedByUserId?: Maybe<Scalars['uuid']>;
  cardBrand?: Maybe<Scalars['String']>;
  cardExpMonth?: Maybe<Scalars['Int']>;
  cardExpYear?: Maybe<Scalars['Int']>;
  cardLast4?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  stripePaymentMethodId?: Maybe<Scalars['String']>;
  workspaceId?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "payment_methods" */
export type PaymentMethods_Max_Order_By = {
  addedByUserId?: InputMaybe<Order_By>;
  cardBrand?: InputMaybe<Order_By>;
  cardExpMonth?: InputMaybe<Order_By>;
  cardExpYear?: InputMaybe<Order_By>;
  cardLast4?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  stripePaymentMethodId?: InputMaybe<Order_By>;
  workspaceId?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type PaymentMethods_Min_Fields = {
  __typename?: 'paymentMethods_min_fields';
  addedByUserId?: Maybe<Scalars['uuid']>;
  cardBrand?: Maybe<Scalars['String']>;
  cardExpMonth?: Maybe<Scalars['Int']>;
  cardExpYear?: Maybe<Scalars['Int']>;
  cardLast4?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  stripePaymentMethodId?: Maybe<Scalars['String']>;
  workspaceId?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "payment_methods" */
export type PaymentMethods_Min_Order_By = {
  addedByUserId?: InputMaybe<Order_By>;
  cardBrand?: InputMaybe<Order_By>;
  cardExpMonth?: InputMaybe<Order_By>;
  cardExpYear?: InputMaybe<Order_By>;
  cardLast4?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  stripePaymentMethodId?: InputMaybe<Order_By>;
  workspaceId?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "payment_methods" */
export type PaymentMethods_Mutation_Response = {
  __typename?: 'paymentMethods_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<PaymentMethods>;
};

/** input type for inserting object relation for remote table "payment_methods" */
export type PaymentMethods_Obj_Rel_Insert_Input = {
  data: PaymentMethods_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<PaymentMethods_On_Conflict>;
};

/** on_conflict condition type for table "payment_methods" */
export type PaymentMethods_On_Conflict = {
  constraint: PaymentMethods_Constraint;
  update_columns?: Array<PaymentMethods_Update_Column>;
  where?: InputMaybe<PaymentMethods_Bool_Exp>;
};

/** Ordering options when selecting data from "payment_methods". */
export type PaymentMethods_Order_By = {
  addedByUserId?: InputMaybe<Order_By>;
  cardBrand?: InputMaybe<Order_By>;
  cardExpMonth?: InputMaybe<Order_By>;
  cardExpYear?: InputMaybe<Order_By>;
  cardLast4?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  isDefault?: InputMaybe<Order_By>;
  stripePaymentMethodId?: InputMaybe<Order_By>;
  user?: InputMaybe<Users_Order_By>;
  workspace?: InputMaybe<Workspaces_Order_By>;
  workspaceId?: InputMaybe<Order_By>;
};

/** primary key columns input for table: payment_methods */
export type PaymentMethods_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "payment_methods" */
export enum PaymentMethods_Select_Column {
  /** column name */
  AddedByUserId = 'addedByUserId',
  /** column name */
  CardBrand = 'cardBrand',
  /** column name */
  CardExpMonth = 'cardExpMonth',
  /** column name */
  CardExpYear = 'cardExpYear',
  /** column name */
  CardLast4 = 'cardLast4',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  IsDefault = 'isDefault',
  /** column name */
  StripePaymentMethodId = 'stripePaymentMethodId',
  /** column name */
  WorkspaceId = 'workspaceId'
}

/** select "paymentMethods_aggregate_bool_exp_bool_and_arguments_columns" columns of table "payment_methods" */
export enum PaymentMethods_Select_Column_PaymentMethods_Aggregate_Bool_Exp_Bool_And_Arguments_Columns {
  /** column name */
  IsDefault = 'isDefault'
}

/** select "paymentMethods_aggregate_bool_exp_bool_or_arguments_columns" columns of table "payment_methods" */
export enum PaymentMethods_Select_Column_PaymentMethods_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns {
  /** column name */
  IsDefault = 'isDefault'
}

/** input type for updating data in table "payment_methods" */
export type PaymentMethods_Set_Input = {
  addedByUserId?: InputMaybe<Scalars['uuid']>;
  cardBrand?: InputMaybe<Scalars['String']>;
  cardExpMonth?: InputMaybe<Scalars['Int']>;
  cardExpYear?: InputMaybe<Scalars['Int']>;
  cardLast4?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  isDefault?: InputMaybe<Scalars['Boolean']>;
  stripePaymentMethodId?: InputMaybe<Scalars['String']>;
  workspaceId?: InputMaybe<Scalars['uuid']>;
};

/** aggregate stddev on columns */
export type PaymentMethods_Stddev_Fields = {
  __typename?: 'paymentMethods_stddev_fields';
  cardExpMonth?: Maybe<Scalars['Float']>;
  cardExpYear?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "payment_methods" */
export type PaymentMethods_Stddev_Order_By = {
  cardExpMonth?: InputMaybe<Order_By>;
  cardExpYear?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type PaymentMethods_Stddev_Pop_Fields = {
  __typename?: 'paymentMethods_stddev_pop_fields';
  cardExpMonth?: Maybe<Scalars['Float']>;
  cardExpYear?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "payment_methods" */
export type PaymentMethods_Stddev_Pop_Order_By = {
  cardExpMonth?: InputMaybe<Order_By>;
  cardExpYear?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type PaymentMethods_Stddev_Samp_Fields = {
  __typename?: 'paymentMethods_stddev_samp_fields';
  cardExpMonth?: Maybe<Scalars['Float']>;
  cardExpYear?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "payment_methods" */
export type PaymentMethods_Stddev_Samp_Order_By = {
  cardExpMonth?: InputMaybe<Order_By>;
  cardExpYear?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "paymentMethods" */
export type PaymentMethods_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: PaymentMethods_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type PaymentMethods_Stream_Cursor_Value_Input = {
  addedByUserId?: InputMaybe<Scalars['uuid']>;
  cardBrand?: InputMaybe<Scalars['String']>;
  cardExpMonth?: InputMaybe<Scalars['Int']>;
  cardExpYear?: InputMaybe<Scalars['Int']>;
  cardLast4?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  isDefault?: InputMaybe<Scalars['Boolean']>;
  stripePaymentMethodId?: InputMaybe<Scalars['String']>;
  workspaceId?: InputMaybe<Scalars['uuid']>;
};

/** aggregate sum on columns */
export type PaymentMethods_Sum_Fields = {
  __typename?: 'paymentMethods_sum_fields';
  cardExpMonth?: Maybe<Scalars['Int']>;
  cardExpYear?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "payment_methods" */
export type PaymentMethods_Sum_Order_By = {
  cardExpMonth?: InputMaybe<Order_By>;
  cardExpYear?: InputMaybe<Order_By>;
};

/** update columns of table "payment_methods" */
export enum PaymentMethods_Update_Column {
  /** column name */
  AddedByUserId = 'addedByUserId',
  /** column name */
  CardBrand = 'cardBrand',
  /** column name */
  CardExpMonth = 'cardExpMonth',
  /** column name */
  CardExpYear = 'cardExpYear',
  /** column name */
  CardLast4 = 'cardLast4',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  IsDefault = 'isDefault',
  /** column name */
  StripePaymentMethodId = 'stripePaymentMethodId',
  /** column name */
  WorkspaceId = 'workspaceId'
}

export type PaymentMethods_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<PaymentMethods_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<PaymentMethods_Set_Input>;
  /** filter the rows which have to be updated */
  where: PaymentMethods_Bool_Exp;
};

/** aggregate var_pop on columns */
export type PaymentMethods_Var_Pop_Fields = {
  __typename?: 'paymentMethods_var_pop_fields';
  cardExpMonth?: Maybe<Scalars['Float']>;
  cardExpYear?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "payment_methods" */
export type PaymentMethods_Var_Pop_Order_By = {
  cardExpMonth?: InputMaybe<Order_By>;
  cardExpYear?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type PaymentMethods_Var_Samp_Fields = {
  __typename?: 'paymentMethods_var_samp_fields';
  cardExpMonth?: Maybe<Scalars['Float']>;
  cardExpYear?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "payment_methods" */
export type PaymentMethods_Var_Samp_Order_By = {
  cardExpMonth?: InputMaybe<Order_By>;
  cardExpYear?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type PaymentMethods_Variance_Fields = {
  __typename?: 'paymentMethods_variance_fields';
  cardExpMonth?: Maybe<Scalars['Float']>;
  cardExpYear?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "payment_methods" */
export type PaymentMethods_Variance_Order_By = {
  cardExpMonth?: InputMaybe<Order_By>;
  cardExpYear?: InputMaybe<Order_By>;
};

/** columns and relationships of "plans" */
export type Plans = {
  __typename?: 'plans';
  /** An array relationship */
  apps: Array<Apps>;
  /** An aggregate relationship */
  apps_aggregate: Apps_Aggregate;
  createdAt: Scalars['timestamptz'];
  deprecated: Scalars['Boolean'];
  featureAdvancedGraphql: Scalars['Boolean'];
  featureBackupEnabled: Scalars['Boolean'];
  featureBackupRetentionDays: Scalars['Int'];
  featureCustomDomainsEnabled: Scalars['Boolean'];
  featureCustomEmailTemplatesEnabled: Scalars['Boolean'];
  featureCustomResources: Scalars['Boolean'];
  /** Weather or not to deploy email templates for git deployments */
  featureDeployEmailTemplates: Scalars['Boolean'];
  /** Function execution timeout in seconds */
  featureFunctionExecutionTimeout: Scalars['Int'];
  featureMaxDbSize: Scalars['Int'];
  featureMaxFilesSize?: Maybe<Scalars['Int']>;
  /** Max number of functions to deploy per git deployment */
  featureMaxNumberOfFunctionsPerDeployment: Scalars['Int'];
  id: Scalars['uuid'];
  individual: Scalars['Boolean'];
  isDefault: Scalars['Boolean'];
  isFree: Scalars['Boolean'];
  isPublic: Scalars['Boolean'];
  name: Scalars['String'];
  /** An array relationship */
  organizations: Array<Organizations>;
  /** An aggregate relationship */
  organizations_aggregate: Organizations_Aggregate;
  price: Scalars['Int'];
  sort: Scalars['Int'];
  stripePriceIDCustomDomains: Scalars['String'];
  stripePriceIDDedicatedCompute: Scalars['String'];
  stripePriceIDEgressUsageMB: Scalars['String'];
  stripePriceIDFunctionsAmount: Scalars['String'];
  stripePriceIDFunctionsUsageSeconds: Scalars['String'];
  stripePriceIDPersistentVolumesGB: Scalars['String'];
  stripePriceId: Scalars['String'];
  upatedAt: Scalars['timestamptz'];
};


/** columns and relationships of "plans" */
export type PlansAppsArgs = {
  distinct_on?: InputMaybe<Array<Apps_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Apps_Order_By>>;
  where?: InputMaybe<Apps_Bool_Exp>;
};


/** columns and relationships of "plans" */
export type PlansApps_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Apps_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Apps_Order_By>>;
  where?: InputMaybe<Apps_Bool_Exp>;
};


/** columns and relationships of "plans" */
export type PlansOrganizationsArgs = {
  distinct_on?: InputMaybe<Array<Organizations_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Organizations_Order_By>>;
  where?: InputMaybe<Organizations_Bool_Exp>;
};


/** columns and relationships of "plans" */
export type PlansOrganizations_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Organizations_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Organizations_Order_By>>;
  where?: InputMaybe<Organizations_Bool_Exp>;
};

/** aggregated selection of "plans" */
export type Plans_Aggregate = {
  __typename?: 'plans_aggregate';
  aggregate?: Maybe<Plans_Aggregate_Fields>;
  nodes: Array<Plans>;
};

/** aggregate fields of "plans" */
export type Plans_Aggregate_Fields = {
  __typename?: 'plans_aggregate_fields';
  avg?: Maybe<Plans_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Plans_Max_Fields>;
  min?: Maybe<Plans_Min_Fields>;
  stddev?: Maybe<Plans_Stddev_Fields>;
  stddev_pop?: Maybe<Plans_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Plans_Stddev_Samp_Fields>;
  sum?: Maybe<Plans_Sum_Fields>;
  var_pop?: Maybe<Plans_Var_Pop_Fields>;
  var_samp?: Maybe<Plans_Var_Samp_Fields>;
  variance?: Maybe<Plans_Variance_Fields>;
};


/** aggregate fields of "plans" */
export type Plans_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Plans_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Plans_Avg_Fields = {
  __typename?: 'plans_avg_fields';
  featureBackupRetentionDays?: Maybe<Scalars['Float']>;
  /** Function execution timeout in seconds */
  featureFunctionExecutionTimeout?: Maybe<Scalars['Float']>;
  featureMaxDbSize?: Maybe<Scalars['Float']>;
  featureMaxFilesSize?: Maybe<Scalars['Float']>;
  /** Max number of functions to deploy per git deployment */
  featureMaxNumberOfFunctionsPerDeployment?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  sort?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "plans". All fields are combined with a logical 'AND'. */
export type Plans_Bool_Exp = {
  _and?: InputMaybe<Array<Plans_Bool_Exp>>;
  _not?: InputMaybe<Plans_Bool_Exp>;
  _or?: InputMaybe<Array<Plans_Bool_Exp>>;
  apps?: InputMaybe<Apps_Bool_Exp>;
  apps_aggregate?: InputMaybe<Apps_Aggregate_Bool_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  deprecated?: InputMaybe<Boolean_Comparison_Exp>;
  featureAdvancedGraphql?: InputMaybe<Boolean_Comparison_Exp>;
  featureBackupEnabled?: InputMaybe<Boolean_Comparison_Exp>;
  featureBackupRetentionDays?: InputMaybe<Int_Comparison_Exp>;
  featureCustomDomainsEnabled?: InputMaybe<Boolean_Comparison_Exp>;
  featureCustomEmailTemplatesEnabled?: InputMaybe<Boolean_Comparison_Exp>;
  featureCustomResources?: InputMaybe<Boolean_Comparison_Exp>;
  featureDeployEmailTemplates?: InputMaybe<Boolean_Comparison_Exp>;
  featureFunctionExecutionTimeout?: InputMaybe<Int_Comparison_Exp>;
  featureMaxDbSize?: InputMaybe<Int_Comparison_Exp>;
  featureMaxFilesSize?: InputMaybe<Int_Comparison_Exp>;
  featureMaxNumberOfFunctionsPerDeployment?: InputMaybe<Int_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  individual?: InputMaybe<Boolean_Comparison_Exp>;
  isDefault?: InputMaybe<Boolean_Comparison_Exp>;
  isFree?: InputMaybe<Boolean_Comparison_Exp>;
  isPublic?: InputMaybe<Boolean_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  organizations?: InputMaybe<Organizations_Bool_Exp>;
  organizations_aggregate?: InputMaybe<Organizations_Aggregate_Bool_Exp>;
  price?: InputMaybe<Int_Comparison_Exp>;
  sort?: InputMaybe<Int_Comparison_Exp>;
  stripePriceIDCustomDomains?: InputMaybe<String_Comparison_Exp>;
  stripePriceIDDedicatedCompute?: InputMaybe<String_Comparison_Exp>;
  stripePriceIDEgressUsageMB?: InputMaybe<String_Comparison_Exp>;
  stripePriceIDFunctionsAmount?: InputMaybe<String_Comparison_Exp>;
  stripePriceIDFunctionsUsageSeconds?: InputMaybe<String_Comparison_Exp>;
  stripePriceIDPersistentVolumesGB?: InputMaybe<String_Comparison_Exp>;
  stripePriceId?: InputMaybe<String_Comparison_Exp>;
  upatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "plans" */
export enum Plans_Constraint {
  /** unique or primary key constraint on columns "id" */
  PlansPkey = 'plans_pkey'
}

/** input type for incrementing numeric columns in table "plans" */
export type Plans_Inc_Input = {
  featureBackupRetentionDays?: InputMaybe<Scalars['Int']>;
  /** Function execution timeout in seconds */
  featureFunctionExecutionTimeout?: InputMaybe<Scalars['Int']>;
  featureMaxDbSize?: InputMaybe<Scalars['Int']>;
  featureMaxFilesSize?: InputMaybe<Scalars['Int']>;
  /** Max number of functions to deploy per git deployment */
  featureMaxNumberOfFunctionsPerDeployment?: InputMaybe<Scalars['Int']>;
  price?: InputMaybe<Scalars['Int']>;
  sort?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "plans" */
export type Plans_Insert_Input = {
  apps?: InputMaybe<Apps_Arr_Rel_Insert_Input>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deprecated?: InputMaybe<Scalars['Boolean']>;
  featureAdvancedGraphql?: InputMaybe<Scalars['Boolean']>;
  featureBackupEnabled?: InputMaybe<Scalars['Boolean']>;
  featureBackupRetentionDays?: InputMaybe<Scalars['Int']>;
  featureCustomDomainsEnabled?: InputMaybe<Scalars['Boolean']>;
  featureCustomEmailTemplatesEnabled?: InputMaybe<Scalars['Boolean']>;
  featureCustomResources?: InputMaybe<Scalars['Boolean']>;
  /** Weather or not to deploy email templates for git deployments */
  featureDeployEmailTemplates?: InputMaybe<Scalars['Boolean']>;
  /** Function execution timeout in seconds */
  featureFunctionExecutionTimeout?: InputMaybe<Scalars['Int']>;
  featureMaxDbSize?: InputMaybe<Scalars['Int']>;
  featureMaxFilesSize?: InputMaybe<Scalars['Int']>;
  /** Max number of functions to deploy per git deployment */
  featureMaxNumberOfFunctionsPerDeployment?: InputMaybe<Scalars['Int']>;
  id?: InputMaybe<Scalars['uuid']>;
  individual?: InputMaybe<Scalars['Boolean']>;
  isDefault?: InputMaybe<Scalars['Boolean']>;
  isFree?: InputMaybe<Scalars['Boolean']>;
  isPublic?: InputMaybe<Scalars['Boolean']>;
  name?: InputMaybe<Scalars['String']>;
  organizations?: InputMaybe<Organizations_Arr_Rel_Insert_Input>;
  price?: InputMaybe<Scalars['Int']>;
  sort?: InputMaybe<Scalars['Int']>;
  stripePriceIDCustomDomains?: InputMaybe<Scalars['String']>;
  stripePriceIDDedicatedCompute?: InputMaybe<Scalars['String']>;
  stripePriceIDEgressUsageMB?: InputMaybe<Scalars['String']>;
  stripePriceIDFunctionsAmount?: InputMaybe<Scalars['String']>;
  stripePriceIDFunctionsUsageSeconds?: InputMaybe<Scalars['String']>;
  stripePriceIDPersistentVolumesGB?: InputMaybe<Scalars['String']>;
  stripePriceId?: InputMaybe<Scalars['String']>;
  upatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Plans_Max_Fields = {
  __typename?: 'plans_max_fields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  featureBackupRetentionDays?: Maybe<Scalars['Int']>;
  /** Function execution timeout in seconds */
  featureFunctionExecutionTimeout?: Maybe<Scalars['Int']>;
  featureMaxDbSize?: Maybe<Scalars['Int']>;
  featureMaxFilesSize?: Maybe<Scalars['Int']>;
  /** Max number of functions to deploy per git deployment */
  featureMaxNumberOfFunctionsPerDeployment?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
  price?: Maybe<Scalars['Int']>;
  sort?: Maybe<Scalars['Int']>;
  stripePriceIDCustomDomains?: Maybe<Scalars['String']>;
  stripePriceIDDedicatedCompute?: Maybe<Scalars['String']>;
  stripePriceIDEgressUsageMB?: Maybe<Scalars['String']>;
  stripePriceIDFunctionsAmount?: Maybe<Scalars['String']>;
  stripePriceIDFunctionsUsageSeconds?: Maybe<Scalars['String']>;
  stripePriceIDPersistentVolumesGB?: Maybe<Scalars['String']>;
  stripePriceId?: Maybe<Scalars['String']>;
  upatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Plans_Min_Fields = {
  __typename?: 'plans_min_fields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  featureBackupRetentionDays?: Maybe<Scalars['Int']>;
  /** Function execution timeout in seconds */
  featureFunctionExecutionTimeout?: Maybe<Scalars['Int']>;
  featureMaxDbSize?: Maybe<Scalars['Int']>;
  featureMaxFilesSize?: Maybe<Scalars['Int']>;
  /** Max number of functions to deploy per git deployment */
  featureMaxNumberOfFunctionsPerDeployment?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
  price?: Maybe<Scalars['Int']>;
  sort?: Maybe<Scalars['Int']>;
  stripePriceIDCustomDomains?: Maybe<Scalars['String']>;
  stripePriceIDDedicatedCompute?: Maybe<Scalars['String']>;
  stripePriceIDEgressUsageMB?: Maybe<Scalars['String']>;
  stripePriceIDFunctionsAmount?: Maybe<Scalars['String']>;
  stripePriceIDFunctionsUsageSeconds?: Maybe<Scalars['String']>;
  stripePriceIDPersistentVolumesGB?: Maybe<Scalars['String']>;
  stripePriceId?: Maybe<Scalars['String']>;
  upatedAt?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "plans" */
export type Plans_Mutation_Response = {
  __typename?: 'plans_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Plans>;
};

/** input type for inserting object relation for remote table "plans" */
export type Plans_Obj_Rel_Insert_Input = {
  data: Plans_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Plans_On_Conflict>;
};

/** on_conflict condition type for table "plans" */
export type Plans_On_Conflict = {
  constraint: Plans_Constraint;
  update_columns?: Array<Plans_Update_Column>;
  where?: InputMaybe<Plans_Bool_Exp>;
};

/** Ordering options when selecting data from "plans". */
export type Plans_Order_By = {
  apps_aggregate?: InputMaybe<Apps_Aggregate_Order_By>;
  createdAt?: InputMaybe<Order_By>;
  deprecated?: InputMaybe<Order_By>;
  featureAdvancedGraphql?: InputMaybe<Order_By>;
  featureBackupEnabled?: InputMaybe<Order_By>;
  featureBackupRetentionDays?: InputMaybe<Order_By>;
  featureCustomDomainsEnabled?: InputMaybe<Order_By>;
  featureCustomEmailTemplatesEnabled?: InputMaybe<Order_By>;
  featureCustomResources?: InputMaybe<Order_By>;
  featureDeployEmailTemplates?: InputMaybe<Order_By>;
  featureFunctionExecutionTimeout?: InputMaybe<Order_By>;
  featureMaxDbSize?: InputMaybe<Order_By>;
  featureMaxFilesSize?: InputMaybe<Order_By>;
  featureMaxNumberOfFunctionsPerDeployment?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  individual?: InputMaybe<Order_By>;
  isDefault?: InputMaybe<Order_By>;
  isFree?: InputMaybe<Order_By>;
  isPublic?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  organizations_aggregate?: InputMaybe<Organizations_Aggregate_Order_By>;
  price?: InputMaybe<Order_By>;
  sort?: InputMaybe<Order_By>;
  stripePriceIDCustomDomains?: InputMaybe<Order_By>;
  stripePriceIDDedicatedCompute?: InputMaybe<Order_By>;
  stripePriceIDEgressUsageMB?: InputMaybe<Order_By>;
  stripePriceIDFunctionsAmount?: InputMaybe<Order_By>;
  stripePriceIDFunctionsUsageSeconds?: InputMaybe<Order_By>;
  stripePriceIDPersistentVolumesGB?: InputMaybe<Order_By>;
  stripePriceId?: InputMaybe<Order_By>;
  upatedAt?: InputMaybe<Order_By>;
};

/** primary key columns input for table: plans */
export type Plans_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "plans" */
export enum Plans_Select_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Deprecated = 'deprecated',
  /** column name */
  FeatureAdvancedGraphql = 'featureAdvancedGraphql',
  /** column name */
  FeatureBackupEnabled = 'featureBackupEnabled',
  /** column name */
  FeatureBackupRetentionDays = 'featureBackupRetentionDays',
  /** column name */
  FeatureCustomDomainsEnabled = 'featureCustomDomainsEnabled',
  /** column name */
  FeatureCustomEmailTemplatesEnabled = 'featureCustomEmailTemplatesEnabled',
  /** column name */
  FeatureCustomResources = 'featureCustomResources',
  /** column name */
  FeatureDeployEmailTemplates = 'featureDeployEmailTemplates',
  /** column name */
  FeatureFunctionExecutionTimeout = 'featureFunctionExecutionTimeout',
  /** column name */
  FeatureMaxDbSize = 'featureMaxDbSize',
  /** column name */
  FeatureMaxFilesSize = 'featureMaxFilesSize',
  /** column name */
  FeatureMaxNumberOfFunctionsPerDeployment = 'featureMaxNumberOfFunctionsPerDeployment',
  /** column name */
  Id = 'id',
  /** column name */
  Individual = 'individual',
  /** column name */
  IsDefault = 'isDefault',
  /** column name */
  IsFree = 'isFree',
  /** column name */
  IsPublic = 'isPublic',
  /** column name */
  Name = 'name',
  /** column name */
  Price = 'price',
  /** column name */
  Sort = 'sort',
  /** column name */
  StripePriceIdCustomDomains = 'stripePriceIDCustomDomains',
  /** column name */
  StripePriceIdDedicatedCompute = 'stripePriceIDDedicatedCompute',
  /** column name */
  StripePriceIdEgressUsageMb = 'stripePriceIDEgressUsageMB',
  /** column name */
  StripePriceIdFunctionsAmount = 'stripePriceIDFunctionsAmount',
  /** column name */
  StripePriceIdFunctionsUsageSeconds = 'stripePriceIDFunctionsUsageSeconds',
  /** column name */
  StripePriceIdPersistentVolumesGb = 'stripePriceIDPersistentVolumesGB',
  /** column name */
  StripePriceId = 'stripePriceId',
  /** column name */
  UpatedAt = 'upatedAt'
}

/** input type for updating data in table "plans" */
export type Plans_Set_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deprecated?: InputMaybe<Scalars['Boolean']>;
  featureAdvancedGraphql?: InputMaybe<Scalars['Boolean']>;
  featureBackupEnabled?: InputMaybe<Scalars['Boolean']>;
  featureBackupRetentionDays?: InputMaybe<Scalars['Int']>;
  featureCustomDomainsEnabled?: InputMaybe<Scalars['Boolean']>;
  featureCustomEmailTemplatesEnabled?: InputMaybe<Scalars['Boolean']>;
  featureCustomResources?: InputMaybe<Scalars['Boolean']>;
  /** Weather or not to deploy email templates for git deployments */
  featureDeployEmailTemplates?: InputMaybe<Scalars['Boolean']>;
  /** Function execution timeout in seconds */
  featureFunctionExecutionTimeout?: InputMaybe<Scalars['Int']>;
  featureMaxDbSize?: InputMaybe<Scalars['Int']>;
  featureMaxFilesSize?: InputMaybe<Scalars['Int']>;
  /** Max number of functions to deploy per git deployment */
  featureMaxNumberOfFunctionsPerDeployment?: InputMaybe<Scalars['Int']>;
  id?: InputMaybe<Scalars['uuid']>;
  individual?: InputMaybe<Scalars['Boolean']>;
  isDefault?: InputMaybe<Scalars['Boolean']>;
  isFree?: InputMaybe<Scalars['Boolean']>;
  isPublic?: InputMaybe<Scalars['Boolean']>;
  name?: InputMaybe<Scalars['String']>;
  price?: InputMaybe<Scalars['Int']>;
  sort?: InputMaybe<Scalars['Int']>;
  stripePriceIDCustomDomains?: InputMaybe<Scalars['String']>;
  stripePriceIDDedicatedCompute?: InputMaybe<Scalars['String']>;
  stripePriceIDEgressUsageMB?: InputMaybe<Scalars['String']>;
  stripePriceIDFunctionsAmount?: InputMaybe<Scalars['String']>;
  stripePriceIDFunctionsUsageSeconds?: InputMaybe<Scalars['String']>;
  stripePriceIDPersistentVolumesGB?: InputMaybe<Scalars['String']>;
  stripePriceId?: InputMaybe<Scalars['String']>;
  upatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Plans_Stddev_Fields = {
  __typename?: 'plans_stddev_fields';
  featureBackupRetentionDays?: Maybe<Scalars['Float']>;
  /** Function execution timeout in seconds */
  featureFunctionExecutionTimeout?: Maybe<Scalars['Float']>;
  featureMaxDbSize?: Maybe<Scalars['Float']>;
  featureMaxFilesSize?: Maybe<Scalars['Float']>;
  /** Max number of functions to deploy per git deployment */
  featureMaxNumberOfFunctionsPerDeployment?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  sort?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Plans_Stddev_Pop_Fields = {
  __typename?: 'plans_stddev_pop_fields';
  featureBackupRetentionDays?: Maybe<Scalars['Float']>;
  /** Function execution timeout in seconds */
  featureFunctionExecutionTimeout?: Maybe<Scalars['Float']>;
  featureMaxDbSize?: Maybe<Scalars['Float']>;
  featureMaxFilesSize?: Maybe<Scalars['Float']>;
  /** Max number of functions to deploy per git deployment */
  featureMaxNumberOfFunctionsPerDeployment?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  sort?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Plans_Stddev_Samp_Fields = {
  __typename?: 'plans_stddev_samp_fields';
  featureBackupRetentionDays?: Maybe<Scalars['Float']>;
  /** Function execution timeout in seconds */
  featureFunctionExecutionTimeout?: Maybe<Scalars['Float']>;
  featureMaxDbSize?: Maybe<Scalars['Float']>;
  featureMaxFilesSize?: Maybe<Scalars['Float']>;
  /** Max number of functions to deploy per git deployment */
  featureMaxNumberOfFunctionsPerDeployment?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  sort?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "plans" */
export type Plans_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Plans_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Plans_Stream_Cursor_Value_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deprecated?: InputMaybe<Scalars['Boolean']>;
  featureAdvancedGraphql?: InputMaybe<Scalars['Boolean']>;
  featureBackupEnabled?: InputMaybe<Scalars['Boolean']>;
  featureBackupRetentionDays?: InputMaybe<Scalars['Int']>;
  featureCustomDomainsEnabled?: InputMaybe<Scalars['Boolean']>;
  featureCustomEmailTemplatesEnabled?: InputMaybe<Scalars['Boolean']>;
  featureCustomResources?: InputMaybe<Scalars['Boolean']>;
  /** Weather or not to deploy email templates for git deployments */
  featureDeployEmailTemplates?: InputMaybe<Scalars['Boolean']>;
  /** Function execution timeout in seconds */
  featureFunctionExecutionTimeout?: InputMaybe<Scalars['Int']>;
  featureMaxDbSize?: InputMaybe<Scalars['Int']>;
  featureMaxFilesSize?: InputMaybe<Scalars['Int']>;
  /** Max number of functions to deploy per git deployment */
  featureMaxNumberOfFunctionsPerDeployment?: InputMaybe<Scalars['Int']>;
  id?: InputMaybe<Scalars['uuid']>;
  individual?: InputMaybe<Scalars['Boolean']>;
  isDefault?: InputMaybe<Scalars['Boolean']>;
  isFree?: InputMaybe<Scalars['Boolean']>;
  isPublic?: InputMaybe<Scalars['Boolean']>;
  name?: InputMaybe<Scalars['String']>;
  price?: InputMaybe<Scalars['Int']>;
  sort?: InputMaybe<Scalars['Int']>;
  stripePriceIDCustomDomains?: InputMaybe<Scalars['String']>;
  stripePriceIDDedicatedCompute?: InputMaybe<Scalars['String']>;
  stripePriceIDEgressUsageMB?: InputMaybe<Scalars['String']>;
  stripePriceIDFunctionsAmount?: InputMaybe<Scalars['String']>;
  stripePriceIDFunctionsUsageSeconds?: InputMaybe<Scalars['String']>;
  stripePriceIDPersistentVolumesGB?: InputMaybe<Scalars['String']>;
  stripePriceId?: InputMaybe<Scalars['String']>;
  upatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate sum on columns */
export type Plans_Sum_Fields = {
  __typename?: 'plans_sum_fields';
  featureBackupRetentionDays?: Maybe<Scalars['Int']>;
  /** Function execution timeout in seconds */
  featureFunctionExecutionTimeout?: Maybe<Scalars['Int']>;
  featureMaxDbSize?: Maybe<Scalars['Int']>;
  featureMaxFilesSize?: Maybe<Scalars['Int']>;
  /** Max number of functions to deploy per git deployment */
  featureMaxNumberOfFunctionsPerDeployment?: Maybe<Scalars['Int']>;
  price?: Maybe<Scalars['Int']>;
  sort?: Maybe<Scalars['Int']>;
};

/** update columns of table "plans" */
export enum Plans_Update_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Deprecated = 'deprecated',
  /** column name */
  FeatureAdvancedGraphql = 'featureAdvancedGraphql',
  /** column name */
  FeatureBackupEnabled = 'featureBackupEnabled',
  /** column name */
  FeatureBackupRetentionDays = 'featureBackupRetentionDays',
  /** column name */
  FeatureCustomDomainsEnabled = 'featureCustomDomainsEnabled',
  /** column name */
  FeatureCustomEmailTemplatesEnabled = 'featureCustomEmailTemplatesEnabled',
  /** column name */
  FeatureCustomResources = 'featureCustomResources',
  /** column name */
  FeatureDeployEmailTemplates = 'featureDeployEmailTemplates',
  /** column name */
  FeatureFunctionExecutionTimeout = 'featureFunctionExecutionTimeout',
  /** column name */
  FeatureMaxDbSize = 'featureMaxDbSize',
  /** column name */
  FeatureMaxFilesSize = 'featureMaxFilesSize',
  /** column name */
  FeatureMaxNumberOfFunctionsPerDeployment = 'featureMaxNumberOfFunctionsPerDeployment',
  /** column name */
  Id = 'id',
  /** column name */
  Individual = 'individual',
  /** column name */
  IsDefault = 'isDefault',
  /** column name */
  IsFree = 'isFree',
  /** column name */
  IsPublic = 'isPublic',
  /** column name */
  Name = 'name',
  /** column name */
  Price = 'price',
  /** column name */
  Sort = 'sort',
  /** column name */
  StripePriceIdCustomDomains = 'stripePriceIDCustomDomains',
  /** column name */
  StripePriceIdDedicatedCompute = 'stripePriceIDDedicatedCompute',
  /** column name */
  StripePriceIdEgressUsageMb = 'stripePriceIDEgressUsageMB',
  /** column name */
  StripePriceIdFunctionsAmount = 'stripePriceIDFunctionsAmount',
  /** column name */
  StripePriceIdFunctionsUsageSeconds = 'stripePriceIDFunctionsUsageSeconds',
  /** column name */
  StripePriceIdPersistentVolumesGb = 'stripePriceIDPersistentVolumesGB',
  /** column name */
  StripePriceId = 'stripePriceId',
  /** column name */
  UpatedAt = 'upatedAt'
}

export type Plans_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Plans_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Plans_Set_Input>;
  /** filter the rows which have to be updated */
  where: Plans_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Plans_Var_Pop_Fields = {
  __typename?: 'plans_var_pop_fields';
  featureBackupRetentionDays?: Maybe<Scalars['Float']>;
  /** Function execution timeout in seconds */
  featureFunctionExecutionTimeout?: Maybe<Scalars['Float']>;
  featureMaxDbSize?: Maybe<Scalars['Float']>;
  featureMaxFilesSize?: Maybe<Scalars['Float']>;
  /** Max number of functions to deploy per git deployment */
  featureMaxNumberOfFunctionsPerDeployment?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  sort?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Plans_Var_Samp_Fields = {
  __typename?: 'plans_var_samp_fields';
  featureBackupRetentionDays?: Maybe<Scalars['Float']>;
  /** Function execution timeout in seconds */
  featureFunctionExecutionTimeout?: Maybe<Scalars['Float']>;
  featureMaxDbSize?: Maybe<Scalars['Float']>;
  featureMaxFilesSize?: Maybe<Scalars['Float']>;
  /** Max number of functions to deploy per git deployment */
  featureMaxNumberOfFunctionsPerDeployment?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  sort?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Plans_Variance_Fields = {
  __typename?: 'plans_variance_fields';
  featureBackupRetentionDays?: Maybe<Scalars['Float']>;
  /** Function execution timeout in seconds */
  featureFunctionExecutionTimeout?: Maybe<Scalars['Float']>;
  featureMaxDbSize?: Maybe<Scalars['Float']>;
  featureMaxFilesSize?: Maybe<Scalars['Float']>;
  /** Max number of functions to deploy per git deployment */
  featureMaxNumberOfFunctionsPerDeployment?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  sort?: Maybe<Scalars['Float']>;
};

export type Query_Root = {
  __typename?: 'query_root';
  /** fetch data from the table: "announcements" */
  announcements: Array<Announcements>;
  /** fetch aggregated fields from the table: "announcements" */
  announcements_aggregate: Announcements_Aggregate;
  /** fetch data from the table: "announcements" using primary key columns */
  announcements_by_pk?: Maybe<Announcements>;
  /** fetch data from the table: "apps" using primary key columns */
  app?: Maybe<Apps>;
  appSecrets: Array<ConfigEnvironmentVariable>;
  /** fetch data from the table: "app_states" using primary key columns */
  appState?: Maybe<AppStates>;
  /** fetch data from the table: "app_state_history" */
  appStateHistories: Array<AppStateHistory>;
  /** fetch data from the table: "app_state_history" using primary key columns */
  appStateHistory?: Maybe<AppStateHistory>;
  /** fetch aggregated fields from the table: "app_state_history" */
  appStateHistoryAggregate: AppStateHistory_Aggregate;
  /** fetch data from the table: "app_states" */
  appStates: Array<AppStates>;
  /** fetch aggregated fields from the table: "app_states" */
  appStatesAggregate: AppStates_Aggregate;
  /** An array relationship */
  apps: Array<Apps>;
  /** fetch aggregated fields from the table: "apps" */
  appsAggregate: Apps_Aggregate;
  appsSecrets?: Maybe<Array<ConfigAppSecrets>>;
  /** fetch data from the table: "auth.providers" using primary key columns */
  authProvider?: Maybe<AuthProviders>;
  /** fetch data from the table: "auth.provider_requests" using primary key columns */
  authProviderRequest?: Maybe<AuthProviderRequests>;
  /** fetch data from the table: "auth.provider_requests" */
  authProviderRequests: Array<AuthProviderRequests>;
  /** fetch aggregated fields from the table: "auth.provider_requests" */
  authProviderRequestsAggregate: AuthProviderRequests_Aggregate;
  /** fetch data from the table: "auth.providers" */
  authProviders: Array<AuthProviders>;
  /** fetch aggregated fields from the table: "auth.providers" */
  authProvidersAggregate: AuthProviders_Aggregate;
  /** fetch data from the table: "auth.refresh_tokens" using primary key columns */
  authRefreshToken?: Maybe<AuthRefreshTokens>;
  /** fetch data from the table: "auth.refresh_token_types" using primary key columns */
  authRefreshTokenType?: Maybe<AuthRefreshTokenTypes>;
  /** fetch data from the table: "auth.refresh_token_types" */
  authRefreshTokenTypes: Array<AuthRefreshTokenTypes>;
  /** fetch aggregated fields from the table: "auth.refresh_token_types" */
  authRefreshTokenTypesAggregate: AuthRefreshTokenTypes_Aggregate;
  /** fetch data from the table: "auth.refresh_tokens" */
  authRefreshTokens: Array<AuthRefreshTokens>;
  /** fetch aggregated fields from the table: "auth.refresh_tokens" */
  authRefreshTokensAggregate: AuthRefreshTokens_Aggregate;
  /** fetch data from the table: "auth.roles" using primary key columns */
  authRole?: Maybe<AuthRoles>;
  /** fetch data from the table: "auth.roles" */
  authRoles: Array<AuthRoles>;
  /** fetch aggregated fields from the table: "auth.roles" */
  authRolesAggregate: AuthRoles_Aggregate;
  /** fetch data from the table: "auth.user_providers" using primary key columns */
  authUserProvider?: Maybe<AuthUserProviders>;
  /** fetch data from the table: "auth.user_providers" */
  authUserProviders: Array<AuthUserProviders>;
  /** fetch aggregated fields from the table: "auth.user_providers" */
  authUserProvidersAggregate: AuthUserProviders_Aggregate;
  /** fetch data from the table: "auth.user_roles" using primary key columns */
  authUserRole?: Maybe<AuthUserRoles>;
  /** fetch data from the table: "auth.user_roles" */
  authUserRoles: Array<AuthUserRoles>;
  /** fetch aggregated fields from the table: "auth.user_roles" */
  authUserRolesAggregate: AuthUserRoles_Aggregate;
  /** fetch data from the table: "auth.user_security_keys" using primary key columns */
  authUserSecurityKey?: Maybe<AuthUserSecurityKeys>;
  /** fetch data from the table: "auth.user_security_keys" */
  authUserSecurityKeys: Array<AuthUserSecurityKeys>;
  /** fetch aggregated fields from the table: "auth.user_security_keys" */
  authUserSecurityKeysAggregate: AuthUserSecurityKeys_Aggregate;
  /** fetch data from the table: "auth.migrations" */
  auth_migrations: Array<Auth_Migrations>;
  /** fetch aggregated fields from the table: "auth.migrations" */
  auth_migrations_aggregate: Auth_Migrations_Aggregate;
  /** fetch data from the table: "auth.migrations" using primary key columns */
  auth_migrations_by_pk?: Maybe<Auth_Migrations>;
  /** fetch data from the table: "backups" using primary key columns */
  backup?: Maybe<Backups>;
  /** An array relationship */
  backups: Array<Backups>;
  /** fetch aggregated fields from the table: "backups" */
  backupsAggregate: Backups_Aggregate;
  /** fetch data from the table: "billing.dedicated_compute" using primary key columns */
  billingDedicatedCompute?: Maybe<Billing_Dedicated_Compute>;
  /** fetch aggregated fields from the table: "billing.dedicated_compute" */
  billingDedicatedComputeAggregate: Billing_Dedicated_Compute_Aggregate;
  /** fetch data from the table: "billing.dedicated_compute_reports" using primary key columns */
  billingDedicatedComputeReport?: Maybe<Billing_Dedicated_Compute_Reports>;
  /** fetch data from the table: "billing.dedicated_compute_reports" */
  billingDedicatedComputeReports: Array<Billing_Dedicated_Compute_Reports>;
  /** fetch aggregated fields from the table: "billing.dedicated_compute_reports" */
  billingDedicatedComputeReportsAggregate: Billing_Dedicated_Compute_Reports_Aggregate;
  /** fetch data from the table: "billing.dedicated_compute" */
  billingDedicatedComputes: Array<Billing_Dedicated_Compute>;
  billingGetNextInvoice?: Maybe<InvoiceSummary>;
  billingOrganizationCustomePortal: Scalars['String'];
  /** fetch data from the table: "billing.reports" using primary key columns */
  billingReport?: Maybe<Billing_Reports>;
  /** fetch data from the table: "billing.reports" */
  billingReports: Array<Billing_Reports>;
  /** fetch aggregated fields from the table: "billing.reports" */
  billingReportsAggregate: Billing_Reports_Aggregate;
  /** fetch data from the table: "billing.resources" using primary key columns */
  billingResource?: Maybe<Billing_Resources>;
  /** fetch data from the table: "billing.resources" */
  billingResources: Array<Billing_Resources>;
  /** fetch aggregated fields from the table: "billing.resources" */
  billingResourcesAggregate: Billing_Resources_Aggregate;
  /** fetch data from the table: "billing.subscriptions" using primary key columns */
  billingSubscription?: Maybe<Billing_Subscriptions>;
  /** fetch data from the table: "billing.subscriptions" */
  billingSubscriptions: Array<Billing_Subscriptions>;
  /** fetch aggregated fields from the table: "billing.subscriptions" */
  billingSubscriptionsAggregate: Billing_Subscriptions_Aggregate;
  /** fetch data from the table: "billing.report_type" */
  billing_report_type: Array<Billing_Report_Type>;
  /** fetch aggregated fields from the table: "billing.report_type" */
  billing_report_type_aggregate: Billing_Report_Type_Aggregate;
  /** fetch data from the table: "billing.report_type" using primary key columns */
  billing_report_type_by_pk?: Maybe<Billing_Report_Type>;
  /** fetch data from the table: "storage.buckets" using primary key columns */
  bucket?: Maybe<Buckets>;
  /** fetch data from the table: "storage.buckets" */
  buckets: Array<Buckets>;
  /** fetch aggregated fields from the table: "storage.buckets" */
  bucketsAggregate: Buckets_Aggregate;
  /** fetch data from the table: "cli_tokens" using primary key columns */
  cliToken?: Maybe<CliTokens>;
  /** An array relationship */
  cliTokens: Array<CliTokens>;
  /** fetch aggregated fields from the table: "cli_tokens" */
  cliTokensAggregate: CliTokens_Aggregate;
  config?: Maybe<ConfigConfig>;
  configRawJSON: Scalars['String'];
  configs: Array<ConfigAppConfig>;
  /** fetch data from the table: "continents" */
  continents: Array<Continents>;
  /** fetch aggregated fields from the table: "continents" */
  continents_aggregate: Continents_Aggregate;
  /** fetch data from the table: "continents" using primary key columns */
  continents_by_pk?: Maybe<Continents>;
  /** An array relationship */
  countries: Array<Countries>;
  /** An aggregate relationship */
  countries_aggregate: Countries_Aggregate;
  /** fetch data from the table: "countries" using primary key columns */
  countries_by_pk?: Maybe<Countries>;
  /** fetch data from the table: "deployments" using primary key columns */
  deployment?: Maybe<Deployments>;
  /** fetch data from the table: "deployment_logs" using primary key columns */
  deploymentLog?: Maybe<DeploymentLogs>;
  /** An array relationship */
  deploymentLogs: Array<DeploymentLogs>;
  /** fetch aggregated fields from the table: "deployment_logs" */
  deploymentLogsAggregate: DeploymentLogs_Aggregate;
  /** An array relationship */
  deployments: Array<Deployments>;
  /** fetch aggregated fields from the table: "deployments" */
  deploymentsAggregate: Deployments_Aggregate;
  /**
   * Returns the CNAME the hostname resolves to.
   * If the hostname cannot be resolved or isn't a CNAME, returns empty
   */
  dnsLookupCNAME: Scalars['String'];
  /** fetch data from the table: "feature_flags" using primary key columns */
  featureFlag?: Maybe<FeatureFlags>;
  /** An array relationship */
  featureFlags: Array<FeatureFlags>;
  /** fetch aggregated fields from the table: "feature_flags" */
  featureFlagsAggregate: FeatureFlags_Aggregate;
  /** fetch data from the table: "storage.files" using primary key columns */
  file?: Maybe<Files>;
  /** An array relationship */
  files: Array<Files>;
  /** fetch aggregated fields from the table: "storage.files" */
  filesAggregate: Files_Aggregate;
  getBackupPresignedURL: BackupPresignedUrl;
  getCPUSecondsUsage: Metrics;
  getEgressVolume: Metrics;
  getFunctionsDuration: Metrics;
  getFunctionsInvocations: Metrics;
  getLogsVolume: Metrics;
  getPostgresVolumeCapacity: Metrics;
  getPostgresVolumeUsage: Metrics;
  getProjectStatus: ProjectStatusResponse;
  /**
   * Returns list of label values for a given label within a range of time.
   *
   * If `from` and `to` are not provided, they default to 6 hour ago and now, respectively.
   */
  getServiceLabelValues: Array<Scalars['String']>;
  getTotalRequests: Metrics;
  getUsageAll: Array<UsageSummary>;
  /** fetch data from the table: "github_app_installations" using primary key columns */
  githubAppInstallation?: Maybe<GithubAppInstallations>;
  /** fetch data from the table: "github_app_installations" */
  githubAppInstallations: Array<GithubAppInstallations>;
  /** fetch aggregated fields from the table: "github_app_installations" */
  githubAppInstallationsAggregate: GithubAppInstallations_Aggregate;
  /** An array relationship */
  githubRepositories: Array<GithubRepositories>;
  /** fetch aggregated fields from the table: "github_repositories" */
  githubRepositoriesAggregate: GithubRepositories_Aggregate;
  /** fetch data from the table: "github_repositories" using primary key columns */
  githubRepository?: Maybe<GithubRepositories>;
  /**
   * Returns logs for a given application. If `service` is not provided all services are returned.
   * If `from` and `to` are not provided, they default to an hour ago and now, respectively.
   */
  logs: Array<Log>;
  /** fetch data from the table: "organizations" using primary key columns */
  organization?: Maybe<Organizations>;
  /** fetch data from the table: "organizations_free_usage" using primary key columns */
  organizationFreeUsage?: Maybe<Organizations_Free_Usage>;
  /** fetch data from the table: "organizations_free_usage" */
  organizationFreeUsages: Array<Organizations_Free_Usage>;
  /** fetch aggregated fields from the table: "organizations_free_usage" */
  organizationFreeUsagesAggregate: Organizations_Free_Usage_Aggregate;
  /** fetch data from the table: "organization_members" using primary key columns */
  organizationMember?: Maybe<Organization_Members>;
  /** fetch data from the table: "organization_member_invites" using primary key columns */
  organizationMemberInvite?: Maybe<Organization_Member_Invites>;
  /** fetch data from the table: "organization_member_invites" */
  organizationMemberInvites: Array<Organization_Member_Invites>;
  /** fetch aggregated fields from the table: "organization_member_invites" */
  organizationMemberInvitesAggregate: Organization_Member_Invites_Aggregate;
  /** fetch data from the table: "organization_members" */
  organizationMembers: Array<Organization_Members>;
  /** fetch aggregated fields from the table: "organization_members" */
  organizationMembersAggregate: Organization_Members_Aggregate;
  /** fetch data from the table: "organization_new_request" using primary key columns */
  organizationNewRequest?: Maybe<Organization_New_Request>;
  /** fetch data from the table: "organization_new_request" */
  organizationNewRequests: Array<Organization_New_Request>;
  /** fetch aggregated fields from the table: "organization_new_request" */
  organizationNewRequestsAggregate: Organization_New_Request_Aggregate;
  /** fetch data from the table: "organization_members_role" */
  organization_members_role: Array<Organization_Members_Role>;
  /** fetch aggregated fields from the table: "organization_members_role" */
  organization_members_role_aggregate: Organization_Members_Role_Aggregate;
  /** fetch data from the table: "organization_members_role" using primary key columns */
  organization_members_role_by_pk?: Maybe<Organization_Members_Role>;
  /** fetch data from the table: "organization_status" */
  organization_status: Array<Organization_Status>;
  /** fetch aggregated fields from the table: "organization_status" */
  organization_status_aggregate: Organization_Status_Aggregate;
  /** fetch data from the table: "organization_status" using primary key columns */
  organization_status_by_pk?: Maybe<Organization_Status>;
  /** An array relationship */
  organizations: Array<Organizations>;
  /** fetch aggregated fields from the table: "organizations" */
  organizationsAggregate: Organizations_Aggregate;
  /** fetch data from the table: "payment_methods" using primary key columns */
  paymentMethod?: Maybe<PaymentMethods>;
  /** An array relationship */
  paymentMethods: Array<PaymentMethods>;
  /** fetch aggregated fields from the table: "payment_methods" */
  paymentMethodsAggregate: PaymentMethods_Aggregate;
  /** fetch data from the table: "plans" using primary key columns */
  plan?: Maybe<Plans>;
  /** fetch data from the table: "plans" */
  plans: Array<Plans>;
  /** fetch aggregated fields from the table: "plans" */
  plansAggregate: Plans_Aggregate;
  /** fetch data from the table: "region_type" */
  region_type: Array<Region_Type>;
  /** fetch aggregated fields from the table: "region_type" */
  region_type_aggregate: Region_Type_Aggregate;
  /** fetch data from the table: "region_type" using primary key columns */
  region_type_by_pk?: Maybe<Region_Type>;
  /** An array relationship */
  regions: Array<Regions>;
  /** fetch data from the table: "regions_allowed_organization" using primary key columns */
  regionsAllowedOrganization?: Maybe<Regions_Allowed_Organization>;
  /** fetch data from the table: "regions_allowed_organization" */
  regionsAllowedOrganizations: Array<Regions_Allowed_Organization>;
  /** fetch aggregated fields from the table: "regions_allowed_organization" */
  regionsAllowedOrganizationsAggregate: Regions_Allowed_Organization_Aggregate;
  /** An aggregate relationship */
  regions_aggregate: Regions_Aggregate;
  /** fetch data from the table: "regions" using primary key columns */
  regions_by_pk?: Maybe<Regions>;
  /** fetch data from the table: "run_service" using primary key columns */
  runService?: Maybe<Run_Service>;
  runServiceConfig?: Maybe<ConfigRunServiceConfig>;
  runServiceConfigRawJSON: Scalars['String'];
  runServiceConfigs: Array<ConfigRunServiceConfigWithId>;
  runServiceConfigsAll: Array<ConfigRunServiceConfigWithId>;
  /** An array relationship */
  runServices: Array<Run_Service>;
  /** fetch aggregated fields from the table: "run_service" */
  runServicesAggregate: Run_Service_Aggregate;
  /** fetch data from the table: "regions_allowed_workspace" using primary key columns */
  selectRegionsAllowedWorkspace?: Maybe<Regions_Allowed_Workspace>;
  /** fetch data from the table: "regions_allowed_workspace" */
  selectRegionsAllowedWorkspaces: Array<Regions_Allowed_Workspace>;
  /** fetch aggregated fields from the table: "regions_allowed_workspace" */
  selectRegionsAllowedWorkspacesAggregate: Regions_Allowed_Workspace_Aggregate;
  /** fetch data from the table: "software_type" using primary key columns */
  softwareType?: Maybe<Software_Type>;
  /** fetch data from the table: "software_type" */
  softwareTypes: Array<Software_Type>;
  /** fetch aggregated fields from the table: "software_type" */
  softwareTypesAggregate: Software_Type_Aggregate;
  /** fetch data from the table: "software_versions" using primary key columns */
  softwareVersion?: Maybe<Software_Versions>;
  /** fetch data from the table: "software_versions" */
  softwareVersions: Array<Software_Versions>;
  /** fetch aggregated fields from the table: "software_versions" */
  softwareVersionsAggregate: Software_Versions_Aggregate;
  /**
   * Returns lists of apps that have some live traffic in the give time range.
   * From defaults to 24 hours ago and to defaults to now.
   *
   * Requests that returned a 4xx or 5xx status code are not counted as live traffic.
   */
  statsLiveApps: StatsLiveApps;
  systemConfig?: Maybe<ConfigSystemConfig>;
  systemConfigs: Array<ConfigAppSystemConfig>;
  /** Returns system logs for a given application */
  systemLogs: Array<Log>;
  /** fetch data from the table: "auth.users" using primary key columns */
  user?: Maybe<Users>;
  /** fetch data from the table: "auth.users" */
  users: Array<Users>;
  /** fetch aggregated fields from the table: "auth.users" */
  usersAggregate: Users_Aggregate;
  /** fetch data from the table: "storage.virus" using primary key columns */
  virus?: Maybe<Virus>;
  /** fetch data from the table: "storage.virus" */
  viruses: Array<Virus>;
  /** fetch aggregated fields from the table: "storage.virus" */
  virusesAggregate: Virus_Aggregate;
  /** fetch data from the table: "workspaces" using primary key columns */
  workspace?: Maybe<Workspaces>;
  /** fetch data from the table: "workspace_members" using primary key columns */
  workspaceMember?: Maybe<WorkspaceMembers>;
  /** fetch data from the table: "workspace_member_invites" using primary key columns */
  workspaceMemberInvite?: Maybe<WorkspaceMemberInvites>;
  /** An array relationship */
  workspaceMemberInvites: Array<WorkspaceMemberInvites>;
  /** fetch aggregated fields from the table: "workspace_member_invites" */
  workspaceMemberInvitesAggregate: WorkspaceMemberInvites_Aggregate;
  /** An array relationship */
  workspaceMembers: Array<WorkspaceMembers>;
  /** fetch aggregated fields from the table: "workspace_members" */
  workspaceMembersAggregate: WorkspaceMembers_Aggregate;
  /** An array relationship */
  workspaces: Array<Workspaces>;
  /** fetch aggregated fields from the table: "workspaces" */
  workspacesAggregate: Workspaces_Aggregate;
};


export type Query_RootAnnouncementsArgs = {
  distinct_on?: InputMaybe<Array<Announcements_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Announcements_Order_By>>;
  where?: InputMaybe<Announcements_Bool_Exp>;
};


export type Query_RootAnnouncements_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Announcements_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Announcements_Order_By>>;
  where?: InputMaybe<Announcements_Bool_Exp>;
};


export type Query_RootAnnouncements_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootAppArgs = {
  id: Scalars['uuid'];
};


export type Query_RootAppSecretsArgs = {
  appID: Scalars['uuid'];
};


export type Query_RootAppStateArgs = {
  id: Scalars['Int'];
};


export type Query_RootAppStateHistoriesArgs = {
  distinct_on?: InputMaybe<Array<AppStateHistory_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<AppStateHistory_Order_By>>;
  where?: InputMaybe<AppStateHistory_Bool_Exp>;
};


export type Query_RootAppStateHistoryArgs = {
  id: Scalars['uuid'];
};


export type Query_RootAppStateHistoryAggregateArgs = {
  distinct_on?: InputMaybe<Array<AppStateHistory_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<AppStateHistory_Order_By>>;
  where?: InputMaybe<AppStateHistory_Bool_Exp>;
};


export type Query_RootAppStatesArgs = {
  distinct_on?: InputMaybe<Array<AppStates_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<AppStates_Order_By>>;
  where?: InputMaybe<AppStates_Bool_Exp>;
};


export type Query_RootAppStatesAggregateArgs = {
  distinct_on?: InputMaybe<Array<AppStates_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<AppStates_Order_By>>;
  where?: InputMaybe<AppStates_Bool_Exp>;
};


export type Query_RootAppsArgs = {
  distinct_on?: InputMaybe<Array<Apps_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Apps_Order_By>>;
  where?: InputMaybe<Apps_Bool_Exp>;
};


export type Query_RootAppsAggregateArgs = {
  distinct_on?: InputMaybe<Array<Apps_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Apps_Order_By>>;
  where?: InputMaybe<Apps_Bool_Exp>;
};


export type Query_RootAuthProviderArgs = {
  id: Scalars['String'];
};


export type Query_RootAuthProviderRequestArgs = {
  id: Scalars['uuid'];
};


export type Query_RootAuthProviderRequestsArgs = {
  distinct_on?: InputMaybe<Array<AuthProviderRequests_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<AuthProviderRequests_Order_By>>;
  where?: InputMaybe<AuthProviderRequests_Bool_Exp>;
};


export type Query_RootAuthProviderRequestsAggregateArgs = {
  distinct_on?: InputMaybe<Array<AuthProviderRequests_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<AuthProviderRequests_Order_By>>;
  where?: InputMaybe<AuthProviderRequests_Bool_Exp>;
};


export type Query_RootAuthProvidersArgs = {
  distinct_on?: InputMaybe<Array<AuthProviders_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<AuthProviders_Order_By>>;
  where?: InputMaybe<AuthProviders_Bool_Exp>;
};


export type Query_RootAuthProvidersAggregateArgs = {
  distinct_on?: InputMaybe<Array<AuthProviders_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<AuthProviders_Order_By>>;
  where?: InputMaybe<AuthProviders_Bool_Exp>;
};


export type Query_RootAuthRefreshTokenArgs = {
  id: Scalars['uuid'];
};


export type Query_RootAuthRefreshTokenTypeArgs = {
  value: Scalars['String'];
};


export type Query_RootAuthRefreshTokenTypesArgs = {
  distinct_on?: InputMaybe<Array<AuthRefreshTokenTypes_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<AuthRefreshTokenTypes_Order_By>>;
  where?: InputMaybe<AuthRefreshTokenTypes_Bool_Exp>;
};


export type Query_RootAuthRefreshTokenTypesAggregateArgs = {
  distinct_on?: InputMaybe<Array<AuthRefreshTokenTypes_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<AuthRefreshTokenTypes_Order_By>>;
  where?: InputMaybe<AuthRefreshTokenTypes_Bool_Exp>;
};


export type Query_RootAuthRefreshTokensArgs = {
  distinct_on?: InputMaybe<Array<AuthRefreshTokens_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<AuthRefreshTokens_Order_By>>;
  where?: InputMaybe<AuthRefreshTokens_Bool_Exp>;
};


export type Query_RootAuthRefreshTokensAggregateArgs = {
  distinct_on?: InputMaybe<Array<AuthRefreshTokens_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<AuthRefreshTokens_Order_By>>;
  where?: InputMaybe<AuthRefreshTokens_Bool_Exp>;
};


export type Query_RootAuthRoleArgs = {
  role: Scalars['String'];
};


export type Query_RootAuthRolesArgs = {
  distinct_on?: InputMaybe<Array<AuthRoles_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<AuthRoles_Order_By>>;
  where?: InputMaybe<AuthRoles_Bool_Exp>;
};


export type Query_RootAuthRolesAggregateArgs = {
  distinct_on?: InputMaybe<Array<AuthRoles_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<AuthRoles_Order_By>>;
  where?: InputMaybe<AuthRoles_Bool_Exp>;
};


export type Query_RootAuthUserProviderArgs = {
  id: Scalars['uuid'];
};


export type Query_RootAuthUserProvidersArgs = {
  distinct_on?: InputMaybe<Array<AuthUserProviders_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<AuthUserProviders_Order_By>>;
  where?: InputMaybe<AuthUserProviders_Bool_Exp>;
};


export type Query_RootAuthUserProvidersAggregateArgs = {
  distinct_on?: InputMaybe<Array<AuthUserProviders_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<AuthUserProviders_Order_By>>;
  where?: InputMaybe<AuthUserProviders_Bool_Exp>;
};


export type Query_RootAuthUserRoleArgs = {
  id: Scalars['uuid'];
};


export type Query_RootAuthUserRolesArgs = {
  distinct_on?: InputMaybe<Array<AuthUserRoles_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<AuthUserRoles_Order_By>>;
  where?: InputMaybe<AuthUserRoles_Bool_Exp>;
};


export type Query_RootAuthUserRolesAggregateArgs = {
  distinct_on?: InputMaybe<Array<AuthUserRoles_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<AuthUserRoles_Order_By>>;
  where?: InputMaybe<AuthUserRoles_Bool_Exp>;
};


export type Query_RootAuthUserSecurityKeyArgs = {
  id: Scalars['uuid'];
};


export type Query_RootAuthUserSecurityKeysArgs = {
  distinct_on?: InputMaybe<Array<AuthUserSecurityKeys_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<AuthUserSecurityKeys_Order_By>>;
  where?: InputMaybe<AuthUserSecurityKeys_Bool_Exp>;
};


export type Query_RootAuthUserSecurityKeysAggregateArgs = {
  distinct_on?: InputMaybe<Array<AuthUserSecurityKeys_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<AuthUserSecurityKeys_Order_By>>;
  where?: InputMaybe<AuthUserSecurityKeys_Bool_Exp>;
};


export type Query_RootAuth_MigrationsArgs = {
  distinct_on?: InputMaybe<Array<Auth_Migrations_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Auth_Migrations_Order_By>>;
  where?: InputMaybe<Auth_Migrations_Bool_Exp>;
};


export type Query_RootAuth_Migrations_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Auth_Migrations_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Auth_Migrations_Order_By>>;
  where?: InputMaybe<Auth_Migrations_Bool_Exp>;
};


export type Query_RootAuth_Migrations_By_PkArgs = {
  id: Scalars['Int'];
};


export type Query_RootBackupArgs = {
  id: Scalars['uuid'];
};


export type Query_RootBackupsArgs = {
  distinct_on?: InputMaybe<Array<Backups_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Backups_Order_By>>;
  where?: InputMaybe<Backups_Bool_Exp>;
};


export type Query_RootBackupsAggregateArgs = {
  distinct_on?: InputMaybe<Array<Backups_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Backups_Order_By>>;
  where?: InputMaybe<Backups_Bool_Exp>;
};


export type Query_RootBillingDedicatedComputeArgs = {
  id: Scalars['uuid'];
};


export type Query_RootBillingDedicatedComputeAggregateArgs = {
  distinct_on?: InputMaybe<Array<Billing_Dedicated_Compute_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Billing_Dedicated_Compute_Order_By>>;
  where?: InputMaybe<Billing_Dedicated_Compute_Bool_Exp>;
};


export type Query_RootBillingDedicatedComputeReportArgs = {
  id: Scalars['uuid'];
};


export type Query_RootBillingDedicatedComputeReportsArgs = {
  distinct_on?: InputMaybe<Array<Billing_Dedicated_Compute_Reports_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Billing_Dedicated_Compute_Reports_Order_By>>;
  where?: InputMaybe<Billing_Dedicated_Compute_Reports_Bool_Exp>;
};


export type Query_RootBillingDedicatedComputeReportsAggregateArgs = {
  distinct_on?: InputMaybe<Array<Billing_Dedicated_Compute_Reports_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Billing_Dedicated_Compute_Reports_Order_By>>;
  where?: InputMaybe<Billing_Dedicated_Compute_Reports_Bool_Exp>;
};


export type Query_RootBillingDedicatedComputesArgs = {
  distinct_on?: InputMaybe<Array<Billing_Dedicated_Compute_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Billing_Dedicated_Compute_Order_By>>;
  where?: InputMaybe<Billing_Dedicated_Compute_Bool_Exp>;
};


export type Query_RootBillingGetNextInvoiceArgs = {
  appID: Scalars['uuid'];
};


export type Query_RootBillingOrganizationCustomePortalArgs = {
  organizationID: Scalars['uuid'];
};


export type Query_RootBillingReportArgs = {
  id: Scalars['uuid'];
};


export type Query_RootBillingReportsArgs = {
  distinct_on?: InputMaybe<Array<Billing_Reports_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Billing_Reports_Order_By>>;
  where?: InputMaybe<Billing_Reports_Bool_Exp>;
};


export type Query_RootBillingReportsAggregateArgs = {
  distinct_on?: InputMaybe<Array<Billing_Reports_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Billing_Reports_Order_By>>;
  where?: InputMaybe<Billing_Reports_Bool_Exp>;
};


export type Query_RootBillingResourceArgs = {
  id: Scalars['uuid'];
};


export type Query_RootBillingResourcesArgs = {
  distinct_on?: InputMaybe<Array<Billing_Resources_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Billing_Resources_Order_By>>;
  where?: InputMaybe<Billing_Resources_Bool_Exp>;
};


export type Query_RootBillingResourcesAggregateArgs = {
  distinct_on?: InputMaybe<Array<Billing_Resources_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Billing_Resources_Order_By>>;
  where?: InputMaybe<Billing_Resources_Bool_Exp>;
};


export type Query_RootBillingSubscriptionArgs = {
  id: Scalars['uuid'];
};


export type Query_RootBillingSubscriptionsArgs = {
  distinct_on?: InputMaybe<Array<Billing_Subscriptions_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Billing_Subscriptions_Order_By>>;
  where?: InputMaybe<Billing_Subscriptions_Bool_Exp>;
};


export type Query_RootBillingSubscriptionsAggregateArgs = {
  distinct_on?: InputMaybe<Array<Billing_Subscriptions_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Billing_Subscriptions_Order_By>>;
  where?: InputMaybe<Billing_Subscriptions_Bool_Exp>;
};


export type Query_RootBilling_Report_TypeArgs = {
  distinct_on?: InputMaybe<Array<Billing_Report_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Billing_Report_Type_Order_By>>;
  where?: InputMaybe<Billing_Report_Type_Bool_Exp>;
};


export type Query_RootBilling_Report_Type_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Billing_Report_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Billing_Report_Type_Order_By>>;
  where?: InputMaybe<Billing_Report_Type_Bool_Exp>;
};


export type Query_RootBilling_Report_Type_By_PkArgs = {
  value: Scalars['String'];
};


export type Query_RootBucketArgs = {
  id: Scalars['String'];
};


export type Query_RootBucketsArgs = {
  distinct_on?: InputMaybe<Array<Buckets_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Buckets_Order_By>>;
  where?: InputMaybe<Buckets_Bool_Exp>;
};


export type Query_RootBucketsAggregateArgs = {
  distinct_on?: InputMaybe<Array<Buckets_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Buckets_Order_By>>;
  where?: InputMaybe<Buckets_Bool_Exp>;
};


export type Query_RootCliTokenArgs = {
  id: Scalars['uuid'];
};


export type Query_RootCliTokensArgs = {
  distinct_on?: InputMaybe<Array<CliTokens_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<CliTokens_Order_By>>;
  where?: InputMaybe<CliTokens_Bool_Exp>;
};


export type Query_RootCliTokensAggregateArgs = {
  distinct_on?: InputMaybe<Array<CliTokens_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<CliTokens_Order_By>>;
  where?: InputMaybe<CliTokens_Bool_Exp>;
};


export type Query_RootConfigArgs = {
  appID: Scalars['uuid'];
  resolve: Scalars['Boolean'];
};


export type Query_RootConfigRawJsonArgs = {
  appID: Scalars['uuid'];
  resolve: Scalars['Boolean'];
};


export type Query_RootConfigsArgs = {
  resolve: Scalars['Boolean'];
  where?: InputMaybe<ConfigConfigComparisonExp>;
};


export type Query_RootContinentsArgs = {
  distinct_on?: InputMaybe<Array<Continents_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Continents_Order_By>>;
  where?: InputMaybe<Continents_Bool_Exp>;
};


export type Query_RootContinents_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Continents_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Continents_Order_By>>;
  where?: InputMaybe<Continents_Bool_Exp>;
};


export type Query_RootContinents_By_PkArgs = {
  code: Scalars['bpchar'];
};


export type Query_RootCountriesArgs = {
  distinct_on?: InputMaybe<Array<Countries_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Countries_Order_By>>;
  where?: InputMaybe<Countries_Bool_Exp>;
};


export type Query_RootCountries_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Countries_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Countries_Order_By>>;
  where?: InputMaybe<Countries_Bool_Exp>;
};


export type Query_RootCountries_By_PkArgs = {
  code: Scalars['bpchar'];
};


export type Query_RootDeploymentArgs = {
  id: Scalars['uuid'];
};


export type Query_RootDeploymentLogArgs = {
  id: Scalars['uuid'];
};


export type Query_RootDeploymentLogsArgs = {
  distinct_on?: InputMaybe<Array<DeploymentLogs_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<DeploymentLogs_Order_By>>;
  where?: InputMaybe<DeploymentLogs_Bool_Exp>;
};


export type Query_RootDeploymentLogsAggregateArgs = {
  distinct_on?: InputMaybe<Array<DeploymentLogs_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<DeploymentLogs_Order_By>>;
  where?: InputMaybe<DeploymentLogs_Bool_Exp>;
};


export type Query_RootDeploymentsArgs = {
  distinct_on?: InputMaybe<Array<Deployments_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Deployments_Order_By>>;
  where?: InputMaybe<Deployments_Bool_Exp>;
};


export type Query_RootDeploymentsAggregateArgs = {
  distinct_on?: InputMaybe<Array<Deployments_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Deployments_Order_By>>;
  where?: InputMaybe<Deployments_Bool_Exp>;
};


export type Query_RootDnsLookupCnameArgs = {
  hostname: Scalars['String'];
};


export type Query_RootFeatureFlagArgs = {
  id: Scalars['uuid'];
};


export type Query_RootFeatureFlagsArgs = {
  distinct_on?: InputMaybe<Array<FeatureFlags_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<FeatureFlags_Order_By>>;
  where?: InputMaybe<FeatureFlags_Bool_Exp>;
};


export type Query_RootFeatureFlagsAggregateArgs = {
  distinct_on?: InputMaybe<Array<FeatureFlags_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<FeatureFlags_Order_By>>;
  where?: InputMaybe<FeatureFlags_Bool_Exp>;
};


export type Query_RootFileArgs = {
  id: Scalars['uuid'];
};


export type Query_RootFilesArgs = {
  distinct_on?: InputMaybe<Array<Files_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Files_Order_By>>;
  where?: InputMaybe<Files_Bool_Exp>;
};


export type Query_RootFilesAggregateArgs = {
  distinct_on?: InputMaybe<Array<Files_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Files_Order_By>>;
  where?: InputMaybe<Files_Bool_Exp>;
};


export type Query_RootGetBackupPresignedUrlArgs = {
  appID: Scalars['String'];
  backupID: Scalars['String'];
  expireInMinutes?: InputMaybe<Scalars['Int']>;
};


export type Query_RootGetCpuSecondsUsageArgs = {
  appID: Scalars['String'];
  from?: InputMaybe<Scalars['Timestamp']>;
  to?: InputMaybe<Scalars['Timestamp']>;
};


export type Query_RootGetEgressVolumeArgs = {
  appID: Scalars['String'];
  from?: InputMaybe<Scalars['Timestamp']>;
  subdomain: Scalars['String'];
  to?: InputMaybe<Scalars['Timestamp']>;
};


export type Query_RootGetFunctionsDurationArgs = {
  appID: Scalars['String'];
  from?: InputMaybe<Scalars['Timestamp']>;
  to?: InputMaybe<Scalars['Timestamp']>;
};


export type Query_RootGetFunctionsInvocationsArgs = {
  appID: Scalars['String'];
  from?: InputMaybe<Scalars['Timestamp']>;
  to?: InputMaybe<Scalars['Timestamp']>;
};


export type Query_RootGetLogsVolumeArgs = {
  appID: Scalars['String'];
  from?: InputMaybe<Scalars['Timestamp']>;
  to?: InputMaybe<Scalars['Timestamp']>;
};


export type Query_RootGetPostgresVolumeCapacityArgs = {
  appID: Scalars['String'];
  t?: InputMaybe<Scalars['Timestamp']>;
};


export type Query_RootGetPostgresVolumeUsageArgs = {
  appID: Scalars['String'];
  t?: InputMaybe<Scalars['Timestamp']>;
};


export type Query_RootGetProjectStatusArgs = {
  appID: Scalars['String'];
};


export type Query_RootGetServiceLabelValuesArgs = {
  appID: Scalars['String'];
};


export type Query_RootGetTotalRequestsArgs = {
  appID: Scalars['String'];
  from?: InputMaybe<Scalars['Timestamp']>;
  to?: InputMaybe<Scalars['Timestamp']>;
};


export type Query_RootGetUsageAllArgs = {
  from: Scalars['Timestamp'];
  to: Scalars['Timestamp'];
};


export type Query_RootGithubAppInstallationArgs = {
  id: Scalars['uuid'];
};


export type Query_RootGithubAppInstallationsArgs = {
  distinct_on?: InputMaybe<Array<GithubAppInstallations_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<GithubAppInstallations_Order_By>>;
  where?: InputMaybe<GithubAppInstallations_Bool_Exp>;
};


export type Query_RootGithubAppInstallationsAggregateArgs = {
  distinct_on?: InputMaybe<Array<GithubAppInstallations_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<GithubAppInstallations_Order_By>>;
  where?: InputMaybe<GithubAppInstallations_Bool_Exp>;
};


export type Query_RootGithubRepositoriesArgs = {
  distinct_on?: InputMaybe<Array<GithubRepositories_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<GithubRepositories_Order_By>>;
  where?: InputMaybe<GithubRepositories_Bool_Exp>;
};


export type Query_RootGithubRepositoriesAggregateArgs = {
  distinct_on?: InputMaybe<Array<GithubRepositories_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<GithubRepositories_Order_By>>;
  where?: InputMaybe<GithubRepositories_Bool_Exp>;
};


export type Query_RootGithubRepositoryArgs = {
  id: Scalars['uuid'];
};


export type Query_RootLogsArgs = {
  appID: Scalars['String'];
  from?: InputMaybe<Scalars['Timestamp']>;
  regexFilter?: InputMaybe<Scalars['String']>;
  service?: InputMaybe<Scalars['String']>;
  to?: InputMaybe<Scalars['Timestamp']>;
};


export type Query_RootOrganizationArgs = {
  id: Scalars['uuid'];
};


export type Query_RootOrganizationFreeUsageArgs = {
  id: Scalars['uuid'];
};


export type Query_RootOrganizationFreeUsagesArgs = {
  distinct_on?: InputMaybe<Array<Organizations_Free_Usage_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Organizations_Free_Usage_Order_By>>;
  where?: InputMaybe<Organizations_Free_Usage_Bool_Exp>;
};


export type Query_RootOrganizationFreeUsagesAggregateArgs = {
  distinct_on?: InputMaybe<Array<Organizations_Free_Usage_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Organizations_Free_Usage_Order_By>>;
  where?: InputMaybe<Organizations_Free_Usage_Bool_Exp>;
};


export type Query_RootOrganizationMemberArgs = {
  id: Scalars['uuid'];
};


export type Query_RootOrganizationMemberInviteArgs = {
  id: Scalars['uuid'];
};


export type Query_RootOrganizationMemberInvitesArgs = {
  distinct_on?: InputMaybe<Array<Organization_Member_Invites_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Organization_Member_Invites_Order_By>>;
  where?: InputMaybe<Organization_Member_Invites_Bool_Exp>;
};


export type Query_RootOrganizationMemberInvitesAggregateArgs = {
  distinct_on?: InputMaybe<Array<Organization_Member_Invites_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Organization_Member_Invites_Order_By>>;
  where?: InputMaybe<Organization_Member_Invites_Bool_Exp>;
};


export type Query_RootOrganizationMembersArgs = {
  distinct_on?: InputMaybe<Array<Organization_Members_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Organization_Members_Order_By>>;
  where?: InputMaybe<Organization_Members_Bool_Exp>;
};


export type Query_RootOrganizationMembersAggregateArgs = {
  distinct_on?: InputMaybe<Array<Organization_Members_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Organization_Members_Order_By>>;
  where?: InputMaybe<Organization_Members_Bool_Exp>;
};


export type Query_RootOrganizationNewRequestArgs = {
  id: Scalars['uuid'];
};


export type Query_RootOrganizationNewRequestsArgs = {
  distinct_on?: InputMaybe<Array<Organization_New_Request_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Organization_New_Request_Order_By>>;
  where?: InputMaybe<Organization_New_Request_Bool_Exp>;
};


export type Query_RootOrganizationNewRequestsAggregateArgs = {
  distinct_on?: InputMaybe<Array<Organization_New_Request_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Organization_New_Request_Order_By>>;
  where?: InputMaybe<Organization_New_Request_Bool_Exp>;
};


export type Query_RootOrganization_Members_RoleArgs = {
  distinct_on?: InputMaybe<Array<Organization_Members_Role_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Organization_Members_Role_Order_By>>;
  where?: InputMaybe<Organization_Members_Role_Bool_Exp>;
};


export type Query_RootOrganization_Members_Role_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Organization_Members_Role_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Organization_Members_Role_Order_By>>;
  where?: InputMaybe<Organization_Members_Role_Bool_Exp>;
};


export type Query_RootOrganization_Members_Role_By_PkArgs = {
  value: Scalars['String'];
};


export type Query_RootOrganization_StatusArgs = {
  distinct_on?: InputMaybe<Array<Organization_Status_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Organization_Status_Order_By>>;
  where?: InputMaybe<Organization_Status_Bool_Exp>;
};


export type Query_RootOrganization_Status_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Organization_Status_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Organization_Status_Order_By>>;
  where?: InputMaybe<Organization_Status_Bool_Exp>;
};


export type Query_RootOrganization_Status_By_PkArgs = {
  value: Scalars['String'];
};


export type Query_RootOrganizationsArgs = {
  distinct_on?: InputMaybe<Array<Organizations_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Organizations_Order_By>>;
  where?: InputMaybe<Organizations_Bool_Exp>;
};


export type Query_RootOrganizationsAggregateArgs = {
  distinct_on?: InputMaybe<Array<Organizations_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Organizations_Order_By>>;
  where?: InputMaybe<Organizations_Bool_Exp>;
};


export type Query_RootPaymentMethodArgs = {
  id: Scalars['uuid'];
};


export type Query_RootPaymentMethodsArgs = {
  distinct_on?: InputMaybe<Array<PaymentMethods_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<PaymentMethods_Order_By>>;
  where?: InputMaybe<PaymentMethods_Bool_Exp>;
};


export type Query_RootPaymentMethodsAggregateArgs = {
  distinct_on?: InputMaybe<Array<PaymentMethods_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<PaymentMethods_Order_By>>;
  where?: InputMaybe<PaymentMethods_Bool_Exp>;
};


export type Query_RootPlanArgs = {
  id: Scalars['uuid'];
};


export type Query_RootPlansArgs = {
  distinct_on?: InputMaybe<Array<Plans_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Plans_Order_By>>;
  where?: InputMaybe<Plans_Bool_Exp>;
};


export type Query_RootPlansAggregateArgs = {
  distinct_on?: InputMaybe<Array<Plans_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Plans_Order_By>>;
  where?: InputMaybe<Plans_Bool_Exp>;
};


export type Query_RootRegion_TypeArgs = {
  distinct_on?: InputMaybe<Array<Region_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Region_Type_Order_By>>;
  where?: InputMaybe<Region_Type_Bool_Exp>;
};


export type Query_RootRegion_Type_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Region_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Region_Type_Order_By>>;
  where?: InputMaybe<Region_Type_Bool_Exp>;
};


export type Query_RootRegion_Type_By_PkArgs = {
  type: Scalars['String'];
};


export type Query_RootRegionsArgs = {
  distinct_on?: InputMaybe<Array<Regions_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Regions_Order_By>>;
  where?: InputMaybe<Regions_Bool_Exp>;
};


export type Query_RootRegionsAllowedOrganizationArgs = {
  id: Scalars['uuid'];
};


export type Query_RootRegionsAllowedOrganizationsArgs = {
  distinct_on?: InputMaybe<Array<Regions_Allowed_Organization_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Regions_Allowed_Organization_Order_By>>;
  where?: InputMaybe<Regions_Allowed_Organization_Bool_Exp>;
};


export type Query_RootRegionsAllowedOrganizationsAggregateArgs = {
  distinct_on?: InputMaybe<Array<Regions_Allowed_Organization_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Regions_Allowed_Organization_Order_By>>;
  where?: InputMaybe<Regions_Allowed_Organization_Bool_Exp>;
};


export type Query_RootRegions_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Regions_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Regions_Order_By>>;
  where?: InputMaybe<Regions_Bool_Exp>;
};


export type Query_RootRegions_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootRunServiceArgs = {
  id: Scalars['uuid'];
};


export type Query_RootRunServiceConfigArgs = {
  appID: Scalars['uuid'];
  resolve: Scalars['Boolean'];
  serviceID: Scalars['uuid'];
};


export type Query_RootRunServiceConfigRawJsonArgs = {
  appID: Scalars['uuid'];
  resolve: Scalars['Boolean'];
  serviceID: Scalars['uuid'];
};


export type Query_RootRunServiceConfigsArgs = {
  appID: Scalars['uuid'];
  resolve: Scalars['Boolean'];
};


export type Query_RootRunServiceConfigsAllArgs = {
  resolve: Scalars['Boolean'];
  where?: InputMaybe<ConfigRunServiceConfigComparisonExp>;
};


export type Query_RootRunServicesArgs = {
  distinct_on?: InputMaybe<Array<Run_Service_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Run_Service_Order_By>>;
  where?: InputMaybe<Run_Service_Bool_Exp>;
};


export type Query_RootRunServicesAggregateArgs = {
  distinct_on?: InputMaybe<Array<Run_Service_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Run_Service_Order_By>>;
  where?: InputMaybe<Run_Service_Bool_Exp>;
};


export type Query_RootSelectRegionsAllowedWorkspaceArgs = {
  id: Scalars['uuid'];
};


export type Query_RootSelectRegionsAllowedWorkspacesArgs = {
  distinct_on?: InputMaybe<Array<Regions_Allowed_Workspace_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Regions_Allowed_Workspace_Order_By>>;
  where?: InputMaybe<Regions_Allowed_Workspace_Bool_Exp>;
};


export type Query_RootSelectRegionsAllowedWorkspacesAggregateArgs = {
  distinct_on?: InputMaybe<Array<Regions_Allowed_Workspace_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Regions_Allowed_Workspace_Order_By>>;
  where?: InputMaybe<Regions_Allowed_Workspace_Bool_Exp>;
};


export type Query_RootSoftwareTypeArgs = {
  type: Scalars['String'];
};


export type Query_RootSoftwareTypesArgs = {
  distinct_on?: InputMaybe<Array<Software_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Software_Type_Order_By>>;
  where?: InputMaybe<Software_Type_Bool_Exp>;
};


export type Query_RootSoftwareTypesAggregateArgs = {
  distinct_on?: InputMaybe<Array<Software_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Software_Type_Order_By>>;
  where?: InputMaybe<Software_Type_Bool_Exp>;
};


export type Query_RootSoftwareVersionArgs = {
  id: Scalars['uuid'];
};


export type Query_RootSoftwareVersionsArgs = {
  distinct_on?: InputMaybe<Array<Software_Versions_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Software_Versions_Order_By>>;
  where?: InputMaybe<Software_Versions_Bool_Exp>;
};


export type Query_RootSoftwareVersionsAggregateArgs = {
  distinct_on?: InputMaybe<Array<Software_Versions_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Software_Versions_Order_By>>;
  where?: InputMaybe<Software_Versions_Bool_Exp>;
};


export type Query_RootStatsLiveAppsArgs = {
  from?: InputMaybe<Scalars['Timestamp']>;
  to?: InputMaybe<Scalars['Timestamp']>;
};


export type Query_RootSystemConfigArgs = {
  appID: Scalars['uuid'];
};


export type Query_RootSystemConfigsArgs = {
  where?: InputMaybe<ConfigSystemConfigComparisonExp>;
};


export type Query_RootSystemLogsArgs = {
  action: Scalars['String'];
  appID: Scalars['String'];
  from?: InputMaybe<Scalars['Timestamp']>;
  to?: InputMaybe<Scalars['Timestamp']>;
};


export type Query_RootUserArgs = {
  id: Scalars['uuid'];
};


export type Query_RootUsersArgs = {
  distinct_on?: InputMaybe<Array<Users_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Users_Order_By>>;
  where?: InputMaybe<Users_Bool_Exp>;
};


export type Query_RootUsersAggregateArgs = {
  distinct_on?: InputMaybe<Array<Users_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Users_Order_By>>;
  where?: InputMaybe<Users_Bool_Exp>;
};


export type Query_RootVirusArgs = {
  id: Scalars['uuid'];
};


export type Query_RootVirusesArgs = {
  distinct_on?: InputMaybe<Array<Virus_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Virus_Order_By>>;
  where?: InputMaybe<Virus_Bool_Exp>;
};


export type Query_RootVirusesAggregateArgs = {
  distinct_on?: InputMaybe<Array<Virus_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Virus_Order_By>>;
  where?: InputMaybe<Virus_Bool_Exp>;
};


export type Query_RootWorkspaceArgs = {
  id: Scalars['uuid'];
};


export type Query_RootWorkspaceMemberArgs = {
  id: Scalars['uuid'];
};


export type Query_RootWorkspaceMemberInviteArgs = {
  id: Scalars['uuid'];
};


export type Query_RootWorkspaceMemberInvitesArgs = {
  distinct_on?: InputMaybe<Array<WorkspaceMemberInvites_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<WorkspaceMemberInvites_Order_By>>;
  where?: InputMaybe<WorkspaceMemberInvites_Bool_Exp>;
};


export type Query_RootWorkspaceMemberInvitesAggregateArgs = {
  distinct_on?: InputMaybe<Array<WorkspaceMemberInvites_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<WorkspaceMemberInvites_Order_By>>;
  where?: InputMaybe<WorkspaceMemberInvites_Bool_Exp>;
};


export type Query_RootWorkspaceMembersArgs = {
  distinct_on?: InputMaybe<Array<WorkspaceMembers_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<WorkspaceMembers_Order_By>>;
  where?: InputMaybe<WorkspaceMembers_Bool_Exp>;
};


export type Query_RootWorkspaceMembersAggregateArgs = {
  distinct_on?: InputMaybe<Array<WorkspaceMembers_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<WorkspaceMembers_Order_By>>;
  where?: InputMaybe<WorkspaceMembers_Bool_Exp>;
};


export type Query_RootWorkspacesArgs = {
  distinct_on?: InputMaybe<Array<Workspaces_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Workspaces_Order_By>>;
  where?: InputMaybe<Workspaces_Bool_Exp>;
};


export type Query_RootWorkspacesAggregateArgs = {
  distinct_on?: InputMaybe<Array<Workspaces_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Workspaces_Order_By>>;
  where?: InputMaybe<Workspaces_Bool_Exp>;
};

/** columns and relationships of "region_type" */
export type Region_Type = {
  __typename?: 'region_type';
  comment: Scalars['String'];
  /** An array relationship */
  regions: Array<Regions>;
  /** An aggregate relationship */
  regions_aggregate: Regions_Aggregate;
  type: Scalars['String'];
};


/** columns and relationships of "region_type" */
export type Region_TypeRegionsArgs = {
  distinct_on?: InputMaybe<Array<Regions_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Regions_Order_By>>;
  where?: InputMaybe<Regions_Bool_Exp>;
};


/** columns and relationships of "region_type" */
export type Region_TypeRegions_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Regions_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Regions_Order_By>>;
  where?: InputMaybe<Regions_Bool_Exp>;
};

/** aggregated selection of "region_type" */
export type Region_Type_Aggregate = {
  __typename?: 'region_type_aggregate';
  aggregate?: Maybe<Region_Type_Aggregate_Fields>;
  nodes: Array<Region_Type>;
};

/** aggregate fields of "region_type" */
export type Region_Type_Aggregate_Fields = {
  __typename?: 'region_type_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Region_Type_Max_Fields>;
  min?: Maybe<Region_Type_Min_Fields>;
};


/** aggregate fields of "region_type" */
export type Region_Type_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Region_Type_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "region_type". All fields are combined with a logical 'AND'. */
export type Region_Type_Bool_Exp = {
  _and?: InputMaybe<Array<Region_Type_Bool_Exp>>;
  _not?: InputMaybe<Region_Type_Bool_Exp>;
  _or?: InputMaybe<Array<Region_Type_Bool_Exp>>;
  comment?: InputMaybe<String_Comparison_Exp>;
  regions?: InputMaybe<Regions_Bool_Exp>;
  regions_aggregate?: InputMaybe<Regions_Aggregate_Bool_Exp>;
  type?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "region_type" */
export enum Region_Type_Constraint {
  /** unique or primary key constraint on columns "type" */
  RegionTypePkey = 'region_type_pkey'
}

export enum Region_Type_Enum {
  /** Private region available to selected workspaces */
  Private = 'private',
  /** Public region available to all Nhost projects */
  Public = 'public'
}

/** Boolean expression to compare columns of type "region_type_enum". All fields are combined with logical 'AND'. */
export type Region_Type_Enum_Comparison_Exp = {
  _eq?: InputMaybe<Region_Type_Enum>;
  _in?: InputMaybe<Array<Region_Type_Enum>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<Region_Type_Enum>;
  _nin?: InputMaybe<Array<Region_Type_Enum>>;
};

/** input type for inserting data into table "region_type" */
export type Region_Type_Insert_Input = {
  comment?: InputMaybe<Scalars['String']>;
  regions?: InputMaybe<Regions_Arr_Rel_Insert_Input>;
  type?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Region_Type_Max_Fields = {
  __typename?: 'region_type_max_fields';
  comment?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Region_Type_Min_Fields = {
  __typename?: 'region_type_min_fields';
  comment?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "region_type" */
export type Region_Type_Mutation_Response = {
  __typename?: 'region_type_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Region_Type>;
};

/** input type for inserting object relation for remote table "region_type" */
export type Region_Type_Obj_Rel_Insert_Input = {
  data: Region_Type_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Region_Type_On_Conflict>;
};

/** on_conflict condition type for table "region_type" */
export type Region_Type_On_Conflict = {
  constraint: Region_Type_Constraint;
  update_columns?: Array<Region_Type_Update_Column>;
  where?: InputMaybe<Region_Type_Bool_Exp>;
};

/** Ordering options when selecting data from "region_type". */
export type Region_Type_Order_By = {
  comment?: InputMaybe<Order_By>;
  regions_aggregate?: InputMaybe<Regions_Aggregate_Order_By>;
  type?: InputMaybe<Order_By>;
};

/** primary key columns input for table: region_type */
export type Region_Type_Pk_Columns_Input = {
  type: Scalars['String'];
};

/** select columns of table "region_type" */
export enum Region_Type_Select_Column {
  /** column name */
  Comment = 'comment',
  /** column name */
  Type = 'type'
}

/** input type for updating data in table "region_type" */
export type Region_Type_Set_Input = {
  comment?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "region_type" */
export type Region_Type_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Region_Type_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Region_Type_Stream_Cursor_Value_Input = {
  comment?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<Scalars['String']>;
};

/** update columns of table "region_type" */
export enum Region_Type_Update_Column {
  /** column name */
  Comment = 'comment',
  /** column name */
  Type = 'type'
}

export type Region_Type_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Region_Type_Set_Input>;
  /** filter the rows which have to be updated */
  where: Region_Type_Bool_Exp;
};

/** columns and relationships of "regions" */
export type Regions = {
  __typename?: 'regions';
  active: Scalars['Boolean'];
  /** An array relationship */
  allowedOrganizations: Array<Regions_Allowed_Organization>;
  /** An aggregate relationship */
  allowedOrganizations_aggregate: Regions_Allowed_Organization_Aggregate;
  /** An object relationship */
  allowedWorkspaces?: Maybe<Regions_Allowed_Workspace>;
  /** An array relationship */
  apps: Array<Apps>;
  /** An aggregate relationship */
  apps_aggregate: Apps_Aggregate;
  awsName: Scalars['String'];
  city: Scalars['String'];
  /** An object relationship */
  country: Countries;
  countryCode: Scalars['String'];
  createdAt: Scalars['timestamptz'];
  description?: Maybe<Scalars['String']>;
  domain: Scalars['String'];
  id: Scalars['uuid'];
  isGdprCompliant: Scalars['Boolean'];
  name: Scalars['String'];
  /** An object relationship */
  region_type: Region_Type;
  /** An array relationship */
  regions_allowed_workspaces: Array<Regions_Allowed_Workspace>;
  /** An aggregate relationship */
  regions_allowed_workspaces_aggregate: Regions_Allowed_Workspace_Aggregate;
  type: Region_Type_Enum;
  updatedAt: Scalars['timestamptz'];
};


/** columns and relationships of "regions" */
export type RegionsAllowedOrganizationsArgs = {
  distinct_on?: InputMaybe<Array<Regions_Allowed_Organization_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Regions_Allowed_Organization_Order_By>>;
  where?: InputMaybe<Regions_Allowed_Organization_Bool_Exp>;
};


/** columns and relationships of "regions" */
export type RegionsAllowedOrganizations_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Regions_Allowed_Organization_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Regions_Allowed_Organization_Order_By>>;
  where?: InputMaybe<Regions_Allowed_Organization_Bool_Exp>;
};


/** columns and relationships of "regions" */
export type RegionsAppsArgs = {
  distinct_on?: InputMaybe<Array<Apps_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Apps_Order_By>>;
  where?: InputMaybe<Apps_Bool_Exp>;
};


/** columns and relationships of "regions" */
export type RegionsApps_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Apps_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Apps_Order_By>>;
  where?: InputMaybe<Apps_Bool_Exp>;
};


/** columns and relationships of "regions" */
export type RegionsRegions_Allowed_WorkspacesArgs = {
  distinct_on?: InputMaybe<Array<Regions_Allowed_Workspace_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Regions_Allowed_Workspace_Order_By>>;
  where?: InputMaybe<Regions_Allowed_Workspace_Bool_Exp>;
};


/** columns and relationships of "regions" */
export type RegionsRegions_Allowed_Workspaces_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Regions_Allowed_Workspace_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Regions_Allowed_Workspace_Order_By>>;
  where?: InputMaybe<Regions_Allowed_Workspace_Bool_Exp>;
};

/** aggregated selection of "regions" */
export type Regions_Aggregate = {
  __typename?: 'regions_aggregate';
  aggregate?: Maybe<Regions_Aggregate_Fields>;
  nodes: Array<Regions>;
};

export type Regions_Aggregate_Bool_Exp = {
  bool_and?: InputMaybe<Regions_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: InputMaybe<Regions_Aggregate_Bool_Exp_Bool_Or>;
  count?: InputMaybe<Regions_Aggregate_Bool_Exp_Count>;
};

export type Regions_Aggregate_Bool_Exp_Bool_And = {
  arguments: Regions_Select_Column_Regions_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<Regions_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Regions_Aggregate_Bool_Exp_Bool_Or = {
  arguments: Regions_Select_Column_Regions_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<Regions_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Regions_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Regions_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<Regions_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "regions" */
export type Regions_Aggregate_Fields = {
  __typename?: 'regions_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Regions_Max_Fields>;
  min?: Maybe<Regions_Min_Fields>;
};


/** aggregate fields of "regions" */
export type Regions_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Regions_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "regions" */
export type Regions_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Regions_Max_Order_By>;
  min?: InputMaybe<Regions_Min_Order_By>;
};

/** columns and relationships of "regions_allowed_organization" */
export type Regions_Allowed_Organization = {
  __typename?: 'regions_allowed_organization';
  createdAt: Scalars['timestamptz'];
  description: Scalars['String'];
  id: Scalars['uuid'];
  /** An object relationship */
  organization: Organizations;
  organizationID: Scalars['uuid'];
  /** An object relationship */
  region: Regions;
  regionID: Scalars['uuid'];
  updatedAt: Scalars['timestamptz'];
};

/** aggregated selection of "regions_allowed_organization" */
export type Regions_Allowed_Organization_Aggregate = {
  __typename?: 'regions_allowed_organization_aggregate';
  aggregate?: Maybe<Regions_Allowed_Organization_Aggregate_Fields>;
  nodes: Array<Regions_Allowed_Organization>;
};

export type Regions_Allowed_Organization_Aggregate_Bool_Exp = {
  count?: InputMaybe<Regions_Allowed_Organization_Aggregate_Bool_Exp_Count>;
};

export type Regions_Allowed_Organization_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Regions_Allowed_Organization_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<Regions_Allowed_Organization_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "regions_allowed_organization" */
export type Regions_Allowed_Organization_Aggregate_Fields = {
  __typename?: 'regions_allowed_organization_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Regions_Allowed_Organization_Max_Fields>;
  min?: Maybe<Regions_Allowed_Organization_Min_Fields>;
};


/** aggregate fields of "regions_allowed_organization" */
export type Regions_Allowed_Organization_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Regions_Allowed_Organization_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "regions_allowed_organization" */
export type Regions_Allowed_Organization_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Regions_Allowed_Organization_Max_Order_By>;
  min?: InputMaybe<Regions_Allowed_Organization_Min_Order_By>;
};

/** input type for inserting array relation for remote table "regions_allowed_organization" */
export type Regions_Allowed_Organization_Arr_Rel_Insert_Input = {
  data: Array<Regions_Allowed_Organization_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Regions_Allowed_Organization_On_Conflict>;
};

/** Boolean expression to filter rows from the table "regions_allowed_organization". All fields are combined with a logical 'AND'. */
export type Regions_Allowed_Organization_Bool_Exp = {
  _and?: InputMaybe<Array<Regions_Allowed_Organization_Bool_Exp>>;
  _not?: InputMaybe<Regions_Allowed_Organization_Bool_Exp>;
  _or?: InputMaybe<Array<Regions_Allowed_Organization_Bool_Exp>>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  organization?: InputMaybe<Organizations_Bool_Exp>;
  organizationID?: InputMaybe<Uuid_Comparison_Exp>;
  region?: InputMaybe<Regions_Bool_Exp>;
  regionID?: InputMaybe<Uuid_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "regions_allowed_organization" */
export enum Regions_Allowed_Organization_Constraint {
  /** unique or primary key constraint on columns "id" */
  RegionsAllowedOrganizationPkey = 'regions_allowed_organization_pkey',
  /** unique or primary key constraint on columns "region_id", "organization_id" */
  RegionsAllowedOrganizationRegionIdOrganizationIdKey = 'regions_allowed_organization_region_id_organization_id_key'
}

/** input type for inserting data into table "regions_allowed_organization" */
export type Regions_Allowed_Organization_Insert_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  description?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  organization?: InputMaybe<Organizations_Obj_Rel_Insert_Input>;
  organizationID?: InputMaybe<Scalars['uuid']>;
  region?: InputMaybe<Regions_Obj_Rel_Insert_Input>;
  regionID?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Regions_Allowed_Organization_Max_Fields = {
  __typename?: 'regions_allowed_organization_max_fields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  description?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  organizationID?: Maybe<Scalars['uuid']>;
  regionID?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "regions_allowed_organization" */
export type Regions_Allowed_Organization_Max_Order_By = {
  createdAt?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  organizationID?: InputMaybe<Order_By>;
  regionID?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Regions_Allowed_Organization_Min_Fields = {
  __typename?: 'regions_allowed_organization_min_fields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  description?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  organizationID?: Maybe<Scalars['uuid']>;
  regionID?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "regions_allowed_organization" */
export type Regions_Allowed_Organization_Min_Order_By = {
  createdAt?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  organizationID?: InputMaybe<Order_By>;
  regionID?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "regions_allowed_organization" */
export type Regions_Allowed_Organization_Mutation_Response = {
  __typename?: 'regions_allowed_organization_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Regions_Allowed_Organization>;
};

/** on_conflict condition type for table "regions_allowed_organization" */
export type Regions_Allowed_Organization_On_Conflict = {
  constraint: Regions_Allowed_Organization_Constraint;
  update_columns?: Array<Regions_Allowed_Organization_Update_Column>;
  where?: InputMaybe<Regions_Allowed_Organization_Bool_Exp>;
};

/** Ordering options when selecting data from "regions_allowed_organization". */
export type Regions_Allowed_Organization_Order_By = {
  createdAt?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  organization?: InputMaybe<Organizations_Order_By>;
  organizationID?: InputMaybe<Order_By>;
  region?: InputMaybe<Regions_Order_By>;
  regionID?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
};

/** primary key columns input for table: regions_allowed_organization */
export type Regions_Allowed_Organization_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "regions_allowed_organization" */
export enum Regions_Allowed_Organization_Select_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  OrganizationId = 'organizationID',
  /** column name */
  RegionId = 'regionID',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "regions_allowed_organization" */
export type Regions_Allowed_Organization_Set_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  description?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  organizationID?: InputMaybe<Scalars['uuid']>;
  regionID?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** Streaming cursor of the table "regions_allowed_organization" */
export type Regions_Allowed_Organization_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Regions_Allowed_Organization_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Regions_Allowed_Organization_Stream_Cursor_Value_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  description?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  organizationID?: InputMaybe<Scalars['uuid']>;
  regionID?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** update columns of table "regions_allowed_organization" */
export enum Regions_Allowed_Organization_Update_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  OrganizationId = 'organizationID',
  /** column name */
  RegionId = 'regionID',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type Regions_Allowed_Organization_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Regions_Allowed_Organization_Set_Input>;
  /** filter the rows which have to be updated */
  where: Regions_Allowed_Organization_Bool_Exp;
};

/** columns and relationships of "regions_allowed_workspace" */
export type Regions_Allowed_Workspace = {
  __typename?: 'regions_allowed_workspace';
  created_at: Scalars['timestamptz'];
  description: Scalars['String'];
  id: Scalars['uuid'];
  /** An object relationship */
  region?: Maybe<Regions>;
  region_id: Scalars['uuid'];
  updated_at: Scalars['timestamptz'];
  /** An object relationship */
  workspace?: Maybe<Workspaces>;
  workspace_id: Scalars['uuid'];
};

/** aggregated selection of "regions_allowed_workspace" */
export type Regions_Allowed_Workspace_Aggregate = {
  __typename?: 'regions_allowed_workspace_aggregate';
  aggregate?: Maybe<Regions_Allowed_Workspace_Aggregate_Fields>;
  nodes: Array<Regions_Allowed_Workspace>;
};

export type Regions_Allowed_Workspace_Aggregate_Bool_Exp = {
  count?: InputMaybe<Regions_Allowed_Workspace_Aggregate_Bool_Exp_Count>;
};

export type Regions_Allowed_Workspace_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Regions_Allowed_Workspace_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<Regions_Allowed_Workspace_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "regions_allowed_workspace" */
export type Regions_Allowed_Workspace_Aggregate_Fields = {
  __typename?: 'regions_allowed_workspace_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Regions_Allowed_Workspace_Max_Fields>;
  min?: Maybe<Regions_Allowed_Workspace_Min_Fields>;
};


/** aggregate fields of "regions_allowed_workspace" */
export type Regions_Allowed_Workspace_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Regions_Allowed_Workspace_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "regions_allowed_workspace" */
export type Regions_Allowed_Workspace_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Regions_Allowed_Workspace_Max_Order_By>;
  min?: InputMaybe<Regions_Allowed_Workspace_Min_Order_By>;
};

/** input type for inserting array relation for remote table "regions_allowed_workspace" */
export type Regions_Allowed_Workspace_Arr_Rel_Insert_Input = {
  data: Array<Regions_Allowed_Workspace_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Regions_Allowed_Workspace_On_Conflict>;
};

/** Boolean expression to filter rows from the table "regions_allowed_workspace". All fields are combined with a logical 'AND'. */
export type Regions_Allowed_Workspace_Bool_Exp = {
  _and?: InputMaybe<Array<Regions_Allowed_Workspace_Bool_Exp>>;
  _not?: InputMaybe<Regions_Allowed_Workspace_Bool_Exp>;
  _or?: InputMaybe<Array<Regions_Allowed_Workspace_Bool_Exp>>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  region?: InputMaybe<Regions_Bool_Exp>;
  region_id?: InputMaybe<Uuid_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  workspace?: InputMaybe<Workspaces_Bool_Exp>;
  workspace_id?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "regions_allowed_workspace" */
export enum Regions_Allowed_Workspace_Constraint {
  /** unique or primary key constraint on columns "id" */
  RegionsAllowedWorkspacePkey = 'regions_allowed_workspace_pkey',
  /** unique or primary key constraint on columns "workspace_id", "region_id" */
  RegionsAllowedWorkspaceRegionIdWorkspaceIdKey = 'regions_allowed_workspace_region_id_workspace_id_key'
}

/** input type for inserting data into table "regions_allowed_workspace" */
export type Regions_Allowed_Workspace_Insert_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']>;
  description?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  region?: InputMaybe<Regions_Obj_Rel_Insert_Input>;
  region_id?: InputMaybe<Scalars['uuid']>;
  updated_at?: InputMaybe<Scalars['timestamptz']>;
  workspace?: InputMaybe<Workspaces_Obj_Rel_Insert_Input>;
  workspace_id?: InputMaybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type Regions_Allowed_Workspace_Max_Fields = {
  __typename?: 'regions_allowed_workspace_max_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  description?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  region_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  workspace_id?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "regions_allowed_workspace" */
export type Regions_Allowed_Workspace_Max_Order_By = {
  created_at?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  region_id?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  workspace_id?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Regions_Allowed_Workspace_Min_Fields = {
  __typename?: 'regions_allowed_workspace_min_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  description?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  region_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  workspace_id?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "regions_allowed_workspace" */
export type Regions_Allowed_Workspace_Min_Order_By = {
  created_at?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  region_id?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  workspace_id?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "regions_allowed_workspace" */
export type Regions_Allowed_Workspace_Mutation_Response = {
  __typename?: 'regions_allowed_workspace_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Regions_Allowed_Workspace>;
};

/** input type for inserting object relation for remote table "regions_allowed_workspace" */
export type Regions_Allowed_Workspace_Obj_Rel_Insert_Input = {
  data: Regions_Allowed_Workspace_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Regions_Allowed_Workspace_On_Conflict>;
};

/** on_conflict condition type for table "regions_allowed_workspace" */
export type Regions_Allowed_Workspace_On_Conflict = {
  constraint: Regions_Allowed_Workspace_Constraint;
  update_columns?: Array<Regions_Allowed_Workspace_Update_Column>;
  where?: InputMaybe<Regions_Allowed_Workspace_Bool_Exp>;
};

/** Ordering options when selecting data from "regions_allowed_workspace". */
export type Regions_Allowed_Workspace_Order_By = {
  created_at?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  region?: InputMaybe<Regions_Order_By>;
  region_id?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  workspace?: InputMaybe<Workspaces_Order_By>;
  workspace_id?: InputMaybe<Order_By>;
};

/** primary key columns input for table: regions_allowed_workspace */
export type Regions_Allowed_Workspace_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "regions_allowed_workspace" */
export enum Regions_Allowed_Workspace_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  RegionId = 'region_id',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  WorkspaceId = 'workspace_id'
}

/** input type for updating data in table "regions_allowed_workspace" */
export type Regions_Allowed_Workspace_Set_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']>;
  description?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  region_id?: InputMaybe<Scalars['uuid']>;
  updated_at?: InputMaybe<Scalars['timestamptz']>;
  workspace_id?: InputMaybe<Scalars['uuid']>;
};

/** Streaming cursor of the table "regions_allowed_workspace" */
export type Regions_Allowed_Workspace_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Regions_Allowed_Workspace_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Regions_Allowed_Workspace_Stream_Cursor_Value_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']>;
  description?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  region_id?: InputMaybe<Scalars['uuid']>;
  updated_at?: InputMaybe<Scalars['timestamptz']>;
  workspace_id?: InputMaybe<Scalars['uuid']>;
};

/** update columns of table "regions_allowed_workspace" */
export enum Regions_Allowed_Workspace_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  RegionId = 'region_id',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  WorkspaceId = 'workspace_id'
}

export type Regions_Allowed_Workspace_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Regions_Allowed_Workspace_Set_Input>;
  /** filter the rows which have to be updated */
  where: Regions_Allowed_Workspace_Bool_Exp;
};

/** input type for inserting array relation for remote table "regions" */
export type Regions_Arr_Rel_Insert_Input = {
  data: Array<Regions_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Regions_On_Conflict>;
};

/** Boolean expression to filter rows from the table "regions". All fields are combined with a logical 'AND'. */
export type Regions_Bool_Exp = {
  _and?: InputMaybe<Array<Regions_Bool_Exp>>;
  _not?: InputMaybe<Regions_Bool_Exp>;
  _or?: InputMaybe<Array<Regions_Bool_Exp>>;
  active?: InputMaybe<Boolean_Comparison_Exp>;
  allowedOrganizations?: InputMaybe<Regions_Allowed_Organization_Bool_Exp>;
  allowedOrganizations_aggregate?: InputMaybe<Regions_Allowed_Organization_Aggregate_Bool_Exp>;
  allowedWorkspaces?: InputMaybe<Regions_Allowed_Workspace_Bool_Exp>;
  apps?: InputMaybe<Apps_Bool_Exp>;
  apps_aggregate?: InputMaybe<Apps_Aggregate_Bool_Exp>;
  awsName?: InputMaybe<String_Comparison_Exp>;
  city?: InputMaybe<String_Comparison_Exp>;
  country?: InputMaybe<Countries_Bool_Exp>;
  countryCode?: InputMaybe<String_Comparison_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  domain?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  isGdprCompliant?: InputMaybe<Boolean_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  region_type?: InputMaybe<Region_Type_Bool_Exp>;
  regions_allowed_workspaces?: InputMaybe<Regions_Allowed_Workspace_Bool_Exp>;
  regions_allowed_workspaces_aggregate?: InputMaybe<Regions_Allowed_Workspace_Aggregate_Bool_Exp>;
  type?: InputMaybe<Region_Type_Enum_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "regions" */
export enum Regions_Constraint {
  /** unique or primary key constraint on columns "id" */
  LocationsPkey = 'locations_pkey'
}

/** input type for inserting data into table "regions" */
export type Regions_Insert_Input = {
  active?: InputMaybe<Scalars['Boolean']>;
  allowedOrganizations?: InputMaybe<Regions_Allowed_Organization_Arr_Rel_Insert_Input>;
  allowedWorkspaces?: InputMaybe<Regions_Allowed_Workspace_Obj_Rel_Insert_Input>;
  apps?: InputMaybe<Apps_Arr_Rel_Insert_Input>;
  awsName?: InputMaybe<Scalars['String']>;
  city?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Countries_Obj_Rel_Insert_Input>;
  countryCode?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  description?: InputMaybe<Scalars['String']>;
  domain?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  isGdprCompliant?: InputMaybe<Scalars['Boolean']>;
  name?: InputMaybe<Scalars['String']>;
  region_type?: InputMaybe<Region_Type_Obj_Rel_Insert_Input>;
  regions_allowed_workspaces?: InputMaybe<Regions_Allowed_Workspace_Arr_Rel_Insert_Input>;
  type?: InputMaybe<Region_Type_Enum>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Regions_Max_Fields = {
  __typename?: 'regions_max_fields';
  awsName?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  countryCode?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  description?: Maybe<Scalars['String']>;
  domain?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "regions" */
export type Regions_Max_Order_By = {
  awsName?: InputMaybe<Order_By>;
  city?: InputMaybe<Order_By>;
  countryCode?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  domain?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Regions_Min_Fields = {
  __typename?: 'regions_min_fields';
  awsName?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  countryCode?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  description?: Maybe<Scalars['String']>;
  domain?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "regions" */
export type Regions_Min_Order_By = {
  awsName?: InputMaybe<Order_By>;
  city?: InputMaybe<Order_By>;
  countryCode?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  domain?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "regions" */
export type Regions_Mutation_Response = {
  __typename?: 'regions_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Regions>;
};

/** input type for inserting object relation for remote table "regions" */
export type Regions_Obj_Rel_Insert_Input = {
  data: Regions_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Regions_On_Conflict>;
};

/** on_conflict condition type for table "regions" */
export type Regions_On_Conflict = {
  constraint: Regions_Constraint;
  update_columns?: Array<Regions_Update_Column>;
  where?: InputMaybe<Regions_Bool_Exp>;
};

/** Ordering options when selecting data from "regions". */
export type Regions_Order_By = {
  active?: InputMaybe<Order_By>;
  allowedOrganizations_aggregate?: InputMaybe<Regions_Allowed_Organization_Aggregate_Order_By>;
  allowedWorkspaces?: InputMaybe<Regions_Allowed_Workspace_Order_By>;
  apps_aggregate?: InputMaybe<Apps_Aggregate_Order_By>;
  awsName?: InputMaybe<Order_By>;
  city?: InputMaybe<Order_By>;
  country?: InputMaybe<Countries_Order_By>;
  countryCode?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  domain?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  isGdprCompliant?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  region_type?: InputMaybe<Region_Type_Order_By>;
  regions_allowed_workspaces_aggregate?: InputMaybe<Regions_Allowed_Workspace_Aggregate_Order_By>;
  type?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
};

/** primary key columns input for table: regions */
export type Regions_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "regions" */
export enum Regions_Select_Column {
  /** column name */
  Active = 'active',
  /** column name */
  AwsName = 'awsName',
  /** column name */
  City = 'city',
  /** column name */
  CountryCode = 'countryCode',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Description = 'description',
  /** column name */
  Domain = 'domain',
  /** column name */
  Id = 'id',
  /** column name */
  IsGdprCompliant = 'isGdprCompliant',
  /** column name */
  Name = 'name',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** select "regions_aggregate_bool_exp_bool_and_arguments_columns" columns of table "regions" */
export enum Regions_Select_Column_Regions_Aggregate_Bool_Exp_Bool_And_Arguments_Columns {
  /** column name */
  Active = 'active',
  /** column name */
  IsGdprCompliant = 'isGdprCompliant'
}

/** select "regions_aggregate_bool_exp_bool_or_arguments_columns" columns of table "regions" */
export enum Regions_Select_Column_Regions_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns {
  /** column name */
  Active = 'active',
  /** column name */
  IsGdprCompliant = 'isGdprCompliant'
}

/** input type for updating data in table "regions" */
export type Regions_Set_Input = {
  active?: InputMaybe<Scalars['Boolean']>;
  awsName?: InputMaybe<Scalars['String']>;
  city?: InputMaybe<Scalars['String']>;
  countryCode?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  description?: InputMaybe<Scalars['String']>;
  domain?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  isGdprCompliant?: InputMaybe<Scalars['Boolean']>;
  name?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<Region_Type_Enum>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** Streaming cursor of the table "regions" */
export type Regions_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Regions_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Regions_Stream_Cursor_Value_Input = {
  active?: InputMaybe<Scalars['Boolean']>;
  awsName?: InputMaybe<Scalars['String']>;
  city?: InputMaybe<Scalars['String']>;
  countryCode?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  description?: InputMaybe<Scalars['String']>;
  domain?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  isGdprCompliant?: InputMaybe<Scalars['Boolean']>;
  name?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<Region_Type_Enum>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** update columns of table "regions" */
export enum Regions_Update_Column {
  /** column name */
  Active = 'active',
  /** column name */
  AwsName = 'awsName',
  /** column name */
  City = 'city',
  /** column name */
  CountryCode = 'countryCode',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Description = 'description',
  /** column name */
  Domain = 'domain',
  /** column name */
  Id = 'id',
  /** column name */
  IsGdprCompliant = 'isGdprCompliant',
  /** column name */
  Name = 'name',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type Regions_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Regions_Set_Input>;
  /** filter the rows which have to be updated */
  where: Regions_Bool_Exp;
};

/** columns and relationships of "run_service" */
export type Run_Service = {
  __typename?: 'run_service';
  /** An object relationship */
  app: Apps;
  appID: Scalars['uuid'];
  config?: Maybe<ConfigRunServiceConfig>;
  createdAt: Scalars['timestamptz'];
  /** An object relationship */
  creator: Users;
  creatorUserId: Scalars['uuid'];
  id: Scalars['uuid'];
  mimirConfigEnc?: Maybe<Scalars['String']>;
  subdomain: Scalars['String'];
  updatedAt: Scalars['timestamptz'];
};


/** columns and relationships of "run_service" */
export type Run_ServiceConfigArgs = {
  resolve: Scalars['Boolean'];
};

/** aggregated selection of "run_service" */
export type Run_Service_Aggregate = {
  __typename?: 'run_service_aggregate';
  aggregate?: Maybe<Run_Service_Aggregate_Fields>;
  nodes: Array<Run_Service>;
};

export type Run_Service_Aggregate_Bool_Exp = {
  count?: InputMaybe<Run_Service_Aggregate_Bool_Exp_Count>;
};

export type Run_Service_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Run_Service_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<Run_Service_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "run_service" */
export type Run_Service_Aggregate_Fields = {
  __typename?: 'run_service_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Run_Service_Max_Fields>;
  min?: Maybe<Run_Service_Min_Fields>;
};


/** aggregate fields of "run_service" */
export type Run_Service_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Run_Service_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "run_service" */
export type Run_Service_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Run_Service_Max_Order_By>;
  min?: InputMaybe<Run_Service_Min_Order_By>;
};

/** input type for inserting array relation for remote table "run_service" */
export type Run_Service_Arr_Rel_Insert_Input = {
  data: Array<Run_Service_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Run_Service_On_Conflict>;
};

/** Boolean expression to filter rows from the table "run_service". All fields are combined with a logical 'AND'. */
export type Run_Service_Bool_Exp = {
  _and?: InputMaybe<Array<Run_Service_Bool_Exp>>;
  _not?: InputMaybe<Run_Service_Bool_Exp>;
  _or?: InputMaybe<Array<Run_Service_Bool_Exp>>;
  app?: InputMaybe<Apps_Bool_Exp>;
  appID?: InputMaybe<Uuid_Comparison_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  creator?: InputMaybe<Users_Bool_Exp>;
  creatorUserId?: InputMaybe<Uuid_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  mimirConfigEnc?: InputMaybe<String_Comparison_Exp>;
  subdomain?: InputMaybe<String_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "run_service" */
export enum Run_Service_Constraint {
  /** unique or primary key constraint on columns "id" */
  RunServicePkey = 'run_service_pkey',
  /** unique or primary key constraint on columns "subdomain" */
  RunServiceSubdomainKey = 'run_service_subdomain_key'
}

/** input type for inserting data into table "run_service" */
export type Run_Service_Insert_Input = {
  app?: InputMaybe<Apps_Obj_Rel_Insert_Input>;
  appID?: InputMaybe<Scalars['uuid']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  creator?: InputMaybe<Users_Obj_Rel_Insert_Input>;
  creatorUserId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  mimirConfigEnc?: InputMaybe<Scalars['String']>;
  subdomain?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Run_Service_Max_Fields = {
  __typename?: 'run_service_max_fields';
  appID?: Maybe<Scalars['uuid']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  creatorUserId?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  mimirConfigEnc?: Maybe<Scalars['String']>;
  subdomain?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "run_service" */
export type Run_Service_Max_Order_By = {
  appID?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  creatorUserId?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  mimirConfigEnc?: InputMaybe<Order_By>;
  subdomain?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Run_Service_Min_Fields = {
  __typename?: 'run_service_min_fields';
  appID?: Maybe<Scalars['uuid']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  creatorUserId?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  mimirConfigEnc?: Maybe<Scalars['String']>;
  subdomain?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "run_service" */
export type Run_Service_Min_Order_By = {
  appID?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  creatorUserId?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  mimirConfigEnc?: InputMaybe<Order_By>;
  subdomain?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "run_service" */
export type Run_Service_Mutation_Response = {
  __typename?: 'run_service_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Run_Service>;
};

/** on_conflict condition type for table "run_service" */
export type Run_Service_On_Conflict = {
  constraint: Run_Service_Constraint;
  update_columns?: Array<Run_Service_Update_Column>;
  where?: InputMaybe<Run_Service_Bool_Exp>;
};

/** Ordering options when selecting data from "run_service". */
export type Run_Service_Order_By = {
  app?: InputMaybe<Apps_Order_By>;
  appID?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  creator?: InputMaybe<Users_Order_By>;
  creatorUserId?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  mimirConfigEnc?: InputMaybe<Order_By>;
  subdomain?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
};

/** primary key columns input for table: run_service */
export type Run_Service_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "run_service" */
export enum Run_Service_Select_Column {
  /** column name */
  AppId = 'appID',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatorUserId = 'creatorUserId',
  /** column name */
  Id = 'id',
  /** column name */
  MimirConfigEnc = 'mimirConfigEnc',
  /** column name */
  Subdomain = 'subdomain',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "run_service" */
export type Run_Service_Set_Input = {
  appID?: InputMaybe<Scalars['uuid']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  creatorUserId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  mimirConfigEnc?: InputMaybe<Scalars['String']>;
  subdomain?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** Streaming cursor of the table "run_service" */
export type Run_Service_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Run_Service_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Run_Service_Stream_Cursor_Value_Input = {
  appID?: InputMaybe<Scalars['uuid']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  creatorUserId?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  mimirConfigEnc?: InputMaybe<Scalars['String']>;
  subdomain?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** update columns of table "run_service" */
export enum Run_Service_Update_Column {
  /** column name */
  AppId = 'appID',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatorUserId = 'creatorUserId',
  /** column name */
  Id = 'id',
  /** column name */
  MimirConfigEnc = 'mimirConfigEnc',
  /** column name */
  Subdomain = 'subdomain',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type Run_Service_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Run_Service_Set_Input>;
  /** filter the rows which have to be updated */
  where: Run_Service_Bool_Exp;
};

/** Boolean expression to compare columns of type "smallint". All fields are combined with logical 'AND'. */
export type Smallint_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['smallint']>;
  _gt?: InputMaybe<Scalars['smallint']>;
  _gte?: InputMaybe<Scalars['smallint']>;
  _in?: InputMaybe<Array<Scalars['smallint']>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _lt?: InputMaybe<Scalars['smallint']>;
  _lte?: InputMaybe<Scalars['smallint']>;
  _neq?: InputMaybe<Scalars['smallint']>;
  _nin?: InputMaybe<Array<Scalars['smallint']>>;
};

/** Software type: hasura, postgres, hasura-auth ... */
export type Software_Type = {
  __typename?: 'software_type';
  comment: Scalars['String'];
  /** An array relationship */
  software_versions: Array<Software_Versions>;
  /** An aggregate relationship */
  software_versions_aggregate: Software_Versions_Aggregate;
  type: Scalars['String'];
};


/** Software type: hasura, postgres, hasura-auth ... */
export type Software_TypeSoftware_VersionsArgs = {
  distinct_on?: InputMaybe<Array<Software_Versions_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Software_Versions_Order_By>>;
  where?: InputMaybe<Software_Versions_Bool_Exp>;
};


/** Software type: hasura, postgres, hasura-auth ... */
export type Software_TypeSoftware_Versions_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Software_Versions_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Software_Versions_Order_By>>;
  where?: InputMaybe<Software_Versions_Bool_Exp>;
};

/** aggregated selection of "software_type" */
export type Software_Type_Aggregate = {
  __typename?: 'software_type_aggregate';
  aggregate?: Maybe<Software_Type_Aggregate_Fields>;
  nodes: Array<Software_Type>;
};

/** aggregate fields of "software_type" */
export type Software_Type_Aggregate_Fields = {
  __typename?: 'software_type_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Software_Type_Max_Fields>;
  min?: Maybe<Software_Type_Min_Fields>;
};


/** aggregate fields of "software_type" */
export type Software_Type_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Software_Type_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "software_type". All fields are combined with a logical 'AND'. */
export type Software_Type_Bool_Exp = {
  _and?: InputMaybe<Array<Software_Type_Bool_Exp>>;
  _not?: InputMaybe<Software_Type_Bool_Exp>;
  _or?: InputMaybe<Array<Software_Type_Bool_Exp>>;
  comment?: InputMaybe<String_Comparison_Exp>;
  software_versions?: InputMaybe<Software_Versions_Bool_Exp>;
  software_versions_aggregate?: InputMaybe<Software_Versions_Aggregate_Bool_Exp>;
  type?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "software_type" */
export enum Software_Type_Constraint {
  /** unique or primary key constraint on columns "type" */
  SoftwareTypePkey = 'software_type_pkey'
}

export enum Software_Type_Enum {
  /** Hasura Auth */
  Auth = 'Auth',
  /** Graphite */
  Graphite = 'Graphite',
  /** Hasura GraphQL Engine */
  Hasura = 'Hasura',
  /** PostgreSQL Database */
  PostgreSql = 'PostgreSQL',
  /** Hasura Storage */
  Storage = 'Storage'
}

/** Boolean expression to compare columns of type "software_type_enum". All fields are combined with logical 'AND'. */
export type Software_Type_Enum_Comparison_Exp = {
  _eq?: InputMaybe<Software_Type_Enum>;
  _in?: InputMaybe<Array<Software_Type_Enum>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<Software_Type_Enum>;
  _nin?: InputMaybe<Array<Software_Type_Enum>>;
};

/** input type for inserting data into table "software_type" */
export type Software_Type_Insert_Input = {
  comment?: InputMaybe<Scalars['String']>;
  software_versions?: InputMaybe<Software_Versions_Arr_Rel_Insert_Input>;
  type?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Software_Type_Max_Fields = {
  __typename?: 'software_type_max_fields';
  comment?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Software_Type_Min_Fields = {
  __typename?: 'software_type_min_fields';
  comment?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "software_type" */
export type Software_Type_Mutation_Response = {
  __typename?: 'software_type_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Software_Type>;
};

/** input type for inserting object relation for remote table "software_type" */
export type Software_Type_Obj_Rel_Insert_Input = {
  data: Software_Type_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Software_Type_On_Conflict>;
};

/** on_conflict condition type for table "software_type" */
export type Software_Type_On_Conflict = {
  constraint: Software_Type_Constraint;
  update_columns?: Array<Software_Type_Update_Column>;
  where?: InputMaybe<Software_Type_Bool_Exp>;
};

/** Ordering options when selecting data from "software_type". */
export type Software_Type_Order_By = {
  comment?: InputMaybe<Order_By>;
  software_versions_aggregate?: InputMaybe<Software_Versions_Aggregate_Order_By>;
  type?: InputMaybe<Order_By>;
};

/** primary key columns input for table: software_type */
export type Software_Type_Pk_Columns_Input = {
  type: Scalars['String'];
};

/** select columns of table "software_type" */
export enum Software_Type_Select_Column {
  /** column name */
  Comment = 'comment',
  /** column name */
  Type = 'type'
}

/** input type for updating data in table "software_type" */
export type Software_Type_Set_Input = {
  comment?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "software_type" */
export type Software_Type_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Software_Type_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Software_Type_Stream_Cursor_Value_Input = {
  comment?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<Scalars['String']>;
};

/** update columns of table "software_type" */
export enum Software_Type_Update_Column {
  /** column name */
  Comment = 'comment',
  /** column name */
  Type = 'type'
}

export type Software_Type_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Software_Type_Set_Input>;
  /** filter the rows which have to be updated */
  where: Software_Type_Bool_Exp;
};

/** columns and relationships of "software_versions" */
export type Software_Versions = {
  __typename?: 'software_versions';
  id: Scalars['uuid'];
  software: Software_Type_Enum;
  /** An object relationship */
  softwareType: Software_Type;
  version: Scalars['String'];
};

/** aggregated selection of "software_versions" */
export type Software_Versions_Aggregate = {
  __typename?: 'software_versions_aggregate';
  aggregate?: Maybe<Software_Versions_Aggregate_Fields>;
  nodes: Array<Software_Versions>;
};

export type Software_Versions_Aggregate_Bool_Exp = {
  count?: InputMaybe<Software_Versions_Aggregate_Bool_Exp_Count>;
};

export type Software_Versions_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Software_Versions_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<Software_Versions_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "software_versions" */
export type Software_Versions_Aggregate_Fields = {
  __typename?: 'software_versions_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Software_Versions_Max_Fields>;
  min?: Maybe<Software_Versions_Min_Fields>;
};


/** aggregate fields of "software_versions" */
export type Software_Versions_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Software_Versions_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "software_versions" */
export type Software_Versions_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Software_Versions_Max_Order_By>;
  min?: InputMaybe<Software_Versions_Min_Order_By>;
};

/** input type for inserting array relation for remote table "software_versions" */
export type Software_Versions_Arr_Rel_Insert_Input = {
  data: Array<Software_Versions_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Software_Versions_On_Conflict>;
};

/** Boolean expression to filter rows from the table "software_versions". All fields are combined with a logical 'AND'. */
export type Software_Versions_Bool_Exp = {
  _and?: InputMaybe<Array<Software_Versions_Bool_Exp>>;
  _not?: InputMaybe<Software_Versions_Bool_Exp>;
  _or?: InputMaybe<Array<Software_Versions_Bool_Exp>>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  software?: InputMaybe<Software_Type_Enum_Comparison_Exp>;
  softwareType?: InputMaybe<Software_Type_Bool_Exp>;
  version?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "software_versions" */
export enum Software_Versions_Constraint {
  /** unique or primary key constraint on columns "id" */
  SoftwareVersionsPkey = 'software_versions_pkey'
}

/** input type for inserting data into table "software_versions" */
export type Software_Versions_Insert_Input = {
  id?: InputMaybe<Scalars['uuid']>;
  software?: InputMaybe<Software_Type_Enum>;
  softwareType?: InputMaybe<Software_Type_Obj_Rel_Insert_Input>;
  version?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Software_Versions_Max_Fields = {
  __typename?: 'software_versions_max_fields';
  id?: Maybe<Scalars['uuid']>;
  version?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "software_versions" */
export type Software_Versions_Max_Order_By = {
  id?: InputMaybe<Order_By>;
  version?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Software_Versions_Min_Fields = {
  __typename?: 'software_versions_min_fields';
  id?: Maybe<Scalars['uuid']>;
  version?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "software_versions" */
export type Software_Versions_Min_Order_By = {
  id?: InputMaybe<Order_By>;
  version?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "software_versions" */
export type Software_Versions_Mutation_Response = {
  __typename?: 'software_versions_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Software_Versions>;
};

/** on_conflict condition type for table "software_versions" */
export type Software_Versions_On_Conflict = {
  constraint: Software_Versions_Constraint;
  update_columns?: Array<Software_Versions_Update_Column>;
  where?: InputMaybe<Software_Versions_Bool_Exp>;
};

/** Ordering options when selecting data from "software_versions". */
export type Software_Versions_Order_By = {
  id?: InputMaybe<Order_By>;
  software?: InputMaybe<Order_By>;
  softwareType?: InputMaybe<Software_Type_Order_By>;
  version?: InputMaybe<Order_By>;
};

/** primary key columns input for table: software_versions */
export type Software_Versions_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "software_versions" */
export enum Software_Versions_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Software = 'software',
  /** column name */
  Version = 'version'
}

/** input type for updating data in table "software_versions" */
export type Software_Versions_Set_Input = {
  id?: InputMaybe<Scalars['uuid']>;
  software?: InputMaybe<Software_Type_Enum>;
  version?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "software_versions" */
export type Software_Versions_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Software_Versions_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Software_Versions_Stream_Cursor_Value_Input = {
  id?: InputMaybe<Scalars['uuid']>;
  software?: InputMaybe<Software_Type_Enum>;
  version?: InputMaybe<Scalars['String']>;
};

/** update columns of table "software_versions" */
export enum Software_Versions_Update_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Software = 'software',
  /** column name */
  Version = 'version'
}

export type Software_Versions_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Software_Versions_Set_Input>;
  /** filter the rows which have to be updated */
  where: Software_Versions_Bool_Exp;
};

export type Subscription_Root = {
  __typename?: 'subscription_root';
  /** fetch data from the table: "announcements" */
  announcements: Array<Announcements>;
  /** fetch aggregated fields from the table: "announcements" */
  announcements_aggregate: Announcements_Aggregate;
  /** fetch data from the table: "announcements" using primary key columns */
  announcements_by_pk?: Maybe<Announcements>;
  /** fetch data from the table in a streaming manner: "announcements" */
  announcements_stream: Array<Announcements>;
  /** fetch data from the table: "apps" using primary key columns */
  app?: Maybe<Apps>;
  /** fetch data from the table: "app_states" using primary key columns */
  appState?: Maybe<AppStates>;
  /** fetch data from the table: "app_state_history" */
  appStateHistories: Array<AppStateHistory>;
  /** fetch data from the table: "app_state_history" using primary key columns */
  appStateHistory?: Maybe<AppStateHistory>;
  /** fetch aggregated fields from the table: "app_state_history" */
  appStateHistoryAggregate: AppStateHistory_Aggregate;
  /** fetch data from the table in a streaming manner: "app_state_history" */
  appStateHistory_stream: Array<AppStateHistory>;
  /** fetch data from the table: "app_states" */
  appStates: Array<AppStates>;
  /** fetch aggregated fields from the table: "app_states" */
  appStatesAggregate: AppStates_Aggregate;
  /** fetch data from the table in a streaming manner: "app_states" */
  appStates_stream: Array<AppStates>;
  /** An array relationship */
  apps: Array<Apps>;
  /** fetch aggregated fields from the table: "apps" */
  appsAggregate: Apps_Aggregate;
  /** fetch data from the table in a streaming manner: "apps" */
  apps_stream: Array<Apps>;
  /** fetch data from the table: "auth.providers" using primary key columns */
  authProvider?: Maybe<AuthProviders>;
  /** fetch data from the table: "auth.provider_requests" using primary key columns */
  authProviderRequest?: Maybe<AuthProviderRequests>;
  /** fetch data from the table: "auth.provider_requests" */
  authProviderRequests: Array<AuthProviderRequests>;
  /** fetch aggregated fields from the table: "auth.provider_requests" */
  authProviderRequestsAggregate: AuthProviderRequests_Aggregate;
  /** fetch data from the table in a streaming manner: "auth.provider_requests" */
  authProviderRequests_stream: Array<AuthProviderRequests>;
  /** fetch data from the table: "auth.providers" */
  authProviders: Array<AuthProviders>;
  /** fetch aggregated fields from the table: "auth.providers" */
  authProvidersAggregate: AuthProviders_Aggregate;
  /** fetch data from the table in a streaming manner: "auth.providers" */
  authProviders_stream: Array<AuthProviders>;
  /** fetch data from the table: "auth.refresh_tokens" using primary key columns */
  authRefreshToken?: Maybe<AuthRefreshTokens>;
  /** fetch data from the table: "auth.refresh_token_types" using primary key columns */
  authRefreshTokenType?: Maybe<AuthRefreshTokenTypes>;
  /** fetch data from the table: "auth.refresh_token_types" */
  authRefreshTokenTypes: Array<AuthRefreshTokenTypes>;
  /** fetch aggregated fields from the table: "auth.refresh_token_types" */
  authRefreshTokenTypesAggregate: AuthRefreshTokenTypes_Aggregate;
  /** fetch data from the table in a streaming manner: "auth.refresh_token_types" */
  authRefreshTokenTypes_stream: Array<AuthRefreshTokenTypes>;
  /** fetch data from the table: "auth.refresh_tokens" */
  authRefreshTokens: Array<AuthRefreshTokens>;
  /** fetch aggregated fields from the table: "auth.refresh_tokens" */
  authRefreshTokensAggregate: AuthRefreshTokens_Aggregate;
  /** fetch data from the table in a streaming manner: "auth.refresh_tokens" */
  authRefreshTokens_stream: Array<AuthRefreshTokens>;
  /** fetch data from the table: "auth.roles" using primary key columns */
  authRole?: Maybe<AuthRoles>;
  /** fetch data from the table: "auth.roles" */
  authRoles: Array<AuthRoles>;
  /** fetch aggregated fields from the table: "auth.roles" */
  authRolesAggregate: AuthRoles_Aggregate;
  /** fetch data from the table in a streaming manner: "auth.roles" */
  authRoles_stream: Array<AuthRoles>;
  /** fetch data from the table: "auth.user_providers" using primary key columns */
  authUserProvider?: Maybe<AuthUserProviders>;
  /** fetch data from the table: "auth.user_providers" */
  authUserProviders: Array<AuthUserProviders>;
  /** fetch aggregated fields from the table: "auth.user_providers" */
  authUserProvidersAggregate: AuthUserProviders_Aggregate;
  /** fetch data from the table in a streaming manner: "auth.user_providers" */
  authUserProviders_stream: Array<AuthUserProviders>;
  /** fetch data from the table: "auth.user_roles" using primary key columns */
  authUserRole?: Maybe<AuthUserRoles>;
  /** fetch data from the table: "auth.user_roles" */
  authUserRoles: Array<AuthUserRoles>;
  /** fetch aggregated fields from the table: "auth.user_roles" */
  authUserRolesAggregate: AuthUserRoles_Aggregate;
  /** fetch data from the table in a streaming manner: "auth.user_roles" */
  authUserRoles_stream: Array<AuthUserRoles>;
  /** fetch data from the table: "auth.user_security_keys" using primary key columns */
  authUserSecurityKey?: Maybe<AuthUserSecurityKeys>;
  /** fetch data from the table: "auth.user_security_keys" */
  authUserSecurityKeys: Array<AuthUserSecurityKeys>;
  /** fetch aggregated fields from the table: "auth.user_security_keys" */
  authUserSecurityKeysAggregate: AuthUserSecurityKeys_Aggregate;
  /** fetch data from the table in a streaming manner: "auth.user_security_keys" */
  authUserSecurityKeys_stream: Array<AuthUserSecurityKeys>;
  /** fetch data from the table: "auth.migrations" */
  auth_migrations: Array<Auth_Migrations>;
  /** fetch aggregated fields from the table: "auth.migrations" */
  auth_migrations_aggregate: Auth_Migrations_Aggregate;
  /** fetch data from the table: "auth.migrations" using primary key columns */
  auth_migrations_by_pk?: Maybe<Auth_Migrations>;
  /** fetch data from the table in a streaming manner: "auth.migrations" */
  auth_migrations_stream: Array<Auth_Migrations>;
  /** fetch data from the table: "backups" using primary key columns */
  backup?: Maybe<Backups>;
  /** An array relationship */
  backups: Array<Backups>;
  /** fetch aggregated fields from the table: "backups" */
  backupsAggregate: Backups_Aggregate;
  /** fetch data from the table in a streaming manner: "backups" */
  backups_stream: Array<Backups>;
  /** fetch data from the table: "billing.dedicated_compute" using primary key columns */
  billingDedicatedCompute?: Maybe<Billing_Dedicated_Compute>;
  /** fetch aggregated fields from the table: "billing.dedicated_compute" */
  billingDedicatedComputeAggregate: Billing_Dedicated_Compute_Aggregate;
  /** fetch data from the table: "billing.dedicated_compute_reports" using primary key columns */
  billingDedicatedComputeReport?: Maybe<Billing_Dedicated_Compute_Reports>;
  /** fetch data from the table: "billing.dedicated_compute_reports" */
  billingDedicatedComputeReports: Array<Billing_Dedicated_Compute_Reports>;
  /** fetch aggregated fields from the table: "billing.dedicated_compute_reports" */
  billingDedicatedComputeReportsAggregate: Billing_Dedicated_Compute_Reports_Aggregate;
  /** fetch data from the table: "billing.dedicated_compute" */
  billingDedicatedComputes: Array<Billing_Dedicated_Compute>;
  /** fetch data from the table: "billing.reports" using primary key columns */
  billingReport?: Maybe<Billing_Reports>;
  /** fetch data from the table: "billing.reports" */
  billingReports: Array<Billing_Reports>;
  /** fetch aggregated fields from the table: "billing.reports" */
  billingReportsAggregate: Billing_Reports_Aggregate;
  /** fetch data from the table in a streaming manner: "billing.reports" */
  billingReportsStream: Array<Billing_Reports>;
  /** fetch data from the table: "billing.resources" using primary key columns */
  billingResource?: Maybe<Billing_Resources>;
  /** fetch data from the table: "billing.resources" */
  billingResources: Array<Billing_Resources>;
  /** fetch aggregated fields from the table: "billing.resources" */
  billingResourcesAggregate: Billing_Resources_Aggregate;
  /** fetch data from the table in a streaming manner: "billing.resources" */
  billingResourcesStream: Array<Billing_Resources>;
  /** fetch data from the table: "billing.subscriptions" using primary key columns */
  billingSubscription?: Maybe<Billing_Subscriptions>;
  /** fetch data from the table: "billing.subscriptions" */
  billingSubscriptions: Array<Billing_Subscriptions>;
  /** fetch aggregated fields from the table: "billing.subscriptions" */
  billingSubscriptionsAggregate: Billing_Subscriptions_Aggregate;
  /** fetch data from the table in a streaming manner: "billing.dedicated_compute_reports" */
  billing_dedicated_compute_reports_stream: Array<Billing_Dedicated_Compute_Reports>;
  /** fetch data from the table in a streaming manner: "billing.dedicated_compute" */
  billing_dedicated_compute_stream: Array<Billing_Dedicated_Compute>;
  /** fetch data from the table: "billing.report_type" */
  billing_report_type: Array<Billing_Report_Type>;
  /** fetch aggregated fields from the table: "billing.report_type" */
  billing_report_type_aggregate: Billing_Report_Type_Aggregate;
  /** fetch data from the table: "billing.report_type" using primary key columns */
  billing_report_type_by_pk?: Maybe<Billing_Report_Type>;
  /** fetch data from the table in a streaming manner: "billing.report_type" */
  billing_report_type_stream: Array<Billing_Report_Type>;
  /** fetch data from the table in a streaming manner: "billing.subscriptions" */
  billing_subscriptions_stream: Array<Billing_Subscriptions>;
  /** fetch data from the table: "storage.buckets" using primary key columns */
  bucket?: Maybe<Buckets>;
  /** fetch data from the table: "storage.buckets" */
  buckets: Array<Buckets>;
  /** fetch aggregated fields from the table: "storage.buckets" */
  bucketsAggregate: Buckets_Aggregate;
  /** fetch data from the table in a streaming manner: "storage.buckets" */
  buckets_stream: Array<Buckets>;
  /** fetch data from the table: "cli_tokens" using primary key columns */
  cliToken?: Maybe<CliTokens>;
  /** An array relationship */
  cliTokens: Array<CliTokens>;
  /** fetch aggregated fields from the table: "cli_tokens" */
  cliTokensAggregate: CliTokens_Aggregate;
  /** fetch data from the table in a streaming manner: "cli_tokens" */
  cliTokens_stream: Array<CliTokens>;
  /** fetch data from the table: "continents" */
  continents: Array<Continents>;
  /** fetch aggregated fields from the table: "continents" */
  continents_aggregate: Continents_Aggregate;
  /** fetch data from the table: "continents" using primary key columns */
  continents_by_pk?: Maybe<Continents>;
  /** fetch data from the table in a streaming manner: "continents" */
  continents_stream: Array<Continents>;
  /** An array relationship */
  countries: Array<Countries>;
  /** An aggregate relationship */
  countries_aggregate: Countries_Aggregate;
  /** fetch data from the table: "countries" using primary key columns */
  countries_by_pk?: Maybe<Countries>;
  /** fetch data from the table in a streaming manner: "countries" */
  countries_stream: Array<Countries>;
  /** fetch data from the table: "deployments" using primary key columns */
  deployment?: Maybe<Deployments>;
  /** fetch data from the table: "deployment_logs" using primary key columns */
  deploymentLog?: Maybe<DeploymentLogs>;
  /** An array relationship */
  deploymentLogs: Array<DeploymentLogs>;
  /** fetch aggregated fields from the table: "deployment_logs" */
  deploymentLogsAggregate: DeploymentLogs_Aggregate;
  /** fetch data from the table in a streaming manner: "deployment_logs" */
  deploymentLogs_stream: Array<DeploymentLogs>;
  /** An array relationship */
  deployments: Array<Deployments>;
  /** fetch aggregated fields from the table: "deployments" */
  deploymentsAggregate: Deployments_Aggregate;
  /** fetch data from the table in a streaming manner: "deployments" */
  deployments_stream: Array<Deployments>;
  /** fetch data from the table: "feature_flags" using primary key columns */
  featureFlag?: Maybe<FeatureFlags>;
  /** An array relationship */
  featureFlags: Array<FeatureFlags>;
  /** fetch aggregated fields from the table: "feature_flags" */
  featureFlagsAggregate: FeatureFlags_Aggregate;
  /** fetch data from the table in a streaming manner: "feature_flags" */
  featureFlags_stream: Array<FeatureFlags>;
  /** fetch data from the table: "storage.files" using primary key columns */
  file?: Maybe<Files>;
  /** An array relationship */
  files: Array<Files>;
  /** fetch aggregated fields from the table: "storage.files" */
  filesAggregate: Files_Aggregate;
  /** fetch data from the table in a streaming manner: "storage.files" */
  files_stream: Array<Files>;
  /** fetch data from the table: "github_app_installations" using primary key columns */
  githubAppInstallation?: Maybe<GithubAppInstallations>;
  /** fetch data from the table: "github_app_installations" */
  githubAppInstallations: Array<GithubAppInstallations>;
  /** fetch aggregated fields from the table: "github_app_installations" */
  githubAppInstallationsAggregate: GithubAppInstallations_Aggregate;
  /** fetch data from the table in a streaming manner: "github_app_installations" */
  githubAppInstallations_stream: Array<GithubAppInstallations>;
  /** An array relationship */
  githubRepositories: Array<GithubRepositories>;
  /** fetch aggregated fields from the table: "github_repositories" */
  githubRepositoriesAggregate: GithubRepositories_Aggregate;
  /** fetch data from the table in a streaming manner: "github_repositories" */
  githubRepositories_stream: Array<GithubRepositories>;
  /** fetch data from the table: "github_repositories" using primary key columns */
  githubRepository?: Maybe<GithubRepositories>;
  /**
   * Returns logs for a given application. If `service` is not provided all services are returned.
   * If `from` is not provided, it defaults to an hour ago.
   */
  logs: Array<Log>;
  /** fetch data from the table: "organizations" using primary key columns */
  organization?: Maybe<Organizations>;
  /** fetch data from the table: "organizations_free_usage" using primary key columns */
  organizationFreeUsage?: Maybe<Organizations_Free_Usage>;
  /** fetch data from the table: "organizations_free_usage" */
  organizationFreeUsages: Array<Organizations_Free_Usage>;
  /** fetch aggregated fields from the table: "organizations_free_usage" */
  organizationFreeUsagesAggregate: Organizations_Free_Usage_Aggregate;
  /** fetch data from the table in a streaming manner: "organizations_free_usage" */
  organizationFreeUsagesStream: Array<Organizations_Free_Usage>;
  /** fetch data from the table: "organization_members" using primary key columns */
  organizationMember?: Maybe<Organization_Members>;
  /** fetch data from the table: "organization_member_invites" using primary key columns */
  organizationMemberInvite?: Maybe<Organization_Member_Invites>;
  /** fetch data from the table: "organization_member_invites" */
  organizationMemberInvites: Array<Organization_Member_Invites>;
  /** fetch aggregated fields from the table: "organization_member_invites" */
  organizationMemberInvitesAggregate: Organization_Member_Invites_Aggregate;
  /** fetch data from the table in a streaming manner: "organization_member_invites" */
  organizationMemberInvitesStream: Array<Organization_Member_Invites>;
  /** fetch data from the table: "organization_members" */
  organizationMembers: Array<Organization_Members>;
  /** fetch aggregated fields from the table: "organization_members" */
  organizationMembersAggregate: Organization_Members_Aggregate;
  /** fetch data from the table in a streaming manner: "organization_members" */
  organizationMembersStream: Array<Organization_Members>;
  /** fetch data from the table: "organization_new_request" using primary key columns */
  organizationNewRequest?: Maybe<Organization_New_Request>;
  /** fetch data from the table: "organization_new_request" */
  organizationNewRequests: Array<Organization_New_Request>;
  /** fetch aggregated fields from the table: "organization_new_request" */
  organizationNewRequestsAggregate: Organization_New_Request_Aggregate;
  /** fetch data from the table in a streaming manner: "organization_new_request" */
  organizationNewRequestsStream: Array<Organization_New_Request>;
  /** fetch data from the table: "organization_members_role" */
  organization_members_role: Array<Organization_Members_Role>;
  /** fetch aggregated fields from the table: "organization_members_role" */
  organization_members_role_aggregate: Organization_Members_Role_Aggregate;
  /** fetch data from the table: "organization_members_role" using primary key columns */
  organization_members_role_by_pk?: Maybe<Organization_Members_Role>;
  /** fetch data from the table in a streaming manner: "organization_members_role" */
  organization_members_role_stream: Array<Organization_Members_Role>;
  /** fetch data from the table: "organization_status" */
  organization_status: Array<Organization_Status>;
  /** fetch aggregated fields from the table: "organization_status" */
  organization_status_aggregate: Organization_Status_Aggregate;
  /** fetch data from the table: "organization_status" using primary key columns */
  organization_status_by_pk?: Maybe<Organization_Status>;
  /** fetch data from the table in a streaming manner: "organization_status" */
  organization_status_stream: Array<Organization_Status>;
  /** An array relationship */
  organizations: Array<Organizations>;
  /** fetch aggregated fields from the table: "organizations" */
  organizationsAggregate: Organizations_Aggregate;
  /** fetch data from the table in a streaming manner: "organizations" */
  organizationsSteam: Array<Organizations>;
  /** fetch data from the table: "payment_methods" using primary key columns */
  paymentMethod?: Maybe<PaymentMethods>;
  /** An array relationship */
  paymentMethods: Array<PaymentMethods>;
  /** fetch aggregated fields from the table: "payment_methods" */
  paymentMethodsAggregate: PaymentMethods_Aggregate;
  /** fetch data from the table in a streaming manner: "payment_methods" */
  paymentMethods_stream: Array<PaymentMethods>;
  /** fetch data from the table: "plans" using primary key columns */
  plan?: Maybe<Plans>;
  /** fetch data from the table: "plans" */
  plans: Array<Plans>;
  /** fetch aggregated fields from the table: "plans" */
  plansAggregate: Plans_Aggregate;
  /** fetch data from the table in a streaming manner: "plans" */
  plans_stream: Array<Plans>;
  /** fetch data from the table: "region_type" */
  region_type: Array<Region_Type>;
  /** fetch aggregated fields from the table: "region_type" */
  region_type_aggregate: Region_Type_Aggregate;
  /** fetch data from the table: "region_type" using primary key columns */
  region_type_by_pk?: Maybe<Region_Type>;
  /** fetch data from the table in a streaming manner: "region_type" */
  region_type_stream: Array<Region_Type>;
  /** An array relationship */
  regions: Array<Regions>;
  /** fetch data from the table: "regions_allowed_organization" using primary key columns */
  regionsAllowedOrganization?: Maybe<Regions_Allowed_Organization>;
  /** fetch data from the table: "regions_allowed_organization" */
  regionsAllowedOrganizations: Array<Regions_Allowed_Organization>;
  /** fetch aggregated fields from the table: "regions_allowed_organization" */
  regionsAllowedOrganizationsAggregate: Regions_Allowed_Organization_Aggregate;
  /** fetch data from the table in a streaming manner: "regions_allowed_organization" */
  regionsAllowedOrganizationsStream: Array<Regions_Allowed_Organization>;
  /** An aggregate relationship */
  regions_aggregate: Regions_Aggregate;
  /** fetch data from the table in a streaming manner: "regions_allowed_workspace" */
  regions_allowed_workspace_stream: Array<Regions_Allowed_Workspace>;
  /** fetch data from the table: "regions" using primary key columns */
  regions_by_pk?: Maybe<Regions>;
  /** fetch data from the table in a streaming manner: "regions" */
  regions_stream: Array<Regions>;
  /** fetch data from the table: "run_service" using primary key columns */
  runService?: Maybe<Run_Service>;
  /** An array relationship */
  runServices: Array<Run_Service>;
  /** fetch aggregated fields from the table: "run_service" */
  runServicesAggregate: Run_Service_Aggregate;
  /** fetch data from the table in a streaming manner: "run_service" */
  run_service_stream: Array<Run_Service>;
  /** fetch data from the table: "regions_allowed_workspace" using primary key columns */
  selectRegionsAllowedWorkspace?: Maybe<Regions_Allowed_Workspace>;
  /** fetch data from the table: "regions_allowed_workspace" */
  selectRegionsAllowedWorkspaces: Array<Regions_Allowed_Workspace>;
  /** fetch aggregated fields from the table: "regions_allowed_workspace" */
  selectRegionsAllowedWorkspacesAggregate: Regions_Allowed_Workspace_Aggregate;
  /** fetch data from the table: "software_type" using primary key columns */
  softwareType?: Maybe<Software_Type>;
  /** fetch data from the table: "software_type" */
  softwareTypes: Array<Software_Type>;
  /** fetch aggregated fields from the table: "software_type" */
  softwareTypesAggregate: Software_Type_Aggregate;
  /** fetch data from the table in a streaming manner: "software_type" */
  softwareTypesStream: Array<Software_Type>;
  /** fetch data from the table: "software_versions" using primary key columns */
  softwareVersion?: Maybe<Software_Versions>;
  /** fetch data from the table: "software_versions" */
  softwareVersions: Array<Software_Versions>;
  /** fetch aggregated fields from the table: "software_versions" */
  softwareVersionsAggregate: Software_Versions_Aggregate;
  /** fetch data from the table in a streaming manner: "software_versions" */
  softwareVersionsStream: Array<Software_Versions>;
  /** fetch data from the table: "auth.users" using primary key columns */
  user?: Maybe<Users>;
  /** fetch data from the table: "auth.users" */
  users: Array<Users>;
  /** fetch aggregated fields from the table: "auth.users" */
  usersAggregate: Users_Aggregate;
  /** fetch data from the table in a streaming manner: "auth.users" */
  users_stream: Array<Users>;
  /** fetch data from the table: "storage.virus" using primary key columns */
  virus?: Maybe<Virus>;
  /** fetch data from the table in a streaming manner: "storage.virus" */
  virus_stream: Array<Virus>;
  /** fetch data from the table: "storage.virus" */
  viruses: Array<Virus>;
  /** fetch aggregated fields from the table: "storage.virus" */
  virusesAggregate: Virus_Aggregate;
  /** fetch data from the table: "workspaces" using primary key columns */
  workspace?: Maybe<Workspaces>;
  /** fetch data from the table: "workspace_members" using primary key columns */
  workspaceMember?: Maybe<WorkspaceMembers>;
  /** fetch data from the table: "workspace_member_invites" using primary key columns */
  workspaceMemberInvite?: Maybe<WorkspaceMemberInvites>;
  /** An array relationship */
  workspaceMemberInvites: Array<WorkspaceMemberInvites>;
  /** fetch aggregated fields from the table: "workspace_member_invites" */
  workspaceMemberInvitesAggregate: WorkspaceMemberInvites_Aggregate;
  /** fetch data from the table in a streaming manner: "workspace_member_invites" */
  workspaceMemberInvites_stream: Array<WorkspaceMemberInvites>;
  /** An array relationship */
  workspaceMembers: Array<WorkspaceMembers>;
  /** fetch aggregated fields from the table: "workspace_members" */
  workspaceMembersAggregate: WorkspaceMembers_Aggregate;
  /** fetch data from the table in a streaming manner: "workspace_members" */
  workspaceMembers_stream: Array<WorkspaceMembers>;
  /** An array relationship */
  workspaces: Array<Workspaces>;
  /** fetch aggregated fields from the table: "workspaces" */
  workspacesAggregate: Workspaces_Aggregate;
  /** fetch data from the table in a streaming manner: "workspaces" */
  workspaces_stream: Array<Workspaces>;
};


export type Subscription_RootAnnouncementsArgs = {
  distinct_on?: InputMaybe<Array<Announcements_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Announcements_Order_By>>;
  where?: InputMaybe<Announcements_Bool_Exp>;
};


export type Subscription_RootAnnouncements_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Announcements_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Announcements_Order_By>>;
  where?: InputMaybe<Announcements_Bool_Exp>;
};


export type Subscription_RootAnnouncements_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootAnnouncements_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Announcements_Stream_Cursor_Input>>;
  where?: InputMaybe<Announcements_Bool_Exp>;
};


export type Subscription_RootAppArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootAppStateArgs = {
  id: Scalars['Int'];
};


export type Subscription_RootAppStateHistoriesArgs = {
  distinct_on?: InputMaybe<Array<AppStateHistory_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<AppStateHistory_Order_By>>;
  where?: InputMaybe<AppStateHistory_Bool_Exp>;
};


export type Subscription_RootAppStateHistoryArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootAppStateHistoryAggregateArgs = {
  distinct_on?: InputMaybe<Array<AppStateHistory_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<AppStateHistory_Order_By>>;
  where?: InputMaybe<AppStateHistory_Bool_Exp>;
};


export type Subscription_RootAppStateHistory_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<AppStateHistory_Stream_Cursor_Input>>;
  where?: InputMaybe<AppStateHistory_Bool_Exp>;
};


export type Subscription_RootAppStatesArgs = {
  distinct_on?: InputMaybe<Array<AppStates_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<AppStates_Order_By>>;
  where?: InputMaybe<AppStates_Bool_Exp>;
};


export type Subscription_RootAppStatesAggregateArgs = {
  distinct_on?: InputMaybe<Array<AppStates_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<AppStates_Order_By>>;
  where?: InputMaybe<AppStates_Bool_Exp>;
};


export type Subscription_RootAppStates_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<AppStates_Stream_Cursor_Input>>;
  where?: InputMaybe<AppStates_Bool_Exp>;
};


export type Subscription_RootAppsArgs = {
  distinct_on?: InputMaybe<Array<Apps_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Apps_Order_By>>;
  where?: InputMaybe<Apps_Bool_Exp>;
};


export type Subscription_RootAppsAggregateArgs = {
  distinct_on?: InputMaybe<Array<Apps_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Apps_Order_By>>;
  where?: InputMaybe<Apps_Bool_Exp>;
};


export type Subscription_RootApps_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Apps_Stream_Cursor_Input>>;
  where?: InputMaybe<Apps_Bool_Exp>;
};


export type Subscription_RootAuthProviderArgs = {
  id: Scalars['String'];
};


export type Subscription_RootAuthProviderRequestArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootAuthProviderRequestsArgs = {
  distinct_on?: InputMaybe<Array<AuthProviderRequests_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<AuthProviderRequests_Order_By>>;
  where?: InputMaybe<AuthProviderRequests_Bool_Exp>;
};


export type Subscription_RootAuthProviderRequestsAggregateArgs = {
  distinct_on?: InputMaybe<Array<AuthProviderRequests_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<AuthProviderRequests_Order_By>>;
  where?: InputMaybe<AuthProviderRequests_Bool_Exp>;
};


export type Subscription_RootAuthProviderRequests_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<AuthProviderRequests_Stream_Cursor_Input>>;
  where?: InputMaybe<AuthProviderRequests_Bool_Exp>;
};


export type Subscription_RootAuthProvidersArgs = {
  distinct_on?: InputMaybe<Array<AuthProviders_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<AuthProviders_Order_By>>;
  where?: InputMaybe<AuthProviders_Bool_Exp>;
};


export type Subscription_RootAuthProvidersAggregateArgs = {
  distinct_on?: InputMaybe<Array<AuthProviders_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<AuthProviders_Order_By>>;
  where?: InputMaybe<AuthProviders_Bool_Exp>;
};


export type Subscription_RootAuthProviders_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<AuthProviders_Stream_Cursor_Input>>;
  where?: InputMaybe<AuthProviders_Bool_Exp>;
};


export type Subscription_RootAuthRefreshTokenArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootAuthRefreshTokenTypeArgs = {
  value: Scalars['String'];
};


export type Subscription_RootAuthRefreshTokenTypesArgs = {
  distinct_on?: InputMaybe<Array<AuthRefreshTokenTypes_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<AuthRefreshTokenTypes_Order_By>>;
  where?: InputMaybe<AuthRefreshTokenTypes_Bool_Exp>;
};


export type Subscription_RootAuthRefreshTokenTypesAggregateArgs = {
  distinct_on?: InputMaybe<Array<AuthRefreshTokenTypes_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<AuthRefreshTokenTypes_Order_By>>;
  where?: InputMaybe<AuthRefreshTokenTypes_Bool_Exp>;
};


export type Subscription_RootAuthRefreshTokenTypes_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<AuthRefreshTokenTypes_Stream_Cursor_Input>>;
  where?: InputMaybe<AuthRefreshTokenTypes_Bool_Exp>;
};


export type Subscription_RootAuthRefreshTokensArgs = {
  distinct_on?: InputMaybe<Array<AuthRefreshTokens_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<AuthRefreshTokens_Order_By>>;
  where?: InputMaybe<AuthRefreshTokens_Bool_Exp>;
};


export type Subscription_RootAuthRefreshTokensAggregateArgs = {
  distinct_on?: InputMaybe<Array<AuthRefreshTokens_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<AuthRefreshTokens_Order_By>>;
  where?: InputMaybe<AuthRefreshTokens_Bool_Exp>;
};


export type Subscription_RootAuthRefreshTokens_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<AuthRefreshTokens_Stream_Cursor_Input>>;
  where?: InputMaybe<AuthRefreshTokens_Bool_Exp>;
};


export type Subscription_RootAuthRoleArgs = {
  role: Scalars['String'];
};


export type Subscription_RootAuthRolesArgs = {
  distinct_on?: InputMaybe<Array<AuthRoles_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<AuthRoles_Order_By>>;
  where?: InputMaybe<AuthRoles_Bool_Exp>;
};


export type Subscription_RootAuthRolesAggregateArgs = {
  distinct_on?: InputMaybe<Array<AuthRoles_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<AuthRoles_Order_By>>;
  where?: InputMaybe<AuthRoles_Bool_Exp>;
};


export type Subscription_RootAuthRoles_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<AuthRoles_Stream_Cursor_Input>>;
  where?: InputMaybe<AuthRoles_Bool_Exp>;
};


export type Subscription_RootAuthUserProviderArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootAuthUserProvidersArgs = {
  distinct_on?: InputMaybe<Array<AuthUserProviders_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<AuthUserProviders_Order_By>>;
  where?: InputMaybe<AuthUserProviders_Bool_Exp>;
};


export type Subscription_RootAuthUserProvidersAggregateArgs = {
  distinct_on?: InputMaybe<Array<AuthUserProviders_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<AuthUserProviders_Order_By>>;
  where?: InputMaybe<AuthUserProviders_Bool_Exp>;
};


export type Subscription_RootAuthUserProviders_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<AuthUserProviders_Stream_Cursor_Input>>;
  where?: InputMaybe<AuthUserProviders_Bool_Exp>;
};


export type Subscription_RootAuthUserRoleArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootAuthUserRolesArgs = {
  distinct_on?: InputMaybe<Array<AuthUserRoles_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<AuthUserRoles_Order_By>>;
  where?: InputMaybe<AuthUserRoles_Bool_Exp>;
};


export type Subscription_RootAuthUserRolesAggregateArgs = {
  distinct_on?: InputMaybe<Array<AuthUserRoles_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<AuthUserRoles_Order_By>>;
  where?: InputMaybe<AuthUserRoles_Bool_Exp>;
};


export type Subscription_RootAuthUserRoles_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<AuthUserRoles_Stream_Cursor_Input>>;
  where?: InputMaybe<AuthUserRoles_Bool_Exp>;
};


export type Subscription_RootAuthUserSecurityKeyArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootAuthUserSecurityKeysArgs = {
  distinct_on?: InputMaybe<Array<AuthUserSecurityKeys_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<AuthUserSecurityKeys_Order_By>>;
  where?: InputMaybe<AuthUserSecurityKeys_Bool_Exp>;
};


export type Subscription_RootAuthUserSecurityKeysAggregateArgs = {
  distinct_on?: InputMaybe<Array<AuthUserSecurityKeys_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<AuthUserSecurityKeys_Order_By>>;
  where?: InputMaybe<AuthUserSecurityKeys_Bool_Exp>;
};


export type Subscription_RootAuthUserSecurityKeys_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<AuthUserSecurityKeys_Stream_Cursor_Input>>;
  where?: InputMaybe<AuthUserSecurityKeys_Bool_Exp>;
};


export type Subscription_RootAuth_MigrationsArgs = {
  distinct_on?: InputMaybe<Array<Auth_Migrations_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Auth_Migrations_Order_By>>;
  where?: InputMaybe<Auth_Migrations_Bool_Exp>;
};


export type Subscription_RootAuth_Migrations_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Auth_Migrations_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Auth_Migrations_Order_By>>;
  where?: InputMaybe<Auth_Migrations_Bool_Exp>;
};


export type Subscription_RootAuth_Migrations_By_PkArgs = {
  id: Scalars['Int'];
};


export type Subscription_RootAuth_Migrations_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Auth_Migrations_Stream_Cursor_Input>>;
  where?: InputMaybe<Auth_Migrations_Bool_Exp>;
};


export type Subscription_RootBackupArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootBackupsArgs = {
  distinct_on?: InputMaybe<Array<Backups_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Backups_Order_By>>;
  where?: InputMaybe<Backups_Bool_Exp>;
};


export type Subscription_RootBackupsAggregateArgs = {
  distinct_on?: InputMaybe<Array<Backups_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Backups_Order_By>>;
  where?: InputMaybe<Backups_Bool_Exp>;
};


export type Subscription_RootBackups_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Backups_Stream_Cursor_Input>>;
  where?: InputMaybe<Backups_Bool_Exp>;
};


export type Subscription_RootBillingDedicatedComputeArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootBillingDedicatedComputeAggregateArgs = {
  distinct_on?: InputMaybe<Array<Billing_Dedicated_Compute_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Billing_Dedicated_Compute_Order_By>>;
  where?: InputMaybe<Billing_Dedicated_Compute_Bool_Exp>;
};


export type Subscription_RootBillingDedicatedComputeReportArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootBillingDedicatedComputeReportsArgs = {
  distinct_on?: InputMaybe<Array<Billing_Dedicated_Compute_Reports_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Billing_Dedicated_Compute_Reports_Order_By>>;
  where?: InputMaybe<Billing_Dedicated_Compute_Reports_Bool_Exp>;
};


export type Subscription_RootBillingDedicatedComputeReportsAggregateArgs = {
  distinct_on?: InputMaybe<Array<Billing_Dedicated_Compute_Reports_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Billing_Dedicated_Compute_Reports_Order_By>>;
  where?: InputMaybe<Billing_Dedicated_Compute_Reports_Bool_Exp>;
};


export type Subscription_RootBillingDedicatedComputesArgs = {
  distinct_on?: InputMaybe<Array<Billing_Dedicated_Compute_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Billing_Dedicated_Compute_Order_By>>;
  where?: InputMaybe<Billing_Dedicated_Compute_Bool_Exp>;
};


export type Subscription_RootBillingReportArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootBillingReportsArgs = {
  distinct_on?: InputMaybe<Array<Billing_Reports_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Billing_Reports_Order_By>>;
  where?: InputMaybe<Billing_Reports_Bool_Exp>;
};


export type Subscription_RootBillingReportsAggregateArgs = {
  distinct_on?: InputMaybe<Array<Billing_Reports_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Billing_Reports_Order_By>>;
  where?: InputMaybe<Billing_Reports_Bool_Exp>;
};


export type Subscription_RootBillingReportsStreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Billing_Reports_Stream_Cursor_Input>>;
  where?: InputMaybe<Billing_Reports_Bool_Exp>;
};


export type Subscription_RootBillingResourceArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootBillingResourcesArgs = {
  distinct_on?: InputMaybe<Array<Billing_Resources_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Billing_Resources_Order_By>>;
  where?: InputMaybe<Billing_Resources_Bool_Exp>;
};


export type Subscription_RootBillingResourcesAggregateArgs = {
  distinct_on?: InputMaybe<Array<Billing_Resources_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Billing_Resources_Order_By>>;
  where?: InputMaybe<Billing_Resources_Bool_Exp>;
};


export type Subscription_RootBillingResourcesStreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Billing_Resources_Stream_Cursor_Input>>;
  where?: InputMaybe<Billing_Resources_Bool_Exp>;
};


export type Subscription_RootBillingSubscriptionArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootBillingSubscriptionsArgs = {
  distinct_on?: InputMaybe<Array<Billing_Subscriptions_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Billing_Subscriptions_Order_By>>;
  where?: InputMaybe<Billing_Subscriptions_Bool_Exp>;
};


export type Subscription_RootBillingSubscriptionsAggregateArgs = {
  distinct_on?: InputMaybe<Array<Billing_Subscriptions_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Billing_Subscriptions_Order_By>>;
  where?: InputMaybe<Billing_Subscriptions_Bool_Exp>;
};


export type Subscription_RootBilling_Dedicated_Compute_Reports_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Billing_Dedicated_Compute_Reports_Stream_Cursor_Input>>;
  where?: InputMaybe<Billing_Dedicated_Compute_Reports_Bool_Exp>;
};


export type Subscription_RootBilling_Dedicated_Compute_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Billing_Dedicated_Compute_Stream_Cursor_Input>>;
  where?: InputMaybe<Billing_Dedicated_Compute_Bool_Exp>;
};


export type Subscription_RootBilling_Report_TypeArgs = {
  distinct_on?: InputMaybe<Array<Billing_Report_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Billing_Report_Type_Order_By>>;
  where?: InputMaybe<Billing_Report_Type_Bool_Exp>;
};


export type Subscription_RootBilling_Report_Type_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Billing_Report_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Billing_Report_Type_Order_By>>;
  where?: InputMaybe<Billing_Report_Type_Bool_Exp>;
};


export type Subscription_RootBilling_Report_Type_By_PkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootBilling_Report_Type_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Billing_Report_Type_Stream_Cursor_Input>>;
  where?: InputMaybe<Billing_Report_Type_Bool_Exp>;
};


export type Subscription_RootBilling_Subscriptions_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Billing_Subscriptions_Stream_Cursor_Input>>;
  where?: InputMaybe<Billing_Subscriptions_Bool_Exp>;
};


export type Subscription_RootBucketArgs = {
  id: Scalars['String'];
};


export type Subscription_RootBucketsArgs = {
  distinct_on?: InputMaybe<Array<Buckets_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Buckets_Order_By>>;
  where?: InputMaybe<Buckets_Bool_Exp>;
};


export type Subscription_RootBucketsAggregateArgs = {
  distinct_on?: InputMaybe<Array<Buckets_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Buckets_Order_By>>;
  where?: InputMaybe<Buckets_Bool_Exp>;
};


export type Subscription_RootBuckets_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Buckets_Stream_Cursor_Input>>;
  where?: InputMaybe<Buckets_Bool_Exp>;
};


export type Subscription_RootCliTokenArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootCliTokensArgs = {
  distinct_on?: InputMaybe<Array<CliTokens_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<CliTokens_Order_By>>;
  where?: InputMaybe<CliTokens_Bool_Exp>;
};


export type Subscription_RootCliTokensAggregateArgs = {
  distinct_on?: InputMaybe<Array<CliTokens_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<CliTokens_Order_By>>;
  where?: InputMaybe<CliTokens_Bool_Exp>;
};


export type Subscription_RootCliTokens_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<CliTokens_Stream_Cursor_Input>>;
  where?: InputMaybe<CliTokens_Bool_Exp>;
};


export type Subscription_RootContinentsArgs = {
  distinct_on?: InputMaybe<Array<Continents_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Continents_Order_By>>;
  where?: InputMaybe<Continents_Bool_Exp>;
};


export type Subscription_RootContinents_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Continents_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Continents_Order_By>>;
  where?: InputMaybe<Continents_Bool_Exp>;
};


export type Subscription_RootContinents_By_PkArgs = {
  code: Scalars['bpchar'];
};


export type Subscription_RootContinents_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Continents_Stream_Cursor_Input>>;
  where?: InputMaybe<Continents_Bool_Exp>;
};


export type Subscription_RootCountriesArgs = {
  distinct_on?: InputMaybe<Array<Countries_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Countries_Order_By>>;
  where?: InputMaybe<Countries_Bool_Exp>;
};


export type Subscription_RootCountries_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Countries_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Countries_Order_By>>;
  where?: InputMaybe<Countries_Bool_Exp>;
};


export type Subscription_RootCountries_By_PkArgs = {
  code: Scalars['bpchar'];
};


export type Subscription_RootCountries_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Countries_Stream_Cursor_Input>>;
  where?: InputMaybe<Countries_Bool_Exp>;
};


export type Subscription_RootDeploymentArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootDeploymentLogArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootDeploymentLogsArgs = {
  distinct_on?: InputMaybe<Array<DeploymentLogs_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<DeploymentLogs_Order_By>>;
  where?: InputMaybe<DeploymentLogs_Bool_Exp>;
};


export type Subscription_RootDeploymentLogsAggregateArgs = {
  distinct_on?: InputMaybe<Array<DeploymentLogs_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<DeploymentLogs_Order_By>>;
  where?: InputMaybe<DeploymentLogs_Bool_Exp>;
};


export type Subscription_RootDeploymentLogs_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<DeploymentLogs_Stream_Cursor_Input>>;
  where?: InputMaybe<DeploymentLogs_Bool_Exp>;
};


export type Subscription_RootDeploymentsArgs = {
  distinct_on?: InputMaybe<Array<Deployments_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Deployments_Order_By>>;
  where?: InputMaybe<Deployments_Bool_Exp>;
};


export type Subscription_RootDeploymentsAggregateArgs = {
  distinct_on?: InputMaybe<Array<Deployments_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Deployments_Order_By>>;
  where?: InputMaybe<Deployments_Bool_Exp>;
};


export type Subscription_RootDeployments_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Deployments_Stream_Cursor_Input>>;
  where?: InputMaybe<Deployments_Bool_Exp>;
};


export type Subscription_RootFeatureFlagArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootFeatureFlagsArgs = {
  distinct_on?: InputMaybe<Array<FeatureFlags_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<FeatureFlags_Order_By>>;
  where?: InputMaybe<FeatureFlags_Bool_Exp>;
};


export type Subscription_RootFeatureFlagsAggregateArgs = {
  distinct_on?: InputMaybe<Array<FeatureFlags_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<FeatureFlags_Order_By>>;
  where?: InputMaybe<FeatureFlags_Bool_Exp>;
};


export type Subscription_RootFeatureFlags_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<FeatureFlags_Stream_Cursor_Input>>;
  where?: InputMaybe<FeatureFlags_Bool_Exp>;
};


export type Subscription_RootFileArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootFilesArgs = {
  distinct_on?: InputMaybe<Array<Files_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Files_Order_By>>;
  where?: InputMaybe<Files_Bool_Exp>;
};


export type Subscription_RootFilesAggregateArgs = {
  distinct_on?: InputMaybe<Array<Files_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Files_Order_By>>;
  where?: InputMaybe<Files_Bool_Exp>;
};


export type Subscription_RootFiles_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Files_Stream_Cursor_Input>>;
  where?: InputMaybe<Files_Bool_Exp>;
};


export type Subscription_RootGithubAppInstallationArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootGithubAppInstallationsArgs = {
  distinct_on?: InputMaybe<Array<GithubAppInstallations_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<GithubAppInstallations_Order_By>>;
  where?: InputMaybe<GithubAppInstallations_Bool_Exp>;
};


export type Subscription_RootGithubAppInstallationsAggregateArgs = {
  distinct_on?: InputMaybe<Array<GithubAppInstallations_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<GithubAppInstallations_Order_By>>;
  where?: InputMaybe<GithubAppInstallations_Bool_Exp>;
};


export type Subscription_RootGithubAppInstallations_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<GithubAppInstallations_Stream_Cursor_Input>>;
  where?: InputMaybe<GithubAppInstallations_Bool_Exp>;
};


export type Subscription_RootGithubRepositoriesArgs = {
  distinct_on?: InputMaybe<Array<GithubRepositories_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<GithubRepositories_Order_By>>;
  where?: InputMaybe<GithubRepositories_Bool_Exp>;
};


export type Subscription_RootGithubRepositoriesAggregateArgs = {
  distinct_on?: InputMaybe<Array<GithubRepositories_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<GithubRepositories_Order_By>>;
  where?: InputMaybe<GithubRepositories_Bool_Exp>;
};


export type Subscription_RootGithubRepositories_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<GithubRepositories_Stream_Cursor_Input>>;
  where?: InputMaybe<GithubRepositories_Bool_Exp>;
};


export type Subscription_RootGithubRepositoryArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootLogsArgs = {
  appID: Scalars['String'];
  from?: InputMaybe<Scalars['Timestamp']>;
  regexFilter?: InputMaybe<Scalars['String']>;
  service?: InputMaybe<Scalars['String']>;
};


export type Subscription_RootOrganizationArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootOrganizationFreeUsageArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootOrganizationFreeUsagesArgs = {
  distinct_on?: InputMaybe<Array<Organizations_Free_Usage_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Organizations_Free_Usage_Order_By>>;
  where?: InputMaybe<Organizations_Free_Usage_Bool_Exp>;
};


export type Subscription_RootOrganizationFreeUsagesAggregateArgs = {
  distinct_on?: InputMaybe<Array<Organizations_Free_Usage_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Organizations_Free_Usage_Order_By>>;
  where?: InputMaybe<Organizations_Free_Usage_Bool_Exp>;
};


export type Subscription_RootOrganizationFreeUsagesStreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Organizations_Free_Usage_Stream_Cursor_Input>>;
  where?: InputMaybe<Organizations_Free_Usage_Bool_Exp>;
};


export type Subscription_RootOrganizationMemberArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootOrganizationMemberInviteArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootOrganizationMemberInvitesArgs = {
  distinct_on?: InputMaybe<Array<Organization_Member_Invites_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Organization_Member_Invites_Order_By>>;
  where?: InputMaybe<Organization_Member_Invites_Bool_Exp>;
};


export type Subscription_RootOrganizationMemberInvitesAggregateArgs = {
  distinct_on?: InputMaybe<Array<Organization_Member_Invites_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Organization_Member_Invites_Order_By>>;
  where?: InputMaybe<Organization_Member_Invites_Bool_Exp>;
};


export type Subscription_RootOrganizationMemberInvitesStreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Organization_Member_Invites_Stream_Cursor_Input>>;
  where?: InputMaybe<Organization_Member_Invites_Bool_Exp>;
};


export type Subscription_RootOrganizationMembersArgs = {
  distinct_on?: InputMaybe<Array<Organization_Members_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Organization_Members_Order_By>>;
  where?: InputMaybe<Organization_Members_Bool_Exp>;
};


export type Subscription_RootOrganizationMembersAggregateArgs = {
  distinct_on?: InputMaybe<Array<Organization_Members_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Organization_Members_Order_By>>;
  where?: InputMaybe<Organization_Members_Bool_Exp>;
};


export type Subscription_RootOrganizationMembersStreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Organization_Members_Stream_Cursor_Input>>;
  where?: InputMaybe<Organization_Members_Bool_Exp>;
};


export type Subscription_RootOrganizationNewRequestArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootOrganizationNewRequestsArgs = {
  distinct_on?: InputMaybe<Array<Organization_New_Request_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Organization_New_Request_Order_By>>;
  where?: InputMaybe<Organization_New_Request_Bool_Exp>;
};


export type Subscription_RootOrganizationNewRequestsAggregateArgs = {
  distinct_on?: InputMaybe<Array<Organization_New_Request_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Organization_New_Request_Order_By>>;
  where?: InputMaybe<Organization_New_Request_Bool_Exp>;
};


export type Subscription_RootOrganizationNewRequestsStreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Organization_New_Request_Stream_Cursor_Input>>;
  where?: InputMaybe<Organization_New_Request_Bool_Exp>;
};


export type Subscription_RootOrganization_Members_RoleArgs = {
  distinct_on?: InputMaybe<Array<Organization_Members_Role_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Organization_Members_Role_Order_By>>;
  where?: InputMaybe<Organization_Members_Role_Bool_Exp>;
};


export type Subscription_RootOrganization_Members_Role_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Organization_Members_Role_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Organization_Members_Role_Order_By>>;
  where?: InputMaybe<Organization_Members_Role_Bool_Exp>;
};


export type Subscription_RootOrganization_Members_Role_By_PkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootOrganization_Members_Role_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Organization_Members_Role_Stream_Cursor_Input>>;
  where?: InputMaybe<Organization_Members_Role_Bool_Exp>;
};


export type Subscription_RootOrganization_StatusArgs = {
  distinct_on?: InputMaybe<Array<Organization_Status_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Organization_Status_Order_By>>;
  where?: InputMaybe<Organization_Status_Bool_Exp>;
};


export type Subscription_RootOrganization_Status_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Organization_Status_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Organization_Status_Order_By>>;
  where?: InputMaybe<Organization_Status_Bool_Exp>;
};


export type Subscription_RootOrganization_Status_By_PkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootOrganization_Status_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Organization_Status_Stream_Cursor_Input>>;
  where?: InputMaybe<Organization_Status_Bool_Exp>;
};


export type Subscription_RootOrganizationsArgs = {
  distinct_on?: InputMaybe<Array<Organizations_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Organizations_Order_By>>;
  where?: InputMaybe<Organizations_Bool_Exp>;
};


export type Subscription_RootOrganizationsAggregateArgs = {
  distinct_on?: InputMaybe<Array<Organizations_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Organizations_Order_By>>;
  where?: InputMaybe<Organizations_Bool_Exp>;
};


export type Subscription_RootOrganizationsSteamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Organizations_Stream_Cursor_Input>>;
  where?: InputMaybe<Organizations_Bool_Exp>;
};


export type Subscription_RootPaymentMethodArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootPaymentMethodsArgs = {
  distinct_on?: InputMaybe<Array<PaymentMethods_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<PaymentMethods_Order_By>>;
  where?: InputMaybe<PaymentMethods_Bool_Exp>;
};


export type Subscription_RootPaymentMethodsAggregateArgs = {
  distinct_on?: InputMaybe<Array<PaymentMethods_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<PaymentMethods_Order_By>>;
  where?: InputMaybe<PaymentMethods_Bool_Exp>;
};


export type Subscription_RootPaymentMethods_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<PaymentMethods_Stream_Cursor_Input>>;
  where?: InputMaybe<PaymentMethods_Bool_Exp>;
};


export type Subscription_RootPlanArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootPlansArgs = {
  distinct_on?: InputMaybe<Array<Plans_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Plans_Order_By>>;
  where?: InputMaybe<Plans_Bool_Exp>;
};


export type Subscription_RootPlansAggregateArgs = {
  distinct_on?: InputMaybe<Array<Plans_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Plans_Order_By>>;
  where?: InputMaybe<Plans_Bool_Exp>;
};


export type Subscription_RootPlans_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Plans_Stream_Cursor_Input>>;
  where?: InputMaybe<Plans_Bool_Exp>;
};


export type Subscription_RootRegion_TypeArgs = {
  distinct_on?: InputMaybe<Array<Region_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Region_Type_Order_By>>;
  where?: InputMaybe<Region_Type_Bool_Exp>;
};


export type Subscription_RootRegion_Type_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Region_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Region_Type_Order_By>>;
  where?: InputMaybe<Region_Type_Bool_Exp>;
};


export type Subscription_RootRegion_Type_By_PkArgs = {
  type: Scalars['String'];
};


export type Subscription_RootRegion_Type_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Region_Type_Stream_Cursor_Input>>;
  where?: InputMaybe<Region_Type_Bool_Exp>;
};


export type Subscription_RootRegionsArgs = {
  distinct_on?: InputMaybe<Array<Regions_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Regions_Order_By>>;
  where?: InputMaybe<Regions_Bool_Exp>;
};


export type Subscription_RootRegionsAllowedOrganizationArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootRegionsAllowedOrganizationsArgs = {
  distinct_on?: InputMaybe<Array<Regions_Allowed_Organization_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Regions_Allowed_Organization_Order_By>>;
  where?: InputMaybe<Regions_Allowed_Organization_Bool_Exp>;
};


export type Subscription_RootRegionsAllowedOrganizationsAggregateArgs = {
  distinct_on?: InputMaybe<Array<Regions_Allowed_Organization_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Regions_Allowed_Organization_Order_By>>;
  where?: InputMaybe<Regions_Allowed_Organization_Bool_Exp>;
};


export type Subscription_RootRegionsAllowedOrganizationsStreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Regions_Allowed_Organization_Stream_Cursor_Input>>;
  where?: InputMaybe<Regions_Allowed_Organization_Bool_Exp>;
};


export type Subscription_RootRegions_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Regions_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Regions_Order_By>>;
  where?: InputMaybe<Regions_Bool_Exp>;
};


export type Subscription_RootRegions_Allowed_Workspace_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Regions_Allowed_Workspace_Stream_Cursor_Input>>;
  where?: InputMaybe<Regions_Allowed_Workspace_Bool_Exp>;
};


export type Subscription_RootRegions_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootRegions_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Regions_Stream_Cursor_Input>>;
  where?: InputMaybe<Regions_Bool_Exp>;
};


export type Subscription_RootRunServiceArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootRunServicesArgs = {
  distinct_on?: InputMaybe<Array<Run_Service_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Run_Service_Order_By>>;
  where?: InputMaybe<Run_Service_Bool_Exp>;
};


export type Subscription_RootRunServicesAggregateArgs = {
  distinct_on?: InputMaybe<Array<Run_Service_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Run_Service_Order_By>>;
  where?: InputMaybe<Run_Service_Bool_Exp>;
};


export type Subscription_RootRun_Service_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Run_Service_Stream_Cursor_Input>>;
  where?: InputMaybe<Run_Service_Bool_Exp>;
};


export type Subscription_RootSelectRegionsAllowedWorkspaceArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootSelectRegionsAllowedWorkspacesArgs = {
  distinct_on?: InputMaybe<Array<Regions_Allowed_Workspace_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Regions_Allowed_Workspace_Order_By>>;
  where?: InputMaybe<Regions_Allowed_Workspace_Bool_Exp>;
};


export type Subscription_RootSelectRegionsAllowedWorkspacesAggregateArgs = {
  distinct_on?: InputMaybe<Array<Regions_Allowed_Workspace_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Regions_Allowed_Workspace_Order_By>>;
  where?: InputMaybe<Regions_Allowed_Workspace_Bool_Exp>;
};


export type Subscription_RootSoftwareTypeArgs = {
  type: Scalars['String'];
};


export type Subscription_RootSoftwareTypesArgs = {
  distinct_on?: InputMaybe<Array<Software_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Software_Type_Order_By>>;
  where?: InputMaybe<Software_Type_Bool_Exp>;
};


export type Subscription_RootSoftwareTypesAggregateArgs = {
  distinct_on?: InputMaybe<Array<Software_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Software_Type_Order_By>>;
  where?: InputMaybe<Software_Type_Bool_Exp>;
};


export type Subscription_RootSoftwareTypesStreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Software_Type_Stream_Cursor_Input>>;
  where?: InputMaybe<Software_Type_Bool_Exp>;
};


export type Subscription_RootSoftwareVersionArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootSoftwareVersionsArgs = {
  distinct_on?: InputMaybe<Array<Software_Versions_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Software_Versions_Order_By>>;
  where?: InputMaybe<Software_Versions_Bool_Exp>;
};


export type Subscription_RootSoftwareVersionsAggregateArgs = {
  distinct_on?: InputMaybe<Array<Software_Versions_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Software_Versions_Order_By>>;
  where?: InputMaybe<Software_Versions_Bool_Exp>;
};


export type Subscription_RootSoftwareVersionsStreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Software_Versions_Stream_Cursor_Input>>;
  where?: InputMaybe<Software_Versions_Bool_Exp>;
};


export type Subscription_RootUserArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootUsersArgs = {
  distinct_on?: InputMaybe<Array<Users_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Users_Order_By>>;
  where?: InputMaybe<Users_Bool_Exp>;
};


export type Subscription_RootUsersAggregateArgs = {
  distinct_on?: InputMaybe<Array<Users_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Users_Order_By>>;
  where?: InputMaybe<Users_Bool_Exp>;
};


export type Subscription_RootUsers_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Users_Stream_Cursor_Input>>;
  where?: InputMaybe<Users_Bool_Exp>;
};


export type Subscription_RootVirusArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootVirus_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Virus_Stream_Cursor_Input>>;
  where?: InputMaybe<Virus_Bool_Exp>;
};


export type Subscription_RootVirusesArgs = {
  distinct_on?: InputMaybe<Array<Virus_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Virus_Order_By>>;
  where?: InputMaybe<Virus_Bool_Exp>;
};


export type Subscription_RootVirusesAggregateArgs = {
  distinct_on?: InputMaybe<Array<Virus_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Virus_Order_By>>;
  where?: InputMaybe<Virus_Bool_Exp>;
};


export type Subscription_RootWorkspaceArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootWorkspaceMemberArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootWorkspaceMemberInviteArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootWorkspaceMemberInvitesArgs = {
  distinct_on?: InputMaybe<Array<WorkspaceMemberInvites_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<WorkspaceMemberInvites_Order_By>>;
  where?: InputMaybe<WorkspaceMemberInvites_Bool_Exp>;
};


export type Subscription_RootWorkspaceMemberInvitesAggregateArgs = {
  distinct_on?: InputMaybe<Array<WorkspaceMemberInvites_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<WorkspaceMemberInvites_Order_By>>;
  where?: InputMaybe<WorkspaceMemberInvites_Bool_Exp>;
};


export type Subscription_RootWorkspaceMemberInvites_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<WorkspaceMemberInvites_Stream_Cursor_Input>>;
  where?: InputMaybe<WorkspaceMemberInvites_Bool_Exp>;
};


export type Subscription_RootWorkspaceMembersArgs = {
  distinct_on?: InputMaybe<Array<WorkspaceMembers_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<WorkspaceMembers_Order_By>>;
  where?: InputMaybe<WorkspaceMembers_Bool_Exp>;
};


export type Subscription_RootWorkspaceMembersAggregateArgs = {
  distinct_on?: InputMaybe<Array<WorkspaceMembers_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<WorkspaceMembers_Order_By>>;
  where?: InputMaybe<WorkspaceMembers_Bool_Exp>;
};


export type Subscription_RootWorkspaceMembers_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<WorkspaceMembers_Stream_Cursor_Input>>;
  where?: InputMaybe<WorkspaceMembers_Bool_Exp>;
};


export type Subscription_RootWorkspacesArgs = {
  distinct_on?: InputMaybe<Array<Workspaces_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Workspaces_Order_By>>;
  where?: InputMaybe<Workspaces_Bool_Exp>;
};


export type Subscription_RootWorkspacesAggregateArgs = {
  distinct_on?: InputMaybe<Array<Workspaces_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Workspaces_Order_By>>;
  where?: InputMaybe<Workspaces_Bool_Exp>;
};


export type Subscription_RootWorkspaces_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<InputMaybe<Workspaces_Stream_Cursor_Input>>;
  where?: InputMaybe<Workspaces_Bool_Exp>;
};

/** Boolean expression to compare columns of type "timestamp". All fields are combined with logical 'AND'. */
export type Timestamp_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['timestamp']>;
  _gt?: InputMaybe<Scalars['timestamp']>;
  _gte?: InputMaybe<Scalars['timestamp']>;
  _in?: InputMaybe<Array<Scalars['timestamp']>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _lt?: InputMaybe<Scalars['timestamp']>;
  _lte?: InputMaybe<Scalars['timestamp']>;
  _neq?: InputMaybe<Scalars['timestamp']>;
  _nin?: InputMaybe<Array<Scalars['timestamp']>>;
};

/** Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'. */
export type Timestamptz_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['timestamptz']>;
  _gt?: InputMaybe<Scalars['timestamptz']>;
  _gte?: InputMaybe<Scalars['timestamptz']>;
  _in?: InputMaybe<Array<Scalars['timestamptz']>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _lt?: InputMaybe<Scalars['timestamptz']>;
  _lte?: InputMaybe<Scalars['timestamptz']>;
  _neq?: InputMaybe<Scalars['timestamptz']>;
  _nin?: InputMaybe<Array<Scalars['timestamptz']>>;
};

/** User account information. Don't modify its structure as Hasura Auth relies on it to function properly. */
export type Users = {
  __typename?: 'users';
  activeMfaType?: Maybe<Scalars['String']>;
  /** An array relationship */
  apps: Array<Apps>;
  /** An aggregate relationship */
  apps_aggregate: Apps_Aggregate;
  avatarUrl: Scalars['String'];
  /** An array relationship */
  cliTokens: Array<CliTokens>;
  /** An aggregate relationship */
  cliTokens_aggregate: CliTokens_Aggregate;
  createdAt: Scalars['timestamptz'];
  /** An array relationship */
  creatorOfWorkspaces: Array<Workspaces>;
  /** An aggregate relationship */
  creatorOfWorkspaces_aggregate: Workspaces_Aggregate;
  currentChallenge?: Maybe<Scalars['String']>;
  defaultRole: Scalars['String'];
  /** An object relationship */
  defaultRoleByRole: AuthRoles;
  disabled: Scalars['Boolean'];
  displayName: Scalars['String'];
  email?: Maybe<Scalars['citext']>;
  emailVerified: Scalars['Boolean'];
  /** An array relationship */
  github_app_installations: Array<GithubAppInstallations>;
  /** An aggregate relationship */
  github_app_installations_aggregate: GithubAppInstallations_Aggregate;
  id: Scalars['uuid'];
  isAnonymous: Scalars['Boolean'];
  lastSeen?: Maybe<Scalars['timestamptz']>;
  locale: Scalars['String'];
  metadata?: Maybe<Scalars['jsonb']>;
  newEmail?: Maybe<Scalars['citext']>;
  /** An array relationship */
  organizationMembership: Array<Organization_Members>;
  /** An aggregate relationship */
  organizationMembership_aggregate: Organization_Members_Aggregate;
  otpHash?: Maybe<Scalars['String']>;
  otpHashExpiresAt: Scalars['timestamptz'];
  otpMethodLastUsed?: Maybe<Scalars['String']>;
  passwordHash?: Maybe<Scalars['String']>;
  /** An array relationship */
  payment_methods: Array<PaymentMethods>;
  /** An aggregate relationship */
  payment_methods_aggregate: PaymentMethods_Aggregate;
  phoneNumber?: Maybe<Scalars['String']>;
  phoneNumberVerified: Scalars['Boolean'];
  /** An array relationship */
  refreshTokens: Array<AuthRefreshTokens>;
  /** An aggregate relationship */
  refreshTokens_aggregate: AuthRefreshTokens_Aggregate;
  /** An object relationship */
  role: AuthRoles;
  /** An array relationship */
  roles: Array<AuthUserRoles>;
  /** An aggregate relationship */
  roles_aggregate: AuthUserRoles_Aggregate;
  /** An array relationship */
  runServices: Array<Run_Service>;
  /** An aggregate relationship */
  runServices_aggregate: Run_Service_Aggregate;
  /** An array relationship */
  securityKeys: Array<AuthUserSecurityKeys>;
  /** An aggregate relationship */
  securityKeys_aggregate: AuthUserSecurityKeys_Aggregate;
  ticket?: Maybe<Scalars['String']>;
  ticketExpiresAt: Scalars['timestamptz'];
  totpSecret?: Maybe<Scalars['String']>;
  updatedAt: Scalars['timestamptz'];
  /** An array relationship */
  userProviders: Array<AuthUserProviders>;
  /** An aggregate relationship */
  userProviders_aggregate: AuthUserProviders_Aggregate;
  /** An array relationship */
  workspaceMemberInvitesByInvitedByUserId: Array<WorkspaceMemberInvites>;
  /** An aggregate relationship */
  workspaceMemberInvitesByInvitedByUserId_aggregate: WorkspaceMemberInvites_Aggregate;
  /** An array relationship */
  workspaceMembers: Array<WorkspaceMembers>;
  /** An aggregate relationship */
  workspaceMembers_aggregate: WorkspaceMembers_Aggregate;
  /** An array relationship */
  workspace_member_invites: Array<WorkspaceMemberInvites>;
  /** An aggregate relationship */
  workspace_member_invites_aggregate: WorkspaceMemberInvites_Aggregate;
};


/** User account information. Don't modify its structure as Hasura Auth relies on it to function properly. */
export type UsersAppsArgs = {
  distinct_on?: InputMaybe<Array<Apps_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Apps_Order_By>>;
  where?: InputMaybe<Apps_Bool_Exp>;
};


/** User account information. Don't modify its structure as Hasura Auth relies on it to function properly. */
export type UsersApps_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Apps_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Apps_Order_By>>;
  where?: InputMaybe<Apps_Bool_Exp>;
};


/** User account information. Don't modify its structure as Hasura Auth relies on it to function properly. */
export type UsersCliTokensArgs = {
  distinct_on?: InputMaybe<Array<CliTokens_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<CliTokens_Order_By>>;
  where?: InputMaybe<CliTokens_Bool_Exp>;
};


/** User account information. Don't modify its structure as Hasura Auth relies on it to function properly. */
export type UsersCliTokens_AggregateArgs = {
  distinct_on?: InputMaybe<Array<CliTokens_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<CliTokens_Order_By>>;
  where?: InputMaybe<CliTokens_Bool_Exp>;
};


/** User account information. Don't modify its structure as Hasura Auth relies on it to function properly. */
export type UsersCreatorOfWorkspacesArgs = {
  distinct_on?: InputMaybe<Array<Workspaces_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Workspaces_Order_By>>;
  where?: InputMaybe<Workspaces_Bool_Exp>;
};


/** User account information. Don't modify its structure as Hasura Auth relies on it to function properly. */
export type UsersCreatorOfWorkspaces_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Workspaces_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Workspaces_Order_By>>;
  where?: InputMaybe<Workspaces_Bool_Exp>;
};


/** User account information. Don't modify its structure as Hasura Auth relies on it to function properly. */
export type UsersGithub_App_InstallationsArgs = {
  distinct_on?: InputMaybe<Array<GithubAppInstallations_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<GithubAppInstallations_Order_By>>;
  where?: InputMaybe<GithubAppInstallations_Bool_Exp>;
};


/** User account information. Don't modify its structure as Hasura Auth relies on it to function properly. */
export type UsersGithub_App_Installations_AggregateArgs = {
  distinct_on?: InputMaybe<Array<GithubAppInstallations_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<GithubAppInstallations_Order_By>>;
  where?: InputMaybe<GithubAppInstallations_Bool_Exp>;
};


/** User account information. Don't modify its structure as Hasura Auth relies on it to function properly. */
export type UsersMetadataArgs = {
  path?: InputMaybe<Scalars['String']>;
};


/** User account information. Don't modify its structure as Hasura Auth relies on it to function properly. */
export type UsersOrganizationMembershipArgs = {
  distinct_on?: InputMaybe<Array<Organization_Members_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Organization_Members_Order_By>>;
  where?: InputMaybe<Organization_Members_Bool_Exp>;
};


/** User account information. Don't modify its structure as Hasura Auth relies on it to function properly. */
export type UsersOrganizationMembership_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Organization_Members_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Organization_Members_Order_By>>;
  where?: InputMaybe<Organization_Members_Bool_Exp>;
};


/** User account information. Don't modify its structure as Hasura Auth relies on it to function properly. */
export type UsersPayment_MethodsArgs = {
  distinct_on?: InputMaybe<Array<PaymentMethods_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<PaymentMethods_Order_By>>;
  where?: InputMaybe<PaymentMethods_Bool_Exp>;
};


/** User account information. Don't modify its structure as Hasura Auth relies on it to function properly. */
export type UsersPayment_Methods_AggregateArgs = {
  distinct_on?: InputMaybe<Array<PaymentMethods_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<PaymentMethods_Order_By>>;
  where?: InputMaybe<PaymentMethods_Bool_Exp>;
};


/** User account information. Don't modify its structure as Hasura Auth relies on it to function properly. */
export type UsersRefreshTokensArgs = {
  distinct_on?: InputMaybe<Array<AuthRefreshTokens_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<AuthRefreshTokens_Order_By>>;
  where?: InputMaybe<AuthRefreshTokens_Bool_Exp>;
};


/** User account information. Don't modify its structure as Hasura Auth relies on it to function properly. */
export type UsersRefreshTokens_AggregateArgs = {
  distinct_on?: InputMaybe<Array<AuthRefreshTokens_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<AuthRefreshTokens_Order_By>>;
  where?: InputMaybe<AuthRefreshTokens_Bool_Exp>;
};


/** User account information. Don't modify its structure as Hasura Auth relies on it to function properly. */
export type UsersRolesArgs = {
  distinct_on?: InputMaybe<Array<AuthUserRoles_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<AuthUserRoles_Order_By>>;
  where?: InputMaybe<AuthUserRoles_Bool_Exp>;
};


/** User account information. Don't modify its structure as Hasura Auth relies on it to function properly. */
export type UsersRoles_AggregateArgs = {
  distinct_on?: InputMaybe<Array<AuthUserRoles_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<AuthUserRoles_Order_By>>;
  where?: InputMaybe<AuthUserRoles_Bool_Exp>;
};


/** User account information. Don't modify its structure as Hasura Auth relies on it to function properly. */
export type UsersRunServicesArgs = {
  distinct_on?: InputMaybe<Array<Run_Service_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Run_Service_Order_By>>;
  where?: InputMaybe<Run_Service_Bool_Exp>;
};


/** User account information. Don't modify its structure as Hasura Auth relies on it to function properly. */
export type UsersRunServices_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Run_Service_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Run_Service_Order_By>>;
  where?: InputMaybe<Run_Service_Bool_Exp>;
};


/** User account information. Don't modify its structure as Hasura Auth relies on it to function properly. */
export type UsersSecurityKeysArgs = {
  distinct_on?: InputMaybe<Array<AuthUserSecurityKeys_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<AuthUserSecurityKeys_Order_By>>;
  where?: InputMaybe<AuthUserSecurityKeys_Bool_Exp>;
};


/** User account information. Don't modify its structure as Hasura Auth relies on it to function properly. */
export type UsersSecurityKeys_AggregateArgs = {
  distinct_on?: InputMaybe<Array<AuthUserSecurityKeys_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<AuthUserSecurityKeys_Order_By>>;
  where?: InputMaybe<AuthUserSecurityKeys_Bool_Exp>;
};


/** User account information. Don't modify its structure as Hasura Auth relies on it to function properly. */
export type UsersUserProvidersArgs = {
  distinct_on?: InputMaybe<Array<AuthUserProviders_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<AuthUserProviders_Order_By>>;
  where?: InputMaybe<AuthUserProviders_Bool_Exp>;
};


/** User account information. Don't modify its structure as Hasura Auth relies on it to function properly. */
export type UsersUserProviders_AggregateArgs = {
  distinct_on?: InputMaybe<Array<AuthUserProviders_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<AuthUserProviders_Order_By>>;
  where?: InputMaybe<AuthUserProviders_Bool_Exp>;
};


/** User account information. Don't modify its structure as Hasura Auth relies on it to function properly. */
export type UsersWorkspaceMemberInvitesByInvitedByUserIdArgs = {
  distinct_on?: InputMaybe<Array<WorkspaceMemberInvites_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<WorkspaceMemberInvites_Order_By>>;
  where?: InputMaybe<WorkspaceMemberInvites_Bool_Exp>;
};


/** User account information. Don't modify its structure as Hasura Auth relies on it to function properly. */
export type UsersWorkspaceMemberInvitesByInvitedByUserId_AggregateArgs = {
  distinct_on?: InputMaybe<Array<WorkspaceMemberInvites_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<WorkspaceMemberInvites_Order_By>>;
  where?: InputMaybe<WorkspaceMemberInvites_Bool_Exp>;
};


/** User account information. Don't modify its structure as Hasura Auth relies on it to function properly. */
export type UsersWorkspaceMembersArgs = {
  distinct_on?: InputMaybe<Array<WorkspaceMembers_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<WorkspaceMembers_Order_By>>;
  where?: InputMaybe<WorkspaceMembers_Bool_Exp>;
};


/** User account information. Don't modify its structure as Hasura Auth relies on it to function properly. */
export type UsersWorkspaceMembers_AggregateArgs = {
  distinct_on?: InputMaybe<Array<WorkspaceMembers_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<WorkspaceMembers_Order_By>>;
  where?: InputMaybe<WorkspaceMembers_Bool_Exp>;
};


/** User account information. Don't modify its structure as Hasura Auth relies on it to function properly. */
export type UsersWorkspace_Member_InvitesArgs = {
  distinct_on?: InputMaybe<Array<WorkspaceMemberInvites_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<WorkspaceMemberInvites_Order_By>>;
  where?: InputMaybe<WorkspaceMemberInvites_Bool_Exp>;
};


/** User account information. Don't modify its structure as Hasura Auth relies on it to function properly. */
export type UsersWorkspace_Member_Invites_AggregateArgs = {
  distinct_on?: InputMaybe<Array<WorkspaceMemberInvites_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<WorkspaceMemberInvites_Order_By>>;
  where?: InputMaybe<WorkspaceMemberInvites_Bool_Exp>;
};

/** aggregated selection of "auth.users" */
export type Users_Aggregate = {
  __typename?: 'users_aggregate';
  aggregate?: Maybe<Users_Aggregate_Fields>;
  nodes: Array<Users>;
};

export type Users_Aggregate_Bool_Exp = {
  bool_and?: InputMaybe<Users_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: InputMaybe<Users_Aggregate_Bool_Exp_Bool_Or>;
  count?: InputMaybe<Users_Aggregate_Bool_Exp_Count>;
};

export type Users_Aggregate_Bool_Exp_Bool_And = {
  arguments: Users_Select_Column_Users_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<Users_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Users_Aggregate_Bool_Exp_Bool_Or = {
  arguments: Users_Select_Column_Users_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<Users_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Users_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Users_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<Users_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "auth.users" */
export type Users_Aggregate_Fields = {
  __typename?: 'users_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Users_Max_Fields>;
  min?: Maybe<Users_Min_Fields>;
};


/** aggregate fields of "auth.users" */
export type Users_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Users_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "auth.users" */
export type Users_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Users_Max_Order_By>;
  min?: InputMaybe<Users_Min_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Users_Append_Input = {
  metadata?: InputMaybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "auth.users" */
export type Users_Arr_Rel_Insert_Input = {
  data: Array<Users_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Users_On_Conflict>;
};

/** Boolean expression to filter rows from the table "auth.users". All fields are combined with a logical 'AND'. */
export type Users_Bool_Exp = {
  _and?: InputMaybe<Array<Users_Bool_Exp>>;
  _not?: InputMaybe<Users_Bool_Exp>;
  _or?: InputMaybe<Array<Users_Bool_Exp>>;
  activeMfaType?: InputMaybe<String_Comparison_Exp>;
  apps?: InputMaybe<Apps_Bool_Exp>;
  apps_aggregate?: InputMaybe<Apps_Aggregate_Bool_Exp>;
  avatarUrl?: InputMaybe<String_Comparison_Exp>;
  cliTokens?: InputMaybe<CliTokens_Bool_Exp>;
  cliTokens_aggregate?: InputMaybe<CliTokens_Aggregate_Bool_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  creatorOfWorkspaces?: InputMaybe<Workspaces_Bool_Exp>;
  creatorOfWorkspaces_aggregate?: InputMaybe<Workspaces_Aggregate_Bool_Exp>;
  currentChallenge?: InputMaybe<String_Comparison_Exp>;
  defaultRole?: InputMaybe<String_Comparison_Exp>;
  defaultRoleByRole?: InputMaybe<AuthRoles_Bool_Exp>;
  disabled?: InputMaybe<Boolean_Comparison_Exp>;
  displayName?: InputMaybe<String_Comparison_Exp>;
  email?: InputMaybe<Citext_Comparison_Exp>;
  emailVerified?: InputMaybe<Boolean_Comparison_Exp>;
  github_app_installations?: InputMaybe<GithubAppInstallations_Bool_Exp>;
  github_app_installations_aggregate?: InputMaybe<GithubAppInstallations_Aggregate_Bool_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  isAnonymous?: InputMaybe<Boolean_Comparison_Exp>;
  lastSeen?: InputMaybe<Timestamptz_Comparison_Exp>;
  locale?: InputMaybe<String_Comparison_Exp>;
  metadata?: InputMaybe<Jsonb_Comparison_Exp>;
  newEmail?: InputMaybe<Citext_Comparison_Exp>;
  organizationMembership?: InputMaybe<Organization_Members_Bool_Exp>;
  organizationMembership_aggregate?: InputMaybe<Organization_Members_Aggregate_Bool_Exp>;
  otpHash?: InputMaybe<String_Comparison_Exp>;
  otpHashExpiresAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  otpMethodLastUsed?: InputMaybe<String_Comparison_Exp>;
  passwordHash?: InputMaybe<String_Comparison_Exp>;
  payment_methods?: InputMaybe<PaymentMethods_Bool_Exp>;
  payment_methods_aggregate?: InputMaybe<PaymentMethods_Aggregate_Bool_Exp>;
  phoneNumber?: InputMaybe<String_Comparison_Exp>;
  phoneNumberVerified?: InputMaybe<Boolean_Comparison_Exp>;
  refreshTokens?: InputMaybe<AuthRefreshTokens_Bool_Exp>;
  refreshTokens_aggregate?: InputMaybe<AuthRefreshTokens_Aggregate_Bool_Exp>;
  role?: InputMaybe<AuthRoles_Bool_Exp>;
  roles?: InputMaybe<AuthUserRoles_Bool_Exp>;
  roles_aggregate?: InputMaybe<AuthUserRoles_Aggregate_Bool_Exp>;
  runServices?: InputMaybe<Run_Service_Bool_Exp>;
  runServices_aggregate?: InputMaybe<Run_Service_Aggregate_Bool_Exp>;
  securityKeys?: InputMaybe<AuthUserSecurityKeys_Bool_Exp>;
  securityKeys_aggregate?: InputMaybe<AuthUserSecurityKeys_Aggregate_Bool_Exp>;
  ticket?: InputMaybe<String_Comparison_Exp>;
  ticketExpiresAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  totpSecret?: InputMaybe<String_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  userProviders?: InputMaybe<AuthUserProviders_Bool_Exp>;
  userProviders_aggregate?: InputMaybe<AuthUserProviders_Aggregate_Bool_Exp>;
  workspaceMemberInvitesByInvitedByUserId?: InputMaybe<WorkspaceMemberInvites_Bool_Exp>;
  workspaceMemberInvitesByInvitedByUserId_aggregate?: InputMaybe<WorkspaceMemberInvites_Aggregate_Bool_Exp>;
  workspaceMembers?: InputMaybe<WorkspaceMembers_Bool_Exp>;
  workspaceMembers_aggregate?: InputMaybe<WorkspaceMembers_Aggregate_Bool_Exp>;
  workspace_member_invites?: InputMaybe<WorkspaceMemberInvites_Bool_Exp>;
  workspace_member_invites_aggregate?: InputMaybe<WorkspaceMemberInvites_Aggregate_Bool_Exp>;
};

/** unique or primary key constraints on table "auth.users" */
export enum Users_Constraint {
  /** unique or primary key constraint on columns "email" */
  UsersEmailKey = 'users_email_key',
  /** unique or primary key constraint on columns "phone_number" */
  UsersPhoneNumberKey = 'users_phone_number_key',
  /** unique or primary key constraint on columns "id" */
  UsersPkey = 'users_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Users_Delete_At_Path_Input = {
  metadata?: InputMaybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Users_Delete_Elem_Input = {
  metadata?: InputMaybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Users_Delete_Key_Input = {
  metadata?: InputMaybe<Scalars['String']>;
};

/** input type for inserting data into table "auth.users" */
export type Users_Insert_Input = {
  activeMfaType?: InputMaybe<Scalars['String']>;
  apps?: InputMaybe<Apps_Arr_Rel_Insert_Input>;
  avatarUrl?: InputMaybe<Scalars['String']>;
  cliTokens?: InputMaybe<CliTokens_Arr_Rel_Insert_Input>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  creatorOfWorkspaces?: InputMaybe<Workspaces_Arr_Rel_Insert_Input>;
  currentChallenge?: InputMaybe<Scalars['String']>;
  defaultRole?: InputMaybe<Scalars['String']>;
  defaultRoleByRole?: InputMaybe<AuthRoles_Obj_Rel_Insert_Input>;
  disabled?: InputMaybe<Scalars['Boolean']>;
  displayName?: InputMaybe<Scalars['String']>;
  email?: InputMaybe<Scalars['citext']>;
  emailVerified?: InputMaybe<Scalars['Boolean']>;
  github_app_installations?: InputMaybe<GithubAppInstallations_Arr_Rel_Insert_Input>;
  id?: InputMaybe<Scalars['uuid']>;
  isAnonymous?: InputMaybe<Scalars['Boolean']>;
  lastSeen?: InputMaybe<Scalars['timestamptz']>;
  locale?: InputMaybe<Scalars['String']>;
  metadata?: InputMaybe<Scalars['jsonb']>;
  newEmail?: InputMaybe<Scalars['citext']>;
  organizationMembership?: InputMaybe<Organization_Members_Arr_Rel_Insert_Input>;
  otpHash?: InputMaybe<Scalars['String']>;
  otpHashExpiresAt?: InputMaybe<Scalars['timestamptz']>;
  otpMethodLastUsed?: InputMaybe<Scalars['String']>;
  passwordHash?: InputMaybe<Scalars['String']>;
  payment_methods?: InputMaybe<PaymentMethods_Arr_Rel_Insert_Input>;
  phoneNumber?: InputMaybe<Scalars['String']>;
  phoneNumberVerified?: InputMaybe<Scalars['Boolean']>;
  refreshTokens?: InputMaybe<AuthRefreshTokens_Arr_Rel_Insert_Input>;
  role?: InputMaybe<AuthRoles_Obj_Rel_Insert_Input>;
  roles?: InputMaybe<AuthUserRoles_Arr_Rel_Insert_Input>;
  runServices?: InputMaybe<Run_Service_Arr_Rel_Insert_Input>;
  securityKeys?: InputMaybe<AuthUserSecurityKeys_Arr_Rel_Insert_Input>;
  ticket?: InputMaybe<Scalars['String']>;
  ticketExpiresAt?: InputMaybe<Scalars['timestamptz']>;
  totpSecret?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userProviders?: InputMaybe<AuthUserProviders_Arr_Rel_Insert_Input>;
  workspaceMemberInvitesByInvitedByUserId?: InputMaybe<WorkspaceMemberInvites_Arr_Rel_Insert_Input>;
  workspaceMembers?: InputMaybe<WorkspaceMembers_Arr_Rel_Insert_Input>;
  workspace_member_invites?: InputMaybe<WorkspaceMemberInvites_Arr_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Users_Max_Fields = {
  __typename?: 'users_max_fields';
  activeMfaType?: Maybe<Scalars['String']>;
  avatarUrl?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  currentChallenge?: Maybe<Scalars['String']>;
  defaultRole?: Maybe<Scalars['String']>;
  displayName?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['citext']>;
  id?: Maybe<Scalars['uuid']>;
  lastSeen?: Maybe<Scalars['timestamptz']>;
  locale?: Maybe<Scalars['String']>;
  newEmail?: Maybe<Scalars['citext']>;
  otpHash?: Maybe<Scalars['String']>;
  otpHashExpiresAt?: Maybe<Scalars['timestamptz']>;
  otpMethodLastUsed?: Maybe<Scalars['String']>;
  passwordHash?: Maybe<Scalars['String']>;
  phoneNumber?: Maybe<Scalars['String']>;
  ticket?: Maybe<Scalars['String']>;
  ticketExpiresAt?: Maybe<Scalars['timestamptz']>;
  totpSecret?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "auth.users" */
export type Users_Max_Order_By = {
  activeMfaType?: InputMaybe<Order_By>;
  avatarUrl?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  currentChallenge?: InputMaybe<Order_By>;
  defaultRole?: InputMaybe<Order_By>;
  displayName?: InputMaybe<Order_By>;
  email?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  lastSeen?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  newEmail?: InputMaybe<Order_By>;
  otpHash?: InputMaybe<Order_By>;
  otpHashExpiresAt?: InputMaybe<Order_By>;
  otpMethodLastUsed?: InputMaybe<Order_By>;
  passwordHash?: InputMaybe<Order_By>;
  phoneNumber?: InputMaybe<Order_By>;
  ticket?: InputMaybe<Order_By>;
  ticketExpiresAt?: InputMaybe<Order_By>;
  totpSecret?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Users_Min_Fields = {
  __typename?: 'users_min_fields';
  activeMfaType?: Maybe<Scalars['String']>;
  avatarUrl?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  currentChallenge?: Maybe<Scalars['String']>;
  defaultRole?: Maybe<Scalars['String']>;
  displayName?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['citext']>;
  id?: Maybe<Scalars['uuid']>;
  lastSeen?: Maybe<Scalars['timestamptz']>;
  locale?: Maybe<Scalars['String']>;
  newEmail?: Maybe<Scalars['citext']>;
  otpHash?: Maybe<Scalars['String']>;
  otpHashExpiresAt?: Maybe<Scalars['timestamptz']>;
  otpMethodLastUsed?: Maybe<Scalars['String']>;
  passwordHash?: Maybe<Scalars['String']>;
  phoneNumber?: Maybe<Scalars['String']>;
  ticket?: Maybe<Scalars['String']>;
  ticketExpiresAt?: Maybe<Scalars['timestamptz']>;
  totpSecret?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "auth.users" */
export type Users_Min_Order_By = {
  activeMfaType?: InputMaybe<Order_By>;
  avatarUrl?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  currentChallenge?: InputMaybe<Order_By>;
  defaultRole?: InputMaybe<Order_By>;
  displayName?: InputMaybe<Order_By>;
  email?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  lastSeen?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  newEmail?: InputMaybe<Order_By>;
  otpHash?: InputMaybe<Order_By>;
  otpHashExpiresAt?: InputMaybe<Order_By>;
  otpMethodLastUsed?: InputMaybe<Order_By>;
  passwordHash?: InputMaybe<Order_By>;
  phoneNumber?: InputMaybe<Order_By>;
  ticket?: InputMaybe<Order_By>;
  ticketExpiresAt?: InputMaybe<Order_By>;
  totpSecret?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "auth.users" */
export type Users_Mutation_Response = {
  __typename?: 'users_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Users>;
};

/** input type for inserting object relation for remote table "auth.users" */
export type Users_Obj_Rel_Insert_Input = {
  data: Users_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Users_On_Conflict>;
};

/** on_conflict condition type for table "auth.users" */
export type Users_On_Conflict = {
  constraint: Users_Constraint;
  update_columns?: Array<Users_Update_Column>;
  where?: InputMaybe<Users_Bool_Exp>;
};

/** Ordering options when selecting data from "auth.users". */
export type Users_Order_By = {
  activeMfaType?: InputMaybe<Order_By>;
  apps_aggregate?: InputMaybe<Apps_Aggregate_Order_By>;
  avatarUrl?: InputMaybe<Order_By>;
  cliTokens_aggregate?: InputMaybe<CliTokens_Aggregate_Order_By>;
  createdAt?: InputMaybe<Order_By>;
  creatorOfWorkspaces_aggregate?: InputMaybe<Workspaces_Aggregate_Order_By>;
  currentChallenge?: InputMaybe<Order_By>;
  defaultRole?: InputMaybe<Order_By>;
  defaultRoleByRole?: InputMaybe<AuthRoles_Order_By>;
  disabled?: InputMaybe<Order_By>;
  displayName?: InputMaybe<Order_By>;
  email?: InputMaybe<Order_By>;
  emailVerified?: InputMaybe<Order_By>;
  github_app_installations_aggregate?: InputMaybe<GithubAppInstallations_Aggregate_Order_By>;
  id?: InputMaybe<Order_By>;
  isAnonymous?: InputMaybe<Order_By>;
  lastSeen?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  metadata?: InputMaybe<Order_By>;
  newEmail?: InputMaybe<Order_By>;
  organizationMembership_aggregate?: InputMaybe<Organization_Members_Aggregate_Order_By>;
  otpHash?: InputMaybe<Order_By>;
  otpHashExpiresAt?: InputMaybe<Order_By>;
  otpMethodLastUsed?: InputMaybe<Order_By>;
  passwordHash?: InputMaybe<Order_By>;
  payment_methods_aggregate?: InputMaybe<PaymentMethods_Aggregate_Order_By>;
  phoneNumber?: InputMaybe<Order_By>;
  phoneNumberVerified?: InputMaybe<Order_By>;
  refreshTokens_aggregate?: InputMaybe<AuthRefreshTokens_Aggregate_Order_By>;
  role?: InputMaybe<AuthRoles_Order_By>;
  roles_aggregate?: InputMaybe<AuthUserRoles_Aggregate_Order_By>;
  runServices_aggregate?: InputMaybe<Run_Service_Aggregate_Order_By>;
  securityKeys_aggregate?: InputMaybe<AuthUserSecurityKeys_Aggregate_Order_By>;
  ticket?: InputMaybe<Order_By>;
  ticketExpiresAt?: InputMaybe<Order_By>;
  totpSecret?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  userProviders_aggregate?: InputMaybe<AuthUserProviders_Aggregate_Order_By>;
  workspaceMemberInvitesByInvitedByUserId_aggregate?: InputMaybe<WorkspaceMemberInvites_Aggregate_Order_By>;
  workspaceMembers_aggregate?: InputMaybe<WorkspaceMembers_Aggregate_Order_By>;
  workspace_member_invites_aggregate?: InputMaybe<WorkspaceMemberInvites_Aggregate_Order_By>;
};

/** primary key columns input for table: auth.users */
export type Users_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Users_Prepend_Input = {
  metadata?: InputMaybe<Scalars['jsonb']>;
};

/** select columns of table "auth.users" */
export enum Users_Select_Column {
  /** column name */
  ActiveMfaType = 'activeMfaType',
  /** column name */
  AvatarUrl = 'avatarUrl',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CurrentChallenge = 'currentChallenge',
  /** column name */
  DefaultRole = 'defaultRole',
  /** column name */
  Disabled = 'disabled',
  /** column name */
  DisplayName = 'displayName',
  /** column name */
  Email = 'email',
  /** column name */
  EmailVerified = 'emailVerified',
  /** column name */
  Id = 'id',
  /** column name */
  IsAnonymous = 'isAnonymous',
  /** column name */
  LastSeen = 'lastSeen',
  /** column name */
  Locale = 'locale',
  /** column name */
  Metadata = 'metadata',
  /** column name */
  NewEmail = 'newEmail',
  /** column name */
  OtpHash = 'otpHash',
  /** column name */
  OtpHashExpiresAt = 'otpHashExpiresAt',
  /** column name */
  OtpMethodLastUsed = 'otpMethodLastUsed',
  /** column name */
  PasswordHash = 'passwordHash',
  /** column name */
  PhoneNumber = 'phoneNumber',
  /** column name */
  PhoneNumberVerified = 'phoneNumberVerified',
  /** column name */
  Ticket = 'ticket',
  /** column name */
  TicketExpiresAt = 'ticketExpiresAt',
  /** column name */
  TotpSecret = 'totpSecret',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** select "users_aggregate_bool_exp_bool_and_arguments_columns" columns of table "auth.users" */
export enum Users_Select_Column_Users_Aggregate_Bool_Exp_Bool_And_Arguments_Columns {
  /** column name */
  Disabled = 'disabled',
  /** column name */
  EmailVerified = 'emailVerified',
  /** column name */
  IsAnonymous = 'isAnonymous',
  /** column name */
  PhoneNumberVerified = 'phoneNumberVerified'
}

/** select "users_aggregate_bool_exp_bool_or_arguments_columns" columns of table "auth.users" */
export enum Users_Select_Column_Users_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns {
  /** column name */
  Disabled = 'disabled',
  /** column name */
  EmailVerified = 'emailVerified',
  /** column name */
  IsAnonymous = 'isAnonymous',
  /** column name */
  PhoneNumberVerified = 'phoneNumberVerified'
}

/** input type for updating data in table "auth.users" */
export type Users_Set_Input = {
  activeMfaType?: InputMaybe<Scalars['String']>;
  avatarUrl?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  currentChallenge?: InputMaybe<Scalars['String']>;
  defaultRole?: InputMaybe<Scalars['String']>;
  disabled?: InputMaybe<Scalars['Boolean']>;
  displayName?: InputMaybe<Scalars['String']>;
  email?: InputMaybe<Scalars['citext']>;
  emailVerified?: InputMaybe<Scalars['Boolean']>;
  id?: InputMaybe<Scalars['uuid']>;
  isAnonymous?: InputMaybe<Scalars['Boolean']>;
  lastSeen?: InputMaybe<Scalars['timestamptz']>;
  locale?: InputMaybe<Scalars['String']>;
  metadata?: InputMaybe<Scalars['jsonb']>;
  newEmail?: InputMaybe<Scalars['citext']>;
  otpHash?: InputMaybe<Scalars['String']>;
  otpHashExpiresAt?: InputMaybe<Scalars['timestamptz']>;
  otpMethodLastUsed?: InputMaybe<Scalars['String']>;
  passwordHash?: InputMaybe<Scalars['String']>;
  phoneNumber?: InputMaybe<Scalars['String']>;
  phoneNumberVerified?: InputMaybe<Scalars['Boolean']>;
  ticket?: InputMaybe<Scalars['String']>;
  ticketExpiresAt?: InputMaybe<Scalars['timestamptz']>;
  totpSecret?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** Streaming cursor of the table "users" */
export type Users_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Users_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Users_Stream_Cursor_Value_Input = {
  activeMfaType?: InputMaybe<Scalars['String']>;
  avatarUrl?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  currentChallenge?: InputMaybe<Scalars['String']>;
  defaultRole?: InputMaybe<Scalars['String']>;
  disabled?: InputMaybe<Scalars['Boolean']>;
  displayName?: InputMaybe<Scalars['String']>;
  email?: InputMaybe<Scalars['citext']>;
  emailVerified?: InputMaybe<Scalars['Boolean']>;
  id?: InputMaybe<Scalars['uuid']>;
  isAnonymous?: InputMaybe<Scalars['Boolean']>;
  lastSeen?: InputMaybe<Scalars['timestamptz']>;
  locale?: InputMaybe<Scalars['String']>;
  metadata?: InputMaybe<Scalars['jsonb']>;
  newEmail?: InputMaybe<Scalars['citext']>;
  otpHash?: InputMaybe<Scalars['String']>;
  otpHashExpiresAt?: InputMaybe<Scalars['timestamptz']>;
  otpMethodLastUsed?: InputMaybe<Scalars['String']>;
  passwordHash?: InputMaybe<Scalars['String']>;
  phoneNumber?: InputMaybe<Scalars['String']>;
  phoneNumberVerified?: InputMaybe<Scalars['Boolean']>;
  ticket?: InputMaybe<Scalars['String']>;
  ticketExpiresAt?: InputMaybe<Scalars['timestamptz']>;
  totpSecret?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** update columns of table "auth.users" */
export enum Users_Update_Column {
  /** column name */
  ActiveMfaType = 'activeMfaType',
  /** column name */
  AvatarUrl = 'avatarUrl',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CurrentChallenge = 'currentChallenge',
  /** column name */
  DefaultRole = 'defaultRole',
  /** column name */
  Disabled = 'disabled',
  /** column name */
  DisplayName = 'displayName',
  /** column name */
  Email = 'email',
  /** column name */
  EmailVerified = 'emailVerified',
  /** column name */
  Id = 'id',
  /** column name */
  IsAnonymous = 'isAnonymous',
  /** column name */
  LastSeen = 'lastSeen',
  /** column name */
  Locale = 'locale',
  /** column name */
  Metadata = 'metadata',
  /** column name */
  NewEmail = 'newEmail',
  /** column name */
  OtpHash = 'otpHash',
  /** column name */
  OtpHashExpiresAt = 'otpHashExpiresAt',
  /** column name */
  OtpMethodLastUsed = 'otpMethodLastUsed',
  /** column name */
  PasswordHash = 'passwordHash',
  /** column name */
  PhoneNumber = 'phoneNumber',
  /** column name */
  PhoneNumberVerified = 'phoneNumberVerified',
  /** column name */
  Ticket = 'ticket',
  /** column name */
  TicketExpiresAt = 'ticketExpiresAt',
  /** column name */
  TotpSecret = 'totpSecret',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type Users_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<Users_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<Users_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<Users_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<Users_Delete_Key_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<Users_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Users_Set_Input>;
  /** filter the rows which have to be updated */
  where: Users_Bool_Exp;
};

/** Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'. */
export type Uuid_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['uuid']>;
  _gt?: InputMaybe<Scalars['uuid']>;
  _gte?: InputMaybe<Scalars['uuid']>;
  _in?: InputMaybe<Array<Scalars['uuid']>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _lt?: InputMaybe<Scalars['uuid']>;
  _lte?: InputMaybe<Scalars['uuid']>;
  _neq?: InputMaybe<Scalars['uuid']>;
  _nin?: InputMaybe<Array<Scalars['uuid']>>;
};

/** columns and relationships of "storage.virus" */
export type Virus = {
  __typename?: 'virus';
  createdAt: Scalars['timestamptz'];
  /** An object relationship */
  file: Files;
  fileId: Scalars['uuid'];
  filename: Scalars['String'];
  id: Scalars['uuid'];
  updatedAt: Scalars['timestamptz'];
  userSession: Scalars['jsonb'];
  virus: Scalars['String'];
};


/** columns and relationships of "storage.virus" */
export type VirusUserSessionArgs = {
  path?: InputMaybe<Scalars['String']>;
};

/** aggregated selection of "storage.virus" */
export type Virus_Aggregate = {
  __typename?: 'virus_aggregate';
  aggregate?: Maybe<Virus_Aggregate_Fields>;
  nodes: Array<Virus>;
};

/** aggregate fields of "storage.virus" */
export type Virus_Aggregate_Fields = {
  __typename?: 'virus_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Virus_Max_Fields>;
  min?: Maybe<Virus_Min_Fields>;
};


/** aggregate fields of "storage.virus" */
export type Virus_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Virus_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Virus_Append_Input = {
  userSession?: InputMaybe<Scalars['jsonb']>;
};

/** Boolean expression to filter rows from the table "storage.virus". All fields are combined with a logical 'AND'. */
export type Virus_Bool_Exp = {
  _and?: InputMaybe<Array<Virus_Bool_Exp>>;
  _not?: InputMaybe<Virus_Bool_Exp>;
  _or?: InputMaybe<Array<Virus_Bool_Exp>>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  file?: InputMaybe<Files_Bool_Exp>;
  fileId?: InputMaybe<Uuid_Comparison_Exp>;
  filename?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  userSession?: InputMaybe<Jsonb_Comparison_Exp>;
  virus?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "storage.virus" */
export enum Virus_Constraint {
  /** unique or primary key constraint on columns "id" */
  VirusPkey = 'virus_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Virus_Delete_At_Path_Input = {
  userSession?: InputMaybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Virus_Delete_Elem_Input = {
  userSession?: InputMaybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Virus_Delete_Key_Input = {
  userSession?: InputMaybe<Scalars['String']>;
};

/** input type for inserting data into table "storage.virus" */
export type Virus_Insert_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  file?: InputMaybe<Files_Obj_Rel_Insert_Input>;
  fileId?: InputMaybe<Scalars['uuid']>;
  filename?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userSession?: InputMaybe<Scalars['jsonb']>;
  virus?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Virus_Max_Fields = {
  __typename?: 'virus_max_fields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  fileId?: Maybe<Scalars['uuid']>;
  filename?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  virus?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Virus_Min_Fields = {
  __typename?: 'virus_min_fields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  fileId?: Maybe<Scalars['uuid']>;
  filename?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  virus?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "storage.virus" */
export type Virus_Mutation_Response = {
  __typename?: 'virus_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Virus>;
};

/** on_conflict condition type for table "storage.virus" */
export type Virus_On_Conflict = {
  constraint: Virus_Constraint;
  update_columns?: Array<Virus_Update_Column>;
  where?: InputMaybe<Virus_Bool_Exp>;
};

/** Ordering options when selecting data from "storage.virus". */
export type Virus_Order_By = {
  createdAt?: InputMaybe<Order_By>;
  file?: InputMaybe<Files_Order_By>;
  fileId?: InputMaybe<Order_By>;
  filename?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  userSession?: InputMaybe<Order_By>;
  virus?: InputMaybe<Order_By>;
};

/** primary key columns input for table: storage.virus */
export type Virus_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Virus_Prepend_Input = {
  userSession?: InputMaybe<Scalars['jsonb']>;
};

/** select columns of table "storage.virus" */
export enum Virus_Select_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  FileId = 'fileId',
  /** column name */
  Filename = 'filename',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserSession = 'userSession',
  /** column name */
  Virus = 'virus'
}

/** input type for updating data in table "storage.virus" */
export type Virus_Set_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  fileId?: InputMaybe<Scalars['uuid']>;
  filename?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userSession?: InputMaybe<Scalars['jsonb']>;
  virus?: InputMaybe<Scalars['String']>;
};

/** Streaming cursor of the table "virus" */
export type Virus_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Virus_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Virus_Stream_Cursor_Value_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  fileId?: InputMaybe<Scalars['uuid']>;
  filename?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userSession?: InputMaybe<Scalars['jsonb']>;
  virus?: InputMaybe<Scalars['String']>;
};

/** update columns of table "storage.virus" */
export enum Virus_Update_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  FileId = 'fileId',
  /** column name */
  Filename = 'filename',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserSession = 'userSession',
  /** column name */
  Virus = 'virus'
}

export type Virus_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<Virus_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<Virus_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<Virus_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<Virus_Delete_Key_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<Virus_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Virus_Set_Input>;
  /** filter the rows which have to be updated */
  where: Virus_Bool_Exp;
};

/** columns and relationships of "workspace_member_invites" */
export type WorkspaceMemberInvites = {
  __typename?: 'workspaceMemberInvites';
  createdAt: Scalars['timestamptz'];
  email: Scalars['citext'];
  id: Scalars['uuid'];
  /** An object relationship */
  invitedByUser: Users;
  invitedByUserId: Scalars['uuid'];
  isAccepted?: Maybe<Scalars['Boolean']>;
  /** owner or member */
  memberType: Scalars['String'];
  updatedAt: Scalars['timestamptz'];
  /** An object relationship */
  userByEmail?: Maybe<Users>;
  /** An object relationship */
  workspace: Workspaces;
  workspaceId: Scalars['uuid'];
};

/** aggregated selection of "workspace_member_invites" */
export type WorkspaceMemberInvites_Aggregate = {
  __typename?: 'workspaceMemberInvites_aggregate';
  aggregate?: Maybe<WorkspaceMemberInvites_Aggregate_Fields>;
  nodes: Array<WorkspaceMemberInvites>;
};

export type WorkspaceMemberInvites_Aggregate_Bool_Exp = {
  bool_and?: InputMaybe<WorkspaceMemberInvites_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: InputMaybe<WorkspaceMemberInvites_Aggregate_Bool_Exp_Bool_Or>;
  count?: InputMaybe<WorkspaceMemberInvites_Aggregate_Bool_Exp_Count>;
};

export type WorkspaceMemberInvites_Aggregate_Bool_Exp_Bool_And = {
  arguments: WorkspaceMemberInvites_Select_Column_WorkspaceMemberInvites_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<WorkspaceMemberInvites_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type WorkspaceMemberInvites_Aggregate_Bool_Exp_Bool_Or = {
  arguments: WorkspaceMemberInvites_Select_Column_WorkspaceMemberInvites_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<WorkspaceMemberInvites_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type WorkspaceMemberInvites_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<WorkspaceMemberInvites_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<WorkspaceMemberInvites_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "workspace_member_invites" */
export type WorkspaceMemberInvites_Aggregate_Fields = {
  __typename?: 'workspaceMemberInvites_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<WorkspaceMemberInvites_Max_Fields>;
  min?: Maybe<WorkspaceMemberInvites_Min_Fields>;
};


/** aggregate fields of "workspace_member_invites" */
export type WorkspaceMemberInvites_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<WorkspaceMemberInvites_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "workspace_member_invites" */
export type WorkspaceMemberInvites_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<WorkspaceMemberInvites_Max_Order_By>;
  min?: InputMaybe<WorkspaceMemberInvites_Min_Order_By>;
};

/** input type for inserting array relation for remote table "workspace_member_invites" */
export type WorkspaceMemberInvites_Arr_Rel_Insert_Input = {
  data: Array<WorkspaceMemberInvites_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<WorkspaceMemberInvites_On_Conflict>;
};

/** Boolean expression to filter rows from the table "workspace_member_invites". All fields are combined with a logical 'AND'. */
export type WorkspaceMemberInvites_Bool_Exp = {
  _and?: InputMaybe<Array<WorkspaceMemberInvites_Bool_Exp>>;
  _not?: InputMaybe<WorkspaceMemberInvites_Bool_Exp>;
  _or?: InputMaybe<Array<WorkspaceMemberInvites_Bool_Exp>>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  email?: InputMaybe<Citext_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  invitedByUser?: InputMaybe<Users_Bool_Exp>;
  invitedByUserId?: InputMaybe<Uuid_Comparison_Exp>;
  isAccepted?: InputMaybe<Boolean_Comparison_Exp>;
  memberType?: InputMaybe<String_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  userByEmail?: InputMaybe<Users_Bool_Exp>;
  workspace?: InputMaybe<Workspaces_Bool_Exp>;
  workspaceId?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "workspace_member_invites" */
export enum WorkspaceMemberInvites_Constraint {
  /** unique or primary key constraint on columns "workspace_id", "email" */
  WorkspaceMemberInvitesEmailWorkspaceIdKey = 'workspace_member_invites_email_workspace_id_key',
  /** unique or primary key constraint on columns "id" */
  WorkspaceMemberInvitesPkey = 'workspace_member_invites_pkey'
}

/** input type for inserting data into table "workspace_member_invites" */
export type WorkspaceMemberInvites_Insert_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  email?: InputMaybe<Scalars['citext']>;
  id?: InputMaybe<Scalars['uuid']>;
  invitedByUser?: InputMaybe<Users_Obj_Rel_Insert_Input>;
  invitedByUserId?: InputMaybe<Scalars['uuid']>;
  isAccepted?: InputMaybe<Scalars['Boolean']>;
  /** owner or member */
  memberType?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userByEmail?: InputMaybe<Users_Obj_Rel_Insert_Input>;
  workspace?: InputMaybe<Workspaces_Obj_Rel_Insert_Input>;
  workspaceId?: InputMaybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type WorkspaceMemberInvites_Max_Fields = {
  __typename?: 'workspaceMemberInvites_max_fields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  email?: Maybe<Scalars['citext']>;
  id?: Maybe<Scalars['uuid']>;
  invitedByUserId?: Maybe<Scalars['uuid']>;
  /** owner or member */
  memberType?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  workspaceId?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "workspace_member_invites" */
export type WorkspaceMemberInvites_Max_Order_By = {
  createdAt?: InputMaybe<Order_By>;
  email?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  invitedByUserId?: InputMaybe<Order_By>;
  /** owner or member */
  memberType?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  workspaceId?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type WorkspaceMemberInvites_Min_Fields = {
  __typename?: 'workspaceMemberInvites_min_fields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  email?: Maybe<Scalars['citext']>;
  id?: Maybe<Scalars['uuid']>;
  invitedByUserId?: Maybe<Scalars['uuid']>;
  /** owner or member */
  memberType?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  workspaceId?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "workspace_member_invites" */
export type WorkspaceMemberInvites_Min_Order_By = {
  createdAt?: InputMaybe<Order_By>;
  email?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  invitedByUserId?: InputMaybe<Order_By>;
  /** owner or member */
  memberType?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  workspaceId?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "workspace_member_invites" */
export type WorkspaceMemberInvites_Mutation_Response = {
  __typename?: 'workspaceMemberInvites_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<WorkspaceMemberInvites>;
};

/** on_conflict condition type for table "workspace_member_invites" */
export type WorkspaceMemberInvites_On_Conflict = {
  constraint: WorkspaceMemberInvites_Constraint;
  update_columns?: Array<WorkspaceMemberInvites_Update_Column>;
  where?: InputMaybe<WorkspaceMemberInvites_Bool_Exp>;
};

/** Ordering options when selecting data from "workspace_member_invites". */
export type WorkspaceMemberInvites_Order_By = {
  createdAt?: InputMaybe<Order_By>;
  email?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  invitedByUser?: InputMaybe<Users_Order_By>;
  invitedByUserId?: InputMaybe<Order_By>;
  isAccepted?: InputMaybe<Order_By>;
  memberType?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  userByEmail?: InputMaybe<Users_Order_By>;
  workspace?: InputMaybe<Workspaces_Order_By>;
  workspaceId?: InputMaybe<Order_By>;
};

/** primary key columns input for table: workspace_member_invites */
export type WorkspaceMemberInvites_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "workspace_member_invites" */
export enum WorkspaceMemberInvites_Select_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Email = 'email',
  /** column name */
  Id = 'id',
  /** column name */
  InvitedByUserId = 'invitedByUserId',
  /** column name */
  IsAccepted = 'isAccepted',
  /** column name */
  MemberType = 'memberType',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  WorkspaceId = 'workspaceId'
}

/** select "workspaceMemberInvites_aggregate_bool_exp_bool_and_arguments_columns" columns of table "workspace_member_invites" */
export enum WorkspaceMemberInvites_Select_Column_WorkspaceMemberInvites_Aggregate_Bool_Exp_Bool_And_Arguments_Columns {
  /** column name */
  IsAccepted = 'isAccepted'
}

/** select "workspaceMemberInvites_aggregate_bool_exp_bool_or_arguments_columns" columns of table "workspace_member_invites" */
export enum WorkspaceMemberInvites_Select_Column_WorkspaceMemberInvites_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns {
  /** column name */
  IsAccepted = 'isAccepted'
}

/** input type for updating data in table "workspace_member_invites" */
export type WorkspaceMemberInvites_Set_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  email?: InputMaybe<Scalars['citext']>;
  id?: InputMaybe<Scalars['uuid']>;
  invitedByUserId?: InputMaybe<Scalars['uuid']>;
  isAccepted?: InputMaybe<Scalars['Boolean']>;
  /** owner or member */
  memberType?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  workspaceId?: InputMaybe<Scalars['uuid']>;
};

/** Streaming cursor of the table "workspaceMemberInvites" */
export type WorkspaceMemberInvites_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: WorkspaceMemberInvites_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type WorkspaceMemberInvites_Stream_Cursor_Value_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  email?: InputMaybe<Scalars['citext']>;
  id?: InputMaybe<Scalars['uuid']>;
  invitedByUserId?: InputMaybe<Scalars['uuid']>;
  isAccepted?: InputMaybe<Scalars['Boolean']>;
  /** owner or member */
  memberType?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  workspaceId?: InputMaybe<Scalars['uuid']>;
};

/** update columns of table "workspace_member_invites" */
export enum WorkspaceMemberInvites_Update_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Email = 'email',
  /** column name */
  Id = 'id',
  /** column name */
  InvitedByUserId = 'invitedByUserId',
  /** column name */
  IsAccepted = 'isAccepted',
  /** column name */
  MemberType = 'memberType',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  WorkspaceId = 'workspaceId'
}

export type WorkspaceMemberInvites_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<WorkspaceMemberInvites_Set_Input>;
  /** filter the rows which have to be updated */
  where: WorkspaceMemberInvites_Bool_Exp;
};

/** columns and relationships of "workspace_members" */
export type WorkspaceMembers = {
  __typename?: 'workspaceMembers';
  createdAt: Scalars['timestamptz'];
  id: Scalars['uuid'];
  /** owner or member */
  type: Scalars['String'];
  updatedAt: Scalars['timestamptz'];
  /** An object relationship */
  user: Users;
  userId: Scalars['uuid'];
  /** An object relationship */
  workspace: Workspaces;
  workspaceId: Scalars['uuid'];
};

/** aggregated selection of "workspace_members" */
export type WorkspaceMembers_Aggregate = {
  __typename?: 'workspaceMembers_aggregate';
  aggregate?: Maybe<WorkspaceMembers_Aggregate_Fields>;
  nodes: Array<WorkspaceMembers>;
};

export type WorkspaceMembers_Aggregate_Bool_Exp = {
  count?: InputMaybe<WorkspaceMembers_Aggregate_Bool_Exp_Count>;
};

export type WorkspaceMembers_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<WorkspaceMembers_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<WorkspaceMembers_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "workspace_members" */
export type WorkspaceMembers_Aggregate_Fields = {
  __typename?: 'workspaceMembers_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<WorkspaceMembers_Max_Fields>;
  min?: Maybe<WorkspaceMembers_Min_Fields>;
};


/** aggregate fields of "workspace_members" */
export type WorkspaceMembers_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<WorkspaceMembers_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "workspace_members" */
export type WorkspaceMembers_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<WorkspaceMembers_Max_Order_By>;
  min?: InputMaybe<WorkspaceMembers_Min_Order_By>;
};

/** input type for inserting array relation for remote table "workspace_members" */
export type WorkspaceMembers_Arr_Rel_Insert_Input = {
  data: Array<WorkspaceMembers_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<WorkspaceMembers_On_Conflict>;
};

/** Boolean expression to filter rows from the table "workspace_members". All fields are combined with a logical 'AND'. */
export type WorkspaceMembers_Bool_Exp = {
  _and?: InputMaybe<Array<WorkspaceMembers_Bool_Exp>>;
  _not?: InputMaybe<WorkspaceMembers_Bool_Exp>;
  _or?: InputMaybe<Array<WorkspaceMembers_Bool_Exp>>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  type?: InputMaybe<String_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  user?: InputMaybe<Users_Bool_Exp>;
  userId?: InputMaybe<Uuid_Comparison_Exp>;
  workspace?: InputMaybe<Workspaces_Bool_Exp>;
  workspaceId?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "workspace_members" */
export enum WorkspaceMembers_Constraint {
  /** unique or primary key constraint on columns "id" */
  WorkspaceMembersPkey = 'workspace_members_pkey',
  /** unique or primary key constraint on columns "workspace_id", "user_id" */
  WorkspaceMembersUserIdWorkspaceIdKey = 'workspace_members_user_id_workspace_id_key'
}

/** input type for inserting data into table "workspace_members" */
export type WorkspaceMembers_Insert_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  /** owner or member */
  type?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  user?: InputMaybe<Users_Obj_Rel_Insert_Input>;
  userId?: InputMaybe<Scalars['uuid']>;
  workspace?: InputMaybe<Workspaces_Obj_Rel_Insert_Input>;
  workspaceId?: InputMaybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type WorkspaceMembers_Max_Fields = {
  __typename?: 'workspaceMembers_max_fields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  /** owner or member */
  type?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userId?: Maybe<Scalars['uuid']>;
  workspaceId?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "workspace_members" */
export type WorkspaceMembers_Max_Order_By = {
  createdAt?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  /** owner or member */
  type?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  userId?: InputMaybe<Order_By>;
  workspaceId?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type WorkspaceMembers_Min_Fields = {
  __typename?: 'workspaceMembers_min_fields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  /** owner or member */
  type?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  userId?: Maybe<Scalars['uuid']>;
  workspaceId?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "workspace_members" */
export type WorkspaceMembers_Min_Order_By = {
  createdAt?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  /** owner or member */
  type?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  userId?: InputMaybe<Order_By>;
  workspaceId?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "workspace_members" */
export type WorkspaceMembers_Mutation_Response = {
  __typename?: 'workspaceMembers_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<WorkspaceMembers>;
};

/** on_conflict condition type for table "workspace_members" */
export type WorkspaceMembers_On_Conflict = {
  constraint: WorkspaceMembers_Constraint;
  update_columns?: Array<WorkspaceMembers_Update_Column>;
  where?: InputMaybe<WorkspaceMembers_Bool_Exp>;
};

/** Ordering options when selecting data from "workspace_members". */
export type WorkspaceMembers_Order_By = {
  createdAt?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  type?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  user?: InputMaybe<Users_Order_By>;
  userId?: InputMaybe<Order_By>;
  workspace?: InputMaybe<Workspaces_Order_By>;
  workspaceId?: InputMaybe<Order_By>;
};

/** primary key columns input for table: workspace_members */
export type WorkspaceMembers_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "workspace_members" */
export enum WorkspaceMembers_Select_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId',
  /** column name */
  WorkspaceId = 'workspaceId'
}

/** input type for updating data in table "workspace_members" */
export type WorkspaceMembers_Set_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  /** owner or member */
  type?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userId?: InputMaybe<Scalars['uuid']>;
  workspaceId?: InputMaybe<Scalars['uuid']>;
};

/** Streaming cursor of the table "workspaceMembers" */
export type WorkspaceMembers_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: WorkspaceMembers_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type WorkspaceMembers_Stream_Cursor_Value_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  /** owner or member */
  type?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  userId?: InputMaybe<Scalars['uuid']>;
  workspaceId?: InputMaybe<Scalars['uuid']>;
};

/** update columns of table "workspace_members" */
export enum WorkspaceMembers_Update_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId',
  /** column name */
  WorkspaceId = 'workspaceId'
}

export type WorkspaceMembers_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<WorkspaceMembers_Set_Input>;
  /** filter the rows which have to be updated */
  where: WorkspaceMembers_Bool_Exp;
};

/** columns and relationships of "workspaces" */
export type Workspaces = {
  __typename?: 'workspaces';
  /** City, district, suburb, town, or village. */
  addressCity: Scalars['String'];
  /** An object relationship */
  addressCountry?: Maybe<Countries>;
  /** Two-letter country code (ISO 3166-1 alpha-2). */
  addressCountryCode?: Maybe<Scalars['String']>;
  /** Address line 1 (e.g., street, PO Box, or company name). */
  addressLine1: Scalars['String'];
  /** Address line 2 (e.g., apartment, suite, unit, or building). */
  addressLine2: Scalars['String'];
  /** ZIP or postal code. */
  addressPostalCode: Scalars['String'];
  /** State, county, province, or region. */
  addressState: Scalars['String'];
  /** An object relationship */
  allowedPrivateRegions?: Maybe<Regions_Allowed_Workspace>;
  /** An array relationship */
  apps: Array<Apps>;
  /** An aggregate relationship */
  apps_aggregate: Apps_Aggregate;
  companyName: Scalars['String'];
  createdAt: Scalars['timestamptz'];
  /** An object relationship */
  creatorUser?: Maybe<Users>;
  creatorUserId?: Maybe<Scalars['uuid']>;
  email: Scalars['String'];
  id: Scalars['uuid'];
  name: Scalars['String'];
  /** An object relationship */
  paymentMethod?: Maybe<PaymentMethods>;
  /** An array relationship */
  paymentMethods: Array<PaymentMethods>;
  /** An aggregate relationship */
  paymentMethods_aggregate: PaymentMethods_Aggregate;
  /** An array relationship */
  regions_allowed_workspaces: Array<Regions_Allowed_Workspace>;
  /** An aggregate relationship */
  regions_allowed_workspaces_aggregate: Regions_Allowed_Workspace_Aggregate;
  slug: Scalars['String'];
  stripeCustomerId?: Maybe<Scalars['String']>;
  taxIdType: Scalars['String'];
  taxIdValue: Scalars['String'];
  updatedAt: Scalars['timestamptz'];
  /** An array relationship */
  workspaceMemberInvites: Array<WorkspaceMemberInvites>;
  /** An aggregate relationship */
  workspaceMemberInvites_aggregate: WorkspaceMemberInvites_Aggregate;
  /** An array relationship */
  workspaceMembers: Array<WorkspaceMembers>;
  /** An aggregate relationship */
  workspaceMembers_aggregate: WorkspaceMembers_Aggregate;
};


/** columns and relationships of "workspaces" */
export type WorkspacesAppsArgs = {
  distinct_on?: InputMaybe<Array<Apps_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Apps_Order_By>>;
  where?: InputMaybe<Apps_Bool_Exp>;
};


/** columns and relationships of "workspaces" */
export type WorkspacesApps_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Apps_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Apps_Order_By>>;
  where?: InputMaybe<Apps_Bool_Exp>;
};


/** columns and relationships of "workspaces" */
export type WorkspacesPaymentMethodsArgs = {
  distinct_on?: InputMaybe<Array<PaymentMethods_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<PaymentMethods_Order_By>>;
  where?: InputMaybe<PaymentMethods_Bool_Exp>;
};


/** columns and relationships of "workspaces" */
export type WorkspacesPaymentMethods_AggregateArgs = {
  distinct_on?: InputMaybe<Array<PaymentMethods_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<PaymentMethods_Order_By>>;
  where?: InputMaybe<PaymentMethods_Bool_Exp>;
};


/** columns and relationships of "workspaces" */
export type WorkspacesRegions_Allowed_WorkspacesArgs = {
  distinct_on?: InputMaybe<Array<Regions_Allowed_Workspace_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Regions_Allowed_Workspace_Order_By>>;
  where?: InputMaybe<Regions_Allowed_Workspace_Bool_Exp>;
};


/** columns and relationships of "workspaces" */
export type WorkspacesRegions_Allowed_Workspaces_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Regions_Allowed_Workspace_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Regions_Allowed_Workspace_Order_By>>;
  where?: InputMaybe<Regions_Allowed_Workspace_Bool_Exp>;
};


/** columns and relationships of "workspaces" */
export type WorkspacesWorkspaceMemberInvitesArgs = {
  distinct_on?: InputMaybe<Array<WorkspaceMemberInvites_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<WorkspaceMemberInvites_Order_By>>;
  where?: InputMaybe<WorkspaceMemberInvites_Bool_Exp>;
};


/** columns and relationships of "workspaces" */
export type WorkspacesWorkspaceMemberInvites_AggregateArgs = {
  distinct_on?: InputMaybe<Array<WorkspaceMemberInvites_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<WorkspaceMemberInvites_Order_By>>;
  where?: InputMaybe<WorkspaceMemberInvites_Bool_Exp>;
};


/** columns and relationships of "workspaces" */
export type WorkspacesWorkspaceMembersArgs = {
  distinct_on?: InputMaybe<Array<WorkspaceMembers_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<WorkspaceMembers_Order_By>>;
  where?: InputMaybe<WorkspaceMembers_Bool_Exp>;
};


/** columns and relationships of "workspaces" */
export type WorkspacesWorkspaceMembers_AggregateArgs = {
  distinct_on?: InputMaybe<Array<WorkspaceMembers_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<WorkspaceMembers_Order_By>>;
  where?: InputMaybe<WorkspaceMembers_Bool_Exp>;
};

/** aggregated selection of "workspaces" */
export type Workspaces_Aggregate = {
  __typename?: 'workspaces_aggregate';
  aggregate?: Maybe<Workspaces_Aggregate_Fields>;
  nodes: Array<Workspaces>;
};

export type Workspaces_Aggregate_Bool_Exp = {
  count?: InputMaybe<Workspaces_Aggregate_Bool_Exp_Count>;
};

export type Workspaces_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Workspaces_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
  filter?: InputMaybe<Workspaces_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "workspaces" */
export type Workspaces_Aggregate_Fields = {
  __typename?: 'workspaces_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Workspaces_Max_Fields>;
  min?: Maybe<Workspaces_Min_Fields>;
};


/** aggregate fields of "workspaces" */
export type Workspaces_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Workspaces_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "workspaces" */
export type Workspaces_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Workspaces_Max_Order_By>;
  min?: InputMaybe<Workspaces_Min_Order_By>;
};

/** input type for inserting array relation for remote table "workspaces" */
export type Workspaces_Arr_Rel_Insert_Input = {
  data: Array<Workspaces_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Workspaces_On_Conflict>;
};

/** Boolean expression to filter rows from the table "workspaces". All fields are combined with a logical 'AND'. */
export type Workspaces_Bool_Exp = {
  _and?: InputMaybe<Array<Workspaces_Bool_Exp>>;
  _not?: InputMaybe<Workspaces_Bool_Exp>;
  _or?: InputMaybe<Array<Workspaces_Bool_Exp>>;
  addressCity?: InputMaybe<String_Comparison_Exp>;
  addressCountry?: InputMaybe<Countries_Bool_Exp>;
  addressCountryCode?: InputMaybe<String_Comparison_Exp>;
  addressLine1?: InputMaybe<String_Comparison_Exp>;
  addressLine2?: InputMaybe<String_Comparison_Exp>;
  addressPostalCode?: InputMaybe<String_Comparison_Exp>;
  addressState?: InputMaybe<String_Comparison_Exp>;
  allowedPrivateRegions?: InputMaybe<Regions_Allowed_Workspace_Bool_Exp>;
  apps?: InputMaybe<Apps_Bool_Exp>;
  apps_aggregate?: InputMaybe<Apps_Aggregate_Bool_Exp>;
  companyName?: InputMaybe<String_Comparison_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  creatorUser?: InputMaybe<Users_Bool_Exp>;
  creatorUserId?: InputMaybe<Uuid_Comparison_Exp>;
  email?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  paymentMethod?: InputMaybe<PaymentMethods_Bool_Exp>;
  paymentMethods?: InputMaybe<PaymentMethods_Bool_Exp>;
  paymentMethods_aggregate?: InputMaybe<PaymentMethods_Aggregate_Bool_Exp>;
  regions_allowed_workspaces?: InputMaybe<Regions_Allowed_Workspace_Bool_Exp>;
  regions_allowed_workspaces_aggregate?: InputMaybe<Regions_Allowed_Workspace_Aggregate_Bool_Exp>;
  slug?: InputMaybe<String_Comparison_Exp>;
  stripeCustomerId?: InputMaybe<String_Comparison_Exp>;
  taxIdType?: InputMaybe<String_Comparison_Exp>;
  taxIdValue?: InputMaybe<String_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  workspaceMemberInvites?: InputMaybe<WorkspaceMemberInvites_Bool_Exp>;
  workspaceMemberInvites_aggregate?: InputMaybe<WorkspaceMemberInvites_Aggregate_Bool_Exp>;
  workspaceMembers?: InputMaybe<WorkspaceMembers_Bool_Exp>;
  workspaceMembers_aggregate?: InputMaybe<WorkspaceMembers_Aggregate_Bool_Exp>;
};

/** unique or primary key constraints on table "workspaces" */
export enum Workspaces_Constraint {
  /** unique or primary key constraint on columns "id" */
  WorkspacesPkey = 'workspaces_pkey',
  /** unique or primary key constraint on columns "slug" */
  WorkspacesSlugKey = 'workspaces_slug_key'
}

/** input type for inserting data into table "workspaces" */
export type Workspaces_Insert_Input = {
  /** City, district, suburb, town, or village. */
  addressCity?: InputMaybe<Scalars['String']>;
  addressCountry?: InputMaybe<Countries_Obj_Rel_Insert_Input>;
  /** Two-letter country code (ISO 3166-1 alpha-2). */
  addressCountryCode?: InputMaybe<Scalars['String']>;
  /** Address line 1 (e.g., street, PO Box, or company name). */
  addressLine1?: InputMaybe<Scalars['String']>;
  /** Address line 2 (e.g., apartment, suite, unit, or building). */
  addressLine2?: InputMaybe<Scalars['String']>;
  /** ZIP or postal code. */
  addressPostalCode?: InputMaybe<Scalars['String']>;
  /** State, county, province, or region. */
  addressState?: InputMaybe<Scalars['String']>;
  allowedPrivateRegions?: InputMaybe<Regions_Allowed_Workspace_Obj_Rel_Insert_Input>;
  apps?: InputMaybe<Apps_Arr_Rel_Insert_Input>;
  companyName?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  creatorUser?: InputMaybe<Users_Obj_Rel_Insert_Input>;
  creatorUserId?: InputMaybe<Scalars['uuid']>;
  email?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  name?: InputMaybe<Scalars['String']>;
  paymentMethod?: InputMaybe<PaymentMethods_Obj_Rel_Insert_Input>;
  paymentMethods?: InputMaybe<PaymentMethods_Arr_Rel_Insert_Input>;
  regions_allowed_workspaces?: InputMaybe<Regions_Allowed_Workspace_Arr_Rel_Insert_Input>;
  slug?: InputMaybe<Scalars['String']>;
  stripeCustomerId?: InputMaybe<Scalars['String']>;
  taxIdType?: InputMaybe<Scalars['String']>;
  taxIdValue?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  workspaceMemberInvites?: InputMaybe<WorkspaceMemberInvites_Arr_Rel_Insert_Input>;
  workspaceMembers?: InputMaybe<WorkspaceMembers_Arr_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Workspaces_Max_Fields = {
  __typename?: 'workspaces_max_fields';
  /** City, district, suburb, town, or village. */
  addressCity?: Maybe<Scalars['String']>;
  /** Two-letter country code (ISO 3166-1 alpha-2). */
  addressCountryCode?: Maybe<Scalars['String']>;
  /** Address line 1 (e.g., street, PO Box, or company name). */
  addressLine1?: Maybe<Scalars['String']>;
  /** Address line 2 (e.g., apartment, suite, unit, or building). */
  addressLine2?: Maybe<Scalars['String']>;
  /** ZIP or postal code. */
  addressPostalCode?: Maybe<Scalars['String']>;
  /** State, county, province, or region. */
  addressState?: Maybe<Scalars['String']>;
  companyName?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  creatorUserId?: Maybe<Scalars['uuid']>;
  email?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
  slug?: Maybe<Scalars['String']>;
  stripeCustomerId?: Maybe<Scalars['String']>;
  taxIdType?: Maybe<Scalars['String']>;
  taxIdValue?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "workspaces" */
export type Workspaces_Max_Order_By = {
  /** City, district, suburb, town, or village. */
  addressCity?: InputMaybe<Order_By>;
  /** Two-letter country code (ISO 3166-1 alpha-2). */
  addressCountryCode?: InputMaybe<Order_By>;
  /** Address line 1 (e.g., street, PO Box, or company name). */
  addressLine1?: InputMaybe<Order_By>;
  /** Address line 2 (e.g., apartment, suite, unit, or building). */
  addressLine2?: InputMaybe<Order_By>;
  /** ZIP or postal code. */
  addressPostalCode?: InputMaybe<Order_By>;
  /** State, county, province, or region. */
  addressState?: InputMaybe<Order_By>;
  companyName?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  creatorUserId?: InputMaybe<Order_By>;
  email?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  slug?: InputMaybe<Order_By>;
  stripeCustomerId?: InputMaybe<Order_By>;
  taxIdType?: InputMaybe<Order_By>;
  taxIdValue?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Workspaces_Min_Fields = {
  __typename?: 'workspaces_min_fields';
  /** City, district, suburb, town, or village. */
  addressCity?: Maybe<Scalars['String']>;
  /** Two-letter country code (ISO 3166-1 alpha-2). */
  addressCountryCode?: Maybe<Scalars['String']>;
  /** Address line 1 (e.g., street, PO Box, or company name). */
  addressLine1?: Maybe<Scalars['String']>;
  /** Address line 2 (e.g., apartment, suite, unit, or building). */
  addressLine2?: Maybe<Scalars['String']>;
  /** ZIP or postal code. */
  addressPostalCode?: Maybe<Scalars['String']>;
  /** State, county, province, or region. */
  addressState?: Maybe<Scalars['String']>;
  companyName?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  creatorUserId?: Maybe<Scalars['uuid']>;
  email?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
  slug?: Maybe<Scalars['String']>;
  stripeCustomerId?: Maybe<Scalars['String']>;
  taxIdType?: Maybe<Scalars['String']>;
  taxIdValue?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "workspaces" */
export type Workspaces_Min_Order_By = {
  /** City, district, suburb, town, or village. */
  addressCity?: InputMaybe<Order_By>;
  /** Two-letter country code (ISO 3166-1 alpha-2). */
  addressCountryCode?: InputMaybe<Order_By>;
  /** Address line 1 (e.g., street, PO Box, or company name). */
  addressLine1?: InputMaybe<Order_By>;
  /** Address line 2 (e.g., apartment, suite, unit, or building). */
  addressLine2?: InputMaybe<Order_By>;
  /** ZIP or postal code. */
  addressPostalCode?: InputMaybe<Order_By>;
  /** State, county, province, or region. */
  addressState?: InputMaybe<Order_By>;
  companyName?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  creatorUserId?: InputMaybe<Order_By>;
  email?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  slug?: InputMaybe<Order_By>;
  stripeCustomerId?: InputMaybe<Order_By>;
  taxIdType?: InputMaybe<Order_By>;
  taxIdValue?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "workspaces" */
export type Workspaces_Mutation_Response = {
  __typename?: 'workspaces_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Workspaces>;
};

/** input type for inserting object relation for remote table "workspaces" */
export type Workspaces_Obj_Rel_Insert_Input = {
  data: Workspaces_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Workspaces_On_Conflict>;
};

/** on_conflict condition type for table "workspaces" */
export type Workspaces_On_Conflict = {
  constraint: Workspaces_Constraint;
  update_columns?: Array<Workspaces_Update_Column>;
  where?: InputMaybe<Workspaces_Bool_Exp>;
};

/** Ordering options when selecting data from "workspaces". */
export type Workspaces_Order_By = {
  addressCity?: InputMaybe<Order_By>;
  addressCountry?: InputMaybe<Countries_Order_By>;
  addressCountryCode?: InputMaybe<Order_By>;
  addressLine1?: InputMaybe<Order_By>;
  addressLine2?: InputMaybe<Order_By>;
  addressPostalCode?: InputMaybe<Order_By>;
  addressState?: InputMaybe<Order_By>;
  allowedPrivateRegions?: InputMaybe<Regions_Allowed_Workspace_Order_By>;
  apps_aggregate?: InputMaybe<Apps_Aggregate_Order_By>;
  companyName?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  creatorUser?: InputMaybe<Users_Order_By>;
  creatorUserId?: InputMaybe<Order_By>;
  email?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  paymentMethod?: InputMaybe<PaymentMethods_Order_By>;
  paymentMethods_aggregate?: InputMaybe<PaymentMethods_Aggregate_Order_By>;
  regions_allowed_workspaces_aggregate?: InputMaybe<Regions_Allowed_Workspace_Aggregate_Order_By>;
  slug?: InputMaybe<Order_By>;
  stripeCustomerId?: InputMaybe<Order_By>;
  taxIdType?: InputMaybe<Order_By>;
  taxIdValue?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  workspaceMemberInvites_aggregate?: InputMaybe<WorkspaceMemberInvites_Aggregate_Order_By>;
  workspaceMembers_aggregate?: InputMaybe<WorkspaceMembers_Aggregate_Order_By>;
};

/** primary key columns input for table: workspaces */
export type Workspaces_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "workspaces" */
export enum Workspaces_Select_Column {
  /** column name */
  AddressCity = 'addressCity',
  /** column name */
  AddressCountryCode = 'addressCountryCode',
  /** column name */
  AddressLine1 = 'addressLine1',
  /** column name */
  AddressLine2 = 'addressLine2',
  /** column name */
  AddressPostalCode = 'addressPostalCode',
  /** column name */
  AddressState = 'addressState',
  /** column name */
  CompanyName = 'companyName',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatorUserId = 'creatorUserId',
  /** column name */
  Email = 'email',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Slug = 'slug',
  /** column name */
  StripeCustomerId = 'stripeCustomerId',
  /** column name */
  TaxIdType = 'taxIdType',
  /** column name */
  TaxIdValue = 'taxIdValue',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "workspaces" */
export type Workspaces_Set_Input = {
  /** City, district, suburb, town, or village. */
  addressCity?: InputMaybe<Scalars['String']>;
  /** Two-letter country code (ISO 3166-1 alpha-2). */
  addressCountryCode?: InputMaybe<Scalars['String']>;
  /** Address line 1 (e.g., street, PO Box, or company name). */
  addressLine1?: InputMaybe<Scalars['String']>;
  /** Address line 2 (e.g., apartment, suite, unit, or building). */
  addressLine2?: InputMaybe<Scalars['String']>;
  /** ZIP or postal code. */
  addressPostalCode?: InputMaybe<Scalars['String']>;
  /** State, county, province, or region. */
  addressState?: InputMaybe<Scalars['String']>;
  companyName?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  creatorUserId?: InputMaybe<Scalars['uuid']>;
  email?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  name?: InputMaybe<Scalars['String']>;
  slug?: InputMaybe<Scalars['String']>;
  stripeCustomerId?: InputMaybe<Scalars['String']>;
  taxIdType?: InputMaybe<Scalars['String']>;
  taxIdValue?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** Streaming cursor of the table "workspaces" */
export type Workspaces_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Workspaces_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Workspaces_Stream_Cursor_Value_Input = {
  /** City, district, suburb, town, or village. */
  addressCity?: InputMaybe<Scalars['String']>;
  /** Two-letter country code (ISO 3166-1 alpha-2). */
  addressCountryCode?: InputMaybe<Scalars['String']>;
  /** Address line 1 (e.g., street, PO Box, or company name). */
  addressLine1?: InputMaybe<Scalars['String']>;
  /** Address line 2 (e.g., apartment, suite, unit, or building). */
  addressLine2?: InputMaybe<Scalars['String']>;
  /** ZIP or postal code. */
  addressPostalCode?: InputMaybe<Scalars['String']>;
  /** State, county, province, or region. */
  addressState?: InputMaybe<Scalars['String']>;
  companyName?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  creatorUserId?: InputMaybe<Scalars['uuid']>;
  email?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  name?: InputMaybe<Scalars['String']>;
  slug?: InputMaybe<Scalars['String']>;
  stripeCustomerId?: InputMaybe<Scalars['String']>;
  taxIdType?: InputMaybe<Scalars['String']>;
  taxIdValue?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** update columns of table "workspaces" */
export enum Workspaces_Update_Column {
  /** column name */
  AddressCity = 'addressCity',
  /** column name */
  AddressCountryCode = 'addressCountryCode',
  /** column name */
  AddressLine1 = 'addressLine1',
  /** column name */
  AddressLine2 = 'addressLine2',
  /** column name */
  AddressPostalCode = 'addressPostalCode',
  /** column name */
  AddressState = 'addressState',
  /** column name */
  CompanyName = 'companyName',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatorUserId = 'creatorUserId',
  /** column name */
  Email = 'email',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Slug = 'slug',
  /** column name */
  StripeCustomerId = 'stripeCustomerId',
  /** column name */
  TaxIdType = 'taxIdType',
  /** column name */
  TaxIdValue = 'taxIdValue',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type Workspaces_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Workspaces_Set_Input>;
  /** filter the rows which have to be updated */
  where: Workspaces_Bool_Exp;
};

export type DeleteUserAccountMutationVariables = Exact<{
  id: Scalars['uuid'];
}>;


export type DeleteUserAccountMutation = { __typename?: 'mutation_root', deleteUser?: { __typename: 'users' } | null };

export type GetAuthUserProvidersQueryVariables = Exact<{ [key: string]: never; }>;


export type GetAuthUserProvidersQuery = { __typename?: 'query_root', authUserProviders: Array<{ __typename?: 'authUserProviders', id: any, providerId: string }> };

export type GetPersonalAccessTokensQueryVariables = Exact<{ [key: string]: never; }>;


export type GetPersonalAccessTokensQuery = { __typename?: 'query_root', personalAccessTokens: Array<{ __typename?: 'authRefreshTokens', id: any, metadata?: any | null, createdAt: any, expiresAt: any }> };

export type DeletePersonalAccessTokenMutationVariables = Exact<{
  patId: Scalars['uuid'];
}>;


export type DeletePersonalAccessTokenMutation = { __typename?: 'mutation_root', deletePersonalAccessToken?: { __typename?: 'authRefreshTokens', id: any, metadata?: any | null } | null };

export type UpdateUserDisplayNameMutationVariables = Exact<{
  id: Scalars['uuid'];
  displayName: Scalars['String'];
}>;


export type UpdateUserDisplayNameMutation = { __typename?: 'mutation_root', updateUser?: { __typename?: 'users', id: any, displayName: string } | null };

export type GetAiSettingsQueryVariables = Exact<{
  appId: Scalars['uuid'];
}>;


export type GetAiSettingsQuery = { __typename?: 'query_root', config?: { __typename?: 'ConfigConfig', postgres?: { __typename?: 'ConfigPostgres', version?: string | null } | null, ai?: { __typename?: 'ConfigAI', version?: string | null, webhookSecret: string, autoEmbeddings?: { __typename?: 'ConfigAIAutoEmbeddings', synchPeriodMinutes?: any | null } | null, openai: { __typename?: 'ConfigAIOpenai', apiKey: string, organization?: string | null }, resources: { __typename?: 'ConfigAIResources', compute: { __typename?: 'ConfigComputeResources', cpu: any, memory: any } } } | null } | null };

export type GetAuthenticationSettingsQueryVariables = Exact<{
  appId: Scalars['uuid'];
}>;


export type GetAuthenticationSettingsQuery = { __typename?: 'query_root', config?: { __typename: 'ConfigConfig', id: 'ConfigConfig', auth?: { __typename: 'ConfigAuth', version?: string | null, id: 'ConfigAuth', redirections?: { __typename?: 'ConfigAuthRedirections', clientUrl?: any | null, allowedUrls?: Array<string> | null } | null, totp?: { __typename?: 'ConfigAuthTotp', enabled?: boolean | null, issuer?: string | null } | null, signUp?: { __typename?: 'ConfigAuthSignUp', enabled?: boolean | null } | null, session?: { __typename?: 'ConfigAuthSession', accessToken?: { __typename?: 'ConfigAuthSessionAccessToken', expiresIn?: any | null } | null, refreshToken?: { __typename?: 'ConfigAuthSessionRefreshToken', expiresIn?: any | null } | null } | null, resources?: { __typename?: 'ConfigResources', networking?: { __typename?: 'ConfigNetworking', ingresses?: Array<{ __typename?: 'ConfigIngress', fqdn?: Array<string> | null }> | null } | null } | null, user?: { __typename?: 'ConfigAuthUser', email?: { __typename?: 'ConfigAuthUserEmail', allowed?: Array<any> | null, blocked?: Array<any> | null } | null, emailDomains?: { __typename?: 'ConfigAuthUserEmailDomains', allowed?: Array<string> | null, blocked?: Array<string> | null } | null, gravatar?: { __typename?: 'ConfigAuthUserGravatar', enabled?: boolean | null, default?: string | null, rating?: string | null } | null, locale?: { __typename?: 'ConfigAuthUserLocale', allowed?: Array<any> | null, default?: any | null } | null } | null, misc?: { __typename?: 'ConfigAuthMisc', concealErrors?: boolean | null } | null } | null } | null };

export type GetPostgresSettingsQueryVariables = Exact<{
  appId: Scalars['uuid'];
}>;


export type GetPostgresSettingsQuery = { __typename?: 'query_root', systemConfig?: { __typename?: 'ConfigSystemConfig', postgres: { __typename?: 'ConfigSystemConfigPostgres', database: string } } | null, config?: { __typename: 'ConfigConfig', id: 'ConfigConfig', postgres?: { __typename?: 'ConfigPostgres', version?: string | null, resources?: { __typename?: 'ConfigPostgresResources', enablePublicAccess?: boolean | null, storage?: { __typename?: 'ConfigPostgresStorage', capacity: any } | null } | null } | null } | null };

export type ResetDatabasePasswordMutationVariables = Exact<{
  appId: Scalars['String'];
  newPassword: Scalars['String'];
}>;


export type ResetDatabasePasswordMutation = { __typename?: 'mutation_root', resetPostgresPassword: boolean };

export type GetHasuraSettingsQueryVariables = Exact<{
  appId: Scalars['uuid'];
}>;


export type GetHasuraSettingsQuery = { __typename?: 'query_root', config?: { __typename: 'ConfigConfig', id: 'ConfigConfig', hasura: { __typename?: 'ConfigHasura', version?: string | null, settings?: { __typename?: 'ConfigHasuraSettings', enableAllowList?: boolean | null, enableRemoteSchemaPermissions?: boolean | null, enableConsole?: boolean | null, devMode?: boolean | null, corsDomain?: Array<any> | null, enabledAPIs?: Array<any> | null } | null, logs?: { __typename?: 'ConfigHasuraLogs', level?: string | null } | null, events?: { __typename?: 'ConfigHasuraEvents', httpPoolSize?: any | null } | null, resources?: { __typename?: 'ConfigResources', networking?: { __typename?: 'ConfigNetworking', ingresses?: Array<{ __typename?: 'ConfigIngress', fqdn?: Array<string> | null }> | null } | null } | null } } | null };

export type BackupFragment = { __typename?: 'backups', id: any, size: any, createdAt: any, completedAt?: any | null };

export type GetApplicationBackupsQueryVariables = Exact<{
  appId: Scalars['uuid'];
}>;


export type GetApplicationBackupsQuery = { __typename?: 'query_root', app?: { __typename?: 'apps', backups: Array<{ __typename?: 'backups', id: any, size: any, createdAt: any, completedAt?: any | null }> } | null };

export type GetBackupPresignedUrlQueryVariables = Exact<{
  appId: Scalars['String'];
  backupId: Scalars['String'];
  expireInMinutes?: InputMaybe<Scalars['Int']>;
}>;


export type GetBackupPresignedUrlQuery = { __typename?: 'query_root', getBackupPresignedUrl: { __typename?: 'BackupPresignedURL', url: string, expiresAt: any } };

export type ServiceResourcesFragment = { __typename?: 'ConfigConfig', auth?: { __typename?: 'ConfigAuth', resources?: { __typename?: 'ConfigResources', replicas?: any | null, compute?: { __typename?: 'ConfigResourcesCompute', cpu: any, memory: any } | null } | null } | null, hasura: { __typename?: 'ConfigHasura', resources?: { __typename?: 'ConfigResources', replicas?: any | null, compute?: { __typename?: 'ConfigResourcesCompute', cpu: any, memory: any } | null } | null }, postgres?: { __typename?: 'ConfigPostgres', resources?: { __typename?: 'ConfigPostgresResources', replicas?: any | null, compute?: { __typename?: 'ConfigResourcesCompute', cpu: any, memory: any } | null } | null } | null, storage?: { __typename?: 'ConfigStorage', resources?: { __typename?: 'ConfigResources', replicas?: any | null, compute?: { __typename?: 'ConfigResourcesCompute', cpu: any, memory: any } | null } | null } | null };

export type GetResourcesQueryVariables = Exact<{
  appId: Scalars['uuid'];
}>;


export type GetResourcesQuery = { __typename?: 'query_root', config?: { __typename?: 'ConfigConfig', auth?: { __typename?: 'ConfigAuth', resources?: { __typename?: 'ConfigResources', replicas?: any | null, compute?: { __typename?: 'ConfigResourcesCompute', cpu: any, memory: any } | null } | null } | null, hasura: { __typename?: 'ConfigHasura', resources?: { __typename?: 'ConfigResources', replicas?: any | null, compute?: { __typename?: 'ConfigResourcesCompute', cpu: any, memory: any } | null } | null }, postgres?: { __typename?: 'ConfigPostgres', resources?: { __typename?: 'ConfigPostgresResources', replicas?: any | null, compute?: { __typename?: 'ConfigResourcesCompute', cpu: any, memory: any } | null } | null } | null, storage?: { __typename?: 'ConfigStorage', resources?: { __typename?: 'ConfigResources', replicas?: any | null, compute?: { __typename?: 'ConfigResourcesCompute', cpu: any, memory: any } | null } | null } | null } | null };

export type GetServerlessFunctionsSettingsQueryVariables = Exact<{
  appId: Scalars['uuid'];
}>;


export type GetServerlessFunctionsSettingsQuery = { __typename?: 'query_root', config?: { __typename?: 'ConfigConfig', functions?: { __typename?: 'ConfigFunctions', resources?: { __typename?: 'ConfigFunctionsResources', networking?: { __typename?: 'ConfigNetworking', ingresses?: Array<{ __typename?: 'ConfigIngress', fqdn?: Array<string> | null }> | null } | null } | null } | null } | null };

export type GetStorageSettingsQueryVariables = Exact<{
  appId: Scalars['uuid'];
}>;


export type GetStorageSettingsQuery = { __typename?: 'query_root', config?: { __typename: 'ConfigConfig', id: 'ConfigConfig', storage?: { __typename?: 'ConfigStorage', version?: string | null, antivirus?: { __typename?: 'ConfigStorageAntivirus', server?: string | null } | null } | null } | null };

export type DeleteApplicationMutationVariables = Exact<{
  appId: Scalars['uuid'];
}>;


export type DeleteApplicationMutation = { __typename?: 'mutation_root', deleteApp?: { __typename?: 'apps', id: any } | null };

export type GetAllWorkspacesAndProjectsQueryVariables = Exact<{ [key: string]: never; }>;


export type GetAllWorkspacesAndProjectsQuery = { __typename?: 'query_root', workspaces: Array<{ __typename?: 'workspaces', id: any, name: string, slug: string, creatorUserId?: any | null, workspaceMembers: Array<{ __typename?: 'workspaceMembers', id: any, type: string, user: { __typename?: 'users', id: any, email?: any | null, displayName: string } }>, projects: Array<{ __typename?: 'apps', id: any, slug: string, name: string, repositoryProductionBranch: string, subdomain: string, createdAt: any, desiredState: number, nhostBaseFolder: string, config?: { __typename?: 'ConfigConfig', observability: { __typename?: 'ConfigObservability', grafana: { __typename?: 'ConfigGrafana', adminPassword: string } }, hasura: { __typename?: 'ConfigHasura', adminSecret: string, settings?: { __typename?: 'ConfigHasuraSettings', enableConsole?: boolean | null } | null }, ai?: { __typename?: 'ConfigAI', version?: string | null } | null } | null, featureFlags: Array<{ __typename?: 'featureFlags', description: string, id: any, name: string, value: string }>, appStates: Array<{ __typename?: 'appStateHistory', id: any, appId: any, message?: string | null, stateId: number, createdAt: any }>, region: { __typename?: 'regions', id: any, countryCode: string, name: string, domain: string, city: string }, legacyPlan?: { __typename?: 'plans', id: any, name: string, price: number, isFree: boolean, featureMaxDbSize: number } | null, githubRepository?: { __typename?: 'githubRepositories', fullName: string } | null, deployments: Array<{ __typename?: 'deployments', id: any, commitSHA: string, commitMessage?: string | null, commitUserName?: string | null, deploymentStartedAt?: any | null, deploymentEndedAt?: any | null, commitUserAvatarUrl?: string | null, deploymentStatus?: string | null }>, creator?: { __typename?: 'users', id: any, email?: any | null, displayName: string } | null }> }> };

export type GetAppPlanAndGlobalPlansAppFragment = { __typename?: 'apps', id: any, subdomain: string, workspace?: { __typename?: 'workspaces', id: any, paymentMethods: Array<{ __typename?: 'paymentMethods', id: any }> } | null, legacyPlan?: { __typename?: 'plans', id: any, name: string } | null };

export type GetAppPlanAndGlobalPlansPlanFragment = { __typename?: 'plans', id: any, name: string, isFree: boolean, price: number, featureMaxDbSize: number };

export type GetAppPlanAndGlobalPlansQueryVariables = Exact<{
  workspaceSlug: Scalars['String'];
  appSlug: Scalars['String'];
}>;


export type GetAppPlanAndGlobalPlansQuery = { __typename?: 'query_root', apps: Array<{ __typename?: 'apps', id: any, subdomain: string, workspace?: { __typename?: 'workspaces', id: any, paymentMethods: Array<{ __typename?: 'paymentMethods', id: any }> } | null, legacyPlan?: { __typename?: 'plans', id: any, name: string } | null }>, plans: Array<{ __typename?: 'plans', id: any, name: string, isFree: boolean, price: number, featureMaxDbSize: number }> };

export type GetApplicationPlanQueryVariables = Exact<{
  workspace: Scalars['String'];
  slug: Scalars['String'];
}>;


export type GetApplicationPlanQuery = { __typename?: 'query_root', apps: Array<{ __typename?: 'apps', id: any, subdomain: string, legacyPlan?: { __typename?: 'plans', name: string, price: number, upatedAt: any, featureMaxDbSize: number } | null }> };

export type GetApplicationStateQueryVariables = Exact<{
  appId: Scalars['uuid'];
}>;


export type GetApplicationStateQuery = { __typename?: 'query_root', app?: { __typename?: 'apps', id: any, name: string, appStates: Array<{ __typename?: 'appStateHistory', id: any, appId: any, message?: string | null, stateId: number, createdAt: any }> } | null };

export type GetConfiguredVersionsQueryVariables = Exact<{
  appId: Scalars['uuid'];
}>;


export type GetConfiguredVersionsQuery = { __typename?: 'query_root', config?: { __typename?: 'ConfigConfig', auth?: { __typename?: 'ConfigAuth', version?: string | null } | null, postgres?: { __typename?: 'ConfigPostgres', version?: string | null } | null, hasura: { __typename?: 'ConfigHasura', version?: string | null }, ai?: { __typename?: 'ConfigAI', version?: string | null } | null, storage?: { __typename?: 'ConfigStorage', version?: string | null } | null } | null };

export type GetProjectIsLockedQueryVariables = Exact<{
  appId: Scalars['uuid'];
}>;


export type GetProjectIsLockedQuery = { __typename?: 'query_root', app?: { __typename?: 'apps', isLocked?: boolean | null, isLockedReason?: string | null } | null };

export type GetProjectLocalesQueryVariables = Exact<{
  appId: Scalars['uuid'];
}>;


export type GetProjectLocalesQuery = { __typename?: 'query_root', config?: { __typename?: 'ConfigConfig', auth?: { __typename?: 'ConfigAuth', user?: { __typename?: 'ConfigAuthUser', locale?: { __typename?: 'ConfigAuthUserLocale', allowed?: Array<any> | null, default?: any | null } | null } | null } | null } | null };

export type GetProjectMetricsQueryVariables = Exact<{
  appId: Scalars['String'];
  subdomain: Scalars['String'];
  from?: InputMaybe<Scalars['Timestamp']>;
  to?: InputMaybe<Scalars['Timestamp']>;
}>;


export type GetProjectMetricsQuery = { __typename?: 'query_root', logsVolume: { __typename?: 'Metrics', value: any }, cpuSecondsUsage: { __typename?: 'Metrics', value: any }, functionInvocations: { __typename?: 'Metrics', value: any }, functionsDuration: { __typename?: 'Metrics', value: any }, postgresVolumeCapacity: { __typename?: 'Metrics', value: any }, postgresVolumeUsage: { __typename?: 'Metrics', value: any }, totalRequests: { __typename?: 'Metrics', value: any }, egressVolume: { __typename?: 'Metrics', value: any } };

export type GetProjectServicesHealthQueryVariables = Exact<{
  appId: Scalars['String'];
}>;


export type GetProjectServicesHealthQuery = { __typename?: 'query_root', getProjectStatus: { __typename?: 'ProjectStatusResponse', services: Array<{ __typename?: 'ServiceStatus', name: string, state: ServiceState, replicas: Array<{ __typename?: 'ReplicaStatus', ready: boolean, date: any, errors: Array<{ __typename?: 'ContainerError', name: string, lastError: { __typename?: 'LastError', reason: string, exitCode: number, message: string } }> }> }> } };

export type GetRemoteAppRolesQueryVariables = Exact<{ [key: string]: never; }>;


export type GetRemoteAppRolesQuery = { __typename?: 'query_root', authRoles: Array<{ __typename?: 'authRoles', role: string }> };

export type GetWorkspaceAndProjectQueryVariables = Exact<{
  workspaceSlug: Scalars['String'];
  projectSlug?: InputMaybe<Scalars['String']>;
}>;


export type GetWorkspaceAndProjectQuery = { __typename?: 'query_root', workspaces: Array<{ __typename?: 'workspaces', id: any, name: string, slug: string, creatorUserId?: any | null, workspaceMembers: Array<{ __typename?: 'workspaceMembers', id: any, type: string, user: { __typename?: 'users', id: any, email?: any | null, displayName: string } }>, projects: Array<{ __typename?: 'apps', id: any, slug: string, name: string, repositoryProductionBranch: string, subdomain: string, createdAt: any, desiredState: number, nhostBaseFolder: string, config?: { __typename?: 'ConfigConfig', observability: { __typename?: 'ConfigObservability', grafana: { __typename?: 'ConfigGrafana', adminPassword: string } }, hasura: { __typename?: 'ConfigHasura', adminSecret: string, settings?: { __typename?: 'ConfigHasuraSettings', enableConsole?: boolean | null } | null }, ai?: { __typename?: 'ConfigAI', version?: string | null } | null } | null, featureFlags: Array<{ __typename?: 'featureFlags', description: string, id: any, name: string, value: string }>, appStates: Array<{ __typename?: 'appStateHistory', id: any, appId: any, message?: string | null, stateId: number, createdAt: any }>, region: { __typename?: 'regions', id: any, countryCode: string, name: string, domain: string, city: string }, legacyPlan?: { __typename?: 'plans', id: any, name: string, price: number, isFree: boolean, featureMaxDbSize: number } | null, githubRepository?: { __typename?: 'githubRepositories', fullName: string } | null, deployments: Array<{ __typename?: 'deployments', id: any, commitSHA: string, commitMessage?: string | null, commitUserName?: string | null, deploymentStartedAt?: any | null, deploymentEndedAt?: any | null, commitUserAvatarUrl?: string | null, deploymentStatus?: string | null }>, creator?: { __typename?: 'users', id: any, email?: any | null, displayName: string } | null }> }> };

export type InsertApplicationMutationVariables = Exact<{
  app: Apps_Insert_Input;
}>;


export type InsertApplicationMutation = { __typename?: 'mutation_root', insertApp?: { __typename?: 'apps', id: any, name: string, slug: string, workspace?: { __typename?: 'workspaces', id: any, name: string, slug: string } | null } | null };

export type PauseApplicationMutationVariables = Exact<{
  appId: Scalars['uuid'];
}>;


export type PauseApplicationMutation = { __typename?: 'mutation_root', updateApp?: { __typename?: 'apps', id: any } | null };

export type PrefetchNewAppRegionsFragment = { __typename?: 'regions', id: any, city: string, active: boolean, country: { __typename?: 'countries', code: any, name: string } };

export type PrefetchNewAppPlansFragment = { __typename?: 'plans', id: any, name: string, isDefault: boolean, isFree: boolean, price: number, featureBackupEnabled: boolean, featureCustomDomainsEnabled: boolean, featureMaxDbSize: number };

export type PrefetchNewAppWorkspaceFragment = { __typename?: 'workspaces', id: any, name: string, slug: string, paymentMethods: Array<{ __typename?: 'paymentMethods', id: any }> };

export type PrefetchNewAppQueryVariables = Exact<{ [key: string]: never; }>;


export type PrefetchNewAppQuery = { __typename?: 'query_root', regions: Array<{ __typename?: 'regions', id: any, city: string, active: boolean, country: { __typename?: 'countries', code: any, name: string } }>, plans: Array<{ __typename?: 'plans', id: any, name: string, isDefault: boolean, isFree: boolean, price: number, featureBackupEnabled: boolean, featureCustomDomainsEnabled: boolean, featureMaxDbSize: number }>, workspaces: Array<{ __typename?: 'workspaces', id: any, name: string, slug: string, paymentMethods: Array<{ __typename?: 'paymentMethods', id: any }> }> };

export type DnsLookupCnameQueryVariables = Exact<{
  hostname: Scalars['String'];
}>;


export type DnsLookupCnameQuery = { __typename?: 'query_root', dnsLookupCNAME: string };

export type EnvironmentVariableFragment = { __typename?: 'ConfigGlobalEnvironmentVariable', name: string, value: string, id: string };

export type JwtSecretFragment = { __typename?: 'ConfigJWTSecret', issuer?: string | null, key?: string | null, type?: string | null, jwk_url?: any | null, header?: string | null, claims_namespace_path?: string | null, claims_namespace?: string | null, claims_format?: string | null, audience?: string | null, allowed_skew?: any | null };

export type GetEnvironmentVariablesQueryVariables = Exact<{
  appId: Scalars['uuid'];
}>;


export type GetEnvironmentVariablesQuery = { __typename?: 'query_root', config?: { __typename: 'ConfigConfig', id: 'ConfigConfig', global?: { __typename?: 'ConfigGlobal', environment?: Array<{ __typename?: 'ConfigGlobalEnvironmentVariable', name: string, value: string, id: string }> | null } | null, hasura: { __typename?: 'ConfigHasura', adminSecret: string, webhookSecret: string, jwtSecrets?: Array<{ __typename?: 'ConfigJWTSecret', issuer?: string | null, key?: string | null, type?: string | null, jwk_url?: any | null, header?: string | null, claims_namespace_path?: string | null, claims_namespace?: string | null, claims_format?: string | null, audience?: string | null, allowed_skew?: any | null }> | null } } | null };

export type GetConfigRawJsonQueryVariables = Exact<{
  appID: Scalars['uuid'];
}>;


export type GetConfigRawJsonQuery = { __typename?: 'query_root', configRawJSON: string };

export type GetRateLimitConfigQueryVariables = Exact<{
  appId: Scalars['uuid'];
  resolve: Scalars['Boolean'];
}>;


export type GetRateLimitConfigQuery = { __typename?: 'query_root', config?: { __typename?: 'ConfigConfig', hasura: { __typename?: 'ConfigHasura', rateLimit?: { __typename?: 'ConfigRateLimit', limit: any, interval: string } | null }, storage?: { __typename?: 'ConfigStorage', rateLimit?: { __typename?: 'ConfigRateLimit', limit: any, interval: string } | null } | null, functions?: { __typename?: 'ConfigFunctions', rateLimit?: { __typename?: 'ConfigRateLimit', limit: any, interval: string } | null } | null, auth?: { __typename?: 'ConfigAuth', rateLimit?: { __typename?: 'ConfigAuthRateLimit', bruteForce?: { __typename?: 'ConfigRateLimit', limit: any, interval: string } | null, emails?: { __typename?: 'ConfigRateLimit', limit: any, interval: string } | null, global?: { __typename?: 'ConfigRateLimit', limit: any, interval: string } | null, signups?: { __typename?: 'ConfigRateLimit', limit: any, interval: string } | null, sms?: { __typename?: 'ConfigRateLimit', limit: any, interval: string } | null } | null } | null } | null };

export type UpdateRateLimitConfigMutationVariables = Exact<{
  appId: Scalars['uuid'];
  config: ConfigConfigUpdateInput;
}>;


export type UpdateRateLimitConfigMutation = { __typename?: 'mutation_root', updateConfig: { __typename?: 'ConfigConfig', hasura: { __typename?: 'ConfigHasura', rateLimit?: { __typename?: 'ConfigRateLimit', limit: any, interval: string } | null }, storage?: { __typename?: 'ConfigStorage', rateLimit?: { __typename?: 'ConfigRateLimit', limit: any, interval: string } | null } | null, functions?: { __typename?: 'ConfigFunctions', rateLimit?: { __typename?: 'ConfigRateLimit', limit: any, interval: string } | null } | null, auth?: { __typename?: 'ConfigAuth', rateLimit?: { __typename?: 'ConfigAuthRateLimit', bruteForce?: { __typename?: 'ConfigRateLimit', limit: any, interval: string } | null, emails?: { __typename?: 'ConfigRateLimit', limit: any, interval: string } | null, global?: { __typename?: 'ConfigRateLimit', limit: any, interval: string } | null, signups?: { __typename?: 'ConfigRateLimit', limit: any, interval: string } | null, sms?: { __typename?: 'ConfigRateLimit', limit: any, interval: string } | null } | null } | null } };

export type ReplaceConfigRawJsonMutationVariables = Exact<{
  appID: Scalars['uuid'];
  rawJSON: Scalars['String'];
}>;


export type ReplaceConfigRawJsonMutation = { __typename?: 'mutation_root', replaceConfigRawJSON: string };

export type PermissionVariableFragment = { __typename?: 'ConfigAuthsessionaccessTokenCustomClaims', key: string, value: string, id: string };

export type GetRolesPermissionsQueryVariables = Exact<{
  appId: Scalars['uuid'];
}>;


export type GetRolesPermissionsQuery = { __typename?: 'query_root', config?: { __typename: 'ConfigConfig', id: 'ConfigConfig', auth?: { __typename?: 'ConfigAuth', user?: { __typename?: 'ConfigAuthUser', roles?: { __typename?: 'ConfigAuthUserRoles', allowed?: Array<any> | null, default?: any | null } | null } | null, session?: { __typename?: 'ConfigAuthSession', accessToken?: { __typename?: 'ConfigAuthSessionAccessToken', customClaims?: Array<{ __typename?: 'ConfigAuthsessionaccessTokenCustomClaims', key: string, value: string, id: string }> | null } | null } | null } | null } | null };

export type DeleteSecretMutationVariables = Exact<{
  appId: Scalars['uuid'];
  name: Scalars['String'];
}>;


export type DeleteSecretMutation = { __typename?: 'mutation_root', deleteSecret?: { __typename?: 'ConfigEnvironmentVariable', name: string } | null };

export type SecretFragment = { __typename?: 'ConfigEnvironmentVariable', name: string };

export type GetSecretsQueryVariables = Exact<{
  appId: Scalars['uuid'];
}>;


export type GetSecretsQuery = { __typename?: 'query_root', appSecrets: Array<{ __typename?: 'ConfigEnvironmentVariable', name: string }> };

export type InsertSecretMutationVariables = Exact<{
  appId: Scalars['uuid'];
  secret: ConfigEnvironmentVariableInsertInput;
}>;


export type InsertSecretMutation = { __typename?: 'mutation_root', insertSecret: { __typename?: 'ConfigEnvironmentVariable', name: string } };

export type UpdateSecretMutationVariables = Exact<{
  appId: Scalars['uuid'];
  secret: ConfigEnvironmentVariableInsertInput;
}>;


export type UpdateSecretMutation = { __typename?: 'mutation_root', updateSecret: { __typename?: 'ConfigEnvironmentVariable', name: string } };

export type GetSignInMethodsQueryVariables = Exact<{
  appId: Scalars['uuid'];
}>;


export type GetSignInMethodsQuery = { __typename?: 'query_root', config?: { __typename: 'ConfigConfig', id: 'ConfigConfig', provider?: { __typename: 'ConfigProvider', id: 'ConfigProvider', sms?: { __typename?: 'ConfigSms', accountSid: string, authToken: string, messagingServiceId: string, provider?: string | null } | null } | null, auth?: { __typename: 'ConfigAuth', id: 'ConfigAuth', method?: { __typename?: 'ConfigAuthMethod', emailPassword?: { __typename?: 'ConfigAuthMethodEmailPassword', emailVerificationRequired?: boolean | null, hibpEnabled?: boolean | null, passwordMinLength?: any | null } | null, emailPasswordless?: { __typename?: 'ConfigAuthMethodEmailPasswordless', enabled?: boolean | null } | null, smsPasswordless?: { __typename?: 'ConfigAuthMethodSmsPasswordless', enabled?: boolean | null } | null, anonymous?: { __typename?: 'ConfigAuthMethodAnonymous', enabled?: boolean | null } | null, webauthn?: { __typename?: 'ConfigAuthMethodWebauthn', enabled?: boolean | null } | null, oauth?: { __typename?: 'ConfigAuthMethodOauth', apple?: { __typename?: 'ConfigAuthMethodOauthApple', enabled?: boolean | null, clientId?: string | null, keyId?: string | null, teamId?: string | null, privateKey?: string | null } | null, bitbucket?: { __typename?: 'ConfigStandardOauthProvider', enabled?: boolean | null, clientId?: string | null, clientSecret?: string | null } | null, gitlab?: { __typename?: 'ConfigStandardOauthProviderWithScope', enabled?: boolean | null, clientId?: string | null, clientSecret?: string | null, scope?: Array<string> | null } | null, strava?: { __typename?: 'ConfigStandardOauthProviderWithScope', enabled?: boolean | null, clientId?: string | null, clientSecret?: string | null, scope?: Array<string> | null } | null, discord?: { __typename?: 'ConfigStandardOauthProviderWithScope', enabled?: boolean | null, clientId?: string | null, clientSecret?: string | null, scope?: Array<string> | null } | null, facebook?: { __typename?: 'ConfigStandardOauthProviderWithScope', enabled?: boolean | null, clientId?: string | null, clientSecret?: string | null, scope?: Array<string> | null } | null, github?: { __typename?: 'ConfigStandardOauthProviderWithScope', enabled?: boolean | null, clientId?: string | null, clientSecret?: string | null, scope?: Array<string> | null } | null, google?: { __typename?: 'ConfigStandardOauthProviderWithScope', enabled?: boolean | null, clientId?: string | null, clientSecret?: string | null, scope?: Array<string> | null } | null, linkedin?: { __typename?: 'ConfigStandardOauthProviderWithScope', enabled?: boolean | null, clientId?: string | null, clientSecret?: string | null, scope?: Array<string> | null } | null, spotify?: { __typename?: 'ConfigStandardOauthProviderWithScope', enabled?: boolean | null, clientId?: string | null, clientSecret?: string | null, scope?: Array<string> | null } | null, twitch?: { __typename?: 'ConfigStandardOauthProviderWithScope', enabled?: boolean | null, clientId?: string | null, clientSecret?: string | null, scope?: Array<string> | null } | null, twitter?: { __typename?: 'ConfigAuthMethodOauthTwitter', enabled?: boolean | null, consumerKey?: string | null, consumerSecret?: string | null } | null, windowslive?: { __typename?: 'ConfigStandardOauthProviderWithScope', enabled?: boolean | null, clientId?: string | null, clientSecret?: string | null, scope?: Array<string> | null } | null, workos?: { __typename?: 'ConfigAuthMethodOauthWorkos', enabled?: boolean | null, clientId?: string | null, clientSecret?: string | null, connection?: string | null, organization?: string | null } | null, azuread?: { __typename?: 'ConfigAuthMethodOauthAzuread', enabled?: boolean | null, clientId?: string | null, clientSecret?: string | null, tenant?: string | null } | null } | null } | null } | null } | null };

export type GetSmtpSettingsQueryVariables = Exact<{
  appId: Scalars['uuid'];
}>;


export type GetSmtpSettingsQuery = { __typename?: 'query_root', config?: { __typename: 'ConfigConfig', id: 'ConfigConfig', provider?: { __typename: 'ConfigProvider', id: 'ConfigProvider', smtp?: { __typename?: 'ConfigSmtp', host: string, method: string, port: any, secure: boolean, sender: string, user: string, password: string } | null } | null } | null };

export type UpdateConfigMutationVariables = Exact<{
  appId: Scalars['uuid'];
  config: ConfigConfigUpdateInput;
}>;


export type UpdateConfigMutation = { __typename?: 'mutation_root', updateConfig: { __typename?: 'ConfigConfig', id: 'ConfigConfig', postgres?: { __typename?: 'ConfigPostgres', resources?: { __typename?: 'ConfigPostgresResources', enablePublicAccess?: boolean | null, storage?: { __typename?: 'ConfigPostgresStorage', capacity: any } | null } | null } | null, ai?: { __typename?: 'ConfigAI', version?: string | null, webhookSecret: string, autoEmbeddings?: { __typename?: 'ConfigAIAutoEmbeddings', synchPeriodMinutes?: any | null } | null, openai: { __typename?: 'ConfigAIOpenai', organization?: string | null, apiKey: string }, resources: { __typename?: 'ConfigAIResources', compute: { __typename?: 'ConfigComputeResources', cpu: any, memory: any } } } | null } };

export type UpdateDatabaseVersionMutationVariables = Exact<{
  appId: Scalars['uuid'];
  version: Scalars['String'];
}>;


export type UpdateDatabaseVersionMutation = { __typename?: 'mutation_root', changeDatabaseVersion: boolean };

export type UnpauseApplicationMutationVariables = Exact<{
  appId: Scalars['uuid'];
}>;


export type UnpauseApplicationMutation = { __typename?: 'mutation_root', updateApp?: { __typename?: 'apps', id: any } | null };

export type UpdateApplicationMutationVariables = Exact<{
  appId: Scalars['uuid'];
  app: Apps_Set_Input;
}>;


export type UpdateApplicationMutation = { __typename?: 'mutation_root', updateApp?: { __typename?: 'apps', name: string, id: any, slug: string } | null };

export type GetCountriesQueryVariables = Exact<{ [key: string]: never; }>;


export type GetCountriesQuery = { __typename?: 'query_root', countries: Array<{ __typename?: 'countries', code: any, name: string }> };

export type DeploymentRowFragment = { __typename?: 'deployments', id: any, commitSHA: string, deploymentStartedAt?: any | null, deploymentEndedAt?: any | null, deploymentStatus?: string | null, commitUserName?: string | null, commitUserAvatarUrl?: string | null, commitMessage?: string | null };

export type ScheduledOrPendingDeploymentsSubSubscriptionVariables = Exact<{
  appId: Scalars['uuid'];
}>;


export type ScheduledOrPendingDeploymentsSubSubscription = { __typename?: 'subscription_root', deployments: Array<{ __typename?: 'deployments', id: any, commitSHA: string, deploymentStartedAt?: any | null, deploymentEndedAt?: any | null, deploymentStatus?: string | null, commitUserName?: string | null, commitUserAvatarUrl?: string | null, commitMessage?: string | null }> };

export type LatestLiveDeploymentSubSubscriptionVariables = Exact<{
  appId: Scalars['uuid'];
}>;


export type LatestLiveDeploymentSubSubscription = { __typename?: 'subscription_root', deployments: Array<{ __typename?: 'deployments', id: any, commitSHA: string, deploymentStartedAt?: any | null, deploymentEndedAt?: any | null, deploymentStatus?: string | null, commitUserName?: string | null, commitUserAvatarUrl?: string | null, commitMessage?: string | null }> };

export type InsertDeploymentMutationVariables = Exact<{
  object: Deployments_Insert_Input;
}>;


export type InsertDeploymentMutation = { __typename?: 'mutation_root', insertDeployment?: { __typename?: 'deployments', id: any, commitSHA: string, deploymentStartedAt?: any | null, deploymentEndedAt?: any | null, deploymentStatus?: string | null, commitUserName?: string | null, commitUserAvatarUrl?: string | null, commitMessage?: string | null } | null };

export type GetDeploymentsSubSubscriptionVariables = Exact<{
  id: Scalars['uuid'];
  limit: Scalars['Int'];
  offset: Scalars['Int'];
}>;


export type GetDeploymentsSubSubscription = { __typename?: 'subscription_root', deployments: Array<{ __typename?: 'deployments', id: any, commitSHA: string, deploymentStartedAt?: any | null, deploymentEndedAt?: any | null, deploymentStatus?: string | null, commitUserName?: string | null, commitUserAvatarUrl?: string | null, commitMessage?: string | null }> };

export type DeploymentSubSubscriptionVariables = Exact<{
  id: Scalars['uuid'];
}>;


export type DeploymentSubSubscription = { __typename?: 'subscription_root', deployment?: { __typename?: 'deployments', id: any, commitMessage?: string | null, commitSHA: string, commitUserName?: string | null, commitUserAvatarUrl?: string | null, deploymentStartedAt?: any | null, deploymentEndedAt?: any | null, deploymentStatus?: string | null, metadataStartedAt?: any | null, metadataEndedAt?: any | null, metadataStatus?: string | null, migrationsStartedAt?: any | null, migrationsEndedAt?: any | null, migrationsStatus?: string | null, functionsStartedAt?: any | null, functionsEndedAt?: any | null, functionsStatus?: string | null, deploymentLogs: Array<{ __typename?: 'deploymentLogs', id: any, createdAt: any, message: string }> } | null };

export type GetBucketsQueryVariables = Exact<{ [key: string]: never; }>;


export type GetBucketsQuery = { __typename?: 'query_root', buckets: Array<{ __typename?: 'buckets', id: string, maxUploadFileSize: number }> };

export type GetFilesQueryVariables = Exact<{
  where?: InputMaybe<Files_Bool_Exp>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Files_Order_By> | Files_Order_By>;
}>;


export type GetFilesQuery = { __typename?: 'query_root', files: Array<{ __typename?: 'files', id: any, bucketId: string, createdAt: any, updatedAt: any, name?: string | null, size?: number | null, mimeType?: string | null, etag?: string | null, isUploaded?: boolean | null, uploadedByUserId?: any | null }> };

export type GetFilesAggregateQueryVariables = Exact<{
  where?: InputMaybe<Files_Bool_Exp>;
}>;


export type GetFilesAggregateQuery = { __typename?: 'query_root', filesAggregate: { __typename?: 'files_aggregate', aggregate?: { __typename?: 'files_aggregate_fields', count: number } | null } };

export type AppStateHistoryFragment = { __typename?: 'appStateHistory', id: any, appId: any, message?: string | null, stateId: number, createdAt: any };

export type ProjectFragment = { __typename?: 'apps', id: any, slug: string, name: string, repositoryProductionBranch: string, subdomain: string, createdAt: any, desiredState: number, nhostBaseFolder: string, config?: { __typename?: 'ConfigConfig', observability: { __typename?: 'ConfigObservability', grafana: { __typename?: 'ConfigGrafana', adminPassword: string } }, hasura: { __typename?: 'ConfigHasura', adminSecret: string, settings?: { __typename?: 'ConfigHasuraSettings', enableConsole?: boolean | null } | null }, ai?: { __typename?: 'ConfigAI', version?: string | null } | null } | null, featureFlags: Array<{ __typename?: 'featureFlags', description: string, id: any, name: string, value: string }>, appStates: Array<{ __typename?: 'appStateHistory', id: any, appId: any, message?: string | null, stateId: number, createdAt: any }>, region: { __typename?: 'regions', id: any, countryCode: string, name: string, domain: string, city: string }, legacyPlan?: { __typename?: 'plans', id: any, name: string, price: number, isFree: boolean, featureMaxDbSize: number } | null, githubRepository?: { __typename?: 'githubRepositories', fullName: string } | null, deployments: Array<{ __typename?: 'deployments', id: any, commitSHA: string, commitMessage?: string | null, commitUserName?: string | null, deploymentStartedAt?: any | null, deploymentEndedAt?: any | null, commitUserAvatarUrl?: string | null, deploymentStatus?: string | null }>, creator?: { __typename?: 'users', id: any, email?: any | null, displayName: string } | null };

export type WorkspaceFragment = { __typename?: 'workspaces', id: any, name: string, slug: string, creatorUserId?: any | null, workspaceMembers: Array<{ __typename?: 'workspaceMembers', id: any, type: string, user: { __typename?: 'users', id: any, email?: any | null, displayName: string } }>, projects: Array<{ __typename?: 'apps', id: any, slug: string, name: string, repositoryProductionBranch: string, subdomain: string, createdAt: any, desiredState: number, nhostBaseFolder: string, config?: { __typename?: 'ConfigConfig', observability: { __typename?: 'ConfigObservability', grafana: { __typename?: 'ConfigGrafana', adminPassword: string } }, hasura: { __typename?: 'ConfigHasura', adminSecret: string, settings?: { __typename?: 'ConfigHasuraSettings', enableConsole?: boolean | null } | null }, ai?: { __typename?: 'ConfigAI', version?: string | null } | null } | null, featureFlags: Array<{ __typename?: 'featureFlags', description: string, id: any, name: string, value: string }>, appStates: Array<{ __typename?: 'appStateHistory', id: any, appId: any, message?: string | null, stateId: number, createdAt: any }>, region: { __typename?: 'regions', id: any, countryCode: string, name: string, domain: string, city: string }, legacyPlan?: { __typename?: 'plans', id: any, name: string, price: number, isFree: boolean, featureMaxDbSize: number } | null, githubRepository?: { __typename?: 'githubRepositories', fullName: string } | null, deployments: Array<{ __typename?: 'deployments', id: any, commitSHA: string, commitMessage?: string | null, commitUserName?: string | null, deploymentStartedAt?: any | null, deploymentEndedAt?: any | null, commitUserAvatarUrl?: string | null, deploymentStatus?: string | null }>, creator?: { __typename?: 'users', id: any, email?: any | null, displayName: string } | null }> };

export type GithubRepositoryFragment = { __typename?: 'githubRepositories', id: any, name: string, fullName: string, private: boolean, githubAppInstallation: { __typename?: 'githubAppInstallations', id: any, accountLogin?: string | null, accountType?: string | null, accountAvatarUrl?: string | null } };

export type GetGithubRepositoriesQueryVariables = Exact<{ [key: string]: never; }>;


export type GetGithubRepositoriesQuery = { __typename?: 'query_root', githubRepositories: Array<{ __typename?: 'githubRepositories', id: any, name: string, fullName: string, private: boolean, githubAppInstallation: { __typename?: 'githubAppInstallations', id: any, accountLogin?: string | null, accountType?: string | null, accountAvatarUrl?: string | null } }>, githubAppInstallations: Array<{ __typename?: 'githubAppInstallations', id: any, accountLogin?: string | null, accountType?: string | null, accountAvatarUrl?: string | null }> };

export type GetProjectLogsQueryVariables = Exact<{
  appID: Scalars['String'];
  service?: InputMaybe<Scalars['String']>;
  from?: InputMaybe<Scalars['Timestamp']>;
  to?: InputMaybe<Scalars['Timestamp']>;
  regexFilter?: InputMaybe<Scalars['String']>;
}>;


export type GetProjectLogsQuery = { __typename?: 'query_root', logs: Array<{ __typename?: 'Log', log: string, service: string, timestamp: any }> };

export type GetLogsSubscriptionSubscriptionVariables = Exact<{
  appID: Scalars['String'];
  service?: InputMaybe<Scalars['String']>;
  from?: InputMaybe<Scalars['Timestamp']>;
  regexFilter?: InputMaybe<Scalars['String']>;
}>;


export type GetLogsSubscriptionSubscription = { __typename?: 'subscription_root', logs: Array<{ __typename?: 'Log', log: string, service: string, timestamp: any }> };

export type GetServiceLabelValuesQueryVariables = Exact<{
  appID: Scalars['String'];
}>;


export type GetServiceLabelValuesQuery = { __typename?: 'query_root', getServiceLabelValues: Array<string> };

export type GetSystemLogsQueryVariables = Exact<{
  appID: Scalars['String'];
  action: Scalars['String'];
  from?: InputMaybe<Scalars['Timestamp']>;
  to?: InputMaybe<Scalars['Timestamp']>;
}>;


export type GetSystemLogsQuery = { __typename?: 'query_root', systemLogs: Array<{ __typename?: 'Log', timestamp: any, log: string }> };

export type CreateOrganizationRequestMutationVariables = Exact<{
  organizationName: Scalars['String'];
  planID: Scalars['uuid'];
  redirectURL: Scalars['String'];
}>;


export type CreateOrganizationRequestMutation = { __typename?: 'mutation_root', billingCreateOrganizationRequest: string };

export type GetOrganizationQueryVariables = Exact<{
  orgSlug: Scalars['String'];
}>;


export type GetOrganizationQuery = { __typename?: 'query_root', organizations: Array<{ __typename?: 'organizations', id: any, name: string, slug: string, plan: { __typename?: 'plans', id: any, name: string, deprecated: boolean, individual: boolean, isFree: boolean }, apps: Array<{ __typename?: 'apps', id: any, name: string, subdomain: string, slug: string }> }> };

export type GetOrganizationByIdQueryVariables = Exact<{
  orgId: Scalars['uuid'];
}>;


export type GetOrganizationByIdQuery = { __typename?: 'query_root', organizations: Array<{ __typename?: 'organizations', id: any, name: string, slug: string }> };

export type GetOrganizationProjectsQueryVariables = Exact<{
  orgId: Scalars['uuid'];
}>;


export type GetOrganizationProjectsQuery = { __typename?: 'query_root', apps: Array<{ __typename?: 'apps', id: any, slug: string, name: string, repositoryProductionBranch: string, subdomain: string, createdAt: any, desiredState: number, nhostBaseFolder: string, config?: { __typename?: 'ConfigConfig', observability: { __typename?: 'ConfigObservability', grafana: { __typename?: 'ConfigGrafana', adminPassword: string } }, hasura: { __typename?: 'ConfigHasura', adminSecret: string, settings?: { __typename?: 'ConfigHasuraSettings', enableConsole?: boolean | null } | null }, ai?: { __typename?: 'ConfigAI', version?: string | null } | null } | null, featureFlags: Array<{ __typename?: 'featureFlags', description: string, id: any, name: string, value: string }>, appStates: Array<{ __typename?: 'appStateHistory', id: any, appId: any, message?: string | null, stateId: number, createdAt: any }>, region: { __typename?: 'regions', id: any, countryCode: string, name: string, domain: string, city: string }, legacyPlan?: { __typename?: 'plans', id: any, name: string, price: number, isFree: boolean, featureMaxDbSize: number } | null, githubRepository?: { __typename?: 'githubRepositories', fullName: string } | null, deployments: Array<{ __typename?: 'deployments', id: any, commitSHA: string, commitMessage?: string | null, commitUserName?: string | null, deploymentStartedAt?: any | null, deploymentEndedAt?: any | null, commitUserAvatarUrl?: string | null, deploymentStatus?: string | null }>, creator?: { __typename?: 'users', id: any, email?: any | null, displayName: string } | null }> };

export type GetOrganizationsQueryVariables = Exact<{ [key: string]: never; }>;


export type GetOrganizationsQuery = { __typename?: 'query_root', organizations: Array<{ __typename?: 'organizations', id: any, name: string, slug: string, plan: { __typename?: 'plans', id: any, name: string, deprecated: boolean, individual: boolean, isFree: boolean }, apps: Array<{ __typename?: 'apps', id: any, name: string, subdomain: string, slug: string }> }> };

export type GetProjectQueryVariables = Exact<{
  slug: Scalars['String'];
}>;


export type GetProjectQuery = { __typename?: 'query_root', apps: Array<{ __typename?: 'apps', id: any, slug: string, name: string, repositoryProductionBranch: string, subdomain: string, createdAt: any, desiredState: number, nhostBaseFolder: string, config?: { __typename?: 'ConfigConfig', observability: { __typename?: 'ConfigObservability', grafana: { __typename?: 'ConfigGrafana', adminPassword: string } }, hasura: { __typename?: 'ConfigHasura', adminSecret: string, settings?: { __typename?: 'ConfigHasuraSettings', enableConsole?: boolean | null } | null }, ai?: { __typename?: 'ConfigAI', version?: string | null } | null } | null, featureFlags: Array<{ __typename?: 'featureFlags', description: string, id: any, name: string, value: string }>, appStates: Array<{ __typename?: 'appStateHistory', id: any, appId: any, message?: string | null, stateId: number, createdAt: any }>, region: { __typename?: 'regions', id: any, countryCode: string, name: string, domain: string, city: string }, legacyPlan?: { __typename?: 'plans', id: any, name: string, price: number, isFree: boolean, featureMaxDbSize: number } | null, githubRepository?: { __typename?: 'githubRepositories', fullName: string } | null, deployments: Array<{ __typename?: 'deployments', id: any, commitSHA: string, commitMessage?: string | null, commitUserName?: string | null, deploymentStartedAt?: any | null, deploymentEndedAt?: any | null, commitUserAvatarUrl?: string | null, deploymentStatus?: string | null }>, creator?: { __typename?: 'users', id: any, email?: any | null, displayName: string } | null }> };

export type PostOrganizationRequestMutationVariables = Exact<{
  sessionID: Scalars['String'];
}>;


export type PostOrganizationRequestMutation = { __typename?: 'mutation_root', billingPostOrganizationRequest: { __typename?: 'PostOrganizationRequestResponse', Status: CheckoutStatus, Slug: string } };

export type DeletePaymentMethodMutationVariables = Exact<{
  paymentMethodId: Scalars['uuid'];
}>;


export type DeletePaymentMethodMutation = { __typename?: 'mutation_root', deletePaymentMethod?: { __typename?: 'paymentMethods', id: any } | null };

export type GetPaymentMethodsFragment = { __typename?: 'paymentMethods', id: any, createdAt: any, cardBrand: string, cardLast4: string, cardExpMonth: number, cardExpYear: number, isDefault: boolean, workspace: { __typename?: 'workspaces', id: any, apps: Array<{ __typename?: 'apps', id: any, legacyPlan?: { __typename?: 'plans', isFree: boolean } | null }> } };

export type GetPaymentMethodsQueryVariables = Exact<{
  workspaceId: Scalars['uuid'];
}>;


export type GetPaymentMethodsQuery = { __typename?: 'query_root', paymentMethods: Array<{ __typename?: 'paymentMethods', id: any, createdAt: any, cardBrand: string, cardLast4: string, cardExpMonth: number, cardExpYear: number, isDefault: boolean, workspace: { __typename?: 'workspaces', id: any, apps: Array<{ __typename?: 'apps', id: any, legacyPlan?: { __typename?: 'plans', isFree: boolean } | null }> } }> };

export type InsertNewPaymentMethodMutationVariables = Exact<{
  workspaceId: Scalars['uuid'];
  paymentMethod: PaymentMethods_Insert_Input;
}>;


export type InsertNewPaymentMethodMutation = { __typename?: 'mutation_root', updatePaymentMethods?: { __typename?: 'paymentMethods_mutation_response', affected_rows: number } | null, insertPaymentMethod?: { __typename?: 'paymentMethods', id: any } | null };

export type SetNewDefaultPaymentMethodMutationVariables = Exact<{
  workspaceId: Scalars['uuid'];
  paymentMethodId: Scalars['uuid'];
}>;


export type SetNewDefaultPaymentMethodMutation = { __typename?: 'mutation_root', setAllPaymentMethodToDefaultFalse?: { __typename?: 'paymentMethods_mutation_response', affected_rows: number } | null, updatePaymentMethods?: { __typename?: 'paymentMethods_mutation_response', affected_rows: number } | null };

export type GetAnnouncementsQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']>;
}>;


export type GetAnnouncementsQuery = { __typename?: 'query_root', announcements: Array<{ __typename?: 'announcements', id: any, href: string, content: string, createdAt: any }> };

export type GetPlansQueryVariables = Exact<{
  where?: InputMaybe<Plans_Bool_Exp>;
}>;


export type GetPlansQuery = { __typename?: 'query_root', plans: Array<{ __typename?: 'plans', id: any, name: string, isFree: boolean, price: number }> };

export type GetRecommendedSoftwareVersionsQueryVariables = Exact<{ [key: string]: never; }>;


export type GetRecommendedSoftwareVersionsQuery = { __typename?: 'query_root', softwareVersions: Array<{ __typename?: 'software_versions', software: Software_Type_Enum, version: string }> };

export type GetSoftwareVersionsQueryVariables = Exact<{
  software: Software_Type_Enum;
}>;


export type GetSoftwareVersionsQuery = { __typename?: 'query_root', softwareVersions: Array<{ __typename?: 'software_versions', version: string, software: Software_Type_Enum }> };

export type RestoreApplicationDatabaseMutationVariables = Exact<{
  appId: Scalars['String'];
  backupId: Scalars['String'];
}>;


export type RestoreApplicationDatabaseMutation = { __typename?: 'mutation_root', restoreApplicationDatabase: boolean };

export type RemoteAppDeleteUserMutationVariables = Exact<{
  id: Scalars['uuid'];
}>;


export type RemoteAppDeleteUserMutation = { __typename?: 'mutation_root', deleteUser?: { __typename?: 'users', id: any } | null };

export type GetAppFunctionsMetadataQueryVariables = Exact<{
  id: Scalars['uuid'];
}>;


export type GetAppFunctionsMetadataQuery = { __typename?: 'query_root', app?: { __typename?: 'apps', id: any, metadataFunctions: any } | null };

export type GetRemoteAppMetricsQueryVariables = Exact<{ [key: string]: never; }>;


export type GetRemoteAppMetricsQuery = { __typename?: 'query_root', filesAggregate: { __typename?: 'files_aggregate', aggregate?: { __typename?: 'files_aggregate_fields', count: number, sum?: { __typename?: 'files_sum_fields', size?: number | null } | null } | null }, usersAggregate: { __typename?: 'users_aggregate', aggregate?: { __typename?: 'users_aggregate_fields', count: number } | null } };

export type RemoteAppGetUsersFragment = { __typename?: 'users', id: any, createdAt: any, displayName: string, avatarUrl: string, email?: any | null, emailVerified: boolean, phoneNumber?: string | null, phoneNumberVerified: boolean, disabled: boolean, defaultRole: string, lastSeen?: any | null, locale: string, metadata?: any | null, roles: Array<{ __typename?: 'authUserRoles', id: any, role: string }>, userProviders: Array<{ __typename?: 'authUserProviders', id: any, providerId: string }> };

export type RemoteAppGetUsersQueryVariables = Exact<{
  where: Users_Bool_Exp;
  limit: Scalars['Int'];
  offset: Scalars['Int'];
}>;


export type RemoteAppGetUsersQuery = { __typename?: 'query_root', users: Array<{ __typename?: 'users', id: any, createdAt: any, displayName: string, avatarUrl: string, email?: any | null, emailVerified: boolean, phoneNumber?: string | null, phoneNumberVerified: boolean, disabled: boolean, defaultRole: string, lastSeen?: any | null, locale: string, metadata?: any | null, roles: Array<{ __typename?: 'authUserRoles', id: any, role: string }>, userProviders: Array<{ __typename?: 'authUserProviders', id: any, providerId: string }> }>, filteredUsersAggreggate: { __typename?: 'users_aggregate', aggregate?: { __typename?: 'users_aggregate_fields', count: number } | null }, usersAggregate: { __typename?: 'users_aggregate', aggregate?: { __typename?: 'users_aggregate_fields', count: number } | null } };

export type RemoteAppGetUsersCustomQueryVariables = Exact<{
  where: Users_Bool_Exp;
  limit: Scalars['Int'];
  offset: Scalars['Int'];
}>;


export type RemoteAppGetUsersCustomQuery = { __typename?: 'query_root', users: Array<{ __typename?: 'users', id: any, createdAt: any, displayName: string, phoneNumber?: string | null, avatarUrl: string, email?: any | null, disabled: boolean, defaultRole: string, isAnonymous: boolean, roles: Array<{ __typename?: 'authUserRoles', role: string }> }> };

export type RemoteAppGetUsersWholeQueryVariables = Exact<{
  limit: Scalars['Int'];
  offset: Scalars['Int'];
}>;


export type RemoteAppGetUsersWholeQuery = { __typename?: 'query_root', users: Array<{ __typename?: 'users', id: any, createdAt: any, displayName: string, avatarUrl: string, email?: any | null, emailVerified: boolean, phoneNumber?: string | null, phoneNumberVerified: boolean, disabled: boolean, defaultRole: string, lastSeen?: any | null, locale: string, metadata?: any | null, roles: Array<{ __typename?: 'authUserRoles', id: any, role: string }>, userProviders: Array<{ __typename?: 'authUserProviders', id: any, providerId: string }> }>, usersAggregate: { __typename?: 'users_aggregate', aggregate?: { __typename?: 'users_aggregate_fields', count: number } | null } };

export type TotalUsersQueryVariables = Exact<{ [key: string]: never; }>;


export type TotalUsersQuery = { __typename?: 'query_root', usersAggregate: { __typename?: 'users_aggregate', aggregate?: { __typename?: 'users_aggregate_fields', count: number } | null } };

export type TotalUsersByDateQueryVariables = Exact<{
  where: Users_Bool_Exp;
}>;


export type TotalUsersByDateQuery = { __typename?: 'query_root', usersAggregate: { __typename?: 'users_aggregate', aggregate?: { __typename?: 'users_aggregate_fields', count: number } | null } };

export type UpdateRemoteAppUserMutationVariables = Exact<{
  id: Scalars['uuid'];
  user: Users_Set_Input;
}>;


export type UpdateRemoteAppUserMutation = { __typename?: 'mutation_root', updateUser?: { __typename?: 'users', id: any } | null };

export type InsertRemoteAppUserRolesMutationVariables = Exact<{
  roles: Array<AuthUserRoles_Insert_Input> | AuthUserRoles_Insert_Input;
}>;


export type InsertRemoteAppUserRolesMutation = { __typename?: 'mutation_root', insertAuthUserRoles?: { __typename?: 'authUserRoles_mutation_response', affected_rows: number } | null };

export type DeleteRemoteAppUserRolesMutationVariables = Exact<{
  userId: Scalars['uuid'];
  roles: Array<Scalars['String']> | Scalars['String'];
}>;


export type DeleteRemoteAppUserRolesMutation = { __typename?: 'mutation_root', deleteAuthUserRoles?: { __typename?: 'authUserRoles_mutation_response', affected_rows: number } | null };

export type DeleteRunServiceMutationVariables = Exact<{
  serviceID: Scalars['uuid'];
}>;


export type DeleteRunServiceMutation = { __typename?: 'mutation_root', deleteRunService?: { __typename?: 'run_service', id: any } | null };

export type DeleteRunServiceConfigMutationVariables = Exact<{
  appID: Scalars['uuid'];
  serviceID: Scalars['uuid'];
}>;


export type DeleteRunServiceConfigMutation = { __typename?: 'mutation_root', deleteRunServiceConfig?: { __typename?: 'ConfigRunServiceConfig', name: any } | null };

export type GetRunServiceQueryVariables = Exact<{
  id: Scalars['uuid'];
  resolve: Scalars['Boolean'];
}>;


export type GetRunServiceQuery = { __typename?: 'query_root', runService?: { __typename?: 'run_service', id: any, subdomain: string, config?: { __typename?: 'ConfigRunServiceConfig', name: any, command?: Array<string> | null, image: { __typename?: 'ConfigRunServiceImage', image: string }, resources: { __typename?: 'ConfigRunServiceResources', replicas: any, compute: { __typename?: 'ConfigComputeResources', cpu: any, memory: any }, storage?: Array<{ __typename?: 'ConfigRunServiceResourcesStorage', name: any, path: string, capacity: any }> | null }, environment?: Array<{ __typename?: 'ConfigEnvironmentVariable', name: string, value: string }> | null, ports?: Array<{ __typename?: 'ConfigRunServicePort', port: any, type: string, publish?: boolean | null }> | null } | null } | null };

export type RunServiceConfigFragment = { __typename?: 'ConfigRunServiceConfig', name: any, command?: Array<string> | null, image: { __typename?: 'ConfigRunServiceImage', image: string }, resources: { __typename?: 'ConfigRunServiceResources', replicas: any, compute: { __typename?: 'ConfigComputeResources', cpu: any, memory: any }, storage?: Array<{ __typename?: 'ConfigRunServiceResourcesStorage', name: any, path: string, capacity: any }> | null }, environment?: Array<{ __typename?: 'ConfigEnvironmentVariable', name: string, value: string }> | null, ports?: Array<{ __typename?: 'ConfigRunServicePort', port: any, type: string, publish?: boolean | null, ingresses?: Array<{ __typename?: 'ConfigIngress', fqdn?: Array<string> | null }> | null, rateLimit?: { __typename?: 'ConfigRateLimit', limit: any, interval: string } | null }> | null, healthCheck?: { __typename?: 'ConfigHealthCheck', port: any, initialDelaySeconds?: number | null, probePeriodSeconds?: number | null } | null };

export type GetRunServicesQueryVariables = Exact<{
  appID: Scalars['uuid'];
  resolve: Scalars['Boolean'];
  limit: Scalars['Int'];
  offset: Scalars['Int'];
}>;


export type GetRunServicesQuery = { __typename?: 'query_root', app?: { __typename?: 'apps', runServices: Array<{ __typename?: 'run_service', id: any, createdAt: any, updatedAt: any, subdomain: string, config?: { __typename?: 'ConfigRunServiceConfig', name: any, command?: Array<string> | null, image: { __typename?: 'ConfigRunServiceImage', image: string }, resources: { __typename?: 'ConfigRunServiceResources', replicas: any, compute: { __typename?: 'ConfigComputeResources', cpu: any, memory: any }, storage?: Array<{ __typename?: 'ConfigRunServiceResourcesStorage', name: any, path: string, capacity: any }> | null }, environment?: Array<{ __typename?: 'ConfigEnvironmentVariable', name: string, value: string }> | null, ports?: Array<{ __typename?: 'ConfigRunServicePort', port: any, type: string, publish?: boolean | null, ingresses?: Array<{ __typename?: 'ConfigIngress', fqdn?: Array<string> | null }> | null, rateLimit?: { __typename?: 'ConfigRateLimit', limit: any, interval: string } | null }> | null, healthCheck?: { __typename?: 'ConfigHealthCheck', port: any, initialDelaySeconds?: number | null, probePeriodSeconds?: number | null } | null } | null }>, runServices_aggregate: { __typename?: 'run_service_aggregate', aggregate?: { __typename?: 'run_service_aggregate_fields', count: number } | null } } | null };

export type GetLocalRunServiceConfigsQueryVariables = Exact<{
  appID: Scalars['uuid'];
  resolve: Scalars['Boolean'];
}>;


export type GetLocalRunServiceConfigsQuery = { __typename?: 'query_root', runServiceConfigs: Array<{ __typename?: 'ConfigRunServiceConfigWithID', serviceID: any, config: { __typename?: 'ConfigRunServiceConfig', name: any, command?: Array<string> | null, image: { __typename?: 'ConfigRunServiceImage', image: string }, resources: { __typename?: 'ConfigRunServiceResources', replicas: any, compute: { __typename?: 'ConfigComputeResources', cpu: any, memory: any }, storage?: Array<{ __typename?: 'ConfigRunServiceResourcesStorage', name: any, path: string, capacity: any }> | null }, environment?: Array<{ __typename?: 'ConfigEnvironmentVariable', name: string, value: string }> | null, ports?: Array<{ __typename?: 'ConfigRunServicePort', port: any, type: string, publish?: boolean | null, ingresses?: Array<{ __typename?: 'ConfigIngress', fqdn?: Array<string> | null }> | null, rateLimit?: { __typename?: 'ConfigRateLimit', limit: any, interval: string } | null }> | null, healthCheck?: { __typename?: 'ConfigHealthCheck', port: any, initialDelaySeconds?: number | null, probePeriodSeconds?: number | null } | null } }> };

export type RunServiceRateLimitFragment = { __typename?: 'ConfigRunServiceConfig', name: any, ports?: Array<{ __typename?: 'ConfigRunServicePort', port: any, type: string, publish?: boolean | null, rateLimit?: { __typename?: 'ConfigRateLimit', limit: any, interval: string } | null, ingresses?: Array<{ __typename?: 'ConfigIngress', fqdn?: Array<string> | null }> | null }> | null };

export type GetRunServicesRateLimitQueryVariables = Exact<{
  appID: Scalars['uuid'];
  resolve: Scalars['Boolean'];
}>;


export type GetRunServicesRateLimitQuery = { __typename?: 'query_root', app?: { __typename?: 'apps', runServices: Array<{ __typename?: 'run_service', id: any, createdAt: any, updatedAt: any, subdomain: string, config?: { __typename?: 'ConfigRunServiceConfig', name: any, ports?: Array<{ __typename?: 'ConfigRunServicePort', port: any, type: string, publish?: boolean | null, rateLimit?: { __typename?: 'ConfigRateLimit', limit: any, interval: string } | null, ingresses?: Array<{ __typename?: 'ConfigIngress', fqdn?: Array<string> | null }> | null }> | null } | null }> } | null };

export type GetLocalRunServiceRateLimitQueryVariables = Exact<{
  appID: Scalars['uuid'];
  resolve: Scalars['Boolean'];
}>;


export type GetLocalRunServiceRateLimitQuery = { __typename?: 'query_root', runServiceConfigs: Array<{ __typename?: 'ConfigRunServiceConfigWithID', serviceID: any, config: { __typename?: 'ConfigRunServiceConfig', name: any, ports?: Array<{ __typename?: 'ConfigRunServicePort', port: any, type: string, publish?: boolean | null, rateLimit?: { __typename?: 'ConfigRateLimit', limit: any, interval: string } | null, ingresses?: Array<{ __typename?: 'ConfigIngress', fqdn?: Array<string> | null }> | null }> | null } }> };

export type InsertRunServiceMutationVariables = Exact<{
  object: Run_Service_Insert_Input;
}>;


export type InsertRunServiceMutation = { __typename?: 'mutation_root', insertRunService?: { __typename?: 'run_service', id: any, subdomain: string } | null };

export type InsertRunServiceConfigMutationVariables = Exact<{
  appID: Scalars['uuid'];
  serviceID: Scalars['uuid'];
  config: ConfigRunServiceConfigInsertInput;
}>;


export type InsertRunServiceConfigMutation = { __typename?: 'mutation_root', insertRunServiceConfig: { __typename?: 'ConfigRunServiceConfig', name: any } };

export type ReplaceRunServiceConfigMutationVariables = Exact<{
  appID: Scalars['uuid'];
  serviceID: Scalars['uuid'];
  config: ConfigRunServiceConfigInsertInput;
}>;


export type ReplaceRunServiceConfigMutation = { __typename?: 'mutation_root', replaceRunServiceConfig: { __typename: 'ConfigRunServiceConfig' } };

export type UpdateRunServiceConfigMutationVariables = Exact<{
  appID: Scalars['uuid'];
  serviceID: Scalars['uuid'];
  config: ConfigRunServiceConfigUpdateInput;
}>;


export type UpdateRunServiceConfigMutation = { __typename?: 'mutation_root', updateRunServiceConfig: { __typename?: 'ConfigRunServiceConfig', name: any } };

export type GetFreeAndActiveProjectsQueryVariables = Exact<{
  userId: Scalars['uuid'];
}>;


export type GetFreeAndActiveProjectsQuery = { __typename?: 'query_root', freeAndActiveProjects: Array<{ __typename?: 'apps', id: any }> };

export type DeleteWorkspaceMemberInvitesMutationVariables = Exact<{
  id: Scalars['uuid'];
}>;


export type DeleteWorkspaceMemberInvitesMutation = { __typename?: 'mutation_root', deleteWorkspaceMemberInvites?: { __typename?: 'workspaceMemberInvites_mutation_response', affected_rows: number } | null };

export type GetWorkspaceMemberInvitesToManageQueryVariables = Exact<{
  userId: Scalars['uuid'];
}>;


export type GetWorkspaceMemberInvitesToManageQuery = { __typename?: 'query_root', workspaceMemberInvites: Array<{ __typename?: 'workspaceMemberInvites', id: any, email: any, userByEmail?: { __typename?: 'users', id: any } | null, workspace: { __typename?: 'workspaces', id: any, name: string, slug: string } }> };

export type InsertWorkspaceMemberInviteMutationVariables = Exact<{
  workspaceMemberInvite: WorkspaceMemberInvites_Insert_Input;
}>;


export type InsertWorkspaceMemberInviteMutation = { __typename?: 'mutation_root', insertWorkspaceMemberInvite?: { __typename?: 'workspaceMemberInvites', id: any } | null };

export type UpdateWorkspaceMemberInviteMutationVariables = Exact<{
  id: Scalars['uuid'];
  workspaceMemberInvite: WorkspaceMemberInvites_Set_Input;
}>;


export type UpdateWorkspaceMemberInviteMutation = { __typename?: 'mutation_root', updateWorkspaceMemberInvites?: { __typename?: 'workspaceMemberInvites_mutation_response', affected_rows: number } | null };

export type DeleteWorkspaceMemberMutationVariables = Exact<{
  id: Scalars['uuid'];
}>;


export type DeleteWorkspaceMemberMutation = { __typename?: 'mutation_root', deleteWorkspaceMember?: { __typename?: 'workspaceMembers', id: any } | null };

export type GetWorkspaceMembersWorkspaceMemberFragment = { __typename?: 'workspaceMembers', id: any, type: string, user: { __typename?: 'users', id: any, displayName: string, avatarUrl: string, email?: any | null } };

export type GetWorkspaceMembersWorkspaceMemberInviteFragment = { __typename?: 'workspaceMemberInvites', id: any, email: any, memberType: string };

export type GetWorkspaceMembersQueryVariables = Exact<{
  workspaceId: Scalars['uuid'];
}>;


export type GetWorkspaceMembersQuery = { __typename?: 'query_root', workspace?: { __typename?: 'workspaces', id: any, creatorUser?: { __typename?: 'users', id: any } | null, workspaceMembers: Array<{ __typename?: 'workspaceMembers', id: any, type: string, user: { __typename?: 'users', id: any, displayName: string, avatarUrl: string, email?: any | null } }>, workspaceMemberInvites: Array<{ __typename?: 'workspaceMemberInvites', id: any, email: any, memberType: string }> } | null };

export type UpdateWorkspaceMemberMutationVariables = Exact<{
  id: Scalars['uuid'];
  workspaceMember: WorkspaceMembers_Set_Input;
}>;


export type UpdateWorkspaceMemberMutation = { __typename?: 'mutation_root', updateWorkspaceMember?: { __typename?: 'workspaceMembers', id: any } | null };

export type DeleteWorkspaceMutationVariables = Exact<{
  id: Scalars['uuid'];
}>;


export type DeleteWorkspaceMutation = { __typename?: 'mutation_root', deleteWorkspace?: { __typename?: 'workspaces', id: any } | null };

export type InsertWorkspaceMutationVariables = Exact<{
  workspace: Workspaces_Insert_Input;
}>;


export type InsertWorkspaceMutation = { __typename?: 'mutation_root', insertWorkspace?: { __typename?: 'workspaces', name: string, id: any } | null };

export type UpdateWorkspaceMutationVariables = Exact<{
  id: Scalars['uuid'];
  workspace: Workspaces_Set_Input;
}>;


export type UpdateWorkspaceMutation = { __typename?: 'mutation_root', updateWorkspace?: { __typename?: 'workspaces', id: any, name: string, email: string, companyName: string, addressLine1: string, addressLine2: string, addressPostalCode: string, addressCity: string, addressCountryCode?: string | null, slug: string, taxIdType: string, taxIdValue: string } | null };

export const BackupFragmentDoc = gql`
    fragment Backup on backups {
  id
  size
  createdAt
  completedAt
}
    `;
export const ServiceResourcesFragmentDoc = gql`
    fragment ServiceResources on ConfigConfig {
  auth {
    resources {
      compute {
        cpu
        memory
      }
      replicas
    }
  }
  hasura {
    resources {
      compute {
        cpu
        memory
      }
      replicas
    }
  }
  postgres {
    resources {
      compute {
        cpu
        memory
      }
      replicas
    }
  }
  storage {
    resources {
      compute {
        cpu
        memory
      }
      replicas
    }
  }
}
    `;
export const GetAppPlanAndGlobalPlansAppFragmentDoc = gql`
    fragment getAppPlanAndGlobalPlansApp on apps {
  id
  subdomain
  workspace {
    id
    paymentMethods {
      id
    }
  }
  legacyPlan {
    id
    name
  }
}
    `;
export const GetAppPlanAndGlobalPlansPlanFragmentDoc = gql`
    fragment getAppPlanAndGlobalPlansPlan on plans {
  id
  name
  isFree
  price
  featureMaxDbSize
}
    `;
export const PrefetchNewAppRegionsFragmentDoc = gql`
    fragment PrefetchNewAppRegions on regions {
  id
  city
  active
  country {
    code
    name
  }
}
    `;
export const PrefetchNewAppPlansFragmentDoc = gql`
    fragment PrefetchNewAppPlans on plans {
  id
  name
  isDefault
  isFree
  price
  featureBackupEnabled
  featureCustomDomainsEnabled
  featureMaxDbSize
}
    `;
export const PrefetchNewAppWorkspaceFragmentDoc = gql`
    fragment PrefetchNewAppWorkspace on workspaces {
  id
  name
  slug
  paymentMethods {
    id
  }
}
    `;
export const EnvironmentVariableFragmentDoc = gql`
    fragment EnvironmentVariable on ConfigGlobalEnvironmentVariable {
  id: name
  name
  value
}
    `;
export const JwtSecretFragmentDoc = gql`
    fragment JWTSecret on ConfigJWTSecret {
  issuer
  key
  type
  jwk_url
  header
  claims_namespace_path
  claims_namespace
  claims_format
  audience
  allowed_skew
}
    `;
export const PermissionVariableFragmentDoc = gql`
    fragment PermissionVariable on ConfigAuthsessionaccessTokenCustomClaims {
  id: key
  key
  value
}
    `;
export const SecretFragmentDoc = gql`
    fragment Secret on ConfigEnvironmentVariable {
  name
}
    `;
export const DeploymentRowFragmentDoc = gql`
    fragment DeploymentRow on deployments {
  id
  commitSHA
  deploymentStartedAt
  deploymentEndedAt
  deploymentStatus
  commitUserName
  commitUserAvatarUrl
  commitMessage
}
    `;
export const AppStateHistoryFragmentDoc = gql`
    fragment AppStateHistory on appStateHistory {
  id
  appId
  message
  stateId
  createdAt
}
    `;
export const ProjectFragmentDoc = gql`
    fragment Project on apps {
  id
  slug
  name
  repositoryProductionBranch
  subdomain
  createdAt
  desiredState
  nhostBaseFolder
  config(resolve: true) {
    observability {
      grafana {
        adminPassword
      }
    }
    hasura {
      adminSecret
      settings {
        enableConsole
      }
    }
    ai {
      version
    }
  }
  featureFlags {
    description
    id
    name
    value
  }
  appStates(order_by: {createdAt: desc}, limit: 1) {
    id
    appId
    message
    stateId
    createdAt
  }
  region {
    id
    countryCode
    name
    domain
    city
  }
  legacyPlan {
    id
    name
    price
    isFree
    featureMaxDbSize
  }
  githubRepository {
    fullName
  }
  deployments(limit: 4, order_by: {deploymentStartedAt: desc}) {
    id
    commitSHA
    commitMessage
    commitUserName
    deploymentStartedAt
    deploymentEndedAt
    commitUserAvatarUrl
    deploymentStatus
  }
  creator {
    id
    email
    displayName
  }
}
    `;
export const WorkspaceFragmentDoc = gql`
    fragment Workspace on workspaces {
  id
  name
  slug
  creatorUserId
  workspaceMembers {
    id
    user {
      id
      email
      displayName
    }
    type
  }
  projects: apps(order_by: {name: asc}) {
    ...Project
  }
}
    ${ProjectFragmentDoc}`;
export const GithubRepositoryFragmentDoc = gql`
    fragment GithubRepository on githubRepositories {
  id
  name
  fullName
  private
  githubAppInstallation {
    id
    accountLogin
    accountType
    accountAvatarUrl
  }
}
    `;
export const GetPaymentMethodsFragmentDoc = gql`
    fragment getPaymentMethods on paymentMethods {
  id
  createdAt
  cardBrand
  cardLast4
  cardExpMonth
  cardExpYear
  isDefault
  workspace {
    id
    apps {
      id
      legacyPlan {
        isFree
      }
    }
  }
}
    `;
export const RemoteAppGetUsersFragmentDoc = gql`
    fragment RemoteAppGetUsers on users {
  id
  createdAt
  displayName
  avatarUrl
  email
  emailVerified
  phoneNumber
  phoneNumberVerified
  disabled
  defaultRole
  lastSeen
  locale
  metadata
  roles {
    id
    role
  }
  userProviders {
    id
    providerId
  }
  disabled
}
    `;
export const RunServiceConfigFragmentDoc = gql`
    fragment RunServiceConfig on ConfigRunServiceConfig {
  name
  image {
    image
  }
  command
  resources {
    compute {
      cpu
      memory
    }
    storage {
      name
      path
      capacity
    }
    replicas
  }
  environment {
    name
    value
  }
  ports {
    port
    type
    publish
    ingresses {
      fqdn
    }
    rateLimit {
      limit
      interval
    }
  }
  healthCheck {
    port
    initialDelaySeconds
    probePeriodSeconds
  }
}
    `;
export const RunServiceRateLimitFragmentDoc = gql`
    fragment RunServiceRateLimit on ConfigRunServiceConfig {
  name
  ports {
    port
    type
    publish
    rateLimit {
      limit
      interval
    }
    ingresses {
      fqdn
    }
  }
}
    `;
export const GetWorkspaceMembersWorkspaceMemberFragmentDoc = gql`
    fragment getWorkspaceMembersWorkspaceMember on workspaceMembers {
  id
  type
  user {
    id
    displayName
    avatarUrl
    email
  }
}
    `;
export const GetWorkspaceMembersWorkspaceMemberInviteFragmentDoc = gql`
    fragment getWorkspaceMembersWorkspaceMemberInvite on workspaceMemberInvites {
  id
  email
  memberType
}
    `;
export const DeleteUserAccountDocument = gql`
    mutation deleteUserAccount($id: uuid!) {
  deleteUser(id: $id) {
    __typename
  }
}
    `;
export type DeleteUserAccountMutationFn = Apollo.MutationFunction<DeleteUserAccountMutation, DeleteUserAccountMutationVariables>;

/**
 * __useDeleteUserAccountMutation__
 *
 * To run a mutation, you first call `useDeleteUserAccountMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteUserAccountMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteUserAccountMutation, { data, loading, error }] = useDeleteUserAccountMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteUserAccountMutation(baseOptions?: Apollo.MutationHookOptions<DeleteUserAccountMutation, DeleteUserAccountMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteUserAccountMutation, DeleteUserAccountMutationVariables>(DeleteUserAccountDocument, options);
      }
export type DeleteUserAccountMutationHookResult = ReturnType<typeof useDeleteUserAccountMutation>;
export type DeleteUserAccountMutationResult = Apollo.MutationResult<DeleteUserAccountMutation>;
export type DeleteUserAccountMutationOptions = Apollo.BaseMutationOptions<DeleteUserAccountMutation, DeleteUserAccountMutationVariables>;
export const GetAuthUserProvidersDocument = gql`
    query getAuthUserProviders {
  authUserProviders {
    id
    providerId
  }
}
    `;

/**
 * __useGetAuthUserProvidersQuery__
 *
 * To run a query within a React component, call `useGetAuthUserProvidersQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAuthUserProvidersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAuthUserProvidersQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetAuthUserProvidersQuery(baseOptions?: Apollo.QueryHookOptions<GetAuthUserProvidersQuery, GetAuthUserProvidersQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetAuthUserProvidersQuery, GetAuthUserProvidersQueryVariables>(GetAuthUserProvidersDocument, options);
      }
export function useGetAuthUserProvidersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAuthUserProvidersQuery, GetAuthUserProvidersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetAuthUserProvidersQuery, GetAuthUserProvidersQueryVariables>(GetAuthUserProvidersDocument, options);
        }
export type GetAuthUserProvidersQueryHookResult = ReturnType<typeof useGetAuthUserProvidersQuery>;
export type GetAuthUserProvidersLazyQueryHookResult = ReturnType<typeof useGetAuthUserProvidersLazyQuery>;
export type GetAuthUserProvidersQueryResult = Apollo.QueryResult<GetAuthUserProvidersQuery, GetAuthUserProvidersQueryVariables>;
export function refetchGetAuthUserProvidersQuery(variables?: GetAuthUserProvidersQueryVariables) {
      return { query: GetAuthUserProvidersDocument, variables: variables }
    }
export const GetPersonalAccessTokensDocument = gql`
    query GetPersonalAccessTokens {
  personalAccessTokens: authRefreshTokens(
    where: {type: {_eq: pat}}
    order_by: {expiresAt: asc}
  ) {
    id
    metadata
    createdAt
    expiresAt
  }
}
    `;

/**
 * __useGetPersonalAccessTokensQuery__
 *
 * To run a query within a React component, call `useGetPersonalAccessTokensQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPersonalAccessTokensQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPersonalAccessTokensQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetPersonalAccessTokensQuery(baseOptions?: Apollo.QueryHookOptions<GetPersonalAccessTokensQuery, GetPersonalAccessTokensQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetPersonalAccessTokensQuery, GetPersonalAccessTokensQueryVariables>(GetPersonalAccessTokensDocument, options);
      }
export function useGetPersonalAccessTokensLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPersonalAccessTokensQuery, GetPersonalAccessTokensQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetPersonalAccessTokensQuery, GetPersonalAccessTokensQueryVariables>(GetPersonalAccessTokensDocument, options);
        }
export type GetPersonalAccessTokensQueryHookResult = ReturnType<typeof useGetPersonalAccessTokensQuery>;
export type GetPersonalAccessTokensLazyQueryHookResult = ReturnType<typeof useGetPersonalAccessTokensLazyQuery>;
export type GetPersonalAccessTokensQueryResult = Apollo.QueryResult<GetPersonalAccessTokensQuery, GetPersonalAccessTokensQueryVariables>;
export function refetchGetPersonalAccessTokensQuery(variables?: GetPersonalAccessTokensQueryVariables) {
      return { query: GetPersonalAccessTokensDocument, variables: variables }
    }
export const DeletePersonalAccessTokenDocument = gql`
    mutation DeletePersonalAccessToken($patId: uuid!) {
  deletePersonalAccessToken: deleteAuthRefreshToken(id: $patId) {
    id
    metadata
  }
}
    `;
export type DeletePersonalAccessTokenMutationFn = Apollo.MutationFunction<DeletePersonalAccessTokenMutation, DeletePersonalAccessTokenMutationVariables>;

/**
 * __useDeletePersonalAccessTokenMutation__
 *
 * To run a mutation, you first call `useDeletePersonalAccessTokenMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeletePersonalAccessTokenMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deletePersonalAccessTokenMutation, { data, loading, error }] = useDeletePersonalAccessTokenMutation({
 *   variables: {
 *      patId: // value for 'patId'
 *   },
 * });
 */
export function useDeletePersonalAccessTokenMutation(baseOptions?: Apollo.MutationHookOptions<DeletePersonalAccessTokenMutation, DeletePersonalAccessTokenMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeletePersonalAccessTokenMutation, DeletePersonalAccessTokenMutationVariables>(DeletePersonalAccessTokenDocument, options);
      }
export type DeletePersonalAccessTokenMutationHookResult = ReturnType<typeof useDeletePersonalAccessTokenMutation>;
export type DeletePersonalAccessTokenMutationResult = Apollo.MutationResult<DeletePersonalAccessTokenMutation>;
export type DeletePersonalAccessTokenMutationOptions = Apollo.BaseMutationOptions<DeletePersonalAccessTokenMutation, DeletePersonalAccessTokenMutationVariables>;
export const UpdateUserDisplayNameDocument = gql`
    mutation updateUserDisplayName($id: uuid!, $displayName: String!) {
  updateUser(pk_columns: {id: $id}, _set: {displayName: $displayName}) {
    id
    displayName
  }
}
    `;
export type UpdateUserDisplayNameMutationFn = Apollo.MutationFunction<UpdateUserDisplayNameMutation, UpdateUserDisplayNameMutationVariables>;

/**
 * __useUpdateUserDisplayNameMutation__
 *
 * To run a mutation, you first call `useUpdateUserDisplayNameMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateUserDisplayNameMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateUserDisplayNameMutation, { data, loading, error }] = useUpdateUserDisplayNameMutation({
 *   variables: {
 *      id: // value for 'id'
 *      displayName: // value for 'displayName'
 *   },
 * });
 */
export function useUpdateUserDisplayNameMutation(baseOptions?: Apollo.MutationHookOptions<UpdateUserDisplayNameMutation, UpdateUserDisplayNameMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateUserDisplayNameMutation, UpdateUserDisplayNameMutationVariables>(UpdateUserDisplayNameDocument, options);
      }
export type UpdateUserDisplayNameMutationHookResult = ReturnType<typeof useUpdateUserDisplayNameMutation>;
export type UpdateUserDisplayNameMutationResult = Apollo.MutationResult<UpdateUserDisplayNameMutation>;
export type UpdateUserDisplayNameMutationOptions = Apollo.BaseMutationOptions<UpdateUserDisplayNameMutation, UpdateUserDisplayNameMutationVariables>;
export const GetAiSettingsDocument = gql`
    query GetAISettings($appId: uuid!) {
  config(appID: $appId, resolve: false) {
    postgres {
      version
    }
    ai {
      version
      webhookSecret
      autoEmbeddings {
        synchPeriodMinutes
      }
      openai {
        apiKey
        organization
      }
      resources {
        compute {
          cpu
          memory
        }
      }
    }
  }
}
    `;

/**
 * __useGetAiSettingsQuery__
 *
 * To run a query within a React component, call `useGetAiSettingsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAiSettingsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAiSettingsQuery({
 *   variables: {
 *      appId: // value for 'appId'
 *   },
 * });
 */
export function useGetAiSettingsQuery(baseOptions: Apollo.QueryHookOptions<GetAiSettingsQuery, GetAiSettingsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetAiSettingsQuery, GetAiSettingsQueryVariables>(GetAiSettingsDocument, options);
      }
export function useGetAiSettingsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAiSettingsQuery, GetAiSettingsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetAiSettingsQuery, GetAiSettingsQueryVariables>(GetAiSettingsDocument, options);
        }
export type GetAiSettingsQueryHookResult = ReturnType<typeof useGetAiSettingsQuery>;
export type GetAiSettingsLazyQueryHookResult = ReturnType<typeof useGetAiSettingsLazyQuery>;
export type GetAiSettingsQueryResult = Apollo.QueryResult<GetAiSettingsQuery, GetAiSettingsQueryVariables>;
export function refetchGetAiSettingsQuery(variables: GetAiSettingsQueryVariables) {
      return { query: GetAiSettingsDocument, variables: variables }
    }
export const GetAuthenticationSettingsDocument = gql`
    query GetAuthenticationSettings($appId: uuid!) {
  config(appID: $appId, resolve: false) {
    id: __typename
    __typename
    auth {
      id: __typename
      __typename
      redirections {
        clientUrl
        allowedUrls
      }
      totp {
        enabled
        issuer
      }
      signUp {
        enabled
      }
      session {
        accessToken {
          expiresIn
        }
        refreshToken {
          expiresIn
        }
      }
      resources {
        networking {
          ingresses {
            fqdn
          }
        }
      }
      user {
        email {
          allowed
          blocked
        }
        emailDomains {
          allowed
          blocked
        }
        gravatar {
          enabled
          default
          rating
        }
        locale {
          allowed
          default
        }
      }
      misc {
        concealErrors
      }
      version
    }
  }
}
    `;

/**
 * __useGetAuthenticationSettingsQuery__
 *
 * To run a query within a React component, call `useGetAuthenticationSettingsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAuthenticationSettingsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAuthenticationSettingsQuery({
 *   variables: {
 *      appId: // value for 'appId'
 *   },
 * });
 */
export function useGetAuthenticationSettingsQuery(baseOptions: Apollo.QueryHookOptions<GetAuthenticationSettingsQuery, GetAuthenticationSettingsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetAuthenticationSettingsQuery, GetAuthenticationSettingsQueryVariables>(GetAuthenticationSettingsDocument, options);
      }
export function useGetAuthenticationSettingsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAuthenticationSettingsQuery, GetAuthenticationSettingsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetAuthenticationSettingsQuery, GetAuthenticationSettingsQueryVariables>(GetAuthenticationSettingsDocument, options);
        }
export type GetAuthenticationSettingsQueryHookResult = ReturnType<typeof useGetAuthenticationSettingsQuery>;
export type GetAuthenticationSettingsLazyQueryHookResult = ReturnType<typeof useGetAuthenticationSettingsLazyQuery>;
export type GetAuthenticationSettingsQueryResult = Apollo.QueryResult<GetAuthenticationSettingsQuery, GetAuthenticationSettingsQueryVariables>;
export function refetchGetAuthenticationSettingsQuery(variables: GetAuthenticationSettingsQueryVariables) {
      return { query: GetAuthenticationSettingsDocument, variables: variables }
    }
export const GetPostgresSettingsDocument = gql`
    query GetPostgresSettings($appId: uuid!) {
  systemConfig(appID: $appId) {
    postgres {
      database
    }
  }
  config(appID: $appId, resolve: false) {
    id: __typename
    __typename
    postgres {
      version
      resources {
        storage {
          capacity
        }
        enablePublicAccess
      }
    }
  }
}
    `;

/**
 * __useGetPostgresSettingsQuery__
 *
 * To run a query within a React component, call `useGetPostgresSettingsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPostgresSettingsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPostgresSettingsQuery({
 *   variables: {
 *      appId: // value for 'appId'
 *   },
 * });
 */
export function useGetPostgresSettingsQuery(baseOptions: Apollo.QueryHookOptions<GetPostgresSettingsQuery, GetPostgresSettingsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetPostgresSettingsQuery, GetPostgresSettingsQueryVariables>(GetPostgresSettingsDocument, options);
      }
export function useGetPostgresSettingsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPostgresSettingsQuery, GetPostgresSettingsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetPostgresSettingsQuery, GetPostgresSettingsQueryVariables>(GetPostgresSettingsDocument, options);
        }
export type GetPostgresSettingsQueryHookResult = ReturnType<typeof useGetPostgresSettingsQuery>;
export type GetPostgresSettingsLazyQueryHookResult = ReturnType<typeof useGetPostgresSettingsLazyQuery>;
export type GetPostgresSettingsQueryResult = Apollo.QueryResult<GetPostgresSettingsQuery, GetPostgresSettingsQueryVariables>;
export function refetchGetPostgresSettingsQuery(variables: GetPostgresSettingsQueryVariables) {
      return { query: GetPostgresSettingsDocument, variables: variables }
    }
export const ResetDatabasePasswordDocument = gql`
    mutation ResetDatabasePassword($appId: String!, $newPassword: String!) {
  resetPostgresPassword(appID: $appId, newPassword: $newPassword)
}
    `;
export type ResetDatabasePasswordMutationFn = Apollo.MutationFunction<ResetDatabasePasswordMutation, ResetDatabasePasswordMutationVariables>;

/**
 * __useResetDatabasePasswordMutation__
 *
 * To run a mutation, you first call `useResetDatabasePasswordMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useResetDatabasePasswordMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [resetDatabasePasswordMutation, { data, loading, error }] = useResetDatabasePasswordMutation({
 *   variables: {
 *      appId: // value for 'appId'
 *      newPassword: // value for 'newPassword'
 *   },
 * });
 */
export function useResetDatabasePasswordMutation(baseOptions?: Apollo.MutationHookOptions<ResetDatabasePasswordMutation, ResetDatabasePasswordMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ResetDatabasePasswordMutation, ResetDatabasePasswordMutationVariables>(ResetDatabasePasswordDocument, options);
      }
export type ResetDatabasePasswordMutationHookResult = ReturnType<typeof useResetDatabasePasswordMutation>;
export type ResetDatabasePasswordMutationResult = Apollo.MutationResult<ResetDatabasePasswordMutation>;
export type ResetDatabasePasswordMutationOptions = Apollo.BaseMutationOptions<ResetDatabasePasswordMutation, ResetDatabasePasswordMutationVariables>;
export const GetHasuraSettingsDocument = gql`
    query GetHasuraSettings($appId: uuid!) {
  config(appID: $appId, resolve: false) {
    id: __typename
    __typename
    hasura {
      version
      settings {
        enableAllowList
        enableRemoteSchemaPermissions
        enableConsole
        devMode
        corsDomain
        enabledAPIs
      }
      logs {
        level
      }
      events {
        httpPoolSize
      }
      resources {
        networking {
          ingresses {
            fqdn
          }
        }
      }
    }
  }
}
    `;

/**
 * __useGetHasuraSettingsQuery__
 *
 * To run a query within a React component, call `useGetHasuraSettingsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetHasuraSettingsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetHasuraSettingsQuery({
 *   variables: {
 *      appId: // value for 'appId'
 *   },
 * });
 */
export function useGetHasuraSettingsQuery(baseOptions: Apollo.QueryHookOptions<GetHasuraSettingsQuery, GetHasuraSettingsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetHasuraSettingsQuery, GetHasuraSettingsQueryVariables>(GetHasuraSettingsDocument, options);
      }
export function useGetHasuraSettingsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetHasuraSettingsQuery, GetHasuraSettingsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetHasuraSettingsQuery, GetHasuraSettingsQueryVariables>(GetHasuraSettingsDocument, options);
        }
export type GetHasuraSettingsQueryHookResult = ReturnType<typeof useGetHasuraSettingsQuery>;
export type GetHasuraSettingsLazyQueryHookResult = ReturnType<typeof useGetHasuraSettingsLazyQuery>;
export type GetHasuraSettingsQueryResult = Apollo.QueryResult<GetHasuraSettingsQuery, GetHasuraSettingsQueryVariables>;
export function refetchGetHasuraSettingsQuery(variables: GetHasuraSettingsQueryVariables) {
      return { query: GetHasuraSettingsDocument, variables: variables }
    }
export const GetApplicationBackupsDocument = gql`
    query getApplicationBackups($appId: uuid!) {
  app(id: $appId) {
    backups(order_by: {createdAt: desc}) {
      ...Backup
    }
  }
}
    ${BackupFragmentDoc}`;

/**
 * __useGetApplicationBackupsQuery__
 *
 * To run a query within a React component, call `useGetApplicationBackupsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetApplicationBackupsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetApplicationBackupsQuery({
 *   variables: {
 *      appId: // value for 'appId'
 *   },
 * });
 */
export function useGetApplicationBackupsQuery(baseOptions: Apollo.QueryHookOptions<GetApplicationBackupsQuery, GetApplicationBackupsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetApplicationBackupsQuery, GetApplicationBackupsQueryVariables>(GetApplicationBackupsDocument, options);
      }
export function useGetApplicationBackupsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetApplicationBackupsQuery, GetApplicationBackupsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetApplicationBackupsQuery, GetApplicationBackupsQueryVariables>(GetApplicationBackupsDocument, options);
        }
export type GetApplicationBackupsQueryHookResult = ReturnType<typeof useGetApplicationBackupsQuery>;
export type GetApplicationBackupsLazyQueryHookResult = ReturnType<typeof useGetApplicationBackupsLazyQuery>;
export type GetApplicationBackupsQueryResult = Apollo.QueryResult<GetApplicationBackupsQuery, GetApplicationBackupsQueryVariables>;
export function refetchGetApplicationBackupsQuery(variables: GetApplicationBackupsQueryVariables) {
      return { query: GetApplicationBackupsDocument, variables: variables }
    }
export const GetBackupPresignedUrlDocument = gql`
    query GetBackupPresignedUrl($appId: String!, $backupId: String!, $expireInMinutes: Int) {
  getBackupPresignedUrl: getBackupPresignedURL(
    appID: $appId
    backupID: $backupId
    expireInMinutes: $expireInMinutes
  ) {
    url
    expiresAt: expires_at
  }
}
    `;

/**
 * __useGetBackupPresignedUrlQuery__
 *
 * To run a query within a React component, call `useGetBackupPresignedUrlQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetBackupPresignedUrlQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetBackupPresignedUrlQuery({
 *   variables: {
 *      appId: // value for 'appId'
 *      backupId: // value for 'backupId'
 *      expireInMinutes: // value for 'expireInMinutes'
 *   },
 * });
 */
export function useGetBackupPresignedUrlQuery(baseOptions: Apollo.QueryHookOptions<GetBackupPresignedUrlQuery, GetBackupPresignedUrlQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetBackupPresignedUrlQuery, GetBackupPresignedUrlQueryVariables>(GetBackupPresignedUrlDocument, options);
      }
export function useGetBackupPresignedUrlLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetBackupPresignedUrlQuery, GetBackupPresignedUrlQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetBackupPresignedUrlQuery, GetBackupPresignedUrlQueryVariables>(GetBackupPresignedUrlDocument, options);
        }
export type GetBackupPresignedUrlQueryHookResult = ReturnType<typeof useGetBackupPresignedUrlQuery>;
export type GetBackupPresignedUrlLazyQueryHookResult = ReturnType<typeof useGetBackupPresignedUrlLazyQuery>;
export type GetBackupPresignedUrlQueryResult = Apollo.QueryResult<GetBackupPresignedUrlQuery, GetBackupPresignedUrlQueryVariables>;
export function refetchGetBackupPresignedUrlQuery(variables: GetBackupPresignedUrlQueryVariables) {
      return { query: GetBackupPresignedUrlDocument, variables: variables }
    }
export const GetResourcesDocument = gql`
    query GetResources($appId: uuid!) {
  config(appID: $appId, resolve: false) {
    ...ServiceResources
  }
}
    ${ServiceResourcesFragmentDoc}`;

/**
 * __useGetResourcesQuery__
 *
 * To run a query within a React component, call `useGetResourcesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetResourcesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetResourcesQuery({
 *   variables: {
 *      appId: // value for 'appId'
 *   },
 * });
 */
export function useGetResourcesQuery(baseOptions: Apollo.QueryHookOptions<GetResourcesQuery, GetResourcesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetResourcesQuery, GetResourcesQueryVariables>(GetResourcesDocument, options);
      }
export function useGetResourcesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetResourcesQuery, GetResourcesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetResourcesQuery, GetResourcesQueryVariables>(GetResourcesDocument, options);
        }
export type GetResourcesQueryHookResult = ReturnType<typeof useGetResourcesQuery>;
export type GetResourcesLazyQueryHookResult = ReturnType<typeof useGetResourcesLazyQuery>;
export type GetResourcesQueryResult = Apollo.QueryResult<GetResourcesQuery, GetResourcesQueryVariables>;
export function refetchGetResourcesQuery(variables: GetResourcesQueryVariables) {
      return { query: GetResourcesDocument, variables: variables }
    }
export const GetServerlessFunctionsSettingsDocument = gql`
    query GetServerlessFunctionsSettings($appId: uuid!) {
  config(appID: $appId, resolve: false) {
    functions {
      resources {
        networking {
          ingresses {
            fqdn
          }
        }
      }
    }
  }
}
    `;

/**
 * __useGetServerlessFunctionsSettingsQuery__
 *
 * To run a query within a React component, call `useGetServerlessFunctionsSettingsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetServerlessFunctionsSettingsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetServerlessFunctionsSettingsQuery({
 *   variables: {
 *      appId: // value for 'appId'
 *   },
 * });
 */
export function useGetServerlessFunctionsSettingsQuery(baseOptions: Apollo.QueryHookOptions<GetServerlessFunctionsSettingsQuery, GetServerlessFunctionsSettingsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetServerlessFunctionsSettingsQuery, GetServerlessFunctionsSettingsQueryVariables>(GetServerlessFunctionsSettingsDocument, options);
      }
export function useGetServerlessFunctionsSettingsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetServerlessFunctionsSettingsQuery, GetServerlessFunctionsSettingsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetServerlessFunctionsSettingsQuery, GetServerlessFunctionsSettingsQueryVariables>(GetServerlessFunctionsSettingsDocument, options);
        }
export type GetServerlessFunctionsSettingsQueryHookResult = ReturnType<typeof useGetServerlessFunctionsSettingsQuery>;
export type GetServerlessFunctionsSettingsLazyQueryHookResult = ReturnType<typeof useGetServerlessFunctionsSettingsLazyQuery>;
export type GetServerlessFunctionsSettingsQueryResult = Apollo.QueryResult<GetServerlessFunctionsSettingsQuery, GetServerlessFunctionsSettingsQueryVariables>;
export function refetchGetServerlessFunctionsSettingsQuery(variables: GetServerlessFunctionsSettingsQueryVariables) {
      return { query: GetServerlessFunctionsSettingsDocument, variables: variables }
    }
export const GetStorageSettingsDocument = gql`
    query GetStorageSettings($appId: uuid!) {
  config(appID: $appId, resolve: false) {
    id: __typename
    __typename
    storage {
      version
      antivirus {
        server
      }
    }
  }
}
    `;

/**
 * __useGetStorageSettingsQuery__
 *
 * To run a query within a React component, call `useGetStorageSettingsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetStorageSettingsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetStorageSettingsQuery({
 *   variables: {
 *      appId: // value for 'appId'
 *   },
 * });
 */
export function useGetStorageSettingsQuery(baseOptions: Apollo.QueryHookOptions<GetStorageSettingsQuery, GetStorageSettingsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetStorageSettingsQuery, GetStorageSettingsQueryVariables>(GetStorageSettingsDocument, options);
      }
export function useGetStorageSettingsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetStorageSettingsQuery, GetStorageSettingsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetStorageSettingsQuery, GetStorageSettingsQueryVariables>(GetStorageSettingsDocument, options);
        }
export type GetStorageSettingsQueryHookResult = ReturnType<typeof useGetStorageSettingsQuery>;
export type GetStorageSettingsLazyQueryHookResult = ReturnType<typeof useGetStorageSettingsLazyQuery>;
export type GetStorageSettingsQueryResult = Apollo.QueryResult<GetStorageSettingsQuery, GetStorageSettingsQueryVariables>;
export function refetchGetStorageSettingsQuery(variables: GetStorageSettingsQueryVariables) {
      return { query: GetStorageSettingsDocument, variables: variables }
    }
export const DeleteApplicationDocument = gql`
    mutation deleteApplication($appId: uuid!) {
  deleteApp(id: $appId) {
    id
  }
}
    `;
export type DeleteApplicationMutationFn = Apollo.MutationFunction<DeleteApplicationMutation, DeleteApplicationMutationVariables>;

/**
 * __useDeleteApplicationMutation__
 *
 * To run a mutation, you first call `useDeleteApplicationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteApplicationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteApplicationMutation, { data, loading, error }] = useDeleteApplicationMutation({
 *   variables: {
 *      appId: // value for 'appId'
 *   },
 * });
 */
export function useDeleteApplicationMutation(baseOptions?: Apollo.MutationHookOptions<DeleteApplicationMutation, DeleteApplicationMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteApplicationMutation, DeleteApplicationMutationVariables>(DeleteApplicationDocument, options);
      }
export type DeleteApplicationMutationHookResult = ReturnType<typeof useDeleteApplicationMutation>;
export type DeleteApplicationMutationResult = Apollo.MutationResult<DeleteApplicationMutation>;
export type DeleteApplicationMutationOptions = Apollo.BaseMutationOptions<DeleteApplicationMutation, DeleteApplicationMutationVariables>;
export const GetAllWorkspacesAndProjectsDocument = gql`
    query GetAllWorkspacesAndProjects {
  workspaces(order_by: {name: asc}) {
    ...Workspace
  }
}
    ${WorkspaceFragmentDoc}`;

/**
 * __useGetAllWorkspacesAndProjectsQuery__
 *
 * To run a query within a React component, call `useGetAllWorkspacesAndProjectsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAllWorkspacesAndProjectsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAllWorkspacesAndProjectsQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetAllWorkspacesAndProjectsQuery(baseOptions?: Apollo.QueryHookOptions<GetAllWorkspacesAndProjectsQuery, GetAllWorkspacesAndProjectsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetAllWorkspacesAndProjectsQuery, GetAllWorkspacesAndProjectsQueryVariables>(GetAllWorkspacesAndProjectsDocument, options);
      }
export function useGetAllWorkspacesAndProjectsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAllWorkspacesAndProjectsQuery, GetAllWorkspacesAndProjectsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetAllWorkspacesAndProjectsQuery, GetAllWorkspacesAndProjectsQueryVariables>(GetAllWorkspacesAndProjectsDocument, options);
        }
export type GetAllWorkspacesAndProjectsQueryHookResult = ReturnType<typeof useGetAllWorkspacesAndProjectsQuery>;
export type GetAllWorkspacesAndProjectsLazyQueryHookResult = ReturnType<typeof useGetAllWorkspacesAndProjectsLazyQuery>;
export type GetAllWorkspacesAndProjectsQueryResult = Apollo.QueryResult<GetAllWorkspacesAndProjectsQuery, GetAllWorkspacesAndProjectsQueryVariables>;
export function refetchGetAllWorkspacesAndProjectsQuery(variables?: GetAllWorkspacesAndProjectsQueryVariables) {
      return { query: GetAllWorkspacesAndProjectsDocument, variables: variables }
    }
export const GetAppPlanAndGlobalPlansDocument = gql`
    query getAppPlanAndGlobalPlans($workspaceSlug: String!, $appSlug: String!) {
  apps(where: {workspace: {slug: {_eq: $workspaceSlug}}, slug: {_eq: $appSlug}}) {
    ...getAppPlanAndGlobalPlansApp
  }
  plans {
    ...getAppPlanAndGlobalPlansPlan
  }
}
    ${GetAppPlanAndGlobalPlansAppFragmentDoc}
${GetAppPlanAndGlobalPlansPlanFragmentDoc}`;

/**
 * __useGetAppPlanAndGlobalPlansQuery__
 *
 * To run a query within a React component, call `useGetAppPlanAndGlobalPlansQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAppPlanAndGlobalPlansQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAppPlanAndGlobalPlansQuery({
 *   variables: {
 *      workspaceSlug: // value for 'workspaceSlug'
 *      appSlug: // value for 'appSlug'
 *   },
 * });
 */
export function useGetAppPlanAndGlobalPlansQuery(baseOptions: Apollo.QueryHookOptions<GetAppPlanAndGlobalPlansQuery, GetAppPlanAndGlobalPlansQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetAppPlanAndGlobalPlansQuery, GetAppPlanAndGlobalPlansQueryVariables>(GetAppPlanAndGlobalPlansDocument, options);
      }
export function useGetAppPlanAndGlobalPlansLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAppPlanAndGlobalPlansQuery, GetAppPlanAndGlobalPlansQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetAppPlanAndGlobalPlansQuery, GetAppPlanAndGlobalPlansQueryVariables>(GetAppPlanAndGlobalPlansDocument, options);
        }
export type GetAppPlanAndGlobalPlansQueryHookResult = ReturnType<typeof useGetAppPlanAndGlobalPlansQuery>;
export type GetAppPlanAndGlobalPlansLazyQueryHookResult = ReturnType<typeof useGetAppPlanAndGlobalPlansLazyQuery>;
export type GetAppPlanAndGlobalPlansQueryResult = Apollo.QueryResult<GetAppPlanAndGlobalPlansQuery, GetAppPlanAndGlobalPlansQueryVariables>;
export function refetchGetAppPlanAndGlobalPlansQuery(variables: GetAppPlanAndGlobalPlansQueryVariables) {
      return { query: GetAppPlanAndGlobalPlansDocument, variables: variables }
    }
export const GetApplicationPlanDocument = gql`
    query getApplicationPlan($workspace: String!, $slug: String!) {
  apps(where: {workspace: {slug: {_eq: $workspace}}, slug: {_eq: $slug}}) {
    id
    subdomain
    legacyPlan {
      name
      price
      upatedAt
      featureMaxDbSize
    }
  }
}
    `;

/**
 * __useGetApplicationPlanQuery__
 *
 * To run a query within a React component, call `useGetApplicationPlanQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetApplicationPlanQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetApplicationPlanQuery({
 *   variables: {
 *      workspace: // value for 'workspace'
 *      slug: // value for 'slug'
 *   },
 * });
 */
export function useGetApplicationPlanQuery(baseOptions: Apollo.QueryHookOptions<GetApplicationPlanQuery, GetApplicationPlanQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetApplicationPlanQuery, GetApplicationPlanQueryVariables>(GetApplicationPlanDocument, options);
      }
export function useGetApplicationPlanLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetApplicationPlanQuery, GetApplicationPlanQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetApplicationPlanQuery, GetApplicationPlanQueryVariables>(GetApplicationPlanDocument, options);
        }
export type GetApplicationPlanQueryHookResult = ReturnType<typeof useGetApplicationPlanQuery>;
export type GetApplicationPlanLazyQueryHookResult = ReturnType<typeof useGetApplicationPlanLazyQuery>;
export type GetApplicationPlanQueryResult = Apollo.QueryResult<GetApplicationPlanQuery, GetApplicationPlanQueryVariables>;
export function refetchGetApplicationPlanQuery(variables: GetApplicationPlanQueryVariables) {
      return { query: GetApplicationPlanDocument, variables: variables }
    }
export const GetApplicationStateDocument = gql`
    query getApplicationState($appId: uuid!) {
  app(id: $appId) {
    id
    name
    appStates(order_by: {createdAt: desc}, limit: 10) {
      ...AppStateHistory
    }
  }
}
    ${AppStateHistoryFragmentDoc}`;

/**
 * __useGetApplicationStateQuery__
 *
 * To run a query within a React component, call `useGetApplicationStateQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetApplicationStateQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetApplicationStateQuery({
 *   variables: {
 *      appId: // value for 'appId'
 *   },
 * });
 */
export function useGetApplicationStateQuery(baseOptions: Apollo.QueryHookOptions<GetApplicationStateQuery, GetApplicationStateQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetApplicationStateQuery, GetApplicationStateQueryVariables>(GetApplicationStateDocument, options);
      }
export function useGetApplicationStateLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetApplicationStateQuery, GetApplicationStateQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetApplicationStateQuery, GetApplicationStateQueryVariables>(GetApplicationStateDocument, options);
        }
export type GetApplicationStateQueryHookResult = ReturnType<typeof useGetApplicationStateQuery>;
export type GetApplicationStateLazyQueryHookResult = ReturnType<typeof useGetApplicationStateLazyQuery>;
export type GetApplicationStateQueryResult = Apollo.QueryResult<GetApplicationStateQuery, GetApplicationStateQueryVariables>;
export function refetchGetApplicationStateQuery(variables: GetApplicationStateQueryVariables) {
      return { query: GetApplicationStateDocument, variables: variables }
    }
export const GetConfiguredVersionsDocument = gql`
    query getConfiguredVersions($appId: uuid!) {
  config(appID: $appId, resolve: true) {
    auth {
      version
    }
    postgres {
      version
    }
    hasura {
      version
    }
    ai {
      version
    }
    storage {
      version
    }
  }
}
    `;

/**
 * __useGetConfiguredVersionsQuery__
 *
 * To run a query within a React component, call `useGetConfiguredVersionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetConfiguredVersionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetConfiguredVersionsQuery({
 *   variables: {
 *      appId: // value for 'appId'
 *   },
 * });
 */
export function useGetConfiguredVersionsQuery(baseOptions: Apollo.QueryHookOptions<GetConfiguredVersionsQuery, GetConfiguredVersionsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetConfiguredVersionsQuery, GetConfiguredVersionsQueryVariables>(GetConfiguredVersionsDocument, options);
      }
export function useGetConfiguredVersionsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetConfiguredVersionsQuery, GetConfiguredVersionsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetConfiguredVersionsQuery, GetConfiguredVersionsQueryVariables>(GetConfiguredVersionsDocument, options);
        }
export type GetConfiguredVersionsQueryHookResult = ReturnType<typeof useGetConfiguredVersionsQuery>;
export type GetConfiguredVersionsLazyQueryHookResult = ReturnType<typeof useGetConfiguredVersionsLazyQuery>;
export type GetConfiguredVersionsQueryResult = Apollo.QueryResult<GetConfiguredVersionsQuery, GetConfiguredVersionsQueryVariables>;
export function refetchGetConfiguredVersionsQuery(variables: GetConfiguredVersionsQueryVariables) {
      return { query: GetConfiguredVersionsDocument, variables: variables }
    }
export const GetProjectIsLockedDocument = gql`
    query getProjectIsLocked($appId: uuid!) {
  app(id: $appId) {
    isLocked
    isLockedReason
  }
}
    `;

/**
 * __useGetProjectIsLockedQuery__
 *
 * To run a query within a React component, call `useGetProjectIsLockedQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetProjectIsLockedQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetProjectIsLockedQuery({
 *   variables: {
 *      appId: // value for 'appId'
 *   },
 * });
 */
export function useGetProjectIsLockedQuery(baseOptions: Apollo.QueryHookOptions<GetProjectIsLockedQuery, GetProjectIsLockedQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetProjectIsLockedQuery, GetProjectIsLockedQueryVariables>(GetProjectIsLockedDocument, options);
      }
export function useGetProjectIsLockedLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetProjectIsLockedQuery, GetProjectIsLockedQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetProjectIsLockedQuery, GetProjectIsLockedQueryVariables>(GetProjectIsLockedDocument, options);
        }
export type GetProjectIsLockedQueryHookResult = ReturnType<typeof useGetProjectIsLockedQuery>;
export type GetProjectIsLockedLazyQueryHookResult = ReturnType<typeof useGetProjectIsLockedLazyQuery>;
export type GetProjectIsLockedQueryResult = Apollo.QueryResult<GetProjectIsLockedQuery, GetProjectIsLockedQueryVariables>;
export function refetchGetProjectIsLockedQuery(variables: GetProjectIsLockedQueryVariables) {
      return { query: GetProjectIsLockedDocument, variables: variables }
    }
export const GetProjectLocalesDocument = gql`
    query getProjectLocales($appId: uuid!) {
  config(appID: $appId, resolve: false) {
    auth {
      user {
        locale {
          allowed
          default
        }
      }
    }
  }
}
    `;

/**
 * __useGetProjectLocalesQuery__
 *
 * To run a query within a React component, call `useGetProjectLocalesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetProjectLocalesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetProjectLocalesQuery({
 *   variables: {
 *      appId: // value for 'appId'
 *   },
 * });
 */
export function useGetProjectLocalesQuery(baseOptions: Apollo.QueryHookOptions<GetProjectLocalesQuery, GetProjectLocalesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetProjectLocalesQuery, GetProjectLocalesQueryVariables>(GetProjectLocalesDocument, options);
      }
export function useGetProjectLocalesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetProjectLocalesQuery, GetProjectLocalesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetProjectLocalesQuery, GetProjectLocalesQueryVariables>(GetProjectLocalesDocument, options);
        }
export type GetProjectLocalesQueryHookResult = ReturnType<typeof useGetProjectLocalesQuery>;
export type GetProjectLocalesLazyQueryHookResult = ReturnType<typeof useGetProjectLocalesLazyQuery>;
export type GetProjectLocalesQueryResult = Apollo.QueryResult<GetProjectLocalesQuery, GetProjectLocalesQueryVariables>;
export function refetchGetProjectLocalesQuery(variables: GetProjectLocalesQueryVariables) {
      return { query: GetProjectLocalesDocument, variables: variables }
    }
export const GetProjectMetricsDocument = gql`
    query GetProjectMetrics($appId: String!, $subdomain: String!, $from: Timestamp, $to: Timestamp) {
  logsVolume: getLogsVolume(appID: $appId, from: $from, to: $to) {
    value
  }
  cpuSecondsUsage: getCPUSecondsUsage(appID: $appId, from: $from, to: $to) {
    value
  }
  functionInvocations: getFunctionsInvocations(
    appID: $appId
    from: $from
    to: $to
  ) {
    value
  }
  functionsDuration: getFunctionsDuration(appID: $appId, from: $from, to: $to) {
    value
  }
  postgresVolumeCapacity: getPostgresVolumeCapacity(appID: $appId) {
    value
  }
  postgresVolumeUsage: getPostgresVolumeUsage(appID: $appId) {
    value
  }
  totalRequests: getTotalRequests(appID: $appId, from: $from, to: $to) {
    value
  }
  egressVolume: getEgressVolume(
    appID: $appId
    subdomain: $subdomain
    from: $from
    to: $to
  ) {
    value
  }
}
    `;

/**
 * __useGetProjectMetricsQuery__
 *
 * To run a query within a React component, call `useGetProjectMetricsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetProjectMetricsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetProjectMetricsQuery({
 *   variables: {
 *      appId: // value for 'appId'
 *      subdomain: // value for 'subdomain'
 *      from: // value for 'from'
 *      to: // value for 'to'
 *   },
 * });
 */
export function useGetProjectMetricsQuery(baseOptions: Apollo.QueryHookOptions<GetProjectMetricsQuery, GetProjectMetricsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetProjectMetricsQuery, GetProjectMetricsQueryVariables>(GetProjectMetricsDocument, options);
      }
export function useGetProjectMetricsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetProjectMetricsQuery, GetProjectMetricsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetProjectMetricsQuery, GetProjectMetricsQueryVariables>(GetProjectMetricsDocument, options);
        }
export type GetProjectMetricsQueryHookResult = ReturnType<typeof useGetProjectMetricsQuery>;
export type GetProjectMetricsLazyQueryHookResult = ReturnType<typeof useGetProjectMetricsLazyQuery>;
export type GetProjectMetricsQueryResult = Apollo.QueryResult<GetProjectMetricsQuery, GetProjectMetricsQueryVariables>;
export function refetchGetProjectMetricsQuery(variables: GetProjectMetricsQueryVariables) {
      return { query: GetProjectMetricsDocument, variables: variables }
    }
export const GetProjectServicesHealthDocument = gql`
    query getProjectServicesHealth($appId: String!) {
  getProjectStatus(appID: $appId) {
    services {
      name
      state
      replicas {
        ready
        date
        errors {
          name
          lastError {
            reason
            exitCode
            message
          }
        }
      }
    }
  }
}
    `;

/**
 * __useGetProjectServicesHealthQuery__
 *
 * To run a query within a React component, call `useGetProjectServicesHealthQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetProjectServicesHealthQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetProjectServicesHealthQuery({
 *   variables: {
 *      appId: // value for 'appId'
 *   },
 * });
 */
export function useGetProjectServicesHealthQuery(baseOptions: Apollo.QueryHookOptions<GetProjectServicesHealthQuery, GetProjectServicesHealthQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetProjectServicesHealthQuery, GetProjectServicesHealthQueryVariables>(GetProjectServicesHealthDocument, options);
      }
export function useGetProjectServicesHealthLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetProjectServicesHealthQuery, GetProjectServicesHealthQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetProjectServicesHealthQuery, GetProjectServicesHealthQueryVariables>(GetProjectServicesHealthDocument, options);
        }
export type GetProjectServicesHealthQueryHookResult = ReturnType<typeof useGetProjectServicesHealthQuery>;
export type GetProjectServicesHealthLazyQueryHookResult = ReturnType<typeof useGetProjectServicesHealthLazyQuery>;
export type GetProjectServicesHealthQueryResult = Apollo.QueryResult<GetProjectServicesHealthQuery, GetProjectServicesHealthQueryVariables>;
export function refetchGetProjectServicesHealthQuery(variables: GetProjectServicesHealthQueryVariables) {
      return { query: GetProjectServicesHealthDocument, variables: variables }
    }
export const GetRemoteAppRolesDocument = gql`
    query getRemoteAppRoles {
  authRoles {
    role
  }
}
    `;

/**
 * __useGetRemoteAppRolesQuery__
 *
 * To run a query within a React component, call `useGetRemoteAppRolesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetRemoteAppRolesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetRemoteAppRolesQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetRemoteAppRolesQuery(baseOptions?: Apollo.QueryHookOptions<GetRemoteAppRolesQuery, GetRemoteAppRolesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetRemoteAppRolesQuery, GetRemoteAppRolesQueryVariables>(GetRemoteAppRolesDocument, options);
      }
export function useGetRemoteAppRolesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetRemoteAppRolesQuery, GetRemoteAppRolesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetRemoteAppRolesQuery, GetRemoteAppRolesQueryVariables>(GetRemoteAppRolesDocument, options);
        }
export type GetRemoteAppRolesQueryHookResult = ReturnType<typeof useGetRemoteAppRolesQuery>;
export type GetRemoteAppRolesLazyQueryHookResult = ReturnType<typeof useGetRemoteAppRolesLazyQuery>;
export type GetRemoteAppRolesQueryResult = Apollo.QueryResult<GetRemoteAppRolesQuery, GetRemoteAppRolesQueryVariables>;
export function refetchGetRemoteAppRolesQuery(variables?: GetRemoteAppRolesQueryVariables) {
      return { query: GetRemoteAppRolesDocument, variables: variables }
    }
export const GetWorkspaceAndProjectDocument = gql`
    query GetWorkspaceAndProject($workspaceSlug: String!, $projectSlug: String) {
  workspaces(where: {slug: {_eq: $workspaceSlug}}) {
    ...Workspace
  }
}
    ${WorkspaceFragmentDoc}`;

/**
 * __useGetWorkspaceAndProjectQuery__
 *
 * To run a query within a React component, call `useGetWorkspaceAndProjectQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetWorkspaceAndProjectQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetWorkspaceAndProjectQuery({
 *   variables: {
 *      workspaceSlug: // value for 'workspaceSlug'
 *      projectSlug: // value for 'projectSlug'
 *   },
 * });
 */
export function useGetWorkspaceAndProjectQuery(baseOptions: Apollo.QueryHookOptions<GetWorkspaceAndProjectQuery, GetWorkspaceAndProjectQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetWorkspaceAndProjectQuery, GetWorkspaceAndProjectQueryVariables>(GetWorkspaceAndProjectDocument, options);
      }
export function useGetWorkspaceAndProjectLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetWorkspaceAndProjectQuery, GetWorkspaceAndProjectQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetWorkspaceAndProjectQuery, GetWorkspaceAndProjectQueryVariables>(GetWorkspaceAndProjectDocument, options);
        }
export type GetWorkspaceAndProjectQueryHookResult = ReturnType<typeof useGetWorkspaceAndProjectQuery>;
export type GetWorkspaceAndProjectLazyQueryHookResult = ReturnType<typeof useGetWorkspaceAndProjectLazyQuery>;
export type GetWorkspaceAndProjectQueryResult = Apollo.QueryResult<GetWorkspaceAndProjectQuery, GetWorkspaceAndProjectQueryVariables>;
export function refetchGetWorkspaceAndProjectQuery(variables: GetWorkspaceAndProjectQueryVariables) {
      return { query: GetWorkspaceAndProjectDocument, variables: variables }
    }
export const InsertApplicationDocument = gql`
    mutation insertApplication($app: apps_insert_input!) {
  insertApp(object: $app) {
    id
    name
    slug
    workspace {
      id
      name
      slug
    }
  }
}
    `;
export type InsertApplicationMutationFn = Apollo.MutationFunction<InsertApplicationMutation, InsertApplicationMutationVariables>;

/**
 * __useInsertApplicationMutation__
 *
 * To run a mutation, you first call `useInsertApplicationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertApplicationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertApplicationMutation, { data, loading, error }] = useInsertApplicationMutation({
 *   variables: {
 *      app: // value for 'app'
 *   },
 * });
 */
export function useInsertApplicationMutation(baseOptions?: Apollo.MutationHookOptions<InsertApplicationMutation, InsertApplicationMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<InsertApplicationMutation, InsertApplicationMutationVariables>(InsertApplicationDocument, options);
      }
export type InsertApplicationMutationHookResult = ReturnType<typeof useInsertApplicationMutation>;
export type InsertApplicationMutationResult = Apollo.MutationResult<InsertApplicationMutation>;
export type InsertApplicationMutationOptions = Apollo.BaseMutationOptions<InsertApplicationMutation, InsertApplicationMutationVariables>;
export const PauseApplicationDocument = gql`
    mutation PauseApplication($appId: uuid!) {
  updateApp(pk_columns: {id: $appId}, _set: {desiredState: 6}) {
    id
  }
}
    `;
export type PauseApplicationMutationFn = Apollo.MutationFunction<PauseApplicationMutation, PauseApplicationMutationVariables>;

/**
 * __usePauseApplicationMutation__
 *
 * To run a mutation, you first call `usePauseApplicationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `usePauseApplicationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [pauseApplicationMutation, { data, loading, error }] = usePauseApplicationMutation({
 *   variables: {
 *      appId: // value for 'appId'
 *   },
 * });
 */
export function usePauseApplicationMutation(baseOptions?: Apollo.MutationHookOptions<PauseApplicationMutation, PauseApplicationMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<PauseApplicationMutation, PauseApplicationMutationVariables>(PauseApplicationDocument, options);
      }
export type PauseApplicationMutationHookResult = ReturnType<typeof usePauseApplicationMutation>;
export type PauseApplicationMutationResult = Apollo.MutationResult<PauseApplicationMutation>;
export type PauseApplicationMutationOptions = Apollo.BaseMutationOptions<PauseApplicationMutation, PauseApplicationMutationVariables>;
export const PrefetchNewAppDocument = gql`
    query PrefetchNewApp {
  regions(order_by: {city: asc}) {
    ...PrefetchNewAppRegions
  }
  plans(order_by: {sort: asc}, where: {deprecated: {_eq: false}}) {
    ...PrefetchNewAppPlans
  }
  workspaces {
    ...PrefetchNewAppWorkspace
  }
}
    ${PrefetchNewAppRegionsFragmentDoc}
${PrefetchNewAppPlansFragmentDoc}
${PrefetchNewAppWorkspaceFragmentDoc}`;

/**
 * __usePrefetchNewAppQuery__
 *
 * To run a query within a React component, call `usePrefetchNewAppQuery` and pass it any options that fit your needs.
 * When your component renders, `usePrefetchNewAppQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePrefetchNewAppQuery({
 *   variables: {
 *   },
 * });
 */
export function usePrefetchNewAppQuery(baseOptions?: Apollo.QueryHookOptions<PrefetchNewAppQuery, PrefetchNewAppQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PrefetchNewAppQuery, PrefetchNewAppQueryVariables>(PrefetchNewAppDocument, options);
      }
export function usePrefetchNewAppLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PrefetchNewAppQuery, PrefetchNewAppQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PrefetchNewAppQuery, PrefetchNewAppQueryVariables>(PrefetchNewAppDocument, options);
        }
export type PrefetchNewAppQueryHookResult = ReturnType<typeof usePrefetchNewAppQuery>;
export type PrefetchNewAppLazyQueryHookResult = ReturnType<typeof usePrefetchNewAppLazyQuery>;
export type PrefetchNewAppQueryResult = Apollo.QueryResult<PrefetchNewAppQuery, PrefetchNewAppQueryVariables>;
export function refetchPrefetchNewAppQuery(variables?: PrefetchNewAppQueryVariables) {
      return { query: PrefetchNewAppDocument, variables: variables }
    }
export const DnsLookupCnameDocument = gql`
    query dnsLookupCNAME($hostname: String!) {
  dnsLookupCNAME(hostname: $hostname)
}
    `;

/**
 * __useDnsLookupCnameQuery__
 *
 * To run a query within a React component, call `useDnsLookupCnameQuery` and pass it any options that fit your needs.
 * When your component renders, `useDnsLookupCnameQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useDnsLookupCnameQuery({
 *   variables: {
 *      hostname: // value for 'hostname'
 *   },
 * });
 */
export function useDnsLookupCnameQuery(baseOptions: Apollo.QueryHookOptions<DnsLookupCnameQuery, DnsLookupCnameQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<DnsLookupCnameQuery, DnsLookupCnameQueryVariables>(DnsLookupCnameDocument, options);
      }
export function useDnsLookupCnameLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<DnsLookupCnameQuery, DnsLookupCnameQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<DnsLookupCnameQuery, DnsLookupCnameQueryVariables>(DnsLookupCnameDocument, options);
        }
export type DnsLookupCnameQueryHookResult = ReturnType<typeof useDnsLookupCnameQuery>;
export type DnsLookupCnameLazyQueryHookResult = ReturnType<typeof useDnsLookupCnameLazyQuery>;
export type DnsLookupCnameQueryResult = Apollo.QueryResult<DnsLookupCnameQuery, DnsLookupCnameQueryVariables>;
export function refetchDnsLookupCnameQuery(variables: DnsLookupCnameQueryVariables) {
      return { query: DnsLookupCnameDocument, variables: variables }
    }
export const GetEnvironmentVariablesDocument = gql`
    query GetEnvironmentVariables($appId: uuid!) {
  config(appID: $appId, resolve: false) {
    id: __typename
    __typename
    global {
      environment {
        ...EnvironmentVariable
      }
    }
    hasura {
      adminSecret
      webhookSecret
      jwtSecrets {
        ...JWTSecret
      }
    }
  }
}
    ${EnvironmentVariableFragmentDoc}
${JwtSecretFragmentDoc}`;

/**
 * __useGetEnvironmentVariablesQuery__
 *
 * To run a query within a React component, call `useGetEnvironmentVariablesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetEnvironmentVariablesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetEnvironmentVariablesQuery({
 *   variables: {
 *      appId: // value for 'appId'
 *   },
 * });
 */
export function useGetEnvironmentVariablesQuery(baseOptions: Apollo.QueryHookOptions<GetEnvironmentVariablesQuery, GetEnvironmentVariablesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetEnvironmentVariablesQuery, GetEnvironmentVariablesQueryVariables>(GetEnvironmentVariablesDocument, options);
      }
export function useGetEnvironmentVariablesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetEnvironmentVariablesQuery, GetEnvironmentVariablesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetEnvironmentVariablesQuery, GetEnvironmentVariablesQueryVariables>(GetEnvironmentVariablesDocument, options);
        }
export type GetEnvironmentVariablesQueryHookResult = ReturnType<typeof useGetEnvironmentVariablesQuery>;
export type GetEnvironmentVariablesLazyQueryHookResult = ReturnType<typeof useGetEnvironmentVariablesLazyQuery>;
export type GetEnvironmentVariablesQueryResult = Apollo.QueryResult<GetEnvironmentVariablesQuery, GetEnvironmentVariablesQueryVariables>;
export function refetchGetEnvironmentVariablesQuery(variables: GetEnvironmentVariablesQueryVariables) {
      return { query: GetEnvironmentVariablesDocument, variables: variables }
    }
export const GetConfigRawJsonDocument = gql`
    query getConfigRawJSON($appID: uuid!) {
  configRawJSON(appID: $appID, resolve: false)
}
    `;

/**
 * __useGetConfigRawJsonQuery__
 *
 * To run a query within a React component, call `useGetConfigRawJsonQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetConfigRawJsonQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetConfigRawJsonQuery({
 *   variables: {
 *      appID: // value for 'appID'
 *   },
 * });
 */
export function useGetConfigRawJsonQuery(baseOptions: Apollo.QueryHookOptions<GetConfigRawJsonQuery, GetConfigRawJsonQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetConfigRawJsonQuery, GetConfigRawJsonQueryVariables>(GetConfigRawJsonDocument, options);
      }
export function useGetConfigRawJsonLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetConfigRawJsonQuery, GetConfigRawJsonQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetConfigRawJsonQuery, GetConfigRawJsonQueryVariables>(GetConfigRawJsonDocument, options);
        }
export type GetConfigRawJsonQueryHookResult = ReturnType<typeof useGetConfigRawJsonQuery>;
export type GetConfigRawJsonLazyQueryHookResult = ReturnType<typeof useGetConfigRawJsonLazyQuery>;
export type GetConfigRawJsonQueryResult = Apollo.QueryResult<GetConfigRawJsonQuery, GetConfigRawJsonQueryVariables>;
export function refetchGetConfigRawJsonQuery(variables: GetConfigRawJsonQueryVariables) {
      return { query: GetConfigRawJsonDocument, variables: variables }
    }
export const GetRateLimitConfigDocument = gql`
    query getRateLimitConfig($appId: uuid!, $resolve: Boolean!) {
  config(appID: $appId, resolve: $resolve) {
    hasura {
      rateLimit {
        limit
        interval
      }
    }
    storage {
      rateLimit {
        limit
        interval
      }
    }
    functions {
      rateLimit {
        limit
        interval
      }
    }
    auth {
      rateLimit {
        bruteForce {
          limit
          interval
        }
        emails {
          limit
          interval
        }
        global {
          limit
          interval
        }
        signups {
          limit
          interval
        }
        sms {
          limit
          interval
        }
      }
    }
  }
}
    `;

/**
 * __useGetRateLimitConfigQuery__
 *
 * To run a query within a React component, call `useGetRateLimitConfigQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetRateLimitConfigQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetRateLimitConfigQuery({
 *   variables: {
 *      appId: // value for 'appId'
 *      resolve: // value for 'resolve'
 *   },
 * });
 */
export function useGetRateLimitConfigQuery(baseOptions: Apollo.QueryHookOptions<GetRateLimitConfigQuery, GetRateLimitConfigQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetRateLimitConfigQuery, GetRateLimitConfigQueryVariables>(GetRateLimitConfigDocument, options);
      }
export function useGetRateLimitConfigLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetRateLimitConfigQuery, GetRateLimitConfigQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetRateLimitConfigQuery, GetRateLimitConfigQueryVariables>(GetRateLimitConfigDocument, options);
        }
export type GetRateLimitConfigQueryHookResult = ReturnType<typeof useGetRateLimitConfigQuery>;
export type GetRateLimitConfigLazyQueryHookResult = ReturnType<typeof useGetRateLimitConfigLazyQuery>;
export type GetRateLimitConfigQueryResult = Apollo.QueryResult<GetRateLimitConfigQuery, GetRateLimitConfigQueryVariables>;
export function refetchGetRateLimitConfigQuery(variables: GetRateLimitConfigQueryVariables) {
      return { query: GetRateLimitConfigDocument, variables: variables }
    }
export const UpdateRateLimitConfigDocument = gql`
    mutation UpdateRateLimitConfig($appId: uuid!, $config: ConfigConfigUpdateInput!) {
  updateConfig(appID: $appId, config: $config) {
    hasura {
      rateLimit {
        limit
        interval
      }
    }
    storage {
      rateLimit {
        limit
        interval
      }
    }
    functions {
      rateLimit {
        limit
        interval
      }
    }
    auth {
      rateLimit {
        bruteForce {
          limit
          interval
        }
        emails {
          limit
          interval
        }
        global {
          limit
          interval
        }
        signups {
          limit
          interval
        }
        sms {
          limit
          interval
        }
      }
    }
  }
}
    `;
export type UpdateRateLimitConfigMutationFn = Apollo.MutationFunction<UpdateRateLimitConfigMutation, UpdateRateLimitConfigMutationVariables>;

/**
 * __useUpdateRateLimitConfigMutation__
 *
 * To run a mutation, you first call `useUpdateRateLimitConfigMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateRateLimitConfigMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateRateLimitConfigMutation, { data, loading, error }] = useUpdateRateLimitConfigMutation({
 *   variables: {
 *      appId: // value for 'appId'
 *      config: // value for 'config'
 *   },
 * });
 */
export function useUpdateRateLimitConfigMutation(baseOptions?: Apollo.MutationHookOptions<UpdateRateLimitConfigMutation, UpdateRateLimitConfigMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateRateLimitConfigMutation, UpdateRateLimitConfigMutationVariables>(UpdateRateLimitConfigDocument, options);
      }
export type UpdateRateLimitConfigMutationHookResult = ReturnType<typeof useUpdateRateLimitConfigMutation>;
export type UpdateRateLimitConfigMutationResult = Apollo.MutationResult<UpdateRateLimitConfigMutation>;
export type UpdateRateLimitConfigMutationOptions = Apollo.BaseMutationOptions<UpdateRateLimitConfigMutation, UpdateRateLimitConfigMutationVariables>;
export const ReplaceConfigRawJsonDocument = gql`
    mutation ReplaceConfigRawJSON($appID: uuid!, $rawJSON: String!) {
  replaceConfigRawJSON(appID: $appID, rawJSON: $rawJSON)
}
    `;
export type ReplaceConfigRawJsonMutationFn = Apollo.MutationFunction<ReplaceConfigRawJsonMutation, ReplaceConfigRawJsonMutationVariables>;

/**
 * __useReplaceConfigRawJsonMutation__
 *
 * To run a mutation, you first call `useReplaceConfigRawJsonMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useReplaceConfigRawJsonMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [replaceConfigRawJsonMutation, { data, loading, error }] = useReplaceConfigRawJsonMutation({
 *   variables: {
 *      appID: // value for 'appID'
 *      rawJSON: // value for 'rawJSON'
 *   },
 * });
 */
export function useReplaceConfigRawJsonMutation(baseOptions?: Apollo.MutationHookOptions<ReplaceConfigRawJsonMutation, ReplaceConfigRawJsonMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ReplaceConfigRawJsonMutation, ReplaceConfigRawJsonMutationVariables>(ReplaceConfigRawJsonDocument, options);
      }
export type ReplaceConfigRawJsonMutationHookResult = ReturnType<typeof useReplaceConfigRawJsonMutation>;
export type ReplaceConfigRawJsonMutationResult = Apollo.MutationResult<ReplaceConfigRawJsonMutation>;
export type ReplaceConfigRawJsonMutationOptions = Apollo.BaseMutationOptions<ReplaceConfigRawJsonMutation, ReplaceConfigRawJsonMutationVariables>;
export const GetRolesPermissionsDocument = gql`
    query GetRolesPermissions($appId: uuid!) {
  config(appID: $appId, resolve: false) {
    id: __typename
    __typename
    auth {
      user {
        roles {
          allowed
          default
        }
      }
      session {
        accessToken {
          customClaims {
            ...PermissionVariable
          }
        }
      }
    }
  }
}
    ${PermissionVariableFragmentDoc}`;

/**
 * __useGetRolesPermissionsQuery__
 *
 * To run a query within a React component, call `useGetRolesPermissionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetRolesPermissionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetRolesPermissionsQuery({
 *   variables: {
 *      appId: // value for 'appId'
 *   },
 * });
 */
export function useGetRolesPermissionsQuery(baseOptions: Apollo.QueryHookOptions<GetRolesPermissionsQuery, GetRolesPermissionsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetRolesPermissionsQuery, GetRolesPermissionsQueryVariables>(GetRolesPermissionsDocument, options);
      }
export function useGetRolesPermissionsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetRolesPermissionsQuery, GetRolesPermissionsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetRolesPermissionsQuery, GetRolesPermissionsQueryVariables>(GetRolesPermissionsDocument, options);
        }
export type GetRolesPermissionsQueryHookResult = ReturnType<typeof useGetRolesPermissionsQuery>;
export type GetRolesPermissionsLazyQueryHookResult = ReturnType<typeof useGetRolesPermissionsLazyQuery>;
export type GetRolesPermissionsQueryResult = Apollo.QueryResult<GetRolesPermissionsQuery, GetRolesPermissionsQueryVariables>;
export function refetchGetRolesPermissionsQuery(variables: GetRolesPermissionsQueryVariables) {
      return { query: GetRolesPermissionsDocument, variables: variables }
    }
export const DeleteSecretDocument = gql`
    mutation DeleteSecret($appId: uuid!, $name: String!) {
  deleteSecret(appID: $appId, key: $name) {
    name
  }
}
    `;
export type DeleteSecretMutationFn = Apollo.MutationFunction<DeleteSecretMutation, DeleteSecretMutationVariables>;

/**
 * __useDeleteSecretMutation__
 *
 * To run a mutation, you first call `useDeleteSecretMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteSecretMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteSecretMutation, { data, loading, error }] = useDeleteSecretMutation({
 *   variables: {
 *      appId: // value for 'appId'
 *      name: // value for 'name'
 *   },
 * });
 */
export function useDeleteSecretMutation(baseOptions?: Apollo.MutationHookOptions<DeleteSecretMutation, DeleteSecretMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteSecretMutation, DeleteSecretMutationVariables>(DeleteSecretDocument, options);
      }
export type DeleteSecretMutationHookResult = ReturnType<typeof useDeleteSecretMutation>;
export type DeleteSecretMutationResult = Apollo.MutationResult<DeleteSecretMutation>;
export type DeleteSecretMutationOptions = Apollo.BaseMutationOptions<DeleteSecretMutation, DeleteSecretMutationVariables>;
export const GetSecretsDocument = gql`
    query GetSecrets($appId: uuid!) {
  appSecrets(appID: $appId) {
    ...Secret
  }
}
    ${SecretFragmentDoc}`;

/**
 * __useGetSecretsQuery__
 *
 * To run a query within a React component, call `useGetSecretsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSecretsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSecretsQuery({
 *   variables: {
 *      appId: // value for 'appId'
 *   },
 * });
 */
export function useGetSecretsQuery(baseOptions: Apollo.QueryHookOptions<GetSecretsQuery, GetSecretsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetSecretsQuery, GetSecretsQueryVariables>(GetSecretsDocument, options);
      }
export function useGetSecretsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetSecretsQuery, GetSecretsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetSecretsQuery, GetSecretsQueryVariables>(GetSecretsDocument, options);
        }
export type GetSecretsQueryHookResult = ReturnType<typeof useGetSecretsQuery>;
export type GetSecretsLazyQueryHookResult = ReturnType<typeof useGetSecretsLazyQuery>;
export type GetSecretsQueryResult = Apollo.QueryResult<GetSecretsQuery, GetSecretsQueryVariables>;
export function refetchGetSecretsQuery(variables: GetSecretsQueryVariables) {
      return { query: GetSecretsDocument, variables: variables }
    }
export const InsertSecretDocument = gql`
    mutation InsertSecret($appId: uuid!, $secret: ConfigEnvironmentVariableInsertInput!) {
  insertSecret(appID: $appId, secret: $secret) {
    name
  }
}
    `;
export type InsertSecretMutationFn = Apollo.MutationFunction<InsertSecretMutation, InsertSecretMutationVariables>;

/**
 * __useInsertSecretMutation__
 *
 * To run a mutation, you first call `useInsertSecretMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertSecretMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertSecretMutation, { data, loading, error }] = useInsertSecretMutation({
 *   variables: {
 *      appId: // value for 'appId'
 *      secret: // value for 'secret'
 *   },
 * });
 */
export function useInsertSecretMutation(baseOptions?: Apollo.MutationHookOptions<InsertSecretMutation, InsertSecretMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<InsertSecretMutation, InsertSecretMutationVariables>(InsertSecretDocument, options);
      }
export type InsertSecretMutationHookResult = ReturnType<typeof useInsertSecretMutation>;
export type InsertSecretMutationResult = Apollo.MutationResult<InsertSecretMutation>;
export type InsertSecretMutationOptions = Apollo.BaseMutationOptions<InsertSecretMutation, InsertSecretMutationVariables>;
export const UpdateSecretDocument = gql`
    mutation UpdateSecret($appId: uuid!, $secret: ConfigEnvironmentVariableInsertInput!) {
  updateSecret(appID: $appId, secret: $secret) {
    name
  }
}
    `;
export type UpdateSecretMutationFn = Apollo.MutationFunction<UpdateSecretMutation, UpdateSecretMutationVariables>;

/**
 * __useUpdateSecretMutation__
 *
 * To run a mutation, you first call `useUpdateSecretMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateSecretMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateSecretMutation, { data, loading, error }] = useUpdateSecretMutation({
 *   variables: {
 *      appId: // value for 'appId'
 *      secret: // value for 'secret'
 *   },
 * });
 */
export function useUpdateSecretMutation(baseOptions?: Apollo.MutationHookOptions<UpdateSecretMutation, UpdateSecretMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateSecretMutation, UpdateSecretMutationVariables>(UpdateSecretDocument, options);
      }
export type UpdateSecretMutationHookResult = ReturnType<typeof useUpdateSecretMutation>;
export type UpdateSecretMutationResult = Apollo.MutationResult<UpdateSecretMutation>;
export type UpdateSecretMutationOptions = Apollo.BaseMutationOptions<UpdateSecretMutation, UpdateSecretMutationVariables>;
export const GetSignInMethodsDocument = gql`
    query GetSignInMethods($appId: uuid!) {
  config(appID: $appId, resolve: false) {
    id: __typename
    __typename
    provider {
      id: __typename
      __typename
      sms {
        accountSid
        authToken
        messagingServiceId
        provider
      }
    }
    auth {
      id: __typename
      __typename
      method {
        emailPassword {
          emailVerificationRequired
          hibpEnabled
          passwordMinLength
        }
        emailPasswordless {
          enabled
        }
        smsPasswordless {
          enabled
        }
        anonymous {
          enabled
        }
        webauthn {
          enabled
        }
        oauth {
          apple {
            enabled
            clientId
            keyId
            teamId
            privateKey
          }
          bitbucket {
            enabled
            clientId
            clientSecret
          }
          gitlab {
            enabled
            clientId
            clientSecret
            scope
          }
          strava {
            enabled
            clientId
            clientSecret
            scope
          }
          discord {
            enabled
            clientId
            clientSecret
            scope
          }
          facebook {
            enabled
            clientId
            clientSecret
            scope
          }
          github {
            enabled
            clientId
            clientSecret
            scope
          }
          google {
            enabled
            clientId
            clientSecret
            scope
          }
          linkedin {
            enabled
            clientId
            clientSecret
            scope
          }
          spotify {
            enabled
            clientId
            clientSecret
            scope
          }
          twitch {
            enabled
            clientId
            clientSecret
            scope
          }
          twitter {
            enabled
            consumerKey
            consumerSecret
          }
          windowslive {
            enabled
            clientId
            clientSecret
            scope
          }
          workos {
            enabled
            clientId
            clientSecret
            connection
            organization
          }
          azuread {
            enabled
            clientId
            clientSecret
            tenant
          }
        }
      }
    }
  }
}
    `;

/**
 * __useGetSignInMethodsQuery__
 *
 * To run a query within a React component, call `useGetSignInMethodsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSignInMethodsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSignInMethodsQuery({
 *   variables: {
 *      appId: // value for 'appId'
 *   },
 * });
 */
export function useGetSignInMethodsQuery(baseOptions: Apollo.QueryHookOptions<GetSignInMethodsQuery, GetSignInMethodsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetSignInMethodsQuery, GetSignInMethodsQueryVariables>(GetSignInMethodsDocument, options);
      }
export function useGetSignInMethodsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetSignInMethodsQuery, GetSignInMethodsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetSignInMethodsQuery, GetSignInMethodsQueryVariables>(GetSignInMethodsDocument, options);
        }
export type GetSignInMethodsQueryHookResult = ReturnType<typeof useGetSignInMethodsQuery>;
export type GetSignInMethodsLazyQueryHookResult = ReturnType<typeof useGetSignInMethodsLazyQuery>;
export type GetSignInMethodsQueryResult = Apollo.QueryResult<GetSignInMethodsQuery, GetSignInMethodsQueryVariables>;
export function refetchGetSignInMethodsQuery(variables: GetSignInMethodsQueryVariables) {
      return { query: GetSignInMethodsDocument, variables: variables }
    }
export const GetSmtpSettingsDocument = gql`
    query GetSmtpSettings($appId: uuid!) {
  config(appID: $appId, resolve: false) {
    id: __typename
    __typename
    provider {
      id: __typename
      __typename
      smtp {
        host
        method
        port
        secure
        sender
        user
        password
      }
    }
  }
}
    `;

/**
 * __useGetSmtpSettingsQuery__
 *
 * To run a query within a React component, call `useGetSmtpSettingsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSmtpSettingsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSmtpSettingsQuery({
 *   variables: {
 *      appId: // value for 'appId'
 *   },
 * });
 */
export function useGetSmtpSettingsQuery(baseOptions: Apollo.QueryHookOptions<GetSmtpSettingsQuery, GetSmtpSettingsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetSmtpSettingsQuery, GetSmtpSettingsQueryVariables>(GetSmtpSettingsDocument, options);
      }
export function useGetSmtpSettingsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetSmtpSettingsQuery, GetSmtpSettingsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetSmtpSettingsQuery, GetSmtpSettingsQueryVariables>(GetSmtpSettingsDocument, options);
        }
export type GetSmtpSettingsQueryHookResult = ReturnType<typeof useGetSmtpSettingsQuery>;
export type GetSmtpSettingsLazyQueryHookResult = ReturnType<typeof useGetSmtpSettingsLazyQuery>;
export type GetSmtpSettingsQueryResult = Apollo.QueryResult<GetSmtpSettingsQuery, GetSmtpSettingsQueryVariables>;
export function refetchGetSmtpSettingsQuery(variables: GetSmtpSettingsQueryVariables) {
      return { query: GetSmtpSettingsDocument, variables: variables }
    }
export const UpdateConfigDocument = gql`
    mutation UpdateConfig($appId: uuid!, $config: ConfigConfigUpdateInput!) {
  updateConfig(appID: $appId, config: $config) {
    id: __typename
    postgres {
      resources {
        storage {
          capacity
        }
        enablePublicAccess
      }
    }
    ai {
      version
      webhookSecret
      autoEmbeddings {
        synchPeriodMinutes
      }
      openai {
        organization
        apiKey
      }
      resources {
        compute {
          cpu
          memory
        }
      }
    }
  }
}
    `;
export type UpdateConfigMutationFn = Apollo.MutationFunction<UpdateConfigMutation, UpdateConfigMutationVariables>;

/**
 * __useUpdateConfigMutation__
 *
 * To run a mutation, you first call `useUpdateConfigMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateConfigMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateConfigMutation, { data, loading, error }] = useUpdateConfigMutation({
 *   variables: {
 *      appId: // value for 'appId'
 *      config: // value for 'config'
 *   },
 * });
 */
export function useUpdateConfigMutation(baseOptions?: Apollo.MutationHookOptions<UpdateConfigMutation, UpdateConfigMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateConfigMutation, UpdateConfigMutationVariables>(UpdateConfigDocument, options);
      }
export type UpdateConfigMutationHookResult = ReturnType<typeof useUpdateConfigMutation>;
export type UpdateConfigMutationResult = Apollo.MutationResult<UpdateConfigMutation>;
export type UpdateConfigMutationOptions = Apollo.BaseMutationOptions<UpdateConfigMutation, UpdateConfigMutationVariables>;
export const UpdateDatabaseVersionDocument = gql`
    mutation UpdateDatabaseVersion($appId: uuid!, $version: String!) {
  changeDatabaseVersion(appID: $appId, version: $version)
}
    `;
export type UpdateDatabaseVersionMutationFn = Apollo.MutationFunction<UpdateDatabaseVersionMutation, UpdateDatabaseVersionMutationVariables>;

/**
 * __useUpdateDatabaseVersionMutation__
 *
 * To run a mutation, you first call `useUpdateDatabaseVersionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateDatabaseVersionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateDatabaseVersionMutation, { data, loading, error }] = useUpdateDatabaseVersionMutation({
 *   variables: {
 *      appId: // value for 'appId'
 *      version: // value for 'version'
 *   },
 * });
 */
export function useUpdateDatabaseVersionMutation(baseOptions?: Apollo.MutationHookOptions<UpdateDatabaseVersionMutation, UpdateDatabaseVersionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateDatabaseVersionMutation, UpdateDatabaseVersionMutationVariables>(UpdateDatabaseVersionDocument, options);
      }
export type UpdateDatabaseVersionMutationHookResult = ReturnType<typeof useUpdateDatabaseVersionMutation>;
export type UpdateDatabaseVersionMutationResult = Apollo.MutationResult<UpdateDatabaseVersionMutation>;
export type UpdateDatabaseVersionMutationOptions = Apollo.BaseMutationOptions<UpdateDatabaseVersionMutation, UpdateDatabaseVersionMutationVariables>;
export const UnpauseApplicationDocument = gql`
    mutation UnpauseApplication($appId: uuid!) {
  updateApp(pk_columns: {id: $appId}, _set: {desiredState: 5}) {
    id
  }
}
    `;
export type UnpauseApplicationMutationFn = Apollo.MutationFunction<UnpauseApplicationMutation, UnpauseApplicationMutationVariables>;

/**
 * __useUnpauseApplicationMutation__
 *
 * To run a mutation, you first call `useUnpauseApplicationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUnpauseApplicationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [unpauseApplicationMutation, { data, loading, error }] = useUnpauseApplicationMutation({
 *   variables: {
 *      appId: // value for 'appId'
 *   },
 * });
 */
export function useUnpauseApplicationMutation(baseOptions?: Apollo.MutationHookOptions<UnpauseApplicationMutation, UnpauseApplicationMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UnpauseApplicationMutation, UnpauseApplicationMutationVariables>(UnpauseApplicationDocument, options);
      }
export type UnpauseApplicationMutationHookResult = ReturnType<typeof useUnpauseApplicationMutation>;
export type UnpauseApplicationMutationResult = Apollo.MutationResult<UnpauseApplicationMutation>;
export type UnpauseApplicationMutationOptions = Apollo.BaseMutationOptions<UnpauseApplicationMutation, UnpauseApplicationMutationVariables>;
export const UpdateApplicationDocument = gql`
    mutation updateApplication($appId: uuid!, $app: apps_set_input!) {
  updateApp(pk_columns: {id: $appId}, _set: $app) {
    name
    id
    slug
  }
}
    `;
export type UpdateApplicationMutationFn = Apollo.MutationFunction<UpdateApplicationMutation, UpdateApplicationMutationVariables>;

/**
 * __useUpdateApplicationMutation__
 *
 * To run a mutation, you first call `useUpdateApplicationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateApplicationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateApplicationMutation, { data, loading, error }] = useUpdateApplicationMutation({
 *   variables: {
 *      appId: // value for 'appId'
 *      app: // value for 'app'
 *   },
 * });
 */
export function useUpdateApplicationMutation(baseOptions?: Apollo.MutationHookOptions<UpdateApplicationMutation, UpdateApplicationMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateApplicationMutation, UpdateApplicationMutationVariables>(UpdateApplicationDocument, options);
      }
export type UpdateApplicationMutationHookResult = ReturnType<typeof useUpdateApplicationMutation>;
export type UpdateApplicationMutationResult = Apollo.MutationResult<UpdateApplicationMutation>;
export type UpdateApplicationMutationOptions = Apollo.BaseMutationOptions<UpdateApplicationMutation, UpdateApplicationMutationVariables>;
export const GetCountriesDocument = gql`
    query getCountries {
  countries(order_by: {name: asc}) {
    code
    name
  }
}
    `;

/**
 * __useGetCountriesQuery__
 *
 * To run a query within a React component, call `useGetCountriesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCountriesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCountriesQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetCountriesQuery(baseOptions?: Apollo.QueryHookOptions<GetCountriesQuery, GetCountriesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCountriesQuery, GetCountriesQueryVariables>(GetCountriesDocument, options);
      }
export function useGetCountriesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCountriesQuery, GetCountriesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCountriesQuery, GetCountriesQueryVariables>(GetCountriesDocument, options);
        }
export type GetCountriesQueryHookResult = ReturnType<typeof useGetCountriesQuery>;
export type GetCountriesLazyQueryHookResult = ReturnType<typeof useGetCountriesLazyQuery>;
export type GetCountriesQueryResult = Apollo.QueryResult<GetCountriesQuery, GetCountriesQueryVariables>;
export function refetchGetCountriesQuery(variables?: GetCountriesQueryVariables) {
      return { query: GetCountriesDocument, variables: variables }
    }
export const ScheduledOrPendingDeploymentsSubDocument = gql`
    subscription ScheduledOrPendingDeploymentsSub($appId: uuid!) {
  deployments(
    where: {deploymentStatus: {_in: ["SCHEDULED"]}, appId: {_eq: $appId}}
  ) {
    ...DeploymentRow
  }
}
    ${DeploymentRowFragmentDoc}`;

/**
 * __useScheduledOrPendingDeploymentsSubSubscription__
 *
 * To run a query within a React component, call `useScheduledOrPendingDeploymentsSubSubscription` and pass it any options that fit your needs.
 * When your component renders, `useScheduledOrPendingDeploymentsSubSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useScheduledOrPendingDeploymentsSubSubscription({
 *   variables: {
 *      appId: // value for 'appId'
 *   },
 * });
 */
export function useScheduledOrPendingDeploymentsSubSubscription(baseOptions: Apollo.SubscriptionHookOptions<ScheduledOrPendingDeploymentsSubSubscription, ScheduledOrPendingDeploymentsSubSubscriptionVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<ScheduledOrPendingDeploymentsSubSubscription, ScheduledOrPendingDeploymentsSubSubscriptionVariables>(ScheduledOrPendingDeploymentsSubDocument, options);
      }
export type ScheduledOrPendingDeploymentsSubSubscriptionHookResult = ReturnType<typeof useScheduledOrPendingDeploymentsSubSubscription>;
export type ScheduledOrPendingDeploymentsSubSubscriptionResult = Apollo.SubscriptionResult<ScheduledOrPendingDeploymentsSubSubscription>;
export const LatestLiveDeploymentSubDocument = gql`
    subscription LatestLiveDeploymentSub($appId: uuid!) {
  deployments(
    where: {deploymentStatus: {_eq: "DEPLOYED"}, appId: {_eq: $appId}}
    order_by: {deploymentStartedAt: desc}
    limit: 1
    offset: 0
  ) {
    ...DeploymentRow
  }
}
    ${DeploymentRowFragmentDoc}`;

/**
 * __useLatestLiveDeploymentSubSubscription__
 *
 * To run a query within a React component, call `useLatestLiveDeploymentSubSubscription` and pass it any options that fit your needs.
 * When your component renders, `useLatestLiveDeploymentSubSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useLatestLiveDeploymentSubSubscription({
 *   variables: {
 *      appId: // value for 'appId'
 *   },
 * });
 */
export function useLatestLiveDeploymentSubSubscription(baseOptions: Apollo.SubscriptionHookOptions<LatestLiveDeploymentSubSubscription, LatestLiveDeploymentSubSubscriptionVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<LatestLiveDeploymentSubSubscription, LatestLiveDeploymentSubSubscriptionVariables>(LatestLiveDeploymentSubDocument, options);
      }
export type LatestLiveDeploymentSubSubscriptionHookResult = ReturnType<typeof useLatestLiveDeploymentSubSubscription>;
export type LatestLiveDeploymentSubSubscriptionResult = Apollo.SubscriptionResult<LatestLiveDeploymentSubSubscription>;
export const InsertDeploymentDocument = gql`
    mutation InsertDeployment($object: deployments_insert_input!) {
  insertDeployment(object: $object) {
    ...DeploymentRow
  }
}
    ${DeploymentRowFragmentDoc}`;
export type InsertDeploymentMutationFn = Apollo.MutationFunction<InsertDeploymentMutation, InsertDeploymentMutationVariables>;

/**
 * __useInsertDeploymentMutation__
 *
 * To run a mutation, you first call `useInsertDeploymentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertDeploymentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertDeploymentMutation, { data, loading, error }] = useInsertDeploymentMutation({
 *   variables: {
 *      object: // value for 'object'
 *   },
 * });
 */
export function useInsertDeploymentMutation(baseOptions?: Apollo.MutationHookOptions<InsertDeploymentMutation, InsertDeploymentMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<InsertDeploymentMutation, InsertDeploymentMutationVariables>(InsertDeploymentDocument, options);
      }
export type InsertDeploymentMutationHookResult = ReturnType<typeof useInsertDeploymentMutation>;
export type InsertDeploymentMutationResult = Apollo.MutationResult<InsertDeploymentMutation>;
export type InsertDeploymentMutationOptions = Apollo.BaseMutationOptions<InsertDeploymentMutation, InsertDeploymentMutationVariables>;
export const GetDeploymentsSubDocument = gql`
    subscription getDeploymentsSub($id: uuid!, $limit: Int!, $offset: Int!) {
  deployments(
    where: {appId: {_eq: $id}}
    order_by: {deploymentStartedAt: desc}
    limit: $limit
    offset: $offset
  ) {
    ...DeploymentRow
  }
}
    ${DeploymentRowFragmentDoc}`;

/**
 * __useGetDeploymentsSubSubscription__
 *
 * To run a query within a React component, call `useGetDeploymentsSubSubscription` and pass it any options that fit your needs.
 * When your component renders, `useGetDeploymentsSubSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetDeploymentsSubSubscription({
 *   variables: {
 *      id: // value for 'id'
 *      limit: // value for 'limit'
 *      offset: // value for 'offset'
 *   },
 * });
 */
export function useGetDeploymentsSubSubscription(baseOptions: Apollo.SubscriptionHookOptions<GetDeploymentsSubSubscription, GetDeploymentsSubSubscriptionVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<GetDeploymentsSubSubscription, GetDeploymentsSubSubscriptionVariables>(GetDeploymentsSubDocument, options);
      }
export type GetDeploymentsSubSubscriptionHookResult = ReturnType<typeof useGetDeploymentsSubSubscription>;
export type GetDeploymentsSubSubscriptionResult = Apollo.SubscriptionResult<GetDeploymentsSubSubscription>;
export const DeploymentSubDocument = gql`
    subscription deploymentSub($id: uuid!) {
  deployment(id: $id) {
    id
    commitMessage
    commitSHA
    commitUserName
    commitUserAvatarUrl
    deploymentStartedAt
    deploymentEndedAt
    deploymentStatus
    metadataStartedAt
    metadataEndedAt
    metadataStatus
    migrationsStartedAt
    migrationsEndedAt
    migrationsStatus
    functionsStartedAt
    functionsEndedAt
    functionsStatus
    deploymentLogs(order_by: {createdAt: asc}) {
      id
      createdAt
      message
    }
  }
}
    `;

/**
 * __useDeploymentSubSubscription__
 *
 * To run a query within a React component, call `useDeploymentSubSubscription` and pass it any options that fit your needs.
 * When your component renders, `useDeploymentSubSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useDeploymentSubSubscription({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeploymentSubSubscription(baseOptions: Apollo.SubscriptionHookOptions<DeploymentSubSubscription, DeploymentSubSubscriptionVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<DeploymentSubSubscription, DeploymentSubSubscriptionVariables>(DeploymentSubDocument, options);
      }
export type DeploymentSubSubscriptionHookResult = ReturnType<typeof useDeploymentSubSubscription>;
export type DeploymentSubSubscriptionResult = Apollo.SubscriptionResult<DeploymentSubSubscription>;
export const GetBucketsDocument = gql`
    query getBuckets {
  buckets {
    id
    maxUploadFileSize
  }
}
    `;

/**
 * __useGetBucketsQuery__
 *
 * To run a query within a React component, call `useGetBucketsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetBucketsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetBucketsQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetBucketsQuery(baseOptions?: Apollo.QueryHookOptions<GetBucketsQuery, GetBucketsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetBucketsQuery, GetBucketsQueryVariables>(GetBucketsDocument, options);
      }
export function useGetBucketsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetBucketsQuery, GetBucketsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetBucketsQuery, GetBucketsQueryVariables>(GetBucketsDocument, options);
        }
export type GetBucketsQueryHookResult = ReturnType<typeof useGetBucketsQuery>;
export type GetBucketsLazyQueryHookResult = ReturnType<typeof useGetBucketsLazyQuery>;
export type GetBucketsQueryResult = Apollo.QueryResult<GetBucketsQuery, GetBucketsQueryVariables>;
export function refetchGetBucketsQuery(variables?: GetBucketsQueryVariables) {
      return { query: GetBucketsDocument, variables: variables }
    }
export const GetFilesDocument = gql`
    query getFiles($where: files_bool_exp, $limit: Int, $offset: Int, $order_by: [files_order_by!]) {
  files(where: $where, limit: $limit, offset: $offset, order_by: $order_by) {
    id
    bucketId
    createdAt
    updatedAt
    name
    size
    mimeType
    etag
    isUploaded
    uploadedByUserId
  }
}
    `;

/**
 * __useGetFilesQuery__
 *
 * To run a query within a React component, call `useGetFilesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetFilesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetFilesQuery({
 *   variables: {
 *      where: // value for 'where'
 *      limit: // value for 'limit'
 *      offset: // value for 'offset'
 *      order_by: // value for 'order_by'
 *   },
 * });
 */
export function useGetFilesQuery(baseOptions?: Apollo.QueryHookOptions<GetFilesQuery, GetFilesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetFilesQuery, GetFilesQueryVariables>(GetFilesDocument, options);
      }
export function useGetFilesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetFilesQuery, GetFilesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetFilesQuery, GetFilesQueryVariables>(GetFilesDocument, options);
        }
export type GetFilesQueryHookResult = ReturnType<typeof useGetFilesQuery>;
export type GetFilesLazyQueryHookResult = ReturnType<typeof useGetFilesLazyQuery>;
export type GetFilesQueryResult = Apollo.QueryResult<GetFilesQuery, GetFilesQueryVariables>;
export function refetchGetFilesQuery(variables?: GetFilesQueryVariables) {
      return { query: GetFilesDocument, variables: variables }
    }
export const GetFilesAggregateDocument = gql`
    query getFilesAggregate($where: files_bool_exp) {
  filesAggregate(where: $where) {
    aggregate {
      count
    }
  }
}
    `;

/**
 * __useGetFilesAggregateQuery__
 *
 * To run a query within a React component, call `useGetFilesAggregateQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetFilesAggregateQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetFilesAggregateQuery({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useGetFilesAggregateQuery(baseOptions?: Apollo.QueryHookOptions<GetFilesAggregateQuery, GetFilesAggregateQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetFilesAggregateQuery, GetFilesAggregateQueryVariables>(GetFilesAggregateDocument, options);
      }
export function useGetFilesAggregateLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetFilesAggregateQuery, GetFilesAggregateQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetFilesAggregateQuery, GetFilesAggregateQueryVariables>(GetFilesAggregateDocument, options);
        }
export type GetFilesAggregateQueryHookResult = ReturnType<typeof useGetFilesAggregateQuery>;
export type GetFilesAggregateLazyQueryHookResult = ReturnType<typeof useGetFilesAggregateLazyQuery>;
export type GetFilesAggregateQueryResult = Apollo.QueryResult<GetFilesAggregateQuery, GetFilesAggregateQueryVariables>;
export function refetchGetFilesAggregateQuery(variables?: GetFilesAggregateQueryVariables) {
      return { query: GetFilesAggregateDocument, variables: variables }
    }
export const GetGithubRepositoriesDocument = gql`
    query getGithubRepositories {
  githubRepositories {
    ...GithubRepository
  }
  githubAppInstallations {
    id
    accountLogin
    accountType
    accountAvatarUrl
  }
}
    ${GithubRepositoryFragmentDoc}`;

/**
 * __useGetGithubRepositoriesQuery__
 *
 * To run a query within a React component, call `useGetGithubRepositoriesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetGithubRepositoriesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetGithubRepositoriesQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetGithubRepositoriesQuery(baseOptions?: Apollo.QueryHookOptions<GetGithubRepositoriesQuery, GetGithubRepositoriesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetGithubRepositoriesQuery, GetGithubRepositoriesQueryVariables>(GetGithubRepositoriesDocument, options);
      }
export function useGetGithubRepositoriesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetGithubRepositoriesQuery, GetGithubRepositoriesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetGithubRepositoriesQuery, GetGithubRepositoriesQueryVariables>(GetGithubRepositoriesDocument, options);
        }
export type GetGithubRepositoriesQueryHookResult = ReturnType<typeof useGetGithubRepositoriesQuery>;
export type GetGithubRepositoriesLazyQueryHookResult = ReturnType<typeof useGetGithubRepositoriesLazyQuery>;
export type GetGithubRepositoriesQueryResult = Apollo.QueryResult<GetGithubRepositoriesQuery, GetGithubRepositoriesQueryVariables>;
export function refetchGetGithubRepositoriesQuery(variables?: GetGithubRepositoriesQueryVariables) {
      return { query: GetGithubRepositoriesDocument, variables: variables }
    }
export const GetProjectLogsDocument = gql`
    query getProjectLogs($appID: String!, $service: String, $from: Timestamp, $to: Timestamp, $regexFilter: String) {
  logs(
    appID: $appID
    service: $service
    from: $from
    to: $to
    regexFilter: $regexFilter
  ) {
    log
    service
    timestamp
  }
}
    `;

/**
 * __useGetProjectLogsQuery__
 *
 * To run a query within a React component, call `useGetProjectLogsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetProjectLogsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetProjectLogsQuery({
 *   variables: {
 *      appID: // value for 'appID'
 *      service: // value for 'service'
 *      from: // value for 'from'
 *      to: // value for 'to'
 *      regexFilter: // value for 'regexFilter'
 *   },
 * });
 */
export function useGetProjectLogsQuery(baseOptions: Apollo.QueryHookOptions<GetProjectLogsQuery, GetProjectLogsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetProjectLogsQuery, GetProjectLogsQueryVariables>(GetProjectLogsDocument, options);
      }
export function useGetProjectLogsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetProjectLogsQuery, GetProjectLogsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetProjectLogsQuery, GetProjectLogsQueryVariables>(GetProjectLogsDocument, options);
        }
export type GetProjectLogsQueryHookResult = ReturnType<typeof useGetProjectLogsQuery>;
export type GetProjectLogsLazyQueryHookResult = ReturnType<typeof useGetProjectLogsLazyQuery>;
export type GetProjectLogsQueryResult = Apollo.QueryResult<GetProjectLogsQuery, GetProjectLogsQueryVariables>;
export function refetchGetProjectLogsQuery(variables: GetProjectLogsQueryVariables) {
      return { query: GetProjectLogsDocument, variables: variables }
    }
export const GetLogsSubscriptionDocument = gql`
    subscription getLogsSubscription($appID: String!, $service: String, $from: Timestamp, $regexFilter: String) {
  logs(appID: $appID, service: $service, from: $from, regexFilter: $regexFilter) {
    log
    service
    timestamp
  }
}
    `;

/**
 * __useGetLogsSubscriptionSubscription__
 *
 * To run a query within a React component, call `useGetLogsSubscriptionSubscription` and pass it any options that fit your needs.
 * When your component renders, `useGetLogsSubscriptionSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetLogsSubscriptionSubscription({
 *   variables: {
 *      appID: // value for 'appID'
 *      service: // value for 'service'
 *      from: // value for 'from'
 *      regexFilter: // value for 'regexFilter'
 *   },
 * });
 */
export function useGetLogsSubscriptionSubscription(baseOptions: Apollo.SubscriptionHookOptions<GetLogsSubscriptionSubscription, GetLogsSubscriptionSubscriptionVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<GetLogsSubscriptionSubscription, GetLogsSubscriptionSubscriptionVariables>(GetLogsSubscriptionDocument, options);
      }
export type GetLogsSubscriptionSubscriptionHookResult = ReturnType<typeof useGetLogsSubscriptionSubscription>;
export type GetLogsSubscriptionSubscriptionResult = Apollo.SubscriptionResult<GetLogsSubscriptionSubscription>;
export const GetServiceLabelValuesDocument = gql`
    query getServiceLabelValues($appID: String!) {
  getServiceLabelValues(appID: $appID)
}
    `;

/**
 * __useGetServiceLabelValuesQuery__
 *
 * To run a query within a React component, call `useGetServiceLabelValuesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetServiceLabelValuesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetServiceLabelValuesQuery({
 *   variables: {
 *      appID: // value for 'appID'
 *   },
 * });
 */
export function useGetServiceLabelValuesQuery(baseOptions: Apollo.QueryHookOptions<GetServiceLabelValuesQuery, GetServiceLabelValuesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetServiceLabelValuesQuery, GetServiceLabelValuesQueryVariables>(GetServiceLabelValuesDocument, options);
      }
export function useGetServiceLabelValuesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetServiceLabelValuesQuery, GetServiceLabelValuesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetServiceLabelValuesQuery, GetServiceLabelValuesQueryVariables>(GetServiceLabelValuesDocument, options);
        }
export type GetServiceLabelValuesQueryHookResult = ReturnType<typeof useGetServiceLabelValuesQuery>;
export type GetServiceLabelValuesLazyQueryHookResult = ReturnType<typeof useGetServiceLabelValuesLazyQuery>;
export type GetServiceLabelValuesQueryResult = Apollo.QueryResult<GetServiceLabelValuesQuery, GetServiceLabelValuesQueryVariables>;
export function refetchGetServiceLabelValuesQuery(variables: GetServiceLabelValuesQueryVariables) {
      return { query: GetServiceLabelValuesDocument, variables: variables }
    }
export const GetSystemLogsDocument = gql`
    query getSystemLogs($appID: String!, $action: String!, $from: Timestamp, $to: Timestamp) {
  systemLogs(appID: $appID, action: $action, from: $from) {
    timestamp
    log
  }
}
    `;

/**
 * __useGetSystemLogsQuery__
 *
 * To run a query within a React component, call `useGetSystemLogsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSystemLogsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSystemLogsQuery({
 *   variables: {
 *      appID: // value for 'appID'
 *      action: // value for 'action'
 *      from: // value for 'from'
 *      to: // value for 'to'
 *   },
 * });
 */
export function useGetSystemLogsQuery(baseOptions: Apollo.QueryHookOptions<GetSystemLogsQuery, GetSystemLogsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetSystemLogsQuery, GetSystemLogsQueryVariables>(GetSystemLogsDocument, options);
      }
export function useGetSystemLogsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetSystemLogsQuery, GetSystemLogsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetSystemLogsQuery, GetSystemLogsQueryVariables>(GetSystemLogsDocument, options);
        }
export type GetSystemLogsQueryHookResult = ReturnType<typeof useGetSystemLogsQuery>;
export type GetSystemLogsLazyQueryHookResult = ReturnType<typeof useGetSystemLogsLazyQuery>;
export type GetSystemLogsQueryResult = Apollo.QueryResult<GetSystemLogsQuery, GetSystemLogsQueryVariables>;
export function refetchGetSystemLogsQuery(variables: GetSystemLogsQueryVariables) {
      return { query: GetSystemLogsDocument, variables: variables }
    }
export const CreateOrganizationRequestDocument = gql`
    mutation createOrganizationRequest($organizationName: String!, $planID: uuid!, $redirectURL: String!) {
  billingCreateOrganizationRequest(
    organizationName: $organizationName
    planID: $planID
    redirectURL: $redirectURL
  )
}
    `;
export type CreateOrganizationRequestMutationFn = Apollo.MutationFunction<CreateOrganizationRequestMutation, CreateOrganizationRequestMutationVariables>;

/**
 * __useCreateOrganizationRequestMutation__
 *
 * To run a mutation, you first call `useCreateOrganizationRequestMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateOrganizationRequestMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createOrganizationRequestMutation, { data, loading, error }] = useCreateOrganizationRequestMutation({
 *   variables: {
 *      organizationName: // value for 'organizationName'
 *      planID: // value for 'planID'
 *      redirectURL: // value for 'redirectURL'
 *   },
 * });
 */
export function useCreateOrganizationRequestMutation(baseOptions?: Apollo.MutationHookOptions<CreateOrganizationRequestMutation, CreateOrganizationRequestMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateOrganizationRequestMutation, CreateOrganizationRequestMutationVariables>(CreateOrganizationRequestDocument, options);
      }
export type CreateOrganizationRequestMutationHookResult = ReturnType<typeof useCreateOrganizationRequestMutation>;
export type CreateOrganizationRequestMutationResult = Apollo.MutationResult<CreateOrganizationRequestMutation>;
export type CreateOrganizationRequestMutationOptions = Apollo.BaseMutationOptions<CreateOrganizationRequestMutation, CreateOrganizationRequestMutationVariables>;
export const GetOrganizationDocument = gql`
    query getOrganization($orgSlug: String!) {
  organizations(where: {slug: {_eq: $orgSlug}}) {
    id
    name
    slug
    plan {
      id
      name
      deprecated
      individual
      isFree
    }
    apps(order_by: {name: asc}) {
      id
      name
      subdomain
      slug
    }
  }
}
    `;

/**
 * __useGetOrganizationQuery__
 *
 * To run a query within a React component, call `useGetOrganizationQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetOrganizationQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetOrganizationQuery({
 *   variables: {
 *      orgSlug: // value for 'orgSlug'
 *   },
 * });
 */
export function useGetOrganizationQuery(baseOptions: Apollo.QueryHookOptions<GetOrganizationQuery, GetOrganizationQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetOrganizationQuery, GetOrganizationQueryVariables>(GetOrganizationDocument, options);
      }
export function useGetOrganizationLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetOrganizationQuery, GetOrganizationQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetOrganizationQuery, GetOrganizationQueryVariables>(GetOrganizationDocument, options);
        }
export type GetOrganizationQueryHookResult = ReturnType<typeof useGetOrganizationQuery>;
export type GetOrganizationLazyQueryHookResult = ReturnType<typeof useGetOrganizationLazyQuery>;
export type GetOrganizationQueryResult = Apollo.QueryResult<GetOrganizationQuery, GetOrganizationQueryVariables>;
export function refetchGetOrganizationQuery(variables: GetOrganizationQueryVariables) {
      return { query: GetOrganizationDocument, variables: variables }
    }
export const GetOrganizationByIdDocument = gql`
    query getOrganizationById($orgId: uuid!) {
  organizations(where: {id: {_eq: $orgId}}) {
    id
    name
    slug
  }
}
    `;

/**
 * __useGetOrganizationByIdQuery__
 *
 * To run a query within a React component, call `useGetOrganizationByIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetOrganizationByIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetOrganizationByIdQuery({
 *   variables: {
 *      orgId: // value for 'orgId'
 *   },
 * });
 */
export function useGetOrganizationByIdQuery(baseOptions: Apollo.QueryHookOptions<GetOrganizationByIdQuery, GetOrganizationByIdQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetOrganizationByIdQuery, GetOrganizationByIdQueryVariables>(GetOrganizationByIdDocument, options);
      }
export function useGetOrganizationByIdLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetOrganizationByIdQuery, GetOrganizationByIdQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetOrganizationByIdQuery, GetOrganizationByIdQueryVariables>(GetOrganizationByIdDocument, options);
        }
export type GetOrganizationByIdQueryHookResult = ReturnType<typeof useGetOrganizationByIdQuery>;
export type GetOrganizationByIdLazyQueryHookResult = ReturnType<typeof useGetOrganizationByIdLazyQuery>;
export type GetOrganizationByIdQueryResult = Apollo.QueryResult<GetOrganizationByIdQuery, GetOrganizationByIdQueryVariables>;
export function refetchGetOrganizationByIdQuery(variables: GetOrganizationByIdQueryVariables) {
      return { query: GetOrganizationByIdDocument, variables: variables }
    }
export const GetOrganizationProjectsDocument = gql`
    query getOrganizationProjects($orgId: uuid!) {
  apps(where: {organizationID: {_eq: $orgId}}, order_by: {name: asc}) {
    ...Project
  }
}
    ${ProjectFragmentDoc}`;

/**
 * __useGetOrganizationProjectsQuery__
 *
 * To run a query within a React component, call `useGetOrganizationProjectsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetOrganizationProjectsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetOrganizationProjectsQuery({
 *   variables: {
 *      orgId: // value for 'orgId'
 *   },
 * });
 */
export function useGetOrganizationProjectsQuery(baseOptions: Apollo.QueryHookOptions<GetOrganizationProjectsQuery, GetOrganizationProjectsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetOrganizationProjectsQuery, GetOrganizationProjectsQueryVariables>(GetOrganizationProjectsDocument, options);
      }
export function useGetOrganizationProjectsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetOrganizationProjectsQuery, GetOrganizationProjectsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetOrganizationProjectsQuery, GetOrganizationProjectsQueryVariables>(GetOrganizationProjectsDocument, options);
        }
export type GetOrganizationProjectsQueryHookResult = ReturnType<typeof useGetOrganizationProjectsQuery>;
export type GetOrganizationProjectsLazyQueryHookResult = ReturnType<typeof useGetOrganizationProjectsLazyQuery>;
export type GetOrganizationProjectsQueryResult = Apollo.QueryResult<GetOrganizationProjectsQuery, GetOrganizationProjectsQueryVariables>;
export function refetchGetOrganizationProjectsQuery(variables: GetOrganizationProjectsQueryVariables) {
      return { query: GetOrganizationProjectsDocument, variables: variables }
    }
export const GetOrganizationsDocument = gql`
    query getOrganizations {
  organizations(order_by: {name: asc}) {
    id
    name
    slug
    plan {
      id
      name
      deprecated
      individual
      isFree
    }
    apps(order_by: {name: asc}) {
      id
      name
      subdomain
      slug
    }
  }
}
    `;

/**
 * __useGetOrganizationsQuery__
 *
 * To run a query within a React component, call `useGetOrganizationsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetOrganizationsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetOrganizationsQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetOrganizationsQuery(baseOptions?: Apollo.QueryHookOptions<GetOrganizationsQuery, GetOrganizationsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetOrganizationsQuery, GetOrganizationsQueryVariables>(GetOrganizationsDocument, options);
      }
export function useGetOrganizationsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetOrganizationsQuery, GetOrganizationsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetOrganizationsQuery, GetOrganizationsQueryVariables>(GetOrganizationsDocument, options);
        }
export type GetOrganizationsQueryHookResult = ReturnType<typeof useGetOrganizationsQuery>;
export type GetOrganizationsLazyQueryHookResult = ReturnType<typeof useGetOrganizationsLazyQuery>;
export type GetOrganizationsQueryResult = Apollo.QueryResult<GetOrganizationsQuery, GetOrganizationsQueryVariables>;
export function refetchGetOrganizationsQuery(variables?: GetOrganizationsQueryVariables) {
      return { query: GetOrganizationsDocument, variables: variables }
    }
export const GetProjectDocument = gql`
    query getProject($slug: String!) {
  apps(where: {slug: {_eq: $slug}}) {
    ...Project
  }
}
    ${ProjectFragmentDoc}`;

/**
 * __useGetProjectQuery__
 *
 * To run a query within a React component, call `useGetProjectQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetProjectQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetProjectQuery({
 *   variables: {
 *      slug: // value for 'slug'
 *   },
 * });
 */
export function useGetProjectQuery(baseOptions: Apollo.QueryHookOptions<GetProjectQuery, GetProjectQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetProjectQuery, GetProjectQueryVariables>(GetProjectDocument, options);
      }
export function useGetProjectLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetProjectQuery, GetProjectQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetProjectQuery, GetProjectQueryVariables>(GetProjectDocument, options);
        }
export type GetProjectQueryHookResult = ReturnType<typeof useGetProjectQuery>;
export type GetProjectLazyQueryHookResult = ReturnType<typeof useGetProjectLazyQuery>;
export type GetProjectQueryResult = Apollo.QueryResult<GetProjectQuery, GetProjectQueryVariables>;
export function refetchGetProjectQuery(variables: GetProjectQueryVariables) {
      return { query: GetProjectDocument, variables: variables }
    }
export const PostOrganizationRequestDocument = gql`
    mutation postOrganizationRequest($sessionID: String!) {
  billingPostOrganizationRequest(sessionID: $sessionID) {
    Status
    Slug
  }
}
    `;
export type PostOrganizationRequestMutationFn = Apollo.MutationFunction<PostOrganizationRequestMutation, PostOrganizationRequestMutationVariables>;

/**
 * __usePostOrganizationRequestMutation__
 *
 * To run a mutation, you first call `usePostOrganizationRequestMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `usePostOrganizationRequestMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [postOrganizationRequestMutation, { data, loading, error }] = usePostOrganizationRequestMutation({
 *   variables: {
 *      sessionID: // value for 'sessionID'
 *   },
 * });
 */
export function usePostOrganizationRequestMutation(baseOptions?: Apollo.MutationHookOptions<PostOrganizationRequestMutation, PostOrganizationRequestMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<PostOrganizationRequestMutation, PostOrganizationRequestMutationVariables>(PostOrganizationRequestDocument, options);
      }
export type PostOrganizationRequestMutationHookResult = ReturnType<typeof usePostOrganizationRequestMutation>;
export type PostOrganizationRequestMutationResult = Apollo.MutationResult<PostOrganizationRequestMutation>;
export type PostOrganizationRequestMutationOptions = Apollo.BaseMutationOptions<PostOrganizationRequestMutation, PostOrganizationRequestMutationVariables>;
export const DeletePaymentMethodDocument = gql`
    mutation deletePaymentMethod($paymentMethodId: uuid!) {
  deletePaymentMethod(id: $paymentMethodId) {
    id
  }
}
    `;
export type DeletePaymentMethodMutationFn = Apollo.MutationFunction<DeletePaymentMethodMutation, DeletePaymentMethodMutationVariables>;

/**
 * __useDeletePaymentMethodMutation__
 *
 * To run a mutation, you first call `useDeletePaymentMethodMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeletePaymentMethodMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deletePaymentMethodMutation, { data, loading, error }] = useDeletePaymentMethodMutation({
 *   variables: {
 *      paymentMethodId: // value for 'paymentMethodId'
 *   },
 * });
 */
export function useDeletePaymentMethodMutation(baseOptions?: Apollo.MutationHookOptions<DeletePaymentMethodMutation, DeletePaymentMethodMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeletePaymentMethodMutation, DeletePaymentMethodMutationVariables>(DeletePaymentMethodDocument, options);
      }
export type DeletePaymentMethodMutationHookResult = ReturnType<typeof useDeletePaymentMethodMutation>;
export type DeletePaymentMethodMutationResult = Apollo.MutationResult<DeletePaymentMethodMutation>;
export type DeletePaymentMethodMutationOptions = Apollo.BaseMutationOptions<DeletePaymentMethodMutation, DeletePaymentMethodMutationVariables>;
export const GetPaymentMethodsDocument = gql`
    query getPaymentMethods($workspaceId: uuid!) {
  paymentMethods(
    where: {workspaceId: {_eq: $workspaceId}}
    order_by: {createdAt: desc}
  ) {
    ...getPaymentMethods
  }
}
    ${GetPaymentMethodsFragmentDoc}`;

/**
 * __useGetPaymentMethodsQuery__
 *
 * To run a query within a React component, call `useGetPaymentMethodsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPaymentMethodsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPaymentMethodsQuery({
 *   variables: {
 *      workspaceId: // value for 'workspaceId'
 *   },
 * });
 */
export function useGetPaymentMethodsQuery(baseOptions: Apollo.QueryHookOptions<GetPaymentMethodsQuery, GetPaymentMethodsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetPaymentMethodsQuery, GetPaymentMethodsQueryVariables>(GetPaymentMethodsDocument, options);
      }
export function useGetPaymentMethodsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPaymentMethodsQuery, GetPaymentMethodsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetPaymentMethodsQuery, GetPaymentMethodsQueryVariables>(GetPaymentMethodsDocument, options);
        }
export type GetPaymentMethodsQueryHookResult = ReturnType<typeof useGetPaymentMethodsQuery>;
export type GetPaymentMethodsLazyQueryHookResult = ReturnType<typeof useGetPaymentMethodsLazyQuery>;
export type GetPaymentMethodsQueryResult = Apollo.QueryResult<GetPaymentMethodsQuery, GetPaymentMethodsQueryVariables>;
export function refetchGetPaymentMethodsQuery(variables: GetPaymentMethodsQueryVariables) {
      return { query: GetPaymentMethodsDocument, variables: variables }
    }
export const InsertNewPaymentMethodDocument = gql`
    mutation insertNewPaymentMethod($workspaceId: uuid!, $paymentMethod: paymentMethods_insert_input!) {
  updatePaymentMethods(
    where: {workspaceId: {_eq: $workspaceId}}
    _set: {isDefault: false}
  ) {
    affected_rows
  }
  insertPaymentMethod(object: $paymentMethod) {
    id
  }
}
    `;
export type InsertNewPaymentMethodMutationFn = Apollo.MutationFunction<InsertNewPaymentMethodMutation, InsertNewPaymentMethodMutationVariables>;

/**
 * __useInsertNewPaymentMethodMutation__
 *
 * To run a mutation, you first call `useInsertNewPaymentMethodMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertNewPaymentMethodMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertNewPaymentMethodMutation, { data, loading, error }] = useInsertNewPaymentMethodMutation({
 *   variables: {
 *      workspaceId: // value for 'workspaceId'
 *      paymentMethod: // value for 'paymentMethod'
 *   },
 * });
 */
export function useInsertNewPaymentMethodMutation(baseOptions?: Apollo.MutationHookOptions<InsertNewPaymentMethodMutation, InsertNewPaymentMethodMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<InsertNewPaymentMethodMutation, InsertNewPaymentMethodMutationVariables>(InsertNewPaymentMethodDocument, options);
      }
export type InsertNewPaymentMethodMutationHookResult = ReturnType<typeof useInsertNewPaymentMethodMutation>;
export type InsertNewPaymentMethodMutationResult = Apollo.MutationResult<InsertNewPaymentMethodMutation>;
export type InsertNewPaymentMethodMutationOptions = Apollo.BaseMutationOptions<InsertNewPaymentMethodMutation, InsertNewPaymentMethodMutationVariables>;
export const SetNewDefaultPaymentMethodDocument = gql`
    mutation setNewDefaultPaymentMethod($workspaceId: uuid!, $paymentMethodId: uuid!) {
  setAllPaymentMethodToDefaultFalse: updatePaymentMethods(
    where: {workspaceId: {_eq: $workspaceId}}
    _set: {isDefault: false}
  ) {
    affected_rows
  }
  updatePaymentMethods(
    where: {id: {_eq: $paymentMethodId}}
    _set: {isDefault: true}
  ) {
    affected_rows
  }
}
    `;
export type SetNewDefaultPaymentMethodMutationFn = Apollo.MutationFunction<SetNewDefaultPaymentMethodMutation, SetNewDefaultPaymentMethodMutationVariables>;

/**
 * __useSetNewDefaultPaymentMethodMutation__
 *
 * To run a mutation, you first call `useSetNewDefaultPaymentMethodMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSetNewDefaultPaymentMethodMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [setNewDefaultPaymentMethodMutation, { data, loading, error }] = useSetNewDefaultPaymentMethodMutation({
 *   variables: {
 *      workspaceId: // value for 'workspaceId'
 *      paymentMethodId: // value for 'paymentMethodId'
 *   },
 * });
 */
export function useSetNewDefaultPaymentMethodMutation(baseOptions?: Apollo.MutationHookOptions<SetNewDefaultPaymentMethodMutation, SetNewDefaultPaymentMethodMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SetNewDefaultPaymentMethodMutation, SetNewDefaultPaymentMethodMutationVariables>(SetNewDefaultPaymentMethodDocument, options);
      }
export type SetNewDefaultPaymentMethodMutationHookResult = ReturnType<typeof useSetNewDefaultPaymentMethodMutation>;
export type SetNewDefaultPaymentMethodMutationResult = Apollo.MutationResult<SetNewDefaultPaymentMethodMutation>;
export type SetNewDefaultPaymentMethodMutationOptions = Apollo.BaseMutationOptions<SetNewDefaultPaymentMethodMutation, SetNewDefaultPaymentMethodMutationVariables>;
export const GetAnnouncementsDocument = gql`
    query getAnnouncements($limit: Int) {
  announcements(
    order_by: {createdAt: desc}
    limit: $limit
    where: {_or: [{expiresAt: {_is_null: true}}, {expiresAt: {_gt: now}}]}
  ) {
    id
    href
    content
    createdAt
  }
}
    `;

/**
 * __useGetAnnouncementsQuery__
 *
 * To run a query within a React component, call `useGetAnnouncementsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAnnouncementsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAnnouncementsQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *   },
 * });
 */
export function useGetAnnouncementsQuery(baseOptions?: Apollo.QueryHookOptions<GetAnnouncementsQuery, GetAnnouncementsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetAnnouncementsQuery, GetAnnouncementsQueryVariables>(GetAnnouncementsDocument, options);
      }
export function useGetAnnouncementsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAnnouncementsQuery, GetAnnouncementsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetAnnouncementsQuery, GetAnnouncementsQueryVariables>(GetAnnouncementsDocument, options);
        }
export type GetAnnouncementsQueryHookResult = ReturnType<typeof useGetAnnouncementsQuery>;
export type GetAnnouncementsLazyQueryHookResult = ReturnType<typeof useGetAnnouncementsLazyQuery>;
export type GetAnnouncementsQueryResult = Apollo.QueryResult<GetAnnouncementsQuery, GetAnnouncementsQueryVariables>;
export function refetchGetAnnouncementsQuery(variables?: GetAnnouncementsQueryVariables) {
      return { query: GetAnnouncementsDocument, variables: variables }
    }
export const GetPlansDocument = gql`
    query GetPlans($where: plans_bool_exp) {
  plans(where: $where) {
    id
    name
    isFree
    price
  }
}
    `;

/**
 * __useGetPlansQuery__
 *
 * To run a query within a React component, call `useGetPlansQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPlansQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPlansQuery({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useGetPlansQuery(baseOptions?: Apollo.QueryHookOptions<GetPlansQuery, GetPlansQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetPlansQuery, GetPlansQueryVariables>(GetPlansDocument, options);
      }
export function useGetPlansLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPlansQuery, GetPlansQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetPlansQuery, GetPlansQueryVariables>(GetPlansDocument, options);
        }
export type GetPlansQueryHookResult = ReturnType<typeof useGetPlansQuery>;
export type GetPlansLazyQueryHookResult = ReturnType<typeof useGetPlansLazyQuery>;
export type GetPlansQueryResult = Apollo.QueryResult<GetPlansQuery, GetPlansQueryVariables>;
export function refetchGetPlansQuery(variables?: GetPlansQueryVariables) {
      return { query: GetPlansDocument, variables: variables }
    }
export const GetRecommendedSoftwareVersionsDocument = gql`
    query getRecommendedSoftwareVersions {
  softwareVersions {
    software
    version
  }
}
    `;

/**
 * __useGetRecommendedSoftwareVersionsQuery__
 *
 * To run a query within a React component, call `useGetRecommendedSoftwareVersionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetRecommendedSoftwareVersionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetRecommendedSoftwareVersionsQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetRecommendedSoftwareVersionsQuery(baseOptions?: Apollo.QueryHookOptions<GetRecommendedSoftwareVersionsQuery, GetRecommendedSoftwareVersionsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetRecommendedSoftwareVersionsQuery, GetRecommendedSoftwareVersionsQueryVariables>(GetRecommendedSoftwareVersionsDocument, options);
      }
export function useGetRecommendedSoftwareVersionsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetRecommendedSoftwareVersionsQuery, GetRecommendedSoftwareVersionsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetRecommendedSoftwareVersionsQuery, GetRecommendedSoftwareVersionsQueryVariables>(GetRecommendedSoftwareVersionsDocument, options);
        }
export type GetRecommendedSoftwareVersionsQueryHookResult = ReturnType<typeof useGetRecommendedSoftwareVersionsQuery>;
export type GetRecommendedSoftwareVersionsLazyQueryHookResult = ReturnType<typeof useGetRecommendedSoftwareVersionsLazyQuery>;
export type GetRecommendedSoftwareVersionsQueryResult = Apollo.QueryResult<GetRecommendedSoftwareVersionsQuery, GetRecommendedSoftwareVersionsQueryVariables>;
export function refetchGetRecommendedSoftwareVersionsQuery(variables?: GetRecommendedSoftwareVersionsQueryVariables) {
      return { query: GetRecommendedSoftwareVersionsDocument, variables: variables }
    }
export const GetSoftwareVersionsDocument = gql`
    query getSoftwareVersions($software: software_type_enum!) {
  softwareVersions(where: {software: {_eq: $software}}, order_by: {version: desc}) {
    version
    software
  }
}
    `;

/**
 * __useGetSoftwareVersionsQuery__
 *
 * To run a query within a React component, call `useGetSoftwareVersionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSoftwareVersionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSoftwareVersionsQuery({
 *   variables: {
 *      software: // value for 'software'
 *   },
 * });
 */
export function useGetSoftwareVersionsQuery(baseOptions: Apollo.QueryHookOptions<GetSoftwareVersionsQuery, GetSoftwareVersionsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetSoftwareVersionsQuery, GetSoftwareVersionsQueryVariables>(GetSoftwareVersionsDocument, options);
      }
export function useGetSoftwareVersionsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetSoftwareVersionsQuery, GetSoftwareVersionsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetSoftwareVersionsQuery, GetSoftwareVersionsQueryVariables>(GetSoftwareVersionsDocument, options);
        }
export type GetSoftwareVersionsQueryHookResult = ReturnType<typeof useGetSoftwareVersionsQuery>;
export type GetSoftwareVersionsLazyQueryHookResult = ReturnType<typeof useGetSoftwareVersionsLazyQuery>;
export type GetSoftwareVersionsQueryResult = Apollo.QueryResult<GetSoftwareVersionsQuery, GetSoftwareVersionsQueryVariables>;
export function refetchGetSoftwareVersionsQuery(variables: GetSoftwareVersionsQueryVariables) {
      return { query: GetSoftwareVersionsDocument, variables: variables }
    }
export const RestoreApplicationDatabaseDocument = gql`
    mutation RestoreApplicationDatabase($appId: String!, $backupId: String!) {
  restoreApplicationDatabase(appID: $appId, backupID: $backupId)
}
    `;
export type RestoreApplicationDatabaseMutationFn = Apollo.MutationFunction<RestoreApplicationDatabaseMutation, RestoreApplicationDatabaseMutationVariables>;

/**
 * __useRestoreApplicationDatabaseMutation__
 *
 * To run a mutation, you first call `useRestoreApplicationDatabaseMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRestoreApplicationDatabaseMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [restoreApplicationDatabaseMutation, { data, loading, error }] = useRestoreApplicationDatabaseMutation({
 *   variables: {
 *      appId: // value for 'appId'
 *      backupId: // value for 'backupId'
 *   },
 * });
 */
export function useRestoreApplicationDatabaseMutation(baseOptions?: Apollo.MutationHookOptions<RestoreApplicationDatabaseMutation, RestoreApplicationDatabaseMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RestoreApplicationDatabaseMutation, RestoreApplicationDatabaseMutationVariables>(RestoreApplicationDatabaseDocument, options);
      }
export type RestoreApplicationDatabaseMutationHookResult = ReturnType<typeof useRestoreApplicationDatabaseMutation>;
export type RestoreApplicationDatabaseMutationResult = Apollo.MutationResult<RestoreApplicationDatabaseMutation>;
export type RestoreApplicationDatabaseMutationOptions = Apollo.BaseMutationOptions<RestoreApplicationDatabaseMutation, RestoreApplicationDatabaseMutationVariables>;
export const RemoteAppDeleteUserDocument = gql`
    mutation remoteAppDeleteUser($id: uuid!) {
  deleteUser(id: $id) {
    id
  }
}
    `;
export type RemoteAppDeleteUserMutationFn = Apollo.MutationFunction<RemoteAppDeleteUserMutation, RemoteAppDeleteUserMutationVariables>;

/**
 * __useRemoteAppDeleteUserMutation__
 *
 * To run a mutation, you first call `useRemoteAppDeleteUserMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRemoteAppDeleteUserMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [remoteAppDeleteUserMutation, { data, loading, error }] = useRemoteAppDeleteUserMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useRemoteAppDeleteUserMutation(baseOptions?: Apollo.MutationHookOptions<RemoteAppDeleteUserMutation, RemoteAppDeleteUserMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RemoteAppDeleteUserMutation, RemoteAppDeleteUserMutationVariables>(RemoteAppDeleteUserDocument, options);
      }
export type RemoteAppDeleteUserMutationHookResult = ReturnType<typeof useRemoteAppDeleteUserMutation>;
export type RemoteAppDeleteUserMutationResult = Apollo.MutationResult<RemoteAppDeleteUserMutation>;
export type RemoteAppDeleteUserMutationOptions = Apollo.BaseMutationOptions<RemoteAppDeleteUserMutation, RemoteAppDeleteUserMutationVariables>;
export const GetAppFunctionsMetadataDocument = gql`
    query getAppFunctionsMetadata($id: uuid!) {
  app(id: $id) {
    id
    metadataFunctions
  }
}
    `;

/**
 * __useGetAppFunctionsMetadataQuery__
 *
 * To run a query within a React component, call `useGetAppFunctionsMetadataQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAppFunctionsMetadataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAppFunctionsMetadataQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetAppFunctionsMetadataQuery(baseOptions: Apollo.QueryHookOptions<GetAppFunctionsMetadataQuery, GetAppFunctionsMetadataQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetAppFunctionsMetadataQuery, GetAppFunctionsMetadataQueryVariables>(GetAppFunctionsMetadataDocument, options);
      }
export function useGetAppFunctionsMetadataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAppFunctionsMetadataQuery, GetAppFunctionsMetadataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetAppFunctionsMetadataQuery, GetAppFunctionsMetadataQueryVariables>(GetAppFunctionsMetadataDocument, options);
        }
export type GetAppFunctionsMetadataQueryHookResult = ReturnType<typeof useGetAppFunctionsMetadataQuery>;
export type GetAppFunctionsMetadataLazyQueryHookResult = ReturnType<typeof useGetAppFunctionsMetadataLazyQuery>;
export type GetAppFunctionsMetadataQueryResult = Apollo.QueryResult<GetAppFunctionsMetadataQuery, GetAppFunctionsMetadataQueryVariables>;
export function refetchGetAppFunctionsMetadataQuery(variables: GetAppFunctionsMetadataQueryVariables) {
      return { query: GetAppFunctionsMetadataDocument, variables: variables }
    }
export const GetRemoteAppMetricsDocument = gql`
    query getRemoteAppMetrics {
  filesAggregate {
    aggregate {
      count
      sum {
        size
      }
    }
  }
  usersAggregate {
    aggregate {
      count
    }
  }
}
    `;

/**
 * __useGetRemoteAppMetricsQuery__
 *
 * To run a query within a React component, call `useGetRemoteAppMetricsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetRemoteAppMetricsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetRemoteAppMetricsQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetRemoteAppMetricsQuery(baseOptions?: Apollo.QueryHookOptions<GetRemoteAppMetricsQuery, GetRemoteAppMetricsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetRemoteAppMetricsQuery, GetRemoteAppMetricsQueryVariables>(GetRemoteAppMetricsDocument, options);
      }
export function useGetRemoteAppMetricsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetRemoteAppMetricsQuery, GetRemoteAppMetricsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetRemoteAppMetricsQuery, GetRemoteAppMetricsQueryVariables>(GetRemoteAppMetricsDocument, options);
        }
export type GetRemoteAppMetricsQueryHookResult = ReturnType<typeof useGetRemoteAppMetricsQuery>;
export type GetRemoteAppMetricsLazyQueryHookResult = ReturnType<typeof useGetRemoteAppMetricsLazyQuery>;
export type GetRemoteAppMetricsQueryResult = Apollo.QueryResult<GetRemoteAppMetricsQuery, GetRemoteAppMetricsQueryVariables>;
export function refetchGetRemoteAppMetricsQuery(variables?: GetRemoteAppMetricsQueryVariables) {
      return { query: GetRemoteAppMetricsDocument, variables: variables }
    }
export const RemoteAppGetUsersDocument = gql`
    query remoteAppGetUsers($where: users_bool_exp!, $limit: Int!, $offset: Int!) {
  users(
    where: $where
    limit: $limit
    offset: $offset
    order_by: {createdAt: desc}
  ) {
    ...RemoteAppGetUsers
  }
  filteredUsersAggreggate: usersAggregate(where: $where) {
    aggregate {
      count
    }
  }
  usersAggregate {
    aggregate {
      count
    }
  }
}
    ${RemoteAppGetUsersFragmentDoc}`;

/**
 * __useRemoteAppGetUsersQuery__
 *
 * To run a query within a React component, call `useRemoteAppGetUsersQuery` and pass it any options that fit your needs.
 * When your component renders, `useRemoteAppGetUsersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRemoteAppGetUsersQuery({
 *   variables: {
 *      where: // value for 'where'
 *      limit: // value for 'limit'
 *      offset: // value for 'offset'
 *   },
 * });
 */
export function useRemoteAppGetUsersQuery(baseOptions: Apollo.QueryHookOptions<RemoteAppGetUsersQuery, RemoteAppGetUsersQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<RemoteAppGetUsersQuery, RemoteAppGetUsersQueryVariables>(RemoteAppGetUsersDocument, options);
      }
export function useRemoteAppGetUsersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<RemoteAppGetUsersQuery, RemoteAppGetUsersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<RemoteAppGetUsersQuery, RemoteAppGetUsersQueryVariables>(RemoteAppGetUsersDocument, options);
        }
export type RemoteAppGetUsersQueryHookResult = ReturnType<typeof useRemoteAppGetUsersQuery>;
export type RemoteAppGetUsersLazyQueryHookResult = ReturnType<typeof useRemoteAppGetUsersLazyQuery>;
export type RemoteAppGetUsersQueryResult = Apollo.QueryResult<RemoteAppGetUsersQuery, RemoteAppGetUsersQueryVariables>;
export function refetchRemoteAppGetUsersQuery(variables: RemoteAppGetUsersQueryVariables) {
      return { query: RemoteAppGetUsersDocument, variables: variables }
    }
export const RemoteAppGetUsersCustomDocument = gql`
    query remoteAppGetUsersCustom($where: users_bool_exp!, $limit: Int!, $offset: Int!) {
  users(
    where: $where
    limit: $limit
    offset: $offset
    order_by: {createdAt: desc}
  ) {
    id
    createdAt
    displayName
    phoneNumber
    avatarUrl
    email
    disabled
    defaultRole
    roles(order_by: {role: asc}) {
      role
    }
    isAnonymous
  }
}
    `;

/**
 * __useRemoteAppGetUsersCustomQuery__
 *
 * To run a query within a React component, call `useRemoteAppGetUsersCustomQuery` and pass it any options that fit your needs.
 * When your component renders, `useRemoteAppGetUsersCustomQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRemoteAppGetUsersCustomQuery({
 *   variables: {
 *      where: // value for 'where'
 *      limit: // value for 'limit'
 *      offset: // value for 'offset'
 *   },
 * });
 */
export function useRemoteAppGetUsersCustomQuery(baseOptions: Apollo.QueryHookOptions<RemoteAppGetUsersCustomQuery, RemoteAppGetUsersCustomQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<RemoteAppGetUsersCustomQuery, RemoteAppGetUsersCustomQueryVariables>(RemoteAppGetUsersCustomDocument, options);
      }
export function useRemoteAppGetUsersCustomLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<RemoteAppGetUsersCustomQuery, RemoteAppGetUsersCustomQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<RemoteAppGetUsersCustomQuery, RemoteAppGetUsersCustomQueryVariables>(RemoteAppGetUsersCustomDocument, options);
        }
export type RemoteAppGetUsersCustomQueryHookResult = ReturnType<typeof useRemoteAppGetUsersCustomQuery>;
export type RemoteAppGetUsersCustomLazyQueryHookResult = ReturnType<typeof useRemoteAppGetUsersCustomLazyQuery>;
export type RemoteAppGetUsersCustomQueryResult = Apollo.QueryResult<RemoteAppGetUsersCustomQuery, RemoteAppGetUsersCustomQueryVariables>;
export function refetchRemoteAppGetUsersCustomQuery(variables: RemoteAppGetUsersCustomQueryVariables) {
      return { query: RemoteAppGetUsersCustomDocument, variables: variables }
    }
export const RemoteAppGetUsersWholeDocument = gql`
    query remoteAppGetUsersWhole($limit: Int!, $offset: Int!) {
  users(limit: $limit, offset: $offset) {
    ...RemoteAppGetUsers
  }
  usersAggregate {
    aggregate {
      count
    }
  }
}
    ${RemoteAppGetUsersFragmentDoc}`;

/**
 * __useRemoteAppGetUsersWholeQuery__
 *
 * To run a query within a React component, call `useRemoteAppGetUsersWholeQuery` and pass it any options that fit your needs.
 * When your component renders, `useRemoteAppGetUsersWholeQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRemoteAppGetUsersWholeQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *      offset: // value for 'offset'
 *   },
 * });
 */
export function useRemoteAppGetUsersWholeQuery(baseOptions: Apollo.QueryHookOptions<RemoteAppGetUsersWholeQuery, RemoteAppGetUsersWholeQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<RemoteAppGetUsersWholeQuery, RemoteAppGetUsersWholeQueryVariables>(RemoteAppGetUsersWholeDocument, options);
      }
export function useRemoteAppGetUsersWholeLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<RemoteAppGetUsersWholeQuery, RemoteAppGetUsersWholeQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<RemoteAppGetUsersWholeQuery, RemoteAppGetUsersWholeQueryVariables>(RemoteAppGetUsersWholeDocument, options);
        }
export type RemoteAppGetUsersWholeQueryHookResult = ReturnType<typeof useRemoteAppGetUsersWholeQuery>;
export type RemoteAppGetUsersWholeLazyQueryHookResult = ReturnType<typeof useRemoteAppGetUsersWholeLazyQuery>;
export type RemoteAppGetUsersWholeQueryResult = Apollo.QueryResult<RemoteAppGetUsersWholeQuery, RemoteAppGetUsersWholeQueryVariables>;
export function refetchRemoteAppGetUsersWholeQuery(variables: RemoteAppGetUsersWholeQueryVariables) {
      return { query: RemoteAppGetUsersWholeDocument, variables: variables }
    }
export const TotalUsersDocument = gql`
    query totalUsers {
  usersAggregate {
    aggregate {
      count
    }
  }
}
    `;

/**
 * __useTotalUsersQuery__
 *
 * To run a query within a React component, call `useTotalUsersQuery` and pass it any options that fit your needs.
 * When your component renders, `useTotalUsersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useTotalUsersQuery({
 *   variables: {
 *   },
 * });
 */
export function useTotalUsersQuery(baseOptions?: Apollo.QueryHookOptions<TotalUsersQuery, TotalUsersQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<TotalUsersQuery, TotalUsersQueryVariables>(TotalUsersDocument, options);
      }
export function useTotalUsersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<TotalUsersQuery, TotalUsersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<TotalUsersQuery, TotalUsersQueryVariables>(TotalUsersDocument, options);
        }
export type TotalUsersQueryHookResult = ReturnType<typeof useTotalUsersQuery>;
export type TotalUsersLazyQueryHookResult = ReturnType<typeof useTotalUsersLazyQuery>;
export type TotalUsersQueryResult = Apollo.QueryResult<TotalUsersQuery, TotalUsersQueryVariables>;
export function refetchTotalUsersQuery(variables?: TotalUsersQueryVariables) {
      return { query: TotalUsersDocument, variables: variables }
    }
export const TotalUsersByDateDocument = gql`
    query totalUsersByDate($where: users_bool_exp!) {
  usersAggregate(where: $where) {
    aggregate {
      count
    }
  }
}
    `;

/**
 * __useTotalUsersByDateQuery__
 *
 * To run a query within a React component, call `useTotalUsersByDateQuery` and pass it any options that fit your needs.
 * When your component renders, `useTotalUsersByDateQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useTotalUsersByDateQuery({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useTotalUsersByDateQuery(baseOptions: Apollo.QueryHookOptions<TotalUsersByDateQuery, TotalUsersByDateQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<TotalUsersByDateQuery, TotalUsersByDateQueryVariables>(TotalUsersByDateDocument, options);
      }
export function useTotalUsersByDateLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<TotalUsersByDateQuery, TotalUsersByDateQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<TotalUsersByDateQuery, TotalUsersByDateQueryVariables>(TotalUsersByDateDocument, options);
        }
export type TotalUsersByDateQueryHookResult = ReturnType<typeof useTotalUsersByDateQuery>;
export type TotalUsersByDateLazyQueryHookResult = ReturnType<typeof useTotalUsersByDateLazyQuery>;
export type TotalUsersByDateQueryResult = Apollo.QueryResult<TotalUsersByDateQuery, TotalUsersByDateQueryVariables>;
export function refetchTotalUsersByDateQuery(variables: TotalUsersByDateQueryVariables) {
      return { query: TotalUsersByDateDocument, variables: variables }
    }
export const UpdateRemoteAppUserDocument = gql`
    mutation updateRemoteAppUser($id: uuid!, $user: users_set_input!) {
  updateUser(pk_columns: {id: $id}, _set: $user) {
    id
  }
}
    `;
export type UpdateRemoteAppUserMutationFn = Apollo.MutationFunction<UpdateRemoteAppUserMutation, UpdateRemoteAppUserMutationVariables>;

/**
 * __useUpdateRemoteAppUserMutation__
 *
 * To run a mutation, you first call `useUpdateRemoteAppUserMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateRemoteAppUserMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateRemoteAppUserMutation, { data, loading, error }] = useUpdateRemoteAppUserMutation({
 *   variables: {
 *      id: // value for 'id'
 *      user: // value for 'user'
 *   },
 * });
 */
export function useUpdateRemoteAppUserMutation(baseOptions?: Apollo.MutationHookOptions<UpdateRemoteAppUserMutation, UpdateRemoteAppUserMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateRemoteAppUserMutation, UpdateRemoteAppUserMutationVariables>(UpdateRemoteAppUserDocument, options);
      }
export type UpdateRemoteAppUserMutationHookResult = ReturnType<typeof useUpdateRemoteAppUserMutation>;
export type UpdateRemoteAppUserMutationResult = Apollo.MutationResult<UpdateRemoteAppUserMutation>;
export type UpdateRemoteAppUserMutationOptions = Apollo.BaseMutationOptions<UpdateRemoteAppUserMutation, UpdateRemoteAppUserMutationVariables>;
export const InsertRemoteAppUserRolesDocument = gql`
    mutation insertRemoteAppUserRoles($roles: [authUserRoles_insert_input!]!) {
  insertAuthUserRoles(objects: $roles) {
    affected_rows
  }
}
    `;
export type InsertRemoteAppUserRolesMutationFn = Apollo.MutationFunction<InsertRemoteAppUserRolesMutation, InsertRemoteAppUserRolesMutationVariables>;

/**
 * __useInsertRemoteAppUserRolesMutation__
 *
 * To run a mutation, you first call `useInsertRemoteAppUserRolesMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertRemoteAppUserRolesMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertRemoteAppUserRolesMutation, { data, loading, error }] = useInsertRemoteAppUserRolesMutation({
 *   variables: {
 *      roles: // value for 'roles'
 *   },
 * });
 */
export function useInsertRemoteAppUserRolesMutation(baseOptions?: Apollo.MutationHookOptions<InsertRemoteAppUserRolesMutation, InsertRemoteAppUserRolesMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<InsertRemoteAppUserRolesMutation, InsertRemoteAppUserRolesMutationVariables>(InsertRemoteAppUserRolesDocument, options);
      }
export type InsertRemoteAppUserRolesMutationHookResult = ReturnType<typeof useInsertRemoteAppUserRolesMutation>;
export type InsertRemoteAppUserRolesMutationResult = Apollo.MutationResult<InsertRemoteAppUserRolesMutation>;
export type InsertRemoteAppUserRolesMutationOptions = Apollo.BaseMutationOptions<InsertRemoteAppUserRolesMutation, InsertRemoteAppUserRolesMutationVariables>;
export const DeleteRemoteAppUserRolesDocument = gql`
    mutation deleteRemoteAppUserRoles($userId: uuid!, $roles: [String!]!) {
  deleteAuthUserRoles(
    where: {_and: [{userId: {_eq: $userId}}, {role: {_in: $roles}}]}
  ) {
    affected_rows
  }
}
    `;
export type DeleteRemoteAppUserRolesMutationFn = Apollo.MutationFunction<DeleteRemoteAppUserRolesMutation, DeleteRemoteAppUserRolesMutationVariables>;

/**
 * __useDeleteRemoteAppUserRolesMutation__
 *
 * To run a mutation, you first call `useDeleteRemoteAppUserRolesMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteRemoteAppUserRolesMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteRemoteAppUserRolesMutation, { data, loading, error }] = useDeleteRemoteAppUserRolesMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      roles: // value for 'roles'
 *   },
 * });
 */
export function useDeleteRemoteAppUserRolesMutation(baseOptions?: Apollo.MutationHookOptions<DeleteRemoteAppUserRolesMutation, DeleteRemoteAppUserRolesMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteRemoteAppUserRolesMutation, DeleteRemoteAppUserRolesMutationVariables>(DeleteRemoteAppUserRolesDocument, options);
      }
export type DeleteRemoteAppUserRolesMutationHookResult = ReturnType<typeof useDeleteRemoteAppUserRolesMutation>;
export type DeleteRemoteAppUserRolesMutationResult = Apollo.MutationResult<DeleteRemoteAppUserRolesMutation>;
export type DeleteRemoteAppUserRolesMutationOptions = Apollo.BaseMutationOptions<DeleteRemoteAppUserRolesMutation, DeleteRemoteAppUserRolesMutationVariables>;
export const DeleteRunServiceDocument = gql`
    mutation deleteRunService($serviceID: uuid!) {
  deleteRunService(id: $serviceID) {
    id
  }
}
    `;
export type DeleteRunServiceMutationFn = Apollo.MutationFunction<DeleteRunServiceMutation, DeleteRunServiceMutationVariables>;

/**
 * __useDeleteRunServiceMutation__
 *
 * To run a mutation, you first call `useDeleteRunServiceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteRunServiceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteRunServiceMutation, { data, loading, error }] = useDeleteRunServiceMutation({
 *   variables: {
 *      serviceID: // value for 'serviceID'
 *   },
 * });
 */
export function useDeleteRunServiceMutation(baseOptions?: Apollo.MutationHookOptions<DeleteRunServiceMutation, DeleteRunServiceMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteRunServiceMutation, DeleteRunServiceMutationVariables>(DeleteRunServiceDocument, options);
      }
export type DeleteRunServiceMutationHookResult = ReturnType<typeof useDeleteRunServiceMutation>;
export type DeleteRunServiceMutationResult = Apollo.MutationResult<DeleteRunServiceMutation>;
export type DeleteRunServiceMutationOptions = Apollo.BaseMutationOptions<DeleteRunServiceMutation, DeleteRunServiceMutationVariables>;
export const DeleteRunServiceConfigDocument = gql`
    mutation deleteRunServiceConfig($appID: uuid!, $serviceID: uuid!) {
  deleteRunServiceConfig(appID: $appID, serviceID: $serviceID) {
    name
  }
}
    `;
export type DeleteRunServiceConfigMutationFn = Apollo.MutationFunction<DeleteRunServiceConfigMutation, DeleteRunServiceConfigMutationVariables>;

/**
 * __useDeleteRunServiceConfigMutation__
 *
 * To run a mutation, you first call `useDeleteRunServiceConfigMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteRunServiceConfigMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteRunServiceConfigMutation, { data, loading, error }] = useDeleteRunServiceConfigMutation({
 *   variables: {
 *      appID: // value for 'appID'
 *      serviceID: // value for 'serviceID'
 *   },
 * });
 */
export function useDeleteRunServiceConfigMutation(baseOptions?: Apollo.MutationHookOptions<DeleteRunServiceConfigMutation, DeleteRunServiceConfigMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteRunServiceConfigMutation, DeleteRunServiceConfigMutationVariables>(DeleteRunServiceConfigDocument, options);
      }
export type DeleteRunServiceConfigMutationHookResult = ReturnType<typeof useDeleteRunServiceConfigMutation>;
export type DeleteRunServiceConfigMutationResult = Apollo.MutationResult<DeleteRunServiceConfigMutation>;
export type DeleteRunServiceConfigMutationOptions = Apollo.BaseMutationOptions<DeleteRunServiceConfigMutation, DeleteRunServiceConfigMutationVariables>;
export const GetRunServiceDocument = gql`
    query getRunService($id: uuid!, $resolve: Boolean!) {
  runService(id: $id) {
    id
    subdomain
    config(resolve: $resolve) {
      name
      image {
        image
      }
      command
      resources {
        compute {
          cpu
          memory
        }
        storage {
          name
          path
          capacity
        }
        replicas
      }
      environment {
        name
        value
      }
      ports {
        port
        type
        publish
      }
    }
  }
}
    `;

/**
 * __useGetRunServiceQuery__
 *
 * To run a query within a React component, call `useGetRunServiceQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetRunServiceQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetRunServiceQuery({
 *   variables: {
 *      id: // value for 'id'
 *      resolve: // value for 'resolve'
 *   },
 * });
 */
export function useGetRunServiceQuery(baseOptions: Apollo.QueryHookOptions<GetRunServiceQuery, GetRunServiceQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetRunServiceQuery, GetRunServiceQueryVariables>(GetRunServiceDocument, options);
      }
export function useGetRunServiceLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetRunServiceQuery, GetRunServiceQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetRunServiceQuery, GetRunServiceQueryVariables>(GetRunServiceDocument, options);
        }
export type GetRunServiceQueryHookResult = ReturnType<typeof useGetRunServiceQuery>;
export type GetRunServiceLazyQueryHookResult = ReturnType<typeof useGetRunServiceLazyQuery>;
export type GetRunServiceQueryResult = Apollo.QueryResult<GetRunServiceQuery, GetRunServiceQueryVariables>;
export function refetchGetRunServiceQuery(variables: GetRunServiceQueryVariables) {
      return { query: GetRunServiceDocument, variables: variables }
    }
export const GetRunServicesDocument = gql`
    query getRunServices($appID: uuid!, $resolve: Boolean!, $limit: Int!, $offset: Int!) {
  app(id: $appID) {
    runServices(limit: $limit, offset: $offset) {
      id
      createdAt
      updatedAt
      subdomain
      config(resolve: $resolve) {
        ...RunServiceConfig
      }
    }
    runServices_aggregate {
      aggregate {
        count
      }
    }
  }
}
    ${RunServiceConfigFragmentDoc}`;

/**
 * __useGetRunServicesQuery__
 *
 * To run a query within a React component, call `useGetRunServicesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetRunServicesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetRunServicesQuery({
 *   variables: {
 *      appID: // value for 'appID'
 *      resolve: // value for 'resolve'
 *      limit: // value for 'limit'
 *      offset: // value for 'offset'
 *   },
 * });
 */
export function useGetRunServicesQuery(baseOptions: Apollo.QueryHookOptions<GetRunServicesQuery, GetRunServicesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetRunServicesQuery, GetRunServicesQueryVariables>(GetRunServicesDocument, options);
      }
export function useGetRunServicesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetRunServicesQuery, GetRunServicesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetRunServicesQuery, GetRunServicesQueryVariables>(GetRunServicesDocument, options);
        }
export type GetRunServicesQueryHookResult = ReturnType<typeof useGetRunServicesQuery>;
export type GetRunServicesLazyQueryHookResult = ReturnType<typeof useGetRunServicesLazyQuery>;
export type GetRunServicesQueryResult = Apollo.QueryResult<GetRunServicesQuery, GetRunServicesQueryVariables>;
export function refetchGetRunServicesQuery(variables: GetRunServicesQueryVariables) {
      return { query: GetRunServicesDocument, variables: variables }
    }
export const GetLocalRunServiceConfigsDocument = gql`
    query getLocalRunServiceConfigs($appID: uuid!, $resolve: Boolean!) {
  runServiceConfigs(appID: $appID, resolve: $resolve) {
    serviceID
    config {
      ...RunServiceConfig
    }
  }
}
    ${RunServiceConfigFragmentDoc}`;

/**
 * __useGetLocalRunServiceConfigsQuery__
 *
 * To run a query within a React component, call `useGetLocalRunServiceConfigsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetLocalRunServiceConfigsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetLocalRunServiceConfigsQuery({
 *   variables: {
 *      appID: // value for 'appID'
 *      resolve: // value for 'resolve'
 *   },
 * });
 */
export function useGetLocalRunServiceConfigsQuery(baseOptions: Apollo.QueryHookOptions<GetLocalRunServiceConfigsQuery, GetLocalRunServiceConfigsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetLocalRunServiceConfigsQuery, GetLocalRunServiceConfigsQueryVariables>(GetLocalRunServiceConfigsDocument, options);
      }
export function useGetLocalRunServiceConfigsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetLocalRunServiceConfigsQuery, GetLocalRunServiceConfigsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetLocalRunServiceConfigsQuery, GetLocalRunServiceConfigsQueryVariables>(GetLocalRunServiceConfigsDocument, options);
        }
export type GetLocalRunServiceConfigsQueryHookResult = ReturnType<typeof useGetLocalRunServiceConfigsQuery>;
export type GetLocalRunServiceConfigsLazyQueryHookResult = ReturnType<typeof useGetLocalRunServiceConfigsLazyQuery>;
export type GetLocalRunServiceConfigsQueryResult = Apollo.QueryResult<GetLocalRunServiceConfigsQuery, GetLocalRunServiceConfigsQueryVariables>;
export function refetchGetLocalRunServiceConfigsQuery(variables: GetLocalRunServiceConfigsQueryVariables) {
      return { query: GetLocalRunServiceConfigsDocument, variables: variables }
    }
export const GetRunServicesRateLimitDocument = gql`
    query getRunServicesRateLimit($appID: uuid!, $resolve: Boolean!) {
  app(id: $appID) {
    runServices {
      id
      createdAt
      updatedAt
      subdomain
      config(resolve: $resolve) {
        ...RunServiceRateLimit
      }
    }
  }
}
    ${RunServiceRateLimitFragmentDoc}`;

/**
 * __useGetRunServicesRateLimitQuery__
 *
 * To run a query within a React component, call `useGetRunServicesRateLimitQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetRunServicesRateLimitQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetRunServicesRateLimitQuery({
 *   variables: {
 *      appID: // value for 'appID'
 *      resolve: // value for 'resolve'
 *   },
 * });
 */
export function useGetRunServicesRateLimitQuery(baseOptions: Apollo.QueryHookOptions<GetRunServicesRateLimitQuery, GetRunServicesRateLimitQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetRunServicesRateLimitQuery, GetRunServicesRateLimitQueryVariables>(GetRunServicesRateLimitDocument, options);
      }
export function useGetRunServicesRateLimitLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetRunServicesRateLimitQuery, GetRunServicesRateLimitQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetRunServicesRateLimitQuery, GetRunServicesRateLimitQueryVariables>(GetRunServicesRateLimitDocument, options);
        }
export type GetRunServicesRateLimitQueryHookResult = ReturnType<typeof useGetRunServicesRateLimitQuery>;
export type GetRunServicesRateLimitLazyQueryHookResult = ReturnType<typeof useGetRunServicesRateLimitLazyQuery>;
export type GetRunServicesRateLimitQueryResult = Apollo.QueryResult<GetRunServicesRateLimitQuery, GetRunServicesRateLimitQueryVariables>;
export function refetchGetRunServicesRateLimitQuery(variables: GetRunServicesRateLimitQueryVariables) {
      return { query: GetRunServicesRateLimitDocument, variables: variables }
    }
export const GetLocalRunServiceRateLimitDocument = gql`
    query getLocalRunServiceRateLimit($appID: uuid!, $resolve: Boolean!) {
  runServiceConfigs(appID: $appID, resolve: $resolve) {
    serviceID
    config {
      ...RunServiceRateLimit
    }
  }
}
    ${RunServiceRateLimitFragmentDoc}`;

/**
 * __useGetLocalRunServiceRateLimitQuery__
 *
 * To run a query within a React component, call `useGetLocalRunServiceRateLimitQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetLocalRunServiceRateLimitQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetLocalRunServiceRateLimitQuery({
 *   variables: {
 *      appID: // value for 'appID'
 *      resolve: // value for 'resolve'
 *   },
 * });
 */
export function useGetLocalRunServiceRateLimitQuery(baseOptions: Apollo.QueryHookOptions<GetLocalRunServiceRateLimitQuery, GetLocalRunServiceRateLimitQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetLocalRunServiceRateLimitQuery, GetLocalRunServiceRateLimitQueryVariables>(GetLocalRunServiceRateLimitDocument, options);
      }
export function useGetLocalRunServiceRateLimitLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetLocalRunServiceRateLimitQuery, GetLocalRunServiceRateLimitQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetLocalRunServiceRateLimitQuery, GetLocalRunServiceRateLimitQueryVariables>(GetLocalRunServiceRateLimitDocument, options);
        }
export type GetLocalRunServiceRateLimitQueryHookResult = ReturnType<typeof useGetLocalRunServiceRateLimitQuery>;
export type GetLocalRunServiceRateLimitLazyQueryHookResult = ReturnType<typeof useGetLocalRunServiceRateLimitLazyQuery>;
export type GetLocalRunServiceRateLimitQueryResult = Apollo.QueryResult<GetLocalRunServiceRateLimitQuery, GetLocalRunServiceRateLimitQueryVariables>;
export function refetchGetLocalRunServiceRateLimitQuery(variables: GetLocalRunServiceRateLimitQueryVariables) {
      return { query: GetLocalRunServiceRateLimitDocument, variables: variables }
    }
export const InsertRunServiceDocument = gql`
    mutation insertRunService($object: run_service_insert_input!) {
  insertRunService(object: $object) {
    id
    subdomain
  }
}
    `;
export type InsertRunServiceMutationFn = Apollo.MutationFunction<InsertRunServiceMutation, InsertRunServiceMutationVariables>;

/**
 * __useInsertRunServiceMutation__
 *
 * To run a mutation, you first call `useInsertRunServiceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertRunServiceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertRunServiceMutation, { data, loading, error }] = useInsertRunServiceMutation({
 *   variables: {
 *      object: // value for 'object'
 *   },
 * });
 */
export function useInsertRunServiceMutation(baseOptions?: Apollo.MutationHookOptions<InsertRunServiceMutation, InsertRunServiceMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<InsertRunServiceMutation, InsertRunServiceMutationVariables>(InsertRunServiceDocument, options);
      }
export type InsertRunServiceMutationHookResult = ReturnType<typeof useInsertRunServiceMutation>;
export type InsertRunServiceMutationResult = Apollo.MutationResult<InsertRunServiceMutation>;
export type InsertRunServiceMutationOptions = Apollo.BaseMutationOptions<InsertRunServiceMutation, InsertRunServiceMutationVariables>;
export const InsertRunServiceConfigDocument = gql`
    mutation insertRunServiceConfig($appID: uuid!, $serviceID: uuid!, $config: ConfigRunServiceConfigInsertInput!) {
  insertRunServiceConfig(appID: $appID, serviceID: $serviceID, config: $config) {
    name
  }
}
    `;
export type InsertRunServiceConfigMutationFn = Apollo.MutationFunction<InsertRunServiceConfigMutation, InsertRunServiceConfigMutationVariables>;

/**
 * __useInsertRunServiceConfigMutation__
 *
 * To run a mutation, you first call `useInsertRunServiceConfigMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertRunServiceConfigMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertRunServiceConfigMutation, { data, loading, error }] = useInsertRunServiceConfigMutation({
 *   variables: {
 *      appID: // value for 'appID'
 *      serviceID: // value for 'serviceID'
 *      config: // value for 'config'
 *   },
 * });
 */
export function useInsertRunServiceConfigMutation(baseOptions?: Apollo.MutationHookOptions<InsertRunServiceConfigMutation, InsertRunServiceConfigMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<InsertRunServiceConfigMutation, InsertRunServiceConfigMutationVariables>(InsertRunServiceConfigDocument, options);
      }
export type InsertRunServiceConfigMutationHookResult = ReturnType<typeof useInsertRunServiceConfigMutation>;
export type InsertRunServiceConfigMutationResult = Apollo.MutationResult<InsertRunServiceConfigMutation>;
export type InsertRunServiceConfigMutationOptions = Apollo.BaseMutationOptions<InsertRunServiceConfigMutation, InsertRunServiceConfigMutationVariables>;
export const ReplaceRunServiceConfigDocument = gql`
    mutation replaceRunServiceConfig($appID: uuid!, $serviceID: uuid!, $config: ConfigRunServiceConfigInsertInput!) {
  replaceRunServiceConfig(appID: $appID, serviceID: $serviceID, config: $config) {
    __typename
  }
}
    `;
export type ReplaceRunServiceConfigMutationFn = Apollo.MutationFunction<ReplaceRunServiceConfigMutation, ReplaceRunServiceConfigMutationVariables>;

/**
 * __useReplaceRunServiceConfigMutation__
 *
 * To run a mutation, you first call `useReplaceRunServiceConfigMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useReplaceRunServiceConfigMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [replaceRunServiceConfigMutation, { data, loading, error }] = useReplaceRunServiceConfigMutation({
 *   variables: {
 *      appID: // value for 'appID'
 *      serviceID: // value for 'serviceID'
 *      config: // value for 'config'
 *   },
 * });
 */
export function useReplaceRunServiceConfigMutation(baseOptions?: Apollo.MutationHookOptions<ReplaceRunServiceConfigMutation, ReplaceRunServiceConfigMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ReplaceRunServiceConfigMutation, ReplaceRunServiceConfigMutationVariables>(ReplaceRunServiceConfigDocument, options);
      }
export type ReplaceRunServiceConfigMutationHookResult = ReturnType<typeof useReplaceRunServiceConfigMutation>;
export type ReplaceRunServiceConfigMutationResult = Apollo.MutationResult<ReplaceRunServiceConfigMutation>;
export type ReplaceRunServiceConfigMutationOptions = Apollo.BaseMutationOptions<ReplaceRunServiceConfigMutation, ReplaceRunServiceConfigMutationVariables>;
export const UpdateRunServiceConfigDocument = gql`
    mutation updateRunServiceConfig($appID: uuid!, $serviceID: uuid!, $config: ConfigRunServiceConfigUpdateInput!) {
  updateRunServiceConfig(appID: $appID, serviceID: $serviceID, config: $config) {
    name
  }
}
    `;
export type UpdateRunServiceConfigMutationFn = Apollo.MutationFunction<UpdateRunServiceConfigMutation, UpdateRunServiceConfigMutationVariables>;

/**
 * __useUpdateRunServiceConfigMutation__
 *
 * To run a mutation, you first call `useUpdateRunServiceConfigMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateRunServiceConfigMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateRunServiceConfigMutation, { data, loading, error }] = useUpdateRunServiceConfigMutation({
 *   variables: {
 *      appID: // value for 'appID'
 *      serviceID: // value for 'serviceID'
 *      config: // value for 'config'
 *   },
 * });
 */
export function useUpdateRunServiceConfigMutation(baseOptions?: Apollo.MutationHookOptions<UpdateRunServiceConfigMutation, UpdateRunServiceConfigMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateRunServiceConfigMutation, UpdateRunServiceConfigMutationVariables>(UpdateRunServiceConfigDocument, options);
      }
export type UpdateRunServiceConfigMutationHookResult = ReturnType<typeof useUpdateRunServiceConfigMutation>;
export type UpdateRunServiceConfigMutationResult = Apollo.MutationResult<UpdateRunServiceConfigMutation>;
export type UpdateRunServiceConfigMutationOptions = Apollo.BaseMutationOptions<UpdateRunServiceConfigMutation, UpdateRunServiceConfigMutationVariables>;
export const GetFreeAndActiveProjectsDocument = gql`
    query GetFreeAndActiveProjects($userId: uuid!) {
  freeAndActiveProjects: apps(
    where: {creatorUserId: {_eq: $userId}, legacyPlan: {isFree: {_eq: true}}, desiredState: {_eq: 5}}
  ) {
    id
  }
}
    `;

/**
 * __useGetFreeAndActiveProjectsQuery__
 *
 * To run a query within a React component, call `useGetFreeAndActiveProjectsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetFreeAndActiveProjectsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetFreeAndActiveProjectsQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useGetFreeAndActiveProjectsQuery(baseOptions: Apollo.QueryHookOptions<GetFreeAndActiveProjectsQuery, GetFreeAndActiveProjectsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetFreeAndActiveProjectsQuery, GetFreeAndActiveProjectsQueryVariables>(GetFreeAndActiveProjectsDocument, options);
      }
export function useGetFreeAndActiveProjectsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetFreeAndActiveProjectsQuery, GetFreeAndActiveProjectsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetFreeAndActiveProjectsQuery, GetFreeAndActiveProjectsQueryVariables>(GetFreeAndActiveProjectsDocument, options);
        }
export type GetFreeAndActiveProjectsQueryHookResult = ReturnType<typeof useGetFreeAndActiveProjectsQuery>;
export type GetFreeAndActiveProjectsLazyQueryHookResult = ReturnType<typeof useGetFreeAndActiveProjectsLazyQuery>;
export type GetFreeAndActiveProjectsQueryResult = Apollo.QueryResult<GetFreeAndActiveProjectsQuery, GetFreeAndActiveProjectsQueryVariables>;
export function refetchGetFreeAndActiveProjectsQuery(variables: GetFreeAndActiveProjectsQueryVariables) {
      return { query: GetFreeAndActiveProjectsDocument, variables: variables }
    }
export const DeleteWorkspaceMemberInvitesDocument = gql`
    mutation deleteWorkspaceMemberInvites($id: uuid!) {
  deleteWorkspaceMemberInvites(where: {id: {_eq: $id}}) {
    affected_rows
  }
}
    `;
export type DeleteWorkspaceMemberInvitesMutationFn = Apollo.MutationFunction<DeleteWorkspaceMemberInvitesMutation, DeleteWorkspaceMemberInvitesMutationVariables>;

/**
 * __useDeleteWorkspaceMemberInvitesMutation__
 *
 * To run a mutation, you first call `useDeleteWorkspaceMemberInvitesMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteWorkspaceMemberInvitesMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteWorkspaceMemberInvitesMutation, { data, loading, error }] = useDeleteWorkspaceMemberInvitesMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteWorkspaceMemberInvitesMutation(baseOptions?: Apollo.MutationHookOptions<DeleteWorkspaceMemberInvitesMutation, DeleteWorkspaceMemberInvitesMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteWorkspaceMemberInvitesMutation, DeleteWorkspaceMemberInvitesMutationVariables>(DeleteWorkspaceMemberInvitesDocument, options);
      }
export type DeleteWorkspaceMemberInvitesMutationHookResult = ReturnType<typeof useDeleteWorkspaceMemberInvitesMutation>;
export type DeleteWorkspaceMemberInvitesMutationResult = Apollo.MutationResult<DeleteWorkspaceMemberInvitesMutation>;
export type DeleteWorkspaceMemberInvitesMutationOptions = Apollo.BaseMutationOptions<DeleteWorkspaceMemberInvitesMutation, DeleteWorkspaceMemberInvitesMutationVariables>;
export const GetWorkspaceMemberInvitesToManageDocument = gql`
    query getWorkspaceMemberInvitesToManage($userId: uuid!) {
  workspaceMemberInvites(where: {userByEmail: {id: {_eq: $userId}}}) {
    id
    email
    userByEmail {
      id
    }
    workspace {
      id
      name
      slug
    }
  }
}
    `;

/**
 * __useGetWorkspaceMemberInvitesToManageQuery__
 *
 * To run a query within a React component, call `useGetWorkspaceMemberInvitesToManageQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetWorkspaceMemberInvitesToManageQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetWorkspaceMemberInvitesToManageQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useGetWorkspaceMemberInvitesToManageQuery(baseOptions: Apollo.QueryHookOptions<GetWorkspaceMemberInvitesToManageQuery, GetWorkspaceMemberInvitesToManageQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetWorkspaceMemberInvitesToManageQuery, GetWorkspaceMemberInvitesToManageQueryVariables>(GetWorkspaceMemberInvitesToManageDocument, options);
      }
export function useGetWorkspaceMemberInvitesToManageLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetWorkspaceMemberInvitesToManageQuery, GetWorkspaceMemberInvitesToManageQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetWorkspaceMemberInvitesToManageQuery, GetWorkspaceMemberInvitesToManageQueryVariables>(GetWorkspaceMemberInvitesToManageDocument, options);
        }
export type GetWorkspaceMemberInvitesToManageQueryHookResult = ReturnType<typeof useGetWorkspaceMemberInvitesToManageQuery>;
export type GetWorkspaceMemberInvitesToManageLazyQueryHookResult = ReturnType<typeof useGetWorkspaceMemberInvitesToManageLazyQuery>;
export type GetWorkspaceMemberInvitesToManageQueryResult = Apollo.QueryResult<GetWorkspaceMemberInvitesToManageQuery, GetWorkspaceMemberInvitesToManageQueryVariables>;
export function refetchGetWorkspaceMemberInvitesToManageQuery(variables: GetWorkspaceMemberInvitesToManageQueryVariables) {
      return { query: GetWorkspaceMemberInvitesToManageDocument, variables: variables }
    }
export const InsertWorkspaceMemberInviteDocument = gql`
    mutation insertWorkspaceMemberInvite($workspaceMemberInvite: workspaceMemberInvites_insert_input!) {
  insertWorkspaceMemberInvite(object: $workspaceMemberInvite) {
    id
  }
}
    `;
export type InsertWorkspaceMemberInviteMutationFn = Apollo.MutationFunction<InsertWorkspaceMemberInviteMutation, InsertWorkspaceMemberInviteMutationVariables>;

/**
 * __useInsertWorkspaceMemberInviteMutation__
 *
 * To run a mutation, you first call `useInsertWorkspaceMemberInviteMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertWorkspaceMemberInviteMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertWorkspaceMemberInviteMutation, { data, loading, error }] = useInsertWorkspaceMemberInviteMutation({
 *   variables: {
 *      workspaceMemberInvite: // value for 'workspaceMemberInvite'
 *   },
 * });
 */
export function useInsertWorkspaceMemberInviteMutation(baseOptions?: Apollo.MutationHookOptions<InsertWorkspaceMemberInviteMutation, InsertWorkspaceMemberInviteMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<InsertWorkspaceMemberInviteMutation, InsertWorkspaceMemberInviteMutationVariables>(InsertWorkspaceMemberInviteDocument, options);
      }
export type InsertWorkspaceMemberInviteMutationHookResult = ReturnType<typeof useInsertWorkspaceMemberInviteMutation>;
export type InsertWorkspaceMemberInviteMutationResult = Apollo.MutationResult<InsertWorkspaceMemberInviteMutation>;
export type InsertWorkspaceMemberInviteMutationOptions = Apollo.BaseMutationOptions<InsertWorkspaceMemberInviteMutation, InsertWorkspaceMemberInviteMutationVariables>;
export const UpdateWorkspaceMemberInviteDocument = gql`
    mutation updateWorkspaceMemberInvite($id: uuid!, $workspaceMemberInvite: workspaceMemberInvites_set_input!) {
  updateWorkspaceMemberInvites(
    _set: $workspaceMemberInvite
    where: {id: {_eq: $id}}
  ) {
    affected_rows
  }
}
    `;
export type UpdateWorkspaceMemberInviteMutationFn = Apollo.MutationFunction<UpdateWorkspaceMemberInviteMutation, UpdateWorkspaceMemberInviteMutationVariables>;

/**
 * __useUpdateWorkspaceMemberInviteMutation__
 *
 * To run a mutation, you first call `useUpdateWorkspaceMemberInviteMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateWorkspaceMemberInviteMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateWorkspaceMemberInviteMutation, { data, loading, error }] = useUpdateWorkspaceMemberInviteMutation({
 *   variables: {
 *      id: // value for 'id'
 *      workspaceMemberInvite: // value for 'workspaceMemberInvite'
 *   },
 * });
 */
export function useUpdateWorkspaceMemberInviteMutation(baseOptions?: Apollo.MutationHookOptions<UpdateWorkspaceMemberInviteMutation, UpdateWorkspaceMemberInviteMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateWorkspaceMemberInviteMutation, UpdateWorkspaceMemberInviteMutationVariables>(UpdateWorkspaceMemberInviteDocument, options);
      }
export type UpdateWorkspaceMemberInviteMutationHookResult = ReturnType<typeof useUpdateWorkspaceMemberInviteMutation>;
export type UpdateWorkspaceMemberInviteMutationResult = Apollo.MutationResult<UpdateWorkspaceMemberInviteMutation>;
export type UpdateWorkspaceMemberInviteMutationOptions = Apollo.BaseMutationOptions<UpdateWorkspaceMemberInviteMutation, UpdateWorkspaceMemberInviteMutationVariables>;
export const DeleteWorkspaceMemberDocument = gql`
    mutation deleteWorkspaceMember($id: uuid!) {
  deleteWorkspaceMember(id: $id) {
    id
  }
}
    `;
export type DeleteWorkspaceMemberMutationFn = Apollo.MutationFunction<DeleteWorkspaceMemberMutation, DeleteWorkspaceMemberMutationVariables>;

/**
 * __useDeleteWorkspaceMemberMutation__
 *
 * To run a mutation, you first call `useDeleteWorkspaceMemberMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteWorkspaceMemberMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteWorkspaceMemberMutation, { data, loading, error }] = useDeleteWorkspaceMemberMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteWorkspaceMemberMutation(baseOptions?: Apollo.MutationHookOptions<DeleteWorkspaceMemberMutation, DeleteWorkspaceMemberMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteWorkspaceMemberMutation, DeleteWorkspaceMemberMutationVariables>(DeleteWorkspaceMemberDocument, options);
      }
export type DeleteWorkspaceMemberMutationHookResult = ReturnType<typeof useDeleteWorkspaceMemberMutation>;
export type DeleteWorkspaceMemberMutationResult = Apollo.MutationResult<DeleteWorkspaceMemberMutation>;
export type DeleteWorkspaceMemberMutationOptions = Apollo.BaseMutationOptions<DeleteWorkspaceMemberMutation, DeleteWorkspaceMemberMutationVariables>;
export const GetWorkspaceMembersDocument = gql`
    query getWorkspaceMembers($workspaceId: uuid!) {
  workspace(id: $workspaceId) {
    id
    creatorUser {
      id
    }
    workspaceMembers(order_by: {createdAt: asc}) {
      ...getWorkspaceMembersWorkspaceMember
    }
    workspaceMemberInvites(order_by: {createdAt: asc}) {
      ...getWorkspaceMembersWorkspaceMemberInvite
    }
  }
}
    ${GetWorkspaceMembersWorkspaceMemberFragmentDoc}
${GetWorkspaceMembersWorkspaceMemberInviteFragmentDoc}`;

/**
 * __useGetWorkspaceMembersQuery__
 *
 * To run a query within a React component, call `useGetWorkspaceMembersQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetWorkspaceMembersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetWorkspaceMembersQuery({
 *   variables: {
 *      workspaceId: // value for 'workspaceId'
 *   },
 * });
 */
export function useGetWorkspaceMembersQuery(baseOptions: Apollo.QueryHookOptions<GetWorkspaceMembersQuery, GetWorkspaceMembersQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetWorkspaceMembersQuery, GetWorkspaceMembersQueryVariables>(GetWorkspaceMembersDocument, options);
      }
export function useGetWorkspaceMembersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetWorkspaceMembersQuery, GetWorkspaceMembersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetWorkspaceMembersQuery, GetWorkspaceMembersQueryVariables>(GetWorkspaceMembersDocument, options);
        }
export type GetWorkspaceMembersQueryHookResult = ReturnType<typeof useGetWorkspaceMembersQuery>;
export type GetWorkspaceMembersLazyQueryHookResult = ReturnType<typeof useGetWorkspaceMembersLazyQuery>;
export type GetWorkspaceMembersQueryResult = Apollo.QueryResult<GetWorkspaceMembersQuery, GetWorkspaceMembersQueryVariables>;
export function refetchGetWorkspaceMembersQuery(variables: GetWorkspaceMembersQueryVariables) {
      return { query: GetWorkspaceMembersDocument, variables: variables }
    }
export const UpdateWorkspaceMemberDocument = gql`
    mutation updateWorkspaceMember($id: uuid!, $workspaceMember: workspaceMembers_set_input!) {
  updateWorkspaceMember(_set: $workspaceMember, pk_columns: {id: $id}) {
    id
  }
}
    `;
export type UpdateWorkspaceMemberMutationFn = Apollo.MutationFunction<UpdateWorkspaceMemberMutation, UpdateWorkspaceMemberMutationVariables>;

/**
 * __useUpdateWorkspaceMemberMutation__
 *
 * To run a mutation, you first call `useUpdateWorkspaceMemberMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateWorkspaceMemberMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateWorkspaceMemberMutation, { data, loading, error }] = useUpdateWorkspaceMemberMutation({
 *   variables: {
 *      id: // value for 'id'
 *      workspaceMember: // value for 'workspaceMember'
 *   },
 * });
 */
export function useUpdateWorkspaceMemberMutation(baseOptions?: Apollo.MutationHookOptions<UpdateWorkspaceMemberMutation, UpdateWorkspaceMemberMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateWorkspaceMemberMutation, UpdateWorkspaceMemberMutationVariables>(UpdateWorkspaceMemberDocument, options);
      }
export type UpdateWorkspaceMemberMutationHookResult = ReturnType<typeof useUpdateWorkspaceMemberMutation>;
export type UpdateWorkspaceMemberMutationResult = Apollo.MutationResult<UpdateWorkspaceMemberMutation>;
export type UpdateWorkspaceMemberMutationOptions = Apollo.BaseMutationOptions<UpdateWorkspaceMemberMutation, UpdateWorkspaceMemberMutationVariables>;
export const DeleteWorkspaceDocument = gql`
    mutation deleteWorkspace($id: uuid!) {
  deleteWorkspace(id: $id) {
    id
  }
}
    `;
export type DeleteWorkspaceMutationFn = Apollo.MutationFunction<DeleteWorkspaceMutation, DeleteWorkspaceMutationVariables>;

/**
 * __useDeleteWorkspaceMutation__
 *
 * To run a mutation, you first call `useDeleteWorkspaceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteWorkspaceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteWorkspaceMutation, { data, loading, error }] = useDeleteWorkspaceMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteWorkspaceMutation(baseOptions?: Apollo.MutationHookOptions<DeleteWorkspaceMutation, DeleteWorkspaceMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteWorkspaceMutation, DeleteWorkspaceMutationVariables>(DeleteWorkspaceDocument, options);
      }
export type DeleteWorkspaceMutationHookResult = ReturnType<typeof useDeleteWorkspaceMutation>;
export type DeleteWorkspaceMutationResult = Apollo.MutationResult<DeleteWorkspaceMutation>;
export type DeleteWorkspaceMutationOptions = Apollo.BaseMutationOptions<DeleteWorkspaceMutation, DeleteWorkspaceMutationVariables>;
export const InsertWorkspaceDocument = gql`
    mutation insertWorkspace($workspace: workspaces_insert_input!) {
  insertWorkspace(object: $workspace) {
    name
    id
  }
}
    `;
export type InsertWorkspaceMutationFn = Apollo.MutationFunction<InsertWorkspaceMutation, InsertWorkspaceMutationVariables>;

/**
 * __useInsertWorkspaceMutation__
 *
 * To run a mutation, you first call `useInsertWorkspaceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertWorkspaceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertWorkspaceMutation, { data, loading, error }] = useInsertWorkspaceMutation({
 *   variables: {
 *      workspace: // value for 'workspace'
 *   },
 * });
 */
export function useInsertWorkspaceMutation(baseOptions?: Apollo.MutationHookOptions<InsertWorkspaceMutation, InsertWorkspaceMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<InsertWorkspaceMutation, InsertWorkspaceMutationVariables>(InsertWorkspaceDocument, options);
      }
export type InsertWorkspaceMutationHookResult = ReturnType<typeof useInsertWorkspaceMutation>;
export type InsertWorkspaceMutationResult = Apollo.MutationResult<InsertWorkspaceMutation>;
export type InsertWorkspaceMutationOptions = Apollo.BaseMutationOptions<InsertWorkspaceMutation, InsertWorkspaceMutationVariables>;
export const UpdateWorkspaceDocument = gql`
    mutation updateWorkspace($id: uuid!, $workspace: workspaces_set_input!) {
  updateWorkspace(pk_columns: {id: $id}, _set: $workspace) {
    id
    name
    email
    companyName
    addressLine1
    addressLine2
    addressPostalCode
    addressCity
    addressCountryCode
    slug
    taxIdType
    taxIdValue
  }
}
    `;
export type UpdateWorkspaceMutationFn = Apollo.MutationFunction<UpdateWorkspaceMutation, UpdateWorkspaceMutationVariables>;

/**
 * __useUpdateWorkspaceMutation__
 *
 * To run a mutation, you first call `useUpdateWorkspaceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateWorkspaceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateWorkspaceMutation, { data, loading, error }] = useUpdateWorkspaceMutation({
 *   variables: {
 *      id: // value for 'id'
 *      workspace: // value for 'workspace'
 *   },
 * });
 */
export function useUpdateWorkspaceMutation(baseOptions?: Apollo.MutationHookOptions<UpdateWorkspaceMutation, UpdateWorkspaceMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateWorkspaceMutation, UpdateWorkspaceMutationVariables>(UpdateWorkspaceDocument, options);
      }
export type UpdateWorkspaceMutationHookResult = ReturnType<typeof useUpdateWorkspaceMutation>;
export type UpdateWorkspaceMutationResult = Apollo.MutationResult<UpdateWorkspaceMutation>;
export type UpdateWorkspaceMutationOptions = Apollo.BaseMutationOptions<UpdateWorkspaceMutation, UpdateWorkspaceMutationVariables>;