/**
 * Generated by orval v7.9.0 üç∫
 * Do not edit manually.
 * Hasura API
 * API for managing database operations, migrations, and metadata permissions
 * OpenAPI spec version: 1.0.0
 */
import type {
  MutationFunction,
  UseMutationOptions,
  UseMutationResult,
} from '@tanstack/react-query';
import { useMutation } from '@tanstack/react-query';

import type {
  ErrorResponse,
  ExecuteQuery200,
  ExecuteQueryBody,
  MetadataOperation200,
  MetadataOperationBody,
  MigrationRequest,
  PostgresErrorResponse,
  SuccessResponse,
} from '.././schemas';

import { hasuraMutator } from '../../hasura-mutator';

type AwaitedInput<T> = PromiseLike<T> | T;

type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * Execute SQL queries and other database operations
 * @summary Execute database operations. Do not use to modify the database schema, use /v1/migrate instead
 */
export const executeQuery = (
  executeQueryBody: ExecuteQueryBody,
  options?: SecondParameter<typeof hasuraMutator>,
) => {
  return hasuraMutator<ExecuteQuery200>(
    {
      url: `/v2/query`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: executeQueryBody,
    },
    options,
  );
};

export const getExecuteQueryMutationOptions = <
  TError = PostgresErrorResponse | ErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof executeQuery>>,
    TError,
    { data: ExecuteQueryBody },
    TContext
  >;
  request?: SecondParameter<typeof hasuraMutator>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof executeQuery>>,
  TError,
  { data: ExecuteQueryBody },
  TContext
> => {
  const mutationKey = ['executeQuery'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof executeQuery>>,
    { data: ExecuteQueryBody }
  > = (props) => {
    const { data } = props ?? {};

    return executeQuery(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ExecuteQueryMutationResult = NonNullable<
  Awaited<ReturnType<typeof executeQuery>>
>;
export type ExecuteQueryMutationBody = ExecuteQueryBody;
export type ExecuteQueryMutationError = PostgresErrorResponse | ErrorResponse;

/**
 * @summary Execute database operations. Do not use to modify the database schema, use /v1/migrate instead
 */
export const useExecuteQuery = <
  TError = PostgresErrorResponse | ErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof executeQuery>>,
    TError,
    { data: ExecuteQueryBody },
    TContext
  >;
  request?: SecondParameter<typeof hasuraMutator>;
}): UseMutationResult<
  Awaited<ReturnType<typeof executeQuery>>,
  TError,
  { data: ExecuteQueryBody },
  TContext
> => {
  const mutationOptions = getExecuteQueryMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Executes a migration with the provided up and down steps
 * @summary Execute a database migration
 */
export const executeMigration = (
  migrationRequest: MigrationRequest,
  options?: SecondParameter<typeof hasuraMutator>,
) => {
  return hasuraMutator<SuccessResponse>(
    {
      url: `/apis/migrate`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: migrationRequest,
    },
    options,
  );
};

export const getExecuteMigrationMutationOptions = <
  TError = ErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof executeMigration>>,
    TError,
    { data: MigrationRequest },
    TContext
  >;
  request?: SecondParameter<typeof hasuraMutator>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof executeMigration>>,
  TError,
  { data: MigrationRequest },
  TContext
> => {
  const mutationKey = ['executeMigration'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof executeMigration>>,
    { data: MigrationRequest }
  > = (props) => {
    const { data } = props ?? {};

    return executeMigration(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ExecuteMigrationMutationResult = NonNullable<
  Awaited<ReturnType<typeof executeMigration>>
>;
export type ExecuteMigrationMutationBody = MigrationRequest;
export type ExecuteMigrationMutationError = ErrorResponse;

/**
 * @summary Execute a database migration
 */
export const useExecuteMigration = <
  TError = ErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof executeMigration>>,
    TError,
    { data: MigrationRequest },
    TContext
  >;
  request?: SecondParameter<typeof hasuraMutator>;
}): UseMutationResult<
  Awaited<ReturnType<typeof executeMigration>>,
  TError,
  { data: MigrationRequest },
  TContext
> => {
  const mutationOptions = getExecuteMigrationMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Endpoint for all metadata operations
 * @summary Metadata API endpoint
 */
export const metadataOperation = (
  metadataOperationBody: MetadataOperationBody,
  options?: SecondParameter<typeof hasuraMutator>,
) => {
  return hasuraMutator<MetadataOperation200>(
    {
      url: `/v1/metadata`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: metadataOperationBody,
    },
    options,
  );
};

export const getMetadataOperationMutationOptions = <
  TError = ErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof metadataOperation>>,
    TError,
    { data: MetadataOperationBody },
    TContext
  >;
  request?: SecondParameter<typeof hasuraMutator>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof metadataOperation>>,
  TError,
  { data: MetadataOperationBody },
  TContext
> => {
  const mutationKey = ['metadataOperation'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof metadataOperation>>,
    { data: MetadataOperationBody }
  > = (props) => {
    const { data } = props ?? {};

    return metadataOperation(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type MetadataOperationMutationResult = NonNullable<
  Awaited<ReturnType<typeof metadataOperation>>
>;
export type MetadataOperationMutationBody = MetadataOperationBody;
export type MetadataOperationMutationError = ErrorResponse;

/**
 * @summary Metadata API endpoint
 */
export const useMetadataOperation = <
  TError = ErrorResponse,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof metadataOperation>>,
    TError,
    { data: MetadataOperationBody },
    TContext
  >;
  request?: SecondParameter<typeof hasuraMutator>;
}): UseMutationResult<
  Awaited<ReturnType<typeof metadataOperation>>,
  TError,
  { data: MetadataOperationBody },
  TContext
> => {
  const mutationOptions = getMetadataOperationMutationOptions(options);

  return useMutation(mutationOptions);
};
