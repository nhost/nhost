// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version 2.5.0 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"mime/multipart"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gin-gonic/gin"
	"github.com/oapi-codegen/runtime"
	strictgin "github.com/oapi-codegen/runtime/strictmiddleware/gin"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Upload files
	// (POST /files)
	UploadFiles(c *gin.Context)
	// Delete file
	// (DELETE /files/{id})
	DeleteFile(c *gin.Context, id string)
	// Download file
	// (GET /files/{id})
	GetFile(c *gin.Context, id string, params GetFileParams)
	// Check file information
	// (HEAD /files/{id})
	GetFileMetadataHeaders(c *gin.Context, id string, params GetFileMetadataHeadersParams)
	// Replace file
	// (PUT /files/{id})
	ReplaceFile(c *gin.Context, id string)
	// Retrieve presigned URL to retrieve the file
	// (GET /files/{id}/presignedurl)
	GetFilePresignedURL(c *gin.Context, id string)
	// Retrieve contents of file
	// (GET /files/{id}/presignedurl/contents)
	GetFileWithPresignedURL(c *gin.Context, id string, params GetFileWithPresignedURLParams)
	// Get OpenAPI specification
	// (GET /openapi.yaml)
	GetOpenAPISpec(c *gin.Context)
	// Delete broken metadata
	// (POST /ops/delete-broken-metadata)
	DeleteBrokenMetadata(c *gin.Context)
	// Deletes orphaned files
	// (POST /ops/delete-orphans)
	DeleteOrphanedFiles(c *gin.Context)
	// Lists broken metadata
	// (POST /ops/list-broken-metadata)
	ListBrokenMetadata(c *gin.Context)
	// Lists files that haven't been uploaded
	// (POST /ops/list-not-uploaded)
	ListFilesNotUploaded(c *gin.Context)
	// Lists orphaned files
	// (POST /ops/list-orphans)
	ListOrphanedFiles(c *gin.Context)
	// Get service version information
	// (GET /version)
	GetVersion(c *gin.Context)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// UploadFiles operation middleware
func (siw *ServerInterfaceWrapper) UploadFiles(c *gin.Context) {

	c.Set(AuthorizationScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UploadFiles(c)
}

// DeleteFile operation middleware
func (siw *ServerInterfaceWrapper) DeleteFile(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(AuthorizationScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.DeleteFile(c, id)
}

// GetFile operation middleware
func (siw *ServerInterfaceWrapper) GetFile(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(AuthorizationScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFileParams

	// ------------- Optional query parameter "q" -------------

	err = runtime.BindQueryParameter("form", true, false, "q", c.Request.URL.Query(), &params.Q)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter q: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "h" -------------

	err = runtime.BindQueryParameter("form", true, false, "h", c.Request.URL.Query(), &params.H)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter h: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "w" -------------

	err = runtime.BindQueryParameter("form", true, false, "w", c.Request.URL.Query(), &params.W)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter w: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "b" -------------

	err = runtime.BindQueryParameter("form", true, false, "b", c.Request.URL.Query(), &params.B)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter b: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "f" -------------

	err = runtime.BindQueryParameter("form", true, false, "f", c.Request.URL.Query(), &params.F)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter f: %w", err), http.StatusBadRequest)
		return
	}

	headers := c.Request.Header

	// ------------- Optional header parameter "if-match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-match")]; found {
		var IfMatch string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for if-match, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter if-match: %w", err), http.StatusBadRequest)
			return
		}

		params.IfMatch = &IfMatch

	}

	// ------------- Optional header parameter "if-none-match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-none-match")]; found {
		var IfNoneMatch string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for if-none-match, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-none-match", valueList[0], &IfNoneMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter if-none-match: %w", err), http.StatusBadRequest)
			return
		}

		params.IfNoneMatch = &IfNoneMatch

	}

	// ------------- Optional header parameter "if-modified-since" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-modified-since")]; found {
		var IfModifiedSince RFC2822Date
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for if-modified-since, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-modified-since", valueList[0], &IfModifiedSince, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter if-modified-since: %w", err), http.StatusBadRequest)
			return
		}

		params.IfModifiedSince = &IfModifiedSince

	}

	// ------------- Optional header parameter "if-unmodified-since" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-unmodified-since")]; found {
		var IfUnmodifiedSince RFC2822Date
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for if-unmodified-since, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-unmodified-since", valueList[0], &IfUnmodifiedSince, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter if-unmodified-since: %w", err), http.StatusBadRequest)
			return
		}

		params.IfUnmodifiedSince = &IfUnmodifiedSince

	}

	// ------------- Optional header parameter "Range" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Range")]; found {
		var Range string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Range, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Range", valueList[0], &Range, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Range: %w", err), http.StatusBadRequest)
			return
		}

		params.Range = &Range

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetFile(c, id, params)
}

// GetFileMetadataHeaders operation middleware
func (siw *ServerInterfaceWrapper) GetFileMetadataHeaders(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(AuthorizationScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFileMetadataHeadersParams

	// ------------- Optional query parameter "q" -------------

	err = runtime.BindQueryParameter("form", true, false, "q", c.Request.URL.Query(), &params.Q)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter q: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "h" -------------

	err = runtime.BindQueryParameter("form", true, false, "h", c.Request.URL.Query(), &params.H)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter h: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "w" -------------

	err = runtime.BindQueryParameter("form", true, false, "w", c.Request.URL.Query(), &params.W)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter w: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "b" -------------

	err = runtime.BindQueryParameter("form", true, false, "b", c.Request.URL.Query(), &params.B)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter b: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "f" -------------

	err = runtime.BindQueryParameter("form", true, false, "f", c.Request.URL.Query(), &params.F)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter f: %w", err), http.StatusBadRequest)
		return
	}

	headers := c.Request.Header

	// ------------- Optional header parameter "if-match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-match")]; found {
		var IfMatch string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for if-match, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter if-match: %w", err), http.StatusBadRequest)
			return
		}

		params.IfMatch = &IfMatch

	}

	// ------------- Optional header parameter "if-none-match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-none-match")]; found {
		var IfNoneMatch string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for if-none-match, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-none-match", valueList[0], &IfNoneMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter if-none-match: %w", err), http.StatusBadRequest)
			return
		}

		params.IfNoneMatch = &IfNoneMatch

	}

	// ------------- Optional header parameter "if-modified-since" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-modified-since")]; found {
		var IfModifiedSince RFC2822Date
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for if-modified-since, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-modified-since", valueList[0], &IfModifiedSince, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter if-modified-since: %w", err), http.StatusBadRequest)
			return
		}

		params.IfModifiedSince = &IfModifiedSince

	}

	// ------------- Optional header parameter "if-unmodified-since" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-unmodified-since")]; found {
		var IfUnmodifiedSince RFC2822Date
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for if-unmodified-since, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-unmodified-since", valueList[0], &IfUnmodifiedSince, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter if-unmodified-since: %w", err), http.StatusBadRequest)
			return
		}

		params.IfUnmodifiedSince = &IfUnmodifiedSince

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetFileMetadataHeaders(c, id, params)
}

// ReplaceFile operation middleware
func (siw *ServerInterfaceWrapper) ReplaceFile(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(AuthorizationScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ReplaceFile(c, id)
}

// GetFilePresignedURL operation middleware
func (siw *ServerInterfaceWrapper) GetFilePresignedURL(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(AuthorizationScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetFilePresignedURL(c, id)
}

// GetFileWithPresignedURL operation middleware
func (siw *ServerInterfaceWrapper) GetFileWithPresignedURL(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(AuthorizationScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFileWithPresignedURLParams

	// ------------- Required query parameter "X-Amz-Algorithm" -------------

	if paramValue := c.Query("X-Amz-Algorithm"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument X-Amz-Algorithm is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "X-Amz-Algorithm", c.Request.URL.Query(), &params.XAmzAlgorithm)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Amz-Algorithm: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "X-Amz-Credential" -------------

	if paramValue := c.Query("X-Amz-Credential"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument X-Amz-Credential is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "X-Amz-Credential", c.Request.URL.Query(), &params.XAmzCredential)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Amz-Credential: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "X-Amz-Date" -------------

	if paramValue := c.Query("X-Amz-Date"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument X-Amz-Date is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "X-Amz-Date", c.Request.URL.Query(), &params.XAmzDate)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Amz-Date: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "X-Amz-Expires" -------------

	if paramValue := c.Query("X-Amz-Expires"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument X-Amz-Expires is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "X-Amz-Expires", c.Request.URL.Query(), &params.XAmzExpires)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Amz-Expires: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "X-Amz-Signature" -------------

	if paramValue := c.Query("X-Amz-Signature"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument X-Amz-Signature is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "X-Amz-Signature", c.Request.URL.Query(), &params.XAmzSignature)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Amz-Signature: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "X-Amz-SignedHeaders" -------------

	if paramValue := c.Query("X-Amz-SignedHeaders"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument X-Amz-SignedHeaders is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "X-Amz-SignedHeaders", c.Request.URL.Query(), &params.XAmzSignedHeaders)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Amz-SignedHeaders: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "X-Amz-Checksum-Mode" -------------

	if paramValue := c.Query("X-Amz-Checksum-Mode"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument X-Amz-Checksum-Mode is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "X-Amz-Checksum-Mode", c.Request.URL.Query(), &params.XAmzChecksumMode)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Amz-Checksum-Mode: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "X-Amz-Security-Token" -------------

	err = runtime.BindQueryParameter("form", true, false, "X-Amz-Security-Token", c.Request.URL.Query(), &params.XAmzSecurityToken)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Amz-Security-Token: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "x-id" -------------

	if paramValue := c.Query("x-id"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument x-id is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "x-id", c.Request.URL.Query(), &params.XId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter x-id: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "q" -------------

	err = runtime.BindQueryParameter("form", true, false, "q", c.Request.URL.Query(), &params.Q)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter q: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "h" -------------

	err = runtime.BindQueryParameter("form", true, false, "h", c.Request.URL.Query(), &params.H)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter h: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "w" -------------

	err = runtime.BindQueryParameter("form", true, false, "w", c.Request.URL.Query(), &params.W)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter w: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "b" -------------

	err = runtime.BindQueryParameter("form", true, false, "b", c.Request.URL.Query(), &params.B)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter b: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "f" -------------

	err = runtime.BindQueryParameter("form", true, false, "f", c.Request.URL.Query(), &params.F)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter f: %w", err), http.StatusBadRequest)
		return
	}

	headers := c.Request.Header

	// ------------- Optional header parameter "if-match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-match")]; found {
		var IfMatch string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for if-match, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter if-match: %w", err), http.StatusBadRequest)
			return
		}

		params.IfMatch = &IfMatch

	}

	// ------------- Optional header parameter "if-none-match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-none-match")]; found {
		var IfNoneMatch string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for if-none-match, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-none-match", valueList[0], &IfNoneMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter if-none-match: %w", err), http.StatusBadRequest)
			return
		}

		params.IfNoneMatch = &IfNoneMatch

	}

	// ------------- Optional header parameter "if-modified-since" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-modified-since")]; found {
		var IfModifiedSince RFC2822Date
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for if-modified-since, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-modified-since", valueList[0], &IfModifiedSince, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter if-modified-since: %w", err), http.StatusBadRequest)
			return
		}

		params.IfModifiedSince = &IfModifiedSince

	}

	// ------------- Optional header parameter "if-unmodified-since" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("if-unmodified-since")]; found {
		var IfUnmodifiedSince RFC2822Date
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for if-unmodified-since, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "if-unmodified-since", valueList[0], &IfUnmodifiedSince, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter if-unmodified-since: %w", err), http.StatusBadRequest)
			return
		}

		params.IfUnmodifiedSince = &IfUnmodifiedSince

	}

	// ------------- Optional header parameter "Range" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Range")]; found {
		var Range string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for Range, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Range", valueList[0], &Range, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter Range: %w", err), http.StatusBadRequest)
			return
		}

		params.Range = &Range

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetFileWithPresignedURL(c, id, params)
}

// GetOpenAPISpec operation middleware
func (siw *ServerInterfaceWrapper) GetOpenAPISpec(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetOpenAPISpec(c)
}

// DeleteBrokenMetadata operation middleware
func (siw *ServerInterfaceWrapper) DeleteBrokenMetadata(c *gin.Context) {

	c.Set(X_Hasura_Admin_SecretScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.DeleteBrokenMetadata(c)
}

// DeleteOrphanedFiles operation middleware
func (siw *ServerInterfaceWrapper) DeleteOrphanedFiles(c *gin.Context) {

	c.Set(X_Hasura_Admin_SecretScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.DeleteOrphanedFiles(c)
}

// ListBrokenMetadata operation middleware
func (siw *ServerInterfaceWrapper) ListBrokenMetadata(c *gin.Context) {

	c.Set(X_Hasura_Admin_SecretScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ListBrokenMetadata(c)
}

// ListFilesNotUploaded operation middleware
func (siw *ServerInterfaceWrapper) ListFilesNotUploaded(c *gin.Context) {

	c.Set(X_Hasura_Admin_SecretScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ListFilesNotUploaded(c)
}

// ListOrphanedFiles operation middleware
func (siw *ServerInterfaceWrapper) ListOrphanedFiles(c *gin.Context) {

	c.Set(X_Hasura_Admin_SecretScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ListOrphanedFiles(c)
}

// GetVersion operation middleware
func (siw *ServerInterfaceWrapper) GetVersion(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetVersion(c)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.POST(options.BaseURL+"/files", wrapper.UploadFiles)
	router.DELETE(options.BaseURL+"/files/:id", wrapper.DeleteFile)
	router.GET(options.BaseURL+"/files/:id", wrapper.GetFile)
	router.HEAD(options.BaseURL+"/files/:id", wrapper.GetFileMetadataHeaders)
	router.PUT(options.BaseURL+"/files/:id", wrapper.ReplaceFile)
	router.GET(options.BaseURL+"/files/:id/presignedurl", wrapper.GetFilePresignedURL)
	router.GET(options.BaseURL+"/files/:id/presignedurl/contents", wrapper.GetFileWithPresignedURL)
	router.GET(options.BaseURL+"/openapi.yaml", wrapper.GetOpenAPISpec)
	router.POST(options.BaseURL+"/ops/delete-broken-metadata", wrapper.DeleteBrokenMetadata)
	router.POST(options.BaseURL+"/ops/delete-orphans", wrapper.DeleteOrphanedFiles)
	router.POST(options.BaseURL+"/ops/list-broken-metadata", wrapper.ListBrokenMetadata)
	router.POST(options.BaseURL+"/ops/list-not-uploaded", wrapper.ListFilesNotUploaded)
	router.POST(options.BaseURL+"/ops/list-orphans", wrapper.ListOrphanedFiles)
	router.GET(options.BaseURL+"/version", wrapper.GetVersion)
}

type UploadFilesRequestObject struct {
	Body *multipart.Reader
}

type UploadFilesResponseObject interface {
	VisitUploadFilesResponse(w http.ResponseWriter) error
}

type UploadFiles201JSONResponse struct {
	// ProcessedFiles List of successfully processed files with their metadata.
	ProcessedFiles []FileMetadata `json:"processedFiles"`
}

func (response UploadFiles201JSONResponse) VisitUploadFilesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type UploadFilesdefaultJSONResponse struct {
	Body       ErrorResponseWithProcessedFiles
	StatusCode int
}

func (response UploadFilesdefaultJSONResponse) VisitUploadFilesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type DeleteFileRequestObject struct {
	Id string `json:"id"`
}

type DeleteFileResponseObject interface {
	VisitDeleteFileResponse(w http.ResponseWriter) error
}

type DeleteFile204Response struct {
}

func (response DeleteFile204Response) VisitDeleteFileResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type DeleteFiledefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response DeleteFiledefaultJSONResponse) VisitDeleteFileResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetFileRequestObject struct {
	Id     string `json:"id"`
	Params GetFileParams
}

type GetFileResponseObject interface {
	VisitGetFileResponse(w http.ResponseWriter) error
}

type GetFile200ResponseHeaders struct {
	AcceptRanges       string
	CacheControl       string
	ContentDisposition string
	ContentType        string
	Etag               string
	LastModified       time.Time
	SurrogateControl   string
	SurrogateKey       string
}

type GetFile200ApplicationoctetStreamResponse struct {
	Body          io.Reader
	Headers       GetFile200ResponseHeaders
	ContentLength int64
}

func (response GetFile200ApplicationoctetStreamResponse) VisitGetFileResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/octet-stream")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.Header().Set("Accept-Ranges", fmt.Sprint(response.Headers.AcceptRanges))
	w.Header().Set("Cache-Control", fmt.Sprint(response.Headers.CacheControl))
	w.Header().Set("Content-Disposition", fmt.Sprint(response.Headers.ContentDisposition))
	w.Header().Set("Content-Type", fmt.Sprint(response.Headers.ContentType))
	w.Header().Set("Etag", fmt.Sprint(response.Headers.Etag))
	w.Header().Set("Last-Modified", fmt.Sprint(response.Headers.LastModified))
	w.Header().Set("Surrogate-Control", fmt.Sprint(response.Headers.SurrogateControl))
	w.Header().Set("Surrogate-Key", fmt.Sprint(response.Headers.SurrogateKey))
	w.WriteHeader(200)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type GetFile206ResponseHeaders struct {
	CacheControl       string
	ContentDisposition string
	ContentRange       string
	ContentType        string
	Etag               string
	LastModified       time.Time
	SurrogateControl   string
	SurrogateKey       string
}

type GetFile206ApplicationoctetStreamResponse struct {
	Body          io.Reader
	Headers       GetFile206ResponseHeaders
	ContentLength int64
}

func (response GetFile206ApplicationoctetStreamResponse) VisitGetFileResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/octet-stream")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.Header().Set("Cache-Control", fmt.Sprint(response.Headers.CacheControl))
	w.Header().Set("Content-Disposition", fmt.Sprint(response.Headers.ContentDisposition))
	w.Header().Set("Content-Range", fmt.Sprint(response.Headers.ContentRange))
	w.Header().Set("Content-Type", fmt.Sprint(response.Headers.ContentType))
	w.Header().Set("Etag", fmt.Sprint(response.Headers.Etag))
	w.Header().Set("Last-Modified", fmt.Sprint(response.Headers.LastModified))
	w.Header().Set("Surrogate-Control", fmt.Sprint(response.Headers.SurrogateControl))
	w.Header().Set("Surrogate-Key", fmt.Sprint(response.Headers.SurrogateKey))
	w.WriteHeader(206)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type GetFile304ResponseHeaders struct {
	CacheControl     string
	Etag             string
	SurrogateControl string
}

type GetFile304Response struct {
	Headers GetFile304ResponseHeaders
}

func (response GetFile304Response) VisitGetFileResponse(w http.ResponseWriter) error {
	w.Header().Set("Cache-Control", fmt.Sprint(response.Headers.CacheControl))
	w.Header().Set("Etag", fmt.Sprint(response.Headers.Etag))
	w.Header().Set("Surrogate-Control", fmt.Sprint(response.Headers.SurrogateControl))
	w.WriteHeader(304)
	return nil
}

type GetFile412ResponseHeaders struct {
	CacheControl     string
	Etag             string
	SurrogateControl string
}

type GetFile412Response struct {
	Headers GetFile412ResponseHeaders
}

func (response GetFile412Response) VisitGetFileResponse(w http.ResponseWriter) error {
	w.Header().Set("Cache-Control", fmt.Sprint(response.Headers.CacheControl))
	w.Header().Set("Etag", fmt.Sprint(response.Headers.Etag))
	w.Header().Set("Surrogate-Control", fmt.Sprint(response.Headers.SurrogateControl))
	w.WriteHeader(412)
	return nil
}

type GetFiledefaultResponseHeaders struct {
	XError string
}

type GetFiledefaultResponse struct {
	Headers GetFiledefaultResponseHeaders

	StatusCode int
}

func (response GetFiledefaultResponse) VisitGetFileResponse(w http.ResponseWriter) error {
	w.Header().Set("X-Error", fmt.Sprint(response.Headers.XError))
	w.WriteHeader(response.StatusCode)
	return nil
}

type GetFileMetadataHeadersRequestObject struct {
	Id     string `json:"id"`
	Params GetFileMetadataHeadersParams
}

type GetFileMetadataHeadersResponseObject interface {
	VisitGetFileMetadataHeadersResponse(w http.ResponseWriter) error
}

type GetFileMetadataHeaders200ResponseHeaders struct {
	AcceptRanges       string
	CacheControl       string
	ContentDisposition string
	ContentLength      int
	ContentType        string
	Etag               string
	LastModified       time.Time
	SurrogateControl   string
	SurrogateKey       string
}

type GetFileMetadataHeaders200Response struct {
	Headers GetFileMetadataHeaders200ResponseHeaders
}

func (response GetFileMetadataHeaders200Response) VisitGetFileMetadataHeadersResponse(w http.ResponseWriter) error {
	w.Header().Set("Accept-Ranges", fmt.Sprint(response.Headers.AcceptRanges))
	w.Header().Set("Cache-Control", fmt.Sprint(response.Headers.CacheControl))
	w.Header().Set("Content-Disposition", fmt.Sprint(response.Headers.ContentDisposition))
	w.Header().Set("Content-Length", fmt.Sprint(response.Headers.ContentLength))
	w.Header().Set("Content-Type", fmt.Sprint(response.Headers.ContentType))
	w.Header().Set("Etag", fmt.Sprint(response.Headers.Etag))
	w.Header().Set("Last-Modified", fmt.Sprint(response.Headers.LastModified))
	w.Header().Set("Surrogate-Control", fmt.Sprint(response.Headers.SurrogateControl))
	w.Header().Set("Surrogate-Key", fmt.Sprint(response.Headers.SurrogateKey))
	w.WriteHeader(200)
	return nil
}

type GetFileMetadataHeaders304ResponseHeaders struct {
	CacheControl     string
	Etag             string
	SurrogateControl string
}

type GetFileMetadataHeaders304Response struct {
	Headers GetFileMetadataHeaders304ResponseHeaders
}

func (response GetFileMetadataHeaders304Response) VisitGetFileMetadataHeadersResponse(w http.ResponseWriter) error {
	w.Header().Set("Cache-Control", fmt.Sprint(response.Headers.CacheControl))
	w.Header().Set("Etag", fmt.Sprint(response.Headers.Etag))
	w.Header().Set("Surrogate-Control", fmt.Sprint(response.Headers.SurrogateControl))
	w.WriteHeader(304)
	return nil
}

type GetFileMetadataHeaders412ResponseHeaders struct {
	CacheControl     string
	Etag             string
	SurrogateControl string
}

type GetFileMetadataHeaders412Response struct {
	Headers GetFileMetadataHeaders412ResponseHeaders
}

func (response GetFileMetadataHeaders412Response) VisitGetFileMetadataHeadersResponse(w http.ResponseWriter) error {
	w.Header().Set("Cache-Control", fmt.Sprint(response.Headers.CacheControl))
	w.Header().Set("Etag", fmt.Sprint(response.Headers.Etag))
	w.Header().Set("Surrogate-Control", fmt.Sprint(response.Headers.SurrogateControl))
	w.WriteHeader(412)
	return nil
}

type GetFileMetadataHeadersdefaultResponseHeaders struct {
	XError string
}

type GetFileMetadataHeadersdefaultResponse struct {
	Headers GetFileMetadataHeadersdefaultResponseHeaders

	StatusCode int
}

func (response GetFileMetadataHeadersdefaultResponse) VisitGetFileMetadataHeadersResponse(w http.ResponseWriter) error {
	w.Header().Set("X-Error", fmt.Sprint(response.Headers.XError))
	w.WriteHeader(response.StatusCode)
	return nil
}

type ReplaceFileRequestObject struct {
	Id   string `json:"id"`
	Body *multipart.Reader
}

type ReplaceFileResponseObject interface {
	VisitReplaceFileResponse(w http.ResponseWriter) error
}

type ReplaceFile200JSONResponse FileMetadata

func (response ReplaceFile200JSONResponse) VisitReplaceFileResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ReplaceFiledefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response ReplaceFiledefaultJSONResponse) VisitReplaceFileResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetFilePresignedURLRequestObject struct {
	Id string `json:"id"`
}

type GetFilePresignedURLResponseObject interface {
	VisitGetFilePresignedURLResponse(w http.ResponseWriter) error
}

type GetFilePresignedURL200JSONResponse PresignedURLResponse

func (response GetFilePresignedURL200JSONResponse) VisitGetFilePresignedURLResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetFilePresignedURLdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response GetFilePresignedURLdefaultJSONResponse) VisitGetFilePresignedURLResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetFileWithPresignedURLRequestObject struct {
	Id     string `json:"id"`
	Params GetFileWithPresignedURLParams
}

type GetFileWithPresignedURLResponseObject interface {
	VisitGetFileWithPresignedURLResponse(w http.ResponseWriter) error
}

type GetFileWithPresignedURL200ResponseHeaders struct {
	AcceptRanges       string
	CacheControl       string
	ContentDisposition string
	ContentType        string
	Etag               string
	LastModified       time.Time
	SurrogateControl   string
	SurrogateKey       string
}

type GetFileWithPresignedURL200ApplicationoctetStreamResponse struct {
	Body          io.Reader
	Headers       GetFileWithPresignedURL200ResponseHeaders
	ContentLength int64
}

func (response GetFileWithPresignedURL200ApplicationoctetStreamResponse) VisitGetFileWithPresignedURLResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/octet-stream")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.Header().Set("Accept-Ranges", fmt.Sprint(response.Headers.AcceptRanges))
	w.Header().Set("Cache-Control", fmt.Sprint(response.Headers.CacheControl))
	w.Header().Set("Content-Disposition", fmt.Sprint(response.Headers.ContentDisposition))
	w.Header().Set("Content-Type", fmt.Sprint(response.Headers.ContentType))
	w.Header().Set("Etag", fmt.Sprint(response.Headers.Etag))
	w.Header().Set("Last-Modified", fmt.Sprint(response.Headers.LastModified))
	w.Header().Set("Surrogate-Control", fmt.Sprint(response.Headers.SurrogateControl))
	w.Header().Set("Surrogate-Key", fmt.Sprint(response.Headers.SurrogateKey))
	w.WriteHeader(200)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type GetFileWithPresignedURL206ResponseHeaders struct {
	CacheControl       string
	ContentDisposition string
	ContentRange       string
	ContentType        string
	Etag               string
	LastModified       time.Time
	SurrogateControl   string
	SurrogateKey       string
}

type GetFileWithPresignedURL206ApplicationoctetStreamResponse struct {
	Body          io.Reader
	Headers       GetFileWithPresignedURL206ResponseHeaders
	ContentLength int64
}

func (response GetFileWithPresignedURL206ApplicationoctetStreamResponse) VisitGetFileWithPresignedURLResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/octet-stream")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.Header().Set("Cache-Control", fmt.Sprint(response.Headers.CacheControl))
	w.Header().Set("Content-Disposition", fmt.Sprint(response.Headers.ContentDisposition))
	w.Header().Set("Content-Range", fmt.Sprint(response.Headers.ContentRange))
	w.Header().Set("Content-Type", fmt.Sprint(response.Headers.ContentType))
	w.Header().Set("Etag", fmt.Sprint(response.Headers.Etag))
	w.Header().Set("Last-Modified", fmt.Sprint(response.Headers.LastModified))
	w.Header().Set("Surrogate-Control", fmt.Sprint(response.Headers.SurrogateControl))
	w.Header().Set("Surrogate-Key", fmt.Sprint(response.Headers.SurrogateKey))
	w.WriteHeader(206)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type GetFileWithPresignedURL304ResponseHeaders struct {
	CacheControl     string
	Etag             string
	SurrogateControl string
}

type GetFileWithPresignedURL304Response struct {
	Headers GetFileWithPresignedURL304ResponseHeaders
}

func (response GetFileWithPresignedURL304Response) VisitGetFileWithPresignedURLResponse(w http.ResponseWriter) error {
	w.Header().Set("Cache-Control", fmt.Sprint(response.Headers.CacheControl))
	w.Header().Set("Etag", fmt.Sprint(response.Headers.Etag))
	w.Header().Set("Surrogate-Control", fmt.Sprint(response.Headers.SurrogateControl))
	w.WriteHeader(304)
	return nil
}

type GetFileWithPresignedURL412ResponseHeaders struct {
	CacheControl     string
	Etag             string
	SurrogateControl string
}

type GetFileWithPresignedURL412Response struct {
	Headers GetFileWithPresignedURL412ResponseHeaders
}

func (response GetFileWithPresignedURL412Response) VisitGetFileWithPresignedURLResponse(w http.ResponseWriter) error {
	w.Header().Set("Cache-Control", fmt.Sprint(response.Headers.CacheControl))
	w.Header().Set("Etag", fmt.Sprint(response.Headers.Etag))
	w.Header().Set("Surrogate-Control", fmt.Sprint(response.Headers.SurrogateControl))
	w.WriteHeader(412)
	return nil
}

type GetFileWithPresignedURLdefaultResponseHeaders struct {
	XError string
}

type GetFileWithPresignedURLdefaultResponse struct {
	Headers GetFileWithPresignedURLdefaultResponseHeaders

	StatusCode int
}

func (response GetFileWithPresignedURLdefaultResponse) VisitGetFileWithPresignedURLResponse(w http.ResponseWriter) error {
	w.Header().Set("X-Error", fmt.Sprint(response.Headers.XError))
	w.WriteHeader(response.StatusCode)
	return nil
}

type GetOpenAPISpecRequestObject struct {
}

type GetOpenAPISpecResponseObject interface {
	VisitGetOpenAPISpecResponse(w http.ResponseWriter) error
}

type GetOpenAPISpec200ApplicationxYamlResponse struct {
	Body          io.Reader
	ContentLength int64
}

func (response GetOpenAPISpec200ApplicationxYamlResponse) VisitGetOpenAPISpecResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/x-yaml")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(200)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type GetOpenAPISpecdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response GetOpenAPISpecdefaultJSONResponse) VisitGetOpenAPISpecResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type DeleteBrokenMetadataRequestObject struct {
}

type DeleteBrokenMetadataResponseObject interface {
	VisitDeleteBrokenMetadataResponse(w http.ResponseWriter) error
}

type DeleteBrokenMetadata200JSONResponse struct {
	Metadata *[]FileSummary `json:"metadata,omitempty"`
}

func (response DeleteBrokenMetadata200JSONResponse) VisitDeleteBrokenMetadataResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type DeleteBrokenMetadatadefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response DeleteBrokenMetadatadefaultJSONResponse) VisitDeleteBrokenMetadataResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type DeleteOrphanedFilesRequestObject struct {
}

type DeleteOrphanedFilesResponseObject interface {
	VisitDeleteOrphanedFilesResponse(w http.ResponseWriter) error
}

type DeleteOrphanedFiles200JSONResponse struct {
	Files *[]string `json:"files,omitempty"`
}

func (response DeleteOrphanedFiles200JSONResponse) VisitDeleteOrphanedFilesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type DeleteOrphanedFilesdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response DeleteOrphanedFilesdefaultJSONResponse) VisitDeleteOrphanedFilesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type ListBrokenMetadataRequestObject struct {
}

type ListBrokenMetadataResponseObject interface {
	VisitListBrokenMetadataResponse(w http.ResponseWriter) error
}

type ListBrokenMetadata200JSONResponse struct {
	Metadata *[]FileSummary `json:"metadata,omitempty"`
}

func (response ListBrokenMetadata200JSONResponse) VisitListBrokenMetadataResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListBrokenMetadatadefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response ListBrokenMetadatadefaultJSONResponse) VisitListBrokenMetadataResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type ListFilesNotUploadedRequestObject struct {
}

type ListFilesNotUploadedResponseObject interface {
	VisitListFilesNotUploadedResponse(w http.ResponseWriter) error
}

type ListFilesNotUploaded200JSONResponse struct {
	Metadata *[]FileSummary `json:"metadata,omitempty"`
}

func (response ListFilesNotUploaded200JSONResponse) VisitListFilesNotUploadedResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListFilesNotUploadeddefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response ListFilesNotUploadeddefaultJSONResponse) VisitListFilesNotUploadedResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type ListOrphanedFilesRequestObject struct {
}

type ListOrphanedFilesResponseObject interface {
	VisitListOrphanedFilesResponse(w http.ResponseWriter) error
}

type ListOrphanedFiles200JSONResponse struct {
	Files *[]string `json:"files,omitempty"`
}

func (response ListOrphanedFiles200JSONResponse) VisitListOrphanedFilesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListOrphanedFilesdefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response ListOrphanedFilesdefaultJSONResponse) VisitListOrphanedFilesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetVersionRequestObject struct {
}

type GetVersionResponseObject interface {
	VisitGetVersionResponse(w http.ResponseWriter) error
}

type GetVersion200JSONResponse VersionInformation

func (response GetVersion200JSONResponse) VisitGetVersionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetVersiondefaultJSONResponse struct {
	Body       ErrorResponse
	StatusCode int
}

func (response GetVersiondefaultJSONResponse) VisitGetVersionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
	// Upload files
	// (POST /files)
	UploadFiles(ctx context.Context, request UploadFilesRequestObject) (UploadFilesResponseObject, error)
	// Delete file
	// (DELETE /files/{id})
	DeleteFile(ctx context.Context, request DeleteFileRequestObject) (DeleteFileResponseObject, error)
	// Download file
	// (GET /files/{id})
	GetFile(ctx context.Context, request GetFileRequestObject) (GetFileResponseObject, error)
	// Check file information
	// (HEAD /files/{id})
	GetFileMetadataHeaders(ctx context.Context, request GetFileMetadataHeadersRequestObject) (GetFileMetadataHeadersResponseObject, error)
	// Replace file
	// (PUT /files/{id})
	ReplaceFile(ctx context.Context, request ReplaceFileRequestObject) (ReplaceFileResponseObject, error)
	// Retrieve presigned URL to retrieve the file
	// (GET /files/{id}/presignedurl)
	GetFilePresignedURL(ctx context.Context, request GetFilePresignedURLRequestObject) (GetFilePresignedURLResponseObject, error)
	// Retrieve contents of file
	// (GET /files/{id}/presignedurl/contents)
	GetFileWithPresignedURL(ctx context.Context, request GetFileWithPresignedURLRequestObject) (GetFileWithPresignedURLResponseObject, error)
	// Get OpenAPI specification
	// (GET /openapi.yaml)
	GetOpenAPISpec(ctx context.Context, request GetOpenAPISpecRequestObject) (GetOpenAPISpecResponseObject, error)
	// Delete broken metadata
	// (POST /ops/delete-broken-metadata)
	DeleteBrokenMetadata(ctx context.Context, request DeleteBrokenMetadataRequestObject) (DeleteBrokenMetadataResponseObject, error)
	// Deletes orphaned files
	// (POST /ops/delete-orphans)
	DeleteOrphanedFiles(ctx context.Context, request DeleteOrphanedFilesRequestObject) (DeleteOrphanedFilesResponseObject, error)
	// Lists broken metadata
	// (POST /ops/list-broken-metadata)
	ListBrokenMetadata(ctx context.Context, request ListBrokenMetadataRequestObject) (ListBrokenMetadataResponseObject, error)
	// Lists files that haven't been uploaded
	// (POST /ops/list-not-uploaded)
	ListFilesNotUploaded(ctx context.Context, request ListFilesNotUploadedRequestObject) (ListFilesNotUploadedResponseObject, error)
	// Lists orphaned files
	// (POST /ops/list-orphans)
	ListOrphanedFiles(ctx context.Context, request ListOrphanedFilesRequestObject) (ListOrphanedFilesResponseObject, error)
	// Get service version information
	// (GET /version)
	GetVersion(ctx context.Context, request GetVersionRequestObject) (GetVersionResponseObject, error)
}

type StrictHandlerFunc = strictgin.StrictGinHandlerFunc
type StrictMiddlewareFunc = strictgin.StrictGinMiddlewareFunc

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares}
}

type strictHandler struct {
	ssi         StrictServerInterface
	middlewares []StrictMiddlewareFunc
}

// UploadFiles operation middleware
func (sh *strictHandler) UploadFiles(ctx *gin.Context) {
	var request UploadFilesRequestObject

	if reader, err := ctx.Request.MultipartReader(); err == nil {
		request.Body = reader
	} else {
		ctx.Error(err)
		return
	}

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.UploadFiles(ctx, request.(UploadFilesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "UploadFiles")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(UploadFilesResponseObject); ok {
		if err := validResponse.VisitUploadFilesResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeleteFile operation middleware
func (sh *strictHandler) DeleteFile(ctx *gin.Context, id string) {
	var request DeleteFileRequestObject

	request.Id = id

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteFile(ctx, request.(DeleteFileRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteFile")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(DeleteFileResponseObject); ok {
		if err := validResponse.VisitDeleteFileResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetFile operation middleware
func (sh *strictHandler) GetFile(ctx *gin.Context, id string, params GetFileParams) {
	var request GetFileRequestObject

	request.Id = id
	request.Params = params

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetFile(ctx, request.(GetFileRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetFile")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(GetFileResponseObject); ok {
		if err := validResponse.VisitGetFileResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetFileMetadataHeaders operation middleware
func (sh *strictHandler) GetFileMetadataHeaders(ctx *gin.Context, id string, params GetFileMetadataHeadersParams) {
	var request GetFileMetadataHeadersRequestObject

	request.Id = id
	request.Params = params

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetFileMetadataHeaders(ctx, request.(GetFileMetadataHeadersRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetFileMetadataHeaders")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(GetFileMetadataHeadersResponseObject); ok {
		if err := validResponse.VisitGetFileMetadataHeadersResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// ReplaceFile operation middleware
func (sh *strictHandler) ReplaceFile(ctx *gin.Context, id string) {
	var request ReplaceFileRequestObject

	request.Id = id

	if reader, err := ctx.Request.MultipartReader(); err == nil {
		request.Body = reader
	} else {
		ctx.Error(err)
		return
	}

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.ReplaceFile(ctx, request.(ReplaceFileRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ReplaceFile")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(ReplaceFileResponseObject); ok {
		if err := validResponse.VisitReplaceFileResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetFilePresignedURL operation middleware
func (sh *strictHandler) GetFilePresignedURL(ctx *gin.Context, id string) {
	var request GetFilePresignedURLRequestObject

	request.Id = id

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetFilePresignedURL(ctx, request.(GetFilePresignedURLRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetFilePresignedURL")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(GetFilePresignedURLResponseObject); ok {
		if err := validResponse.VisitGetFilePresignedURLResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetFileWithPresignedURL operation middleware
func (sh *strictHandler) GetFileWithPresignedURL(ctx *gin.Context, id string, params GetFileWithPresignedURLParams) {
	var request GetFileWithPresignedURLRequestObject

	request.Id = id
	request.Params = params

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetFileWithPresignedURL(ctx, request.(GetFileWithPresignedURLRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetFileWithPresignedURL")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(GetFileWithPresignedURLResponseObject); ok {
		if err := validResponse.VisitGetFileWithPresignedURLResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetOpenAPISpec operation middleware
func (sh *strictHandler) GetOpenAPISpec(ctx *gin.Context) {
	var request GetOpenAPISpecRequestObject

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetOpenAPISpec(ctx, request.(GetOpenAPISpecRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetOpenAPISpec")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(GetOpenAPISpecResponseObject); ok {
		if err := validResponse.VisitGetOpenAPISpecResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeleteBrokenMetadata operation middleware
func (sh *strictHandler) DeleteBrokenMetadata(ctx *gin.Context) {
	var request DeleteBrokenMetadataRequestObject

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteBrokenMetadata(ctx, request.(DeleteBrokenMetadataRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteBrokenMetadata")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(DeleteBrokenMetadataResponseObject); ok {
		if err := validResponse.VisitDeleteBrokenMetadataResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeleteOrphanedFiles operation middleware
func (sh *strictHandler) DeleteOrphanedFiles(ctx *gin.Context) {
	var request DeleteOrphanedFilesRequestObject

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteOrphanedFiles(ctx, request.(DeleteOrphanedFilesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteOrphanedFiles")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(DeleteOrphanedFilesResponseObject); ok {
		if err := validResponse.VisitDeleteOrphanedFilesResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// ListBrokenMetadata operation middleware
func (sh *strictHandler) ListBrokenMetadata(ctx *gin.Context) {
	var request ListBrokenMetadataRequestObject

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.ListBrokenMetadata(ctx, request.(ListBrokenMetadataRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListBrokenMetadata")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(ListBrokenMetadataResponseObject); ok {
		if err := validResponse.VisitListBrokenMetadataResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// ListFilesNotUploaded operation middleware
func (sh *strictHandler) ListFilesNotUploaded(ctx *gin.Context) {
	var request ListFilesNotUploadedRequestObject

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.ListFilesNotUploaded(ctx, request.(ListFilesNotUploadedRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListFilesNotUploaded")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(ListFilesNotUploadedResponseObject); ok {
		if err := validResponse.VisitListFilesNotUploadedResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// ListOrphanedFiles operation middleware
func (sh *strictHandler) ListOrphanedFiles(ctx *gin.Context) {
	var request ListOrphanedFilesRequestObject

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.ListOrphanedFiles(ctx, request.(ListOrphanedFilesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListOrphanedFiles")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(ListOrphanedFilesResponseObject); ok {
		if err := validResponse.VisitListOrphanedFilesResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetVersion operation middleware
func (sh *strictHandler) GetVersion(ctx *gin.Context) {
	var request GetVersionRequestObject

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetVersion(ctx, request.(GetVersionRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetVersion")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(GetVersionResponseObject); ok {
		if err := validResponse.VisitGetVersionResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
