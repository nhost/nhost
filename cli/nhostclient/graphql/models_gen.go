// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graphql

import (
	"bytes"
	"fmt"
	"io"
	"strconv"
	"time"
)

type BackupPresignedURL struct {
	ExpiresAt string `json:"expires_at"`
	URL       string `json:"url"`
}

// Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
type BooleanComparisonExp struct {
	Eq     *bool  `json:"_eq,omitempty"`
	Gt     *bool  `json:"_gt,omitempty"`
	Gte    *bool  `json:"_gte,omitempty"`
	In     []bool `json:"_in,omitempty"`
	IsNull *bool  `json:"_is_null,omitempty"`
	Lt     *bool  `json:"_lt,omitempty"`
	Lte    *bool  `json:"_lte,omitempty"`
	Neq    *bool  `json:"_neq,omitempty"`
	Nin    []bool `json:"_nin,omitempty"`
}

type ConfigAi struct {
	AutoEmbeddings *ConfigAIAutoEmbeddings `json:"autoEmbeddings,omitempty"`
	Openai         *ConfigAIOpenai         `json:"openai"`
	Resources      *ConfigAIResources      `json:"resources"`
	Version        *string                 `json:"version,omitempty"`
	WebhookSecret  string                  `json:"webhookSecret"`
}

type ConfigAIAutoEmbeddings struct {
	SynchPeriodMinutes *uint32 `json:"synchPeriodMinutes,omitempty"`
}

type ConfigAIAutoEmbeddingsUpdateInput struct {
	SynchPeriodMinutes *uint32 `json:"synchPeriodMinutes,omitempty"`
}

type ConfigAIOpenai struct {
	APIKey       string  `json:"apiKey"`
	Organization *string `json:"organization,omitempty"`
}

type ConfigAIOpenaiUpdateInput struct {
	APIKey       *string `json:"apiKey,omitempty"`
	Organization *string `json:"organization,omitempty"`
}

type ConfigAIResources struct {
	Compute *ConfigComputeResources `json:"compute"`
}

type ConfigAIResourcesUpdateInput struct {
	Compute *ConfigComputeResourcesUpdateInput `json:"compute,omitempty"`
}

type ConfigAIUpdateInput struct {
	AutoEmbeddings *ConfigAIAutoEmbeddingsUpdateInput `json:"autoEmbeddings,omitempty"`
	Openai         *ConfigAIOpenaiUpdateInput         `json:"openai,omitempty"`
	Resources      *ConfigAIResourcesUpdateInput      `json:"resources,omitempty"`
	Version        *string                            `json:"version,omitempty"`
	WebhookSecret  *string                            `json:"webhookSecret,omitempty"`
}

type ConfigAuth struct {
	ElevatedPrivileges *ConfigAuthElevatedPrivileges `json:"elevatedPrivileges,omitempty"`
	Method             *ConfigAuthMethod             `json:"method,omitempty"`
	Misc               *ConfigAuthMisc               `json:"misc,omitempty"`
	RateLimit          *ConfigAuthRateLimit          `json:"rateLimit,omitempty"`
	Redirections       *ConfigAuthRedirections       `json:"redirections,omitempty"`
	Resources          *ConfigResources              `json:"resources,omitempty"`
	Session            *ConfigAuthSession            `json:"session,omitempty"`
	SignUp             *ConfigAuthSignUp             `json:"signUp,omitempty"`
	Totp               *ConfigAuthTotp               `json:"totp,omitempty"`
	User               *ConfigAuthUser               `json:"user,omitempty"`
	Version            *string                       `json:"version,omitempty"`
}

type ConfigAuthElevatedPrivileges struct {
	Mode *string `json:"mode,omitempty"`
}

type ConfigAuthElevatedPrivilegesUpdateInput struct {
	Mode *string `json:"mode,omitempty"`
}

type ConfigAuthMethod struct {
	Anonymous         *ConfigAuthMethodAnonymous         `json:"anonymous,omitempty"`
	EmailPassword     *ConfigAuthMethodEmailPassword     `json:"emailPassword,omitempty"`
	EmailPasswordless *ConfigAuthMethodEmailPasswordless `json:"emailPasswordless,omitempty"`
	Oauth             *ConfigAuthMethodOauth             `json:"oauth,omitempty"`
	Otp               *ConfigAuthMethodOtp               `json:"otp,omitempty"`
	SmsPasswordless   *ConfigAuthMethodSmsPasswordless   `json:"smsPasswordless,omitempty"`
	Webauthn          *ConfigAuthMethodWebauthn          `json:"webauthn,omitempty"`
}

type ConfigAuthMethodAnonymous struct {
	Enabled *bool `json:"enabled,omitempty"`
}

type ConfigAuthMethodAnonymousUpdateInput struct {
	Enabled *bool `json:"enabled,omitempty"`
}

type ConfigAuthMethodEmailPassword struct {
	EmailVerificationRequired *bool   `json:"emailVerificationRequired,omitempty"`
	HibpEnabled               *bool   `json:"hibpEnabled,omitempty"`
	PasswordMinLength         *uint32 `json:"passwordMinLength,omitempty"`
}

type ConfigAuthMethodEmailPasswordUpdateInput struct {
	EmailVerificationRequired *bool   `json:"emailVerificationRequired,omitempty"`
	HibpEnabled               *bool   `json:"hibpEnabled,omitempty"`
	PasswordMinLength         *uint32 `json:"passwordMinLength,omitempty"`
}

type ConfigAuthMethodEmailPasswordless struct {
	Enabled *bool `json:"enabled,omitempty"`
}

type ConfigAuthMethodEmailPasswordlessUpdateInput struct {
	Enabled *bool `json:"enabled,omitempty"`
}

type ConfigAuthMethodOauth struct {
	Apple       *ConfigAuthMethodOauthApple           `json:"apple,omitempty"`
	Azuread     *ConfigAuthMethodOauthAzuread         `json:"azuread,omitempty"`
	Bitbucket   *ConfigStandardOauthProvider          `json:"bitbucket,omitempty"`
	Discord     *ConfigStandardOauthProviderWithScope `json:"discord,omitempty"`
	Entraid     *ConfigAuthMethodOauthEntraid         `json:"entraid,omitempty"`
	Facebook    *ConfigStandardOauthProviderWithScope `json:"facebook,omitempty"`
	Github      *ConfigStandardOauthProviderWithScope `json:"github,omitempty"`
	Gitlab      *ConfigStandardOauthProviderWithScope `json:"gitlab,omitempty"`
	Google      *ConfigStandardOauthProviderWithScope `json:"google,omitempty"`
	Linkedin    *ConfigStandardOauthProviderWithScope `json:"linkedin,omitempty"`
	Spotify     *ConfigStandardOauthProviderWithScope `json:"spotify,omitempty"`
	Strava      *ConfigStandardOauthProviderWithScope `json:"strava,omitempty"`
	Twitch      *ConfigStandardOauthProviderWithScope `json:"twitch,omitempty"`
	Twitter     *ConfigAuthMethodOauthTwitter         `json:"twitter,omitempty"`
	Windowslive *ConfigStandardOauthProviderWithScope `json:"windowslive,omitempty"`
	Workos      *ConfigAuthMethodOauthWorkos          `json:"workos,omitempty"`
}

type ConfigAuthMethodOauthApple struct {
	Audience   *string  `json:"audience,omitempty"`
	ClientID   *string  `json:"clientId,omitempty"`
	Enabled    *bool    `json:"enabled,omitempty"`
	KeyID      *string  `json:"keyId,omitempty"`
	PrivateKey *string  `json:"privateKey,omitempty"`
	Scope      []string `json:"scope,omitempty"`
	TeamID     *string  `json:"teamId,omitempty"`
}

type ConfigAuthMethodOauthAppleUpdateInput struct {
	Audience   *string  `json:"audience,omitempty"`
	ClientID   *string  `json:"clientId,omitempty"`
	Enabled    *bool    `json:"enabled,omitempty"`
	KeyID      *string  `json:"keyId,omitempty"`
	PrivateKey *string  `json:"privateKey,omitempty"`
	Scope      []string `json:"scope,omitempty"`
	TeamID     *string  `json:"teamId,omitempty"`
}

type ConfigAuthMethodOauthAzuread struct {
	ClientID     *string `json:"clientId,omitempty"`
	ClientSecret *string `json:"clientSecret,omitempty"`
	Enabled      *bool   `json:"enabled,omitempty"`
	Tenant       *string `json:"tenant,omitempty"`
}

type ConfigAuthMethodOauthAzureadUpdateInput struct {
	ClientID     *string `json:"clientId,omitempty"`
	ClientSecret *string `json:"clientSecret,omitempty"`
	Enabled      *bool   `json:"enabled,omitempty"`
	Tenant       *string `json:"tenant,omitempty"`
}

type ConfigAuthMethodOauthEntraid struct {
	ClientID     *string `json:"clientId,omitempty"`
	ClientSecret *string `json:"clientSecret,omitempty"`
	Enabled      *bool   `json:"enabled,omitempty"`
	Tenant       *string `json:"tenant,omitempty"`
}

type ConfigAuthMethodOauthEntraidUpdateInput struct {
	ClientID     *string `json:"clientId,omitempty"`
	ClientSecret *string `json:"clientSecret,omitempty"`
	Enabled      *bool   `json:"enabled,omitempty"`
	Tenant       *string `json:"tenant,omitempty"`
}

type ConfigAuthMethodOauthTwitter struct {
	ConsumerKey    *string `json:"consumerKey,omitempty"`
	ConsumerSecret *string `json:"consumerSecret,omitempty"`
	Enabled        *bool   `json:"enabled,omitempty"`
}

type ConfigAuthMethodOauthTwitterUpdateInput struct {
	ConsumerKey    *string `json:"consumerKey,omitempty"`
	ConsumerSecret *string `json:"consumerSecret,omitempty"`
	Enabled        *bool   `json:"enabled,omitempty"`
}

type ConfigAuthMethodOauthUpdateInput struct {
	Apple       *ConfigAuthMethodOauthAppleUpdateInput           `json:"apple,omitempty"`
	Azuread     *ConfigAuthMethodOauthAzureadUpdateInput         `json:"azuread,omitempty"`
	Bitbucket   *ConfigStandardOauthProviderUpdateInput          `json:"bitbucket,omitempty"`
	Discord     *ConfigStandardOauthProviderWithScopeUpdateInput `json:"discord,omitempty"`
	Entraid     *ConfigAuthMethodOauthEntraidUpdateInput         `json:"entraid,omitempty"`
	Facebook    *ConfigStandardOauthProviderWithScopeUpdateInput `json:"facebook,omitempty"`
	Github      *ConfigStandardOauthProviderWithScopeUpdateInput `json:"github,omitempty"`
	Gitlab      *ConfigStandardOauthProviderWithScopeUpdateInput `json:"gitlab,omitempty"`
	Google      *ConfigStandardOauthProviderWithScopeUpdateInput `json:"google,omitempty"`
	Linkedin    *ConfigStandardOauthProviderWithScopeUpdateInput `json:"linkedin,omitempty"`
	Spotify     *ConfigStandardOauthProviderWithScopeUpdateInput `json:"spotify,omitempty"`
	Strava      *ConfigStandardOauthProviderWithScopeUpdateInput `json:"strava,omitempty"`
	Twitch      *ConfigStandardOauthProviderWithScopeUpdateInput `json:"twitch,omitempty"`
	Twitter     *ConfigAuthMethodOauthTwitterUpdateInput         `json:"twitter,omitempty"`
	Windowslive *ConfigStandardOauthProviderWithScopeUpdateInput `json:"windowslive,omitempty"`
	Workos      *ConfigAuthMethodOauthWorkosUpdateInput          `json:"workos,omitempty"`
}

type ConfigAuthMethodOauthWorkos struct {
	ClientID     *string `json:"clientId,omitempty"`
	ClientSecret *string `json:"clientSecret,omitempty"`
	Connection   *string `json:"connection,omitempty"`
	Enabled      *bool   `json:"enabled,omitempty"`
	Organization *string `json:"organization,omitempty"`
}

type ConfigAuthMethodOauthWorkosUpdateInput struct {
	ClientID     *string `json:"clientId,omitempty"`
	ClientSecret *string `json:"clientSecret,omitempty"`
	Connection   *string `json:"connection,omitempty"`
	Enabled      *bool   `json:"enabled,omitempty"`
	Organization *string `json:"organization,omitempty"`
}

type ConfigAuthMethodOtp struct {
	Email *ConfigAuthMethodOtpEmail `json:"email,omitempty"`
}

type ConfigAuthMethodOtpEmail struct {
	Enabled *bool `json:"enabled,omitempty"`
}

type ConfigAuthMethodOtpEmailUpdateInput struct {
	Enabled *bool `json:"enabled,omitempty"`
}

type ConfigAuthMethodOtpUpdateInput struct {
	Email *ConfigAuthMethodOtpEmailUpdateInput `json:"email,omitempty"`
}

type ConfigAuthMethodSmsPasswordless struct {
	Enabled *bool `json:"enabled,omitempty"`
}

type ConfigAuthMethodSmsPasswordlessUpdateInput struct {
	Enabled *bool `json:"enabled,omitempty"`
}

type ConfigAuthMethodUpdateInput struct {
	Anonymous         *ConfigAuthMethodAnonymousUpdateInput         `json:"anonymous,omitempty"`
	EmailPassword     *ConfigAuthMethodEmailPasswordUpdateInput     `json:"emailPassword,omitempty"`
	EmailPasswordless *ConfigAuthMethodEmailPasswordlessUpdateInput `json:"emailPasswordless,omitempty"`
	Oauth             *ConfigAuthMethodOauthUpdateInput             `json:"oauth,omitempty"`
	Otp               *ConfigAuthMethodOtpUpdateInput               `json:"otp,omitempty"`
	SmsPasswordless   *ConfigAuthMethodSmsPasswordlessUpdateInput   `json:"smsPasswordless,omitempty"`
	Webauthn          *ConfigAuthMethodWebauthnUpdateInput          `json:"webauthn,omitempty"`
}

type ConfigAuthMethodWebauthn struct {
	Attestation  *ConfigAuthMethodWebauthnAttestation  `json:"attestation,omitempty"`
	Enabled      *bool                                 `json:"enabled,omitempty"`
	RelyingParty *ConfigAuthMethodWebauthnRelyingParty `json:"relyingParty,omitempty"`
}

type ConfigAuthMethodWebauthnAttestation struct {
	Timeout *uint32 `json:"timeout,omitempty"`
}

type ConfigAuthMethodWebauthnAttestationUpdateInput struct {
	Timeout *uint32 `json:"timeout,omitempty"`
}

type ConfigAuthMethodWebauthnRelyingParty struct {
	ID      *string  `json:"id,omitempty"`
	Name    *string  `json:"name,omitempty"`
	Origins []string `json:"origins,omitempty"`
}

type ConfigAuthMethodWebauthnRelyingPartyUpdateInput struct {
	ID      *string  `json:"id,omitempty"`
	Name    *string  `json:"name,omitempty"`
	Origins []string `json:"origins,omitempty"`
}

type ConfigAuthMethodWebauthnUpdateInput struct {
	Attestation  *ConfigAuthMethodWebauthnAttestationUpdateInput  `json:"attestation,omitempty"`
	Enabled      *bool                                            `json:"enabled,omitempty"`
	RelyingParty *ConfigAuthMethodWebauthnRelyingPartyUpdateInput `json:"relyingParty,omitempty"`
}

type ConfigAuthMisc struct {
	ConcealErrors *bool `json:"concealErrors,omitempty"`
}

type ConfigAuthMiscUpdateInput struct {
	ConcealErrors *bool `json:"concealErrors,omitempty"`
}

type ConfigAuthRateLimit struct {
	BruteForce *ConfigRateLimit `json:"bruteForce,omitempty"`
	Emails     *ConfigRateLimit `json:"emails,omitempty"`
	Global     *ConfigRateLimit `json:"global,omitempty"`
	Signups    *ConfigRateLimit `json:"signups,omitempty"`
	Sms        *ConfigRateLimit `json:"sms,omitempty"`
}

type ConfigAuthRateLimitUpdateInput struct {
	BruteForce *ConfigRateLimitUpdateInput `json:"bruteForce,omitempty"`
	Emails     *ConfigRateLimitUpdateInput `json:"emails,omitempty"`
	Global     *ConfigRateLimitUpdateInput `json:"global,omitempty"`
	Signups    *ConfigRateLimitUpdateInput `json:"signups,omitempty"`
	Sms        *ConfigRateLimitUpdateInput `json:"sms,omitempty"`
}

type ConfigAuthRedirections struct {
	AllowedUrls []string `json:"allowedUrls,omitempty"`
	ClientURL   *string  `json:"clientUrl,omitempty"`
}

type ConfigAuthRedirectionsUpdateInput struct {
	AllowedUrls []string `json:"allowedUrls,omitempty"`
	ClientURL   *string  `json:"clientUrl,omitempty"`
}

type ConfigAuthSession struct {
	AccessToken  *ConfigAuthSessionAccessToken  `json:"accessToken,omitempty"`
	RefreshToken *ConfigAuthSessionRefreshToken `json:"refreshToken,omitempty"`
}

type ConfigAuthSessionAccessToken struct {
	CustomClaims []*ConfigAuthsessionaccessTokenCustomClaims `json:"customClaims,omitempty"`
	ExpiresIn    *uint32                                     `json:"expiresIn,omitempty"`
}

type ConfigAuthSessionAccessTokenUpdateInput struct {
	CustomClaims []*ConfigAuthsessionaccessTokenCustomClaimsUpdateInput `json:"customClaims,omitempty"`
	ExpiresIn    *uint32                                                `json:"expiresIn,omitempty"`
}

type ConfigAuthSessionRefreshToken struct {
	ExpiresIn *uint32 `json:"expiresIn,omitempty"`
}

type ConfigAuthSessionRefreshTokenUpdateInput struct {
	ExpiresIn *uint32 `json:"expiresIn,omitempty"`
}

type ConfigAuthSessionUpdateInput struct {
	AccessToken  *ConfigAuthSessionAccessTokenUpdateInput  `json:"accessToken,omitempty"`
	RefreshToken *ConfigAuthSessionRefreshTokenUpdateInput `json:"refreshToken,omitempty"`
}

type ConfigAuthSignUp struct {
	DisableNewUsers *bool                      `json:"disableNewUsers,omitempty"`
	Enabled         *bool                      `json:"enabled,omitempty"`
	Turnstile       *ConfigAuthSignUpTurnstile `json:"turnstile,omitempty"`
}

type ConfigAuthSignUpTurnstile struct {
	SecretKey string `json:"secretKey"`
}

type ConfigAuthSignUpTurnstileUpdateInput struct {
	SecretKey *string `json:"secretKey,omitempty"`
}

type ConfigAuthSignUpUpdateInput struct {
	DisableNewUsers *bool                                 `json:"disableNewUsers,omitempty"`
	Enabled         *bool                                 `json:"enabled,omitempty"`
	Turnstile       *ConfigAuthSignUpTurnstileUpdateInput `json:"turnstile,omitempty"`
}

type ConfigAuthTotp struct {
	Enabled *bool   `json:"enabled,omitempty"`
	Issuer  *string `json:"issuer,omitempty"`
}

type ConfigAuthTotpUpdateInput struct {
	Enabled *bool   `json:"enabled,omitempty"`
	Issuer  *string `json:"issuer,omitempty"`
}

type ConfigAuthUpdateInput struct {
	ElevatedPrivileges *ConfigAuthElevatedPrivilegesUpdateInput `json:"elevatedPrivileges,omitempty"`
	Method             *ConfigAuthMethodUpdateInput             `json:"method,omitempty"`
	Misc               *ConfigAuthMiscUpdateInput               `json:"misc,omitempty"`
	RateLimit          *ConfigAuthRateLimitUpdateInput          `json:"rateLimit,omitempty"`
	Redirections       *ConfigAuthRedirectionsUpdateInput       `json:"redirections,omitempty"`
	Resources          *ConfigResourcesUpdateInput              `json:"resources,omitempty"`
	Session            *ConfigAuthSessionUpdateInput            `json:"session,omitempty"`
	SignUp             *ConfigAuthSignUpUpdateInput             `json:"signUp,omitempty"`
	Totp               *ConfigAuthTotpUpdateInput               `json:"totp,omitempty"`
	User               *ConfigAuthUserUpdateInput               `json:"user,omitempty"`
	Version            *string                                  `json:"version,omitempty"`
}

type ConfigAuthUser struct {
	Email        *ConfigAuthUserEmail        `json:"email,omitempty"`
	EmailDomains *ConfigAuthUserEmailDomains `json:"emailDomains,omitempty"`
	Gravatar     *ConfigAuthUserGravatar     `json:"gravatar,omitempty"`
	Locale       *ConfigAuthUserLocale       `json:"locale,omitempty"`
	Roles        *ConfigAuthUserRoles        `json:"roles,omitempty"`
}

type ConfigAuthUserEmail struct {
	Allowed []string `json:"allowed,omitempty"`
	Blocked []string `json:"blocked,omitempty"`
}

type ConfigAuthUserEmailDomains struct {
	Allowed []string `json:"allowed,omitempty"`
	Blocked []string `json:"blocked,omitempty"`
}

type ConfigAuthUserEmailDomainsUpdateInput struct {
	Allowed []string `json:"allowed,omitempty"`
	Blocked []string `json:"blocked,omitempty"`
}

type ConfigAuthUserEmailUpdateInput struct {
	Allowed []string `json:"allowed,omitempty"`
	Blocked []string `json:"blocked,omitempty"`
}

type ConfigAuthUserGravatar struct {
	Default *string `json:"default,omitempty"`
	Enabled *bool   `json:"enabled,omitempty"`
	Rating  *string `json:"rating,omitempty"`
}

type ConfigAuthUserGravatarUpdateInput struct {
	Default *string `json:"default,omitempty"`
	Enabled *bool   `json:"enabled,omitempty"`
	Rating  *string `json:"rating,omitempty"`
}

type ConfigAuthUserLocale struct {
	Allowed []string `json:"allowed,omitempty"`
	Default *string  `json:"default,omitempty"`
}

type ConfigAuthUserLocaleUpdateInput struct {
	Allowed []string `json:"allowed,omitempty"`
	Default *string  `json:"default,omitempty"`
}

type ConfigAuthUserRoles struct {
	Allowed []string `json:"allowed,omitempty"`
	Default *string  `json:"default,omitempty"`
}

type ConfigAuthUserRolesUpdateInput struct {
	Allowed []string `json:"allowed,omitempty"`
	Default *string  `json:"default,omitempty"`
}

type ConfigAuthUserUpdateInput struct {
	Email        *ConfigAuthUserEmailUpdateInput        `json:"email,omitempty"`
	EmailDomains *ConfigAuthUserEmailDomainsUpdateInput `json:"emailDomains,omitempty"`
	Gravatar     *ConfigAuthUserGravatarUpdateInput     `json:"gravatar,omitempty"`
	Locale       *ConfigAuthUserLocaleUpdateInput       `json:"locale,omitempty"`
	Roles        *ConfigAuthUserRolesUpdateInput        `json:"roles,omitempty"`
}

type ConfigAuthsessionaccessTokenCustomClaims struct {
	Default *string `json:"default,omitempty"`
	Key     string  `json:"key"`
	Value   string  `json:"value"`
}

type ConfigAuthsessionaccessTokenCustomClaimsUpdateInput struct {
	Default *string `json:"default,omitempty"`
	Key     *string `json:"key,omitempty"`
	Value   *string `json:"value,omitempty"`
}

type ConfigAutoscaler struct {
	MaxReplicas uint32 `json:"maxReplicas"`
}

type ConfigAutoscalerInsertInput struct {
	MaxReplicas uint32 `json:"maxReplicas"`
}

type ConfigAutoscalerUpdateInput struct {
	MaxReplicas *uint32 `json:"maxReplicas,omitempty"`
}

type ConfigClaimMap struct {
	Claim   string  `json:"claim"`
	Default *string `json:"default,omitempty"`
	Path    *string `json:"path,omitempty"`
	Value   *string `json:"value,omitempty"`
}

type ConfigClaimMapUpdateInput struct {
	Claim   *string `json:"claim,omitempty"`
	Default *string `json:"default,omitempty"`
	Path    *string `json:"path,omitempty"`
	Value   *string `json:"value,omitempty"`
}

type ConfigComputeResources struct {
	CPU    uint32 `json:"cpu"`
	Memory uint32 `json:"memory"`
}

type ConfigComputeResourcesInsertInput struct {
	CPU    uint32 `json:"cpu"`
	Memory uint32 `json:"memory"`
}

type ConfigComputeResourcesUpdateInput struct {
	CPU    *uint32 `json:"cpu,omitempty"`
	Memory *uint32 `json:"memory,omitempty"`
}

type ConfigConfig struct {
	Ai            *ConfigAi            `json:"ai,omitempty"`
	Auth          *ConfigAuth          `json:"auth,omitempty"`
	Functions     *ConfigFunctions     `json:"functions,omitempty"`
	Global        *ConfigGlobal        `json:"global,omitempty"`
	Graphql       *ConfigGraphql       `json:"graphql,omitempty"`
	Hasura        *ConfigHasura        `json:"hasura"`
	Observability *ConfigObservability `json:"observability"`
	Postgres      *ConfigPostgres      `json:"postgres"`
	Provider      *ConfigProvider      `json:"provider,omitempty"`
	Storage       *ConfigStorage       `json:"storage,omitempty"`
}

type ConfigConfigUpdateInput struct {
	Ai            *ConfigAIUpdateInput            `json:"ai,omitempty"`
	Auth          *ConfigAuthUpdateInput          `json:"auth,omitempty"`
	Functions     *ConfigFunctionsUpdateInput     `json:"functions,omitempty"`
	Global        *ConfigGlobalUpdateInput        `json:"global,omitempty"`
	Graphql       *ConfigGraphqlUpdateInput       `json:"graphql,omitempty"`
	Hasura        *ConfigHasuraUpdateInput        `json:"hasura,omitempty"`
	Observability *ConfigObservabilityUpdateInput `json:"observability,omitempty"`
	Postgres      *ConfigPostgresUpdateInput      `json:"postgres,omitempty"`
	Provider      *ConfigProviderUpdateInput      `json:"provider,omitempty"`
	Storage       *ConfigStorageUpdateInput       `json:"storage,omitempty"`
}

type ConfigEnvironmentVariable struct {
	Name  string `json:"name"`
	Value string `json:"value"`
}

type ConfigEnvironmentVariableInsertInput struct {
	Name  string `json:"name"`
	Value string `json:"value"`
}

type ConfigEnvironmentVariableUpdateInput struct {
	Name  *string `json:"name,omitempty"`
	Value *string `json:"value,omitempty"`
}

type ConfigFunctions struct {
	Node      *ConfigFunctionsNode      `json:"node,omitempty"`
	RateLimit *ConfigRateLimit          `json:"rateLimit,omitempty"`
	Resources *ConfigFunctionsResources `json:"resources,omitempty"`
}

type ConfigFunctionsNode struct {
	Version *int64 `json:"version,omitempty"`
}

type ConfigFunctionsNodeUpdateInput struct {
	Version *int64 `json:"version,omitempty"`
}

type ConfigFunctionsResources struct {
	Networking *ConfigNetworking `json:"networking,omitempty"`
}

type ConfigFunctionsResourcesUpdateInput struct {
	Networking *ConfigNetworkingUpdateInput `json:"networking,omitempty"`
}

type ConfigFunctionsUpdateInput struct {
	Node      *ConfigFunctionsNodeUpdateInput      `json:"node,omitempty"`
	RateLimit *ConfigRateLimitUpdateInput          `json:"rateLimit,omitempty"`
	Resources *ConfigFunctionsResourcesUpdateInput `json:"resources,omitempty"`
}

type ConfigGlobal struct {
	Environment []*ConfigGlobalEnvironmentVariable `json:"environment,omitempty"`
}

type ConfigGlobalEnvironmentVariable struct {
	Name  string `json:"name"`
	Value string `json:"value"`
}

type ConfigGlobalEnvironmentVariableUpdateInput struct {
	Name  *string `json:"name,omitempty"`
	Value *string `json:"value,omitempty"`
}

type ConfigGlobalUpdateInput struct {
	Environment []*ConfigGlobalEnvironmentVariableUpdateInput `json:"environment,omitempty"`
}

type ConfigGrafana struct {
	AdminPassword string                 `json:"adminPassword"`
	Alerting      *ConfigGrafanaAlerting `json:"alerting,omitempty"`
	Contacts      *ConfigGrafanaContacts `json:"contacts,omitempty"`
	SMTP          *ConfigGrafanaSMTP     `json:"smtp,omitempty"`
}

type ConfigGrafanaAlerting struct {
	Enabled *bool `json:"enabled,omitempty"`
}

type ConfigGrafanaAlertingUpdateInput struct {
	Enabled *bool `json:"enabled,omitempty"`
}

type ConfigGrafanaContacts struct {
	Discord   []*ConfigGrafanacontactsDiscord   `json:"discord,omitempty"`
	Emails    []string                          `json:"emails,omitempty"`
	Pagerduty []*ConfigGrafanacontactsPagerduty `json:"pagerduty,omitempty"`
	Slack     []*ConfigGrafanacontactsSlack     `json:"slack,omitempty"`
	Webhook   []*ConfigGrafanacontactsWebhook   `json:"webhook,omitempty"`
}

type ConfigGrafanaContactsUpdateInput struct {
	Discord   []*ConfigGrafanacontactsDiscordUpdateInput   `json:"discord,omitempty"`
	Emails    []string                                     `json:"emails,omitempty"`
	Pagerduty []*ConfigGrafanacontactsPagerdutyUpdateInput `json:"pagerduty,omitempty"`
	Slack     []*ConfigGrafanacontactsSlackUpdateInput     `json:"slack,omitempty"`
	Webhook   []*ConfigGrafanacontactsWebhookUpdateInput   `json:"webhook,omitempty"`
}

type ConfigGrafanaSMTP struct {
	Host     string `json:"host"`
	Password string `json:"password"`
	Port     uint32 `json:"port"`
	Sender   string `json:"sender"`
	User     string `json:"user"`
}

type ConfigGrafanaSMTPUpdateInput struct {
	Host     *string `json:"host,omitempty"`
	Password *string `json:"password,omitempty"`
	Port     *uint32 `json:"port,omitempty"`
	Sender   *string `json:"sender,omitempty"`
	User     *string `json:"user,omitempty"`
}

type ConfigGrafanaUpdateInput struct {
	AdminPassword *string                           `json:"adminPassword,omitempty"`
	Alerting      *ConfigGrafanaAlertingUpdateInput `json:"alerting,omitempty"`
	Contacts      *ConfigGrafanaContactsUpdateInput `json:"contacts,omitempty"`
	SMTP          *ConfigGrafanaSMTPUpdateInput     `json:"smtp,omitempty"`
}

type ConfigGrafanacontactsDiscord struct {
	AvatarURL string `json:"avatarUrl"`
	URL       string `json:"url"`
}

type ConfigGrafanacontactsDiscordUpdateInput struct {
	AvatarURL *string `json:"avatarUrl,omitempty"`
	URL       *string `json:"url,omitempty"`
}

type ConfigGrafanacontactsPagerduty struct {
	Class          string `json:"class"`
	Component      string `json:"component"`
	Group          string `json:"group"`
	IntegrationKey string `json:"integrationKey"`
	Severity       string `json:"severity"`
}

type ConfigGrafanacontactsPagerdutyUpdateInput struct {
	Class          *string `json:"class,omitempty"`
	Component      *string `json:"component,omitempty"`
	Group          *string `json:"group,omitempty"`
	IntegrationKey *string `json:"integrationKey,omitempty"`
	Severity       *string `json:"severity,omitempty"`
}

type ConfigGrafanacontactsSlack struct {
	EndpointURL    string   `json:"endpointURL"`
	IconEmoji      string   `json:"iconEmoji"`
	IconURL        string   `json:"iconURL"`
	MentionChannel string   `json:"mentionChannel"`
	MentionGroups  []string `json:"mentionGroups"`
	MentionUsers   []string `json:"mentionUsers"`
	Recipient      string   `json:"recipient"`
	Token          string   `json:"token"`
	URL            string   `json:"url"`
	Username       string   `json:"username"`
}

type ConfigGrafanacontactsSlackUpdateInput struct {
	EndpointURL    *string  `json:"endpointURL,omitempty"`
	IconEmoji      *string  `json:"iconEmoji,omitempty"`
	IconURL        *string  `json:"iconURL,omitempty"`
	MentionChannel *string  `json:"mentionChannel,omitempty"`
	MentionGroups  []string `json:"mentionGroups,omitempty"`
	MentionUsers   []string `json:"mentionUsers,omitempty"`
	Recipient      *string  `json:"recipient,omitempty"`
	Token          *string  `json:"token,omitempty"`
	URL            *string  `json:"url,omitempty"`
	Username       *string  `json:"username,omitempty"`
}

type ConfigGrafanacontactsWebhook struct {
	AuthorizationCredentials string `json:"authorizationCredentials"`
	AuthorizationScheme      string `json:"authorizationScheme"`
	HTTPMethod               string `json:"httpMethod"`
	MaxAlerts                int64  `json:"maxAlerts"`
	Password                 string `json:"password"`
	URL                      string `json:"url"`
	Username                 string `json:"username"`
}

type ConfigGrafanacontactsWebhookUpdateInput struct {
	AuthorizationCredentials *string `json:"authorizationCredentials,omitempty"`
	AuthorizationScheme      *string `json:"authorizationScheme,omitempty"`
	HTTPMethod               *string `json:"httpMethod,omitempty"`
	MaxAlerts                *int64  `json:"maxAlerts,omitempty"`
	Password                 *string `json:"password,omitempty"`
	URL                      *string `json:"url,omitempty"`
	Username                 *string `json:"username,omitempty"`
}

type ConfigGraphql struct {
	Security *ConfigGraphqlSecurity `json:"security,omitempty"`
}

type ConfigGraphqlSecurity struct {
	ForbidAminSecret *bool   `json:"forbidAminSecret,omitempty"`
	MaxDepthQueries  *string `json:"maxDepthQueries,omitempty"`
}

type ConfigGraphqlSecurityUpdateInput struct {
	ForbidAminSecret *bool   `json:"forbidAminSecret,omitempty"`
	MaxDepthQueries  *string `json:"maxDepthQueries,omitempty"`
}

type ConfigGraphqlUpdateInput struct {
	Security *ConfigGraphqlSecurityUpdateInput `json:"security,omitempty"`
}

type ConfigHasura struct {
	AdminSecret   string                `json:"adminSecret"`
	AuthHook      *ConfigHasuraAuthHook `json:"authHook,omitempty"`
	Events        *ConfigHasuraEvents   `json:"events,omitempty"`
	JwtSecrets    []*ConfigJWTSecret    `json:"jwtSecrets,omitempty"`
	Logs          *ConfigHasuraLogs     `json:"logs,omitempty"`
	RateLimit     *ConfigRateLimit      `json:"rateLimit,omitempty"`
	Resources     *ConfigResources      `json:"resources,omitempty"`
	Settings      *ConfigHasuraSettings `json:"settings,omitempty"`
	Version       *string               `json:"version,omitempty"`
	WebhookSecret string                `json:"webhookSecret"`
}

type ConfigHasuraAuthHook struct {
	Mode            *string `json:"mode,omitempty"`
	SendRequestBody *bool   `json:"sendRequestBody,omitempty"`
	URL             string  `json:"url"`
}

type ConfigHasuraAuthHookUpdateInput struct {
	Mode            *string `json:"mode,omitempty"`
	SendRequestBody *bool   `json:"sendRequestBody,omitempty"`
	URL             *string `json:"url,omitempty"`
}

type ConfigHasuraEvents struct {
	HTTPPoolSize *uint32 `json:"httpPoolSize,omitempty"`
}

type ConfigHasuraEventsUpdateInput struct {
	HTTPPoolSize *uint32 `json:"httpPoolSize,omitempty"`
}

type ConfigHasuraLogs struct {
	Level *string `json:"level,omitempty"`
}

type ConfigHasuraLogsUpdateInput struct {
	Level *string `json:"level,omitempty"`
}

type ConfigHasuraSettings struct {
	CorsDomain                            []string `json:"corsDomain,omitempty"`
	DevMode                               *bool    `json:"devMode,omitempty"`
	EnableAllowList                       *bool    `json:"enableAllowList,omitempty"`
	EnableConsole                         *bool    `json:"enableConsole,omitempty"`
	EnableRemoteSchemaPermissions         *bool    `json:"enableRemoteSchemaPermissions,omitempty"`
	EnabledAPIs                           []string `json:"enabledAPIs,omitempty"`
	InferFunctionPermissions              *bool    `json:"inferFunctionPermissions,omitempty"`
	LiveQueriesMultiplexedRefetchInterval *uint32  `json:"liveQueriesMultiplexedRefetchInterval,omitempty"`
	StringifyNumericTypes                 *bool    `json:"stringifyNumericTypes,omitempty"`
}

type ConfigHasuraSettingsUpdateInput struct {
	CorsDomain                            []string `json:"corsDomain,omitempty"`
	DevMode                               *bool    `json:"devMode,omitempty"`
	EnableAllowList                       *bool    `json:"enableAllowList,omitempty"`
	EnableConsole                         *bool    `json:"enableConsole,omitempty"`
	EnableRemoteSchemaPermissions         *bool    `json:"enableRemoteSchemaPermissions,omitempty"`
	EnabledAPIs                           []string `json:"enabledAPIs,omitempty"`
	InferFunctionPermissions              *bool    `json:"inferFunctionPermissions,omitempty"`
	LiveQueriesMultiplexedRefetchInterval *uint32  `json:"liveQueriesMultiplexedRefetchInterval,omitempty"`
	StringifyNumericTypes                 *bool    `json:"stringifyNumericTypes,omitempty"`
}

type ConfigHasuraUpdateInput struct {
	AdminSecret   *string                          `json:"adminSecret,omitempty"`
	AuthHook      *ConfigHasuraAuthHookUpdateInput `json:"authHook,omitempty"`
	Events        *ConfigHasuraEventsUpdateInput   `json:"events,omitempty"`
	JwtSecrets    []*ConfigJWTSecretUpdateInput    `json:"jwtSecrets,omitempty"`
	Logs          *ConfigHasuraLogsUpdateInput     `json:"logs,omitempty"`
	RateLimit     *ConfigRateLimitUpdateInput      `json:"rateLimit,omitempty"`
	Resources     *ConfigResourcesUpdateInput      `json:"resources,omitempty"`
	Settings      *ConfigHasuraSettingsUpdateInput `json:"settings,omitempty"`
	Version       *string                          `json:"version,omitempty"`
	WebhookSecret *string                          `json:"webhookSecret,omitempty"`
}

type ConfigHealthCheck struct {
	InitialDelaySeconds *int64 `json:"initialDelaySeconds,omitempty"`
	Port                uint32 `json:"port"`
	ProbePeriodSeconds  *int64 `json:"probePeriodSeconds,omitempty"`
}

type ConfigHealthCheckInsertInput struct {
	InitialDelaySeconds *int64 `json:"initialDelaySeconds,omitempty"`
	Port                uint32 `json:"port"`
	ProbePeriodSeconds  *int64 `json:"probePeriodSeconds,omitempty"`
}

type ConfigHealthCheckUpdateInput struct {
	InitialDelaySeconds *int64  `json:"initialDelaySeconds,omitempty"`
	Port                *uint32 `json:"port,omitempty"`
	ProbePeriodSeconds  *int64  `json:"probePeriodSeconds,omitempty"`
}

type ConfigIngress struct {
	Fqdn []string          `json:"fqdn,omitempty"`
	TLS  *ConfigIngressTLS `json:"tls,omitempty"`
}

type ConfigIngressInsertInput struct {
	Fqdn []string                     `json:"fqdn,omitempty"`
	TLS  *ConfigIngressTLSInsertInput `json:"tls,omitempty"`
}

type ConfigIngressTLS struct {
	ClientCa *string `json:"clientCA,omitempty"`
}

type ConfigIngressTLSInsertInput struct {
	ClientCa *string `json:"clientCA,omitempty"`
}

type ConfigIngressTLSUpdateInput struct {
	ClientCa *string `json:"clientCA,omitempty"`
}

type ConfigIngressUpdateInput struct {
	Fqdn []string                     `json:"fqdn,omitempty"`
	TLS  *ConfigIngressTLSUpdateInput `json:"tls,omitempty"`
}

type ConfigJWTSecret struct {
	AllowedSkew         *uint32           `json:"allowed_skew,omitempty"`
	Audience            *string           `json:"audience,omitempty"`
	ClaimsFormat        *string           `json:"claims_format,omitempty"`
	ClaimsMap           []*ConfigClaimMap `json:"claims_map,omitempty"`
	ClaimsNamespace     *string           `json:"claims_namespace,omitempty"`
	ClaimsNamespacePath *string           `json:"claims_namespace_path,omitempty"`
	Header              *string           `json:"header,omitempty"`
	Issuer              *string           `json:"issuer,omitempty"`
	JwkURL              *string           `json:"jwk_url,omitempty"`
	Key                 *string           `json:"key,omitempty"`
	Kid                 *string           `json:"kid,omitempty"`
	SigningKey          *string           `json:"signingKey,omitempty"`
	Type                *string           `json:"type,omitempty"`
}

type ConfigJWTSecretUpdateInput struct {
	AllowedSkew         *uint32                      `json:"allowed_skew,omitempty"`
	Audience            *string                      `json:"audience,omitempty"`
	ClaimsFormat        *string                      `json:"claims_format,omitempty"`
	ClaimsMap           []*ConfigClaimMapUpdateInput `json:"claims_map,omitempty"`
	ClaimsNamespace     *string                      `json:"claims_namespace,omitempty"`
	ClaimsNamespacePath *string                      `json:"claims_namespace_path,omitempty"`
	Header              *string                      `json:"header,omitempty"`
	Issuer              *string                      `json:"issuer,omitempty"`
	JwkURL              *string                      `json:"jwk_url,omitempty"`
	Key                 *string                      `json:"key,omitempty"`
	Kid                 *string                      `json:"kid,omitempty"`
	SigningKey          *string                      `json:"signingKey,omitempty"`
	Type                *string                      `json:"type,omitempty"`
}

type ConfigNetworking struct {
	Ingresses []*ConfigIngress `json:"ingresses,omitempty"`
}

type ConfigNetworkingUpdateInput struct {
	Ingresses []*ConfigIngressUpdateInput `json:"ingresses,omitempty"`
}

type ConfigObservability struct {
	Grafana *ConfigGrafana `json:"grafana"`
}

type ConfigObservabilityUpdateInput struct {
	Grafana *ConfigGrafanaUpdateInput `json:"grafana,omitempty"`
}

type ConfigPostgres struct {
	Pitr      *ConfigPostgresPitr      `json:"pitr,omitempty"`
	Resources *ConfigPostgresResources `json:"resources"`
	Settings  *ConfigPostgresSettings  `json:"settings,omitempty"`
	Version   *string                  `json:"version,omitempty"`
}

type ConfigPostgresPitr struct {
	Retention *uint32 `json:"retention,omitempty"`
}

type ConfigPostgresPitrUpdateInput struct {
	Retention *uint32 `json:"retention,omitempty"`
}

type ConfigPostgresResources struct {
	Compute            *ConfigResourcesCompute         `json:"compute,omitempty"`
	EnablePublicAccess *bool                           `json:"enablePublicAccess,omitempty"`
	Replicas           *int64                          `json:"replicas,omitempty"`
	Storage            *ConfigPostgresResourcesStorage `json:"storage"`
}

type ConfigPostgresResourcesStorage struct {
	Capacity uint32 `json:"capacity"`
}

type ConfigPostgresResourcesStorageUpdateInput struct {
	Capacity *uint32 `json:"capacity,omitempty"`
}

type ConfigPostgresResourcesUpdateInput struct {
	Compute            *ConfigResourcesComputeUpdateInput         `json:"compute,omitempty"`
	EnablePublicAccess *bool                                      `json:"enablePublicAccess,omitempty"`
	Replicas           *int64                                     `json:"replicas,omitempty"`
	Storage            *ConfigPostgresResourcesStorageUpdateInput `json:"storage,omitempty"`
}

type ConfigPostgresSettings struct {
	ArchiveTimeout                *string  `json:"archiveTimeout,omitempty"`
	CheckpointCompletionTarget    *float64 `json:"checkpointCompletionTarget,omitempty"`
	DefaultStatisticsTarget       *string  `json:"defaultStatisticsTarget,omitempty"`
	EffectiveCacheSize            *string  `json:"effectiveCacheSize,omitempty"`
	EffectiveIOConcurrency        *string  `json:"effectiveIOConcurrency,omitempty"`
	HugePages                     *string  `json:"hugePages,omitempty"`
	Jit                           *string  `json:"jit,omitempty"`
	MaintenanceWorkMem            *string  `json:"maintenanceWorkMem,omitempty"`
	MaxConnections                *string  `json:"maxConnections,omitempty"`
	MaxParallelMaintenanceWorkers *string  `json:"maxParallelMaintenanceWorkers,omitempty"`
	MaxParallelWorkers            *string  `json:"maxParallelWorkers,omitempty"`
	MaxParallelWorkersPerGather   *string  `json:"maxParallelWorkersPerGather,omitempty"`
	MaxReplicationSlots           *string  `json:"maxReplicationSlots,omitempty"`
	MaxWalSenders                 *string  `json:"maxWalSenders,omitempty"`
	MaxWalSize                    *string  `json:"maxWalSize,omitempty"`
	MaxWorkerProcesses            *string  `json:"maxWorkerProcesses,omitempty"`
	MinWalSize                    *string  `json:"minWalSize,omitempty"`
	RandomPageCost                *float64 `json:"randomPageCost,omitempty"`
	SharedBuffers                 *string  `json:"sharedBuffers,omitempty"`
	TrackIoTiming                 *string  `json:"trackIoTiming,omitempty"`
	WalBuffers                    *string  `json:"walBuffers,omitempty"`
	WalLevel                      *string  `json:"walLevel,omitempty"`
	WorkMem                       *string  `json:"workMem,omitempty"`
}

type ConfigPostgresSettingsUpdateInput struct {
	ArchiveTimeout                *string  `json:"archiveTimeout,omitempty"`
	CheckpointCompletionTarget    *float64 `json:"checkpointCompletionTarget,omitempty"`
	DefaultStatisticsTarget       *string  `json:"defaultStatisticsTarget,omitempty"`
	EffectiveCacheSize            *string  `json:"effectiveCacheSize,omitempty"`
	EffectiveIOConcurrency        *string  `json:"effectiveIOConcurrency,omitempty"`
	HugePages                     *string  `json:"hugePages,omitempty"`
	Jit                           *string  `json:"jit,omitempty"`
	MaintenanceWorkMem            *string  `json:"maintenanceWorkMem,omitempty"`
	MaxConnections                *string  `json:"maxConnections,omitempty"`
	MaxParallelMaintenanceWorkers *string  `json:"maxParallelMaintenanceWorkers,omitempty"`
	MaxParallelWorkers            *string  `json:"maxParallelWorkers,omitempty"`
	MaxParallelWorkersPerGather   *string  `json:"maxParallelWorkersPerGather,omitempty"`
	MaxReplicationSlots           *string  `json:"maxReplicationSlots,omitempty"`
	MaxWalSenders                 *string  `json:"maxWalSenders,omitempty"`
	MaxWalSize                    *string  `json:"maxWalSize,omitempty"`
	MaxWorkerProcesses            *string  `json:"maxWorkerProcesses,omitempty"`
	MinWalSize                    *string  `json:"minWalSize,omitempty"`
	RandomPageCost                *float64 `json:"randomPageCost,omitempty"`
	SharedBuffers                 *string  `json:"sharedBuffers,omitempty"`
	TrackIoTiming                 *string  `json:"trackIoTiming,omitempty"`
	WalBuffers                    *string  `json:"walBuffers,omitempty"`
	WalLevel                      *string  `json:"walLevel,omitempty"`
	WorkMem                       *string  `json:"workMem,omitempty"`
}

type ConfigPostgresUpdateInput struct {
	Pitr      *ConfigPostgresPitrUpdateInput      `json:"pitr,omitempty"`
	Resources *ConfigPostgresResourcesUpdateInput `json:"resources,omitempty"`
	Settings  *ConfigPostgresSettingsUpdateInput  `json:"settings,omitempty"`
	Version   *string                             `json:"version,omitempty"`
}

type ConfigProvider struct {
	Sms  *ConfigSms  `json:"sms,omitempty"`
	SMTP *ConfigSMTP `json:"smtp,omitempty"`
}

type ConfigProviderUpdateInput struct {
	Sms  *ConfigSmsUpdateInput  `json:"sms,omitempty"`
	SMTP *ConfigSMTPUpdateInput `json:"smtp,omitempty"`
}

type ConfigRateLimit struct {
	Interval string `json:"interval"`
	Limit    uint32 `json:"limit"`
}

type ConfigRateLimitInsertInput struct {
	Interval string `json:"interval"`
	Limit    uint32 `json:"limit"`
}

type ConfigRateLimitUpdateInput struct {
	Interval *string `json:"interval,omitempty"`
	Limit    *uint32 `json:"limit,omitempty"`
}

type ConfigResources struct {
	Autoscaler *ConfigAutoscaler       `json:"autoscaler,omitempty"`
	Compute    *ConfigResourcesCompute `json:"compute,omitempty"`
	Networking *ConfigNetworking       `json:"networking,omitempty"`
	Replicas   *uint32                 `json:"replicas,omitempty"`
}

type ConfigResourcesCompute struct {
	CPU    uint32 `json:"cpu"`
	Memory uint32 `json:"memory"`
}

type ConfigResourcesComputeUpdateInput struct {
	CPU    *uint32 `json:"cpu,omitempty"`
	Memory *uint32 `json:"memory,omitempty"`
}

type ConfigResourcesUpdateInput struct {
	Autoscaler *ConfigAutoscalerUpdateInput       `json:"autoscaler,omitempty"`
	Compute    *ConfigResourcesComputeUpdateInput `json:"compute,omitempty"`
	Networking *ConfigNetworkingUpdateInput       `json:"networking,omitempty"`
	Replicas   *uint32                            `json:"replicas,omitempty"`
}

type ConfigRunServiceConfig struct {
	Command     []string                     `json:"command,omitempty"`
	Environment []*ConfigEnvironmentVariable `json:"environment,omitempty"`
	HealthCheck *ConfigHealthCheck           `json:"healthCheck,omitempty"`
	Image       *ConfigRunServiceImage       `json:"image"`
	Name        string                       `json:"name"`
	Ports       []*ConfigRunServicePort      `json:"ports,omitempty"`
	Resources   *ConfigRunServiceResources   `json:"resources"`
}

type ConfigRunServiceConfigInsertInput struct {
	Command     []string                                `json:"command,omitempty"`
	Environment []*ConfigEnvironmentVariableInsertInput `json:"environment,omitempty"`
	HealthCheck *ConfigHealthCheckInsertInput           `json:"healthCheck,omitempty"`
	Image       *ConfigRunServiceImageInsertInput       `json:"image"`
	Name        string                                  `json:"name"`
	Ports       []*ConfigRunServicePortInsertInput      `json:"ports,omitempty"`
	Resources   *ConfigRunServiceResourcesInsertInput   `json:"resources"`
}

type ConfigRunServiceConfigUpdateInput struct {
	Command     []string                                `json:"command,omitempty"`
	Environment []*ConfigEnvironmentVariableUpdateInput `json:"environment,omitempty"`
	HealthCheck *ConfigHealthCheckUpdateInput           `json:"healthCheck,omitempty"`
	Image       *ConfigRunServiceImageUpdateInput       `json:"image,omitempty"`
	Name        *string                                 `json:"name,omitempty"`
	Ports       []*ConfigRunServicePortUpdateInput      `json:"ports,omitempty"`
	Resources   *ConfigRunServiceResourcesUpdateInput   `json:"resources,omitempty"`
}

type ConfigRunServiceConfigWithID struct {
	Config    *ConfigRunServiceConfig `json:"config"`
	ServiceID string                  `json:"serviceID"`
}

type ConfigRunServiceImage struct {
	Image           string  `json:"image"`
	PullCredentials *string `json:"pullCredentials,omitempty"`
}

type ConfigRunServiceImageInsertInput struct {
	Image           string  `json:"image"`
	PullCredentials *string `json:"pullCredentials,omitempty"`
}

type ConfigRunServiceImageUpdateInput struct {
	Image           *string `json:"image,omitempty"`
	PullCredentials *string `json:"pullCredentials,omitempty"`
}

type ConfigRunServicePort struct {
	Ingresses []*ConfigIngress `json:"ingresses,omitempty"`
	Port      uint32           `json:"port"`
	Publish   *bool            `json:"publish,omitempty"`
	RateLimit *ConfigRateLimit `json:"rateLimit,omitempty"`
	Type      string           `json:"type"`
}

type ConfigRunServicePortInsertInput struct {
	Ingresses []*ConfigIngressInsertInput `json:"ingresses,omitempty"`
	Port      uint32                      `json:"port"`
	Publish   *bool                       `json:"publish,omitempty"`
	RateLimit *ConfigRateLimitInsertInput `json:"rateLimit,omitempty"`
	Type      string                      `json:"type"`
}

type ConfigRunServicePortUpdateInput struct {
	Ingresses []*ConfigIngressUpdateInput `json:"ingresses,omitempty"`
	Port      *uint32                     `json:"port,omitempty"`
	Publish   *bool                       `json:"publish,omitempty"`
	RateLimit *ConfigRateLimitUpdateInput `json:"rateLimit,omitempty"`
	Type      *string                     `json:"type,omitempty"`
}

type ConfigRunServiceResources struct {
	Autoscaler *ConfigAutoscaler                   `json:"autoscaler,omitempty"`
	Compute    *ConfigComputeResources             `json:"compute"`
	Replicas   uint32                              `json:"replicas"`
	Storage    []*ConfigRunServiceResourcesStorage `json:"storage,omitempty"`
}

type ConfigRunServiceResourcesInsertInput struct {
	Autoscaler *ConfigAutoscalerInsertInput                   `json:"autoscaler,omitempty"`
	Compute    *ConfigComputeResourcesInsertInput             `json:"compute"`
	Replicas   uint32                                         `json:"replicas"`
	Storage    []*ConfigRunServiceResourcesStorageInsertInput `json:"storage,omitempty"`
}

type ConfigRunServiceResourcesStorage struct {
	Capacity uint32 `json:"capacity"`
	Name     string `json:"name"`
	Path     string `json:"path"`
}

type ConfigRunServiceResourcesStorageInsertInput struct {
	Capacity uint32 `json:"capacity"`
	Name     string `json:"name"`
	Path     string `json:"path"`
}

type ConfigRunServiceResourcesStorageUpdateInput struct {
	Capacity *uint32 `json:"capacity,omitempty"`
	Name     *string `json:"name,omitempty"`
	Path     *string `json:"path,omitempty"`
}

type ConfigRunServiceResourcesUpdateInput struct {
	Autoscaler *ConfigAutoscalerUpdateInput                   `json:"autoscaler,omitempty"`
	Compute    *ConfigComputeResourcesUpdateInput             `json:"compute,omitempty"`
	Replicas   *uint32                                        `json:"replicas,omitempty"`
	Storage    []*ConfigRunServiceResourcesStorageUpdateInput `json:"storage,omitempty"`
}

type ConfigSms struct {
	AccountSid         string  `json:"accountSid"`
	AuthToken          string  `json:"authToken"`
	MessagingServiceID string  `json:"messagingServiceId"`
	Provider           *string `json:"provider,omitempty"`
}

type ConfigSmsUpdateInput struct {
	AccountSid         *string `json:"accountSid,omitempty"`
	AuthToken          *string `json:"authToken,omitempty"`
	MessagingServiceID *string `json:"messagingServiceId,omitempty"`
	Provider           *string `json:"provider,omitempty"`
}

type ConfigSMTP struct {
	Host     string `json:"host"`
	Method   string `json:"method"`
	Password string `json:"password"`
	Port     uint32 `json:"port"`
	Secure   bool   `json:"secure"`
	Sender   string `json:"sender"`
	User     string `json:"user"`
}

type ConfigSMTPUpdateInput struct {
	Host     *string `json:"host,omitempty"`
	Method   *string `json:"method,omitempty"`
	Password *string `json:"password,omitempty"`
	Port     *uint32 `json:"port,omitempty"`
	Secure   *bool   `json:"secure,omitempty"`
	Sender   *string `json:"sender,omitempty"`
	User     *string `json:"user,omitempty"`
}

type ConfigStandardOauthProvider struct {
	ClientID     *string `json:"clientId,omitempty"`
	ClientSecret *string `json:"clientSecret,omitempty"`
	Enabled      *bool   `json:"enabled,omitempty"`
}

type ConfigStandardOauthProviderUpdateInput struct {
	ClientID     *string `json:"clientId,omitempty"`
	ClientSecret *string `json:"clientSecret,omitempty"`
	Enabled      *bool   `json:"enabled,omitempty"`
}

type ConfigStandardOauthProviderWithScope struct {
	Audience     *string  `json:"audience,omitempty"`
	ClientID     *string  `json:"clientId,omitempty"`
	ClientSecret *string  `json:"clientSecret,omitempty"`
	Enabled      *bool    `json:"enabled,omitempty"`
	Scope        []string `json:"scope,omitempty"`
}

type ConfigStandardOauthProviderWithScopeUpdateInput struct {
	Audience     *string  `json:"audience,omitempty"`
	ClientID     *string  `json:"clientId,omitempty"`
	ClientSecret *string  `json:"clientSecret,omitempty"`
	Enabled      *bool    `json:"enabled,omitempty"`
	Scope        []string `json:"scope,omitempty"`
}

type ConfigStorage struct {
	Antivirus *ConfigStorageAntivirus `json:"antivirus,omitempty"`
	RateLimit *ConfigRateLimit        `json:"rateLimit,omitempty"`
	Resources *ConfigResources        `json:"resources,omitempty"`
	Version   *string                 `json:"version,omitempty"`
}

type ConfigStorageAntivirus struct {
	Server *string `json:"server,omitempty"`
}

type ConfigStorageAntivirusUpdateInput struct {
	Server *string `json:"server,omitempty"`
}

type ConfigStorageUpdateInput struct {
	Antivirus *ConfigStorageAntivirusUpdateInput `json:"antivirus,omitempty"`
	RateLimit *ConfigRateLimitUpdateInput        `json:"rateLimit,omitempty"`
	Resources *ConfigResourcesUpdateInput        `json:"resources,omitempty"`
	Version   *string                            `json:"version,omitempty"`
}

type ConfigSystemConfig struct {
	Auth                       *ConfigSystemConfigAuth     `json:"auth,omitempty"`
	Graphql                    *ConfigSystemConfigGraphql  `json:"graphql,omitempty"`
	PersistentVolumesEncrypted *bool                       `json:"persistentVolumesEncrypted,omitempty"`
	Postgres                   *ConfigSystemConfigPostgres `json:"postgres"`
}

type ConfigSystemConfigAuth struct {
	Email *ConfigSystemConfigAuthEmail `json:"email,omitempty"`
}

type ConfigSystemConfigAuthEmail struct {
	Templates *ConfigSystemConfigAuthEmailTemplates `json:"templates,omitempty"`
}

type ConfigSystemConfigAuthEmailTemplates struct {
	S3Key *string `json:"s3Key,omitempty"`
}

type ConfigSystemConfigGraphql struct {
	FeatureAdvancedGraphql *bool `json:"featureAdvancedGraphql,omitempty"`
}

type ConfigSystemConfigPostgres struct {
	ConnectionString *ConfigSystemConfigPostgresConnectionString `json:"connectionString"`
	Database         string                                      `json:"database"`
	Disk             *ConfigSystemConfigPostgresDisk             `json:"disk,omitempty"`
	Enabled          *bool                                       `json:"enabled,omitempty"`
	MajorVersion     *string                                     `json:"majorVersion,omitempty"`
}

type ConfigSystemConfigPostgresConnectionString struct {
	Auth    string `json:"auth"`
	Backup  string `json:"backup"`
	Hasura  string `json:"hasura"`
	Storage string `json:"storage"`
}

type ConfigSystemConfigPostgresDisk struct {
	Iops *uint32 `json:"iops,omitempty"`
	Tput *uint32 `json:"tput,omitempty"`
}

type ContainerError struct {
	LastError *LastError `json:"lastError"`
	Name      string     `json:"name"`
}

type InsertRunServiceConfigResponse struct {
	Config    *ConfigRunServiceConfig `json:"config"`
	ServiceID string                  `json:"serviceID"`
}

// Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
type IntComparisonExp struct {
	Eq     *int64  `json:"_eq,omitempty"`
	Gt     *int64  `json:"_gt,omitempty"`
	Gte    *int64  `json:"_gte,omitempty"`
	In     []int64 `json:"_in,omitempty"`
	IsNull *bool   `json:"_is_null,omitempty"`
	Lt     *int64  `json:"_lt,omitempty"`
	Lte    *int64  `json:"_lte,omitempty"`
	Neq    *int64  `json:"_neq,omitempty"`
	Nin    []int64 `json:"_nin,omitempty"`
}

type InvoiceItem struct {
	Amount      string `json:"Amount"`
	Description string `json:"Description"`
}

type InvoiceSummary struct {
	AmountDue string         `json:"AmountDue"`
	PeriodEnd string         `json:"PeriodEnd"`
	Items     []*InvoiceItem `json:"items"`
}

type LastError struct {
	ExitCode int64  `json:"exitCode"`
	Message  string `json:"message"`
	Reason   string `json:"reason"`
}

type Log struct {
	Log       string `json:"log"`
	Service   string `json:"service"`
	Timestamp string `json:"timestamp"`
}

type Metrics struct {
	Value string `json:"value"`
}

type PiTRBaseBackup struct {
	LSNHigh  int64  `json:"LSNHigh"`
	LSNLow   int64  `json:"LSNLow"`
	Date     string `json:"date"`
	Name     string `json:"name"`
	Timeline int64  `json:"timeline"`
}

type PostOrganizationRequestResponse struct {
	ClientSecret *string        `json:"ClientSecret,omitempty"`
	Slug         string         `json:"Slug"`
	Status       CheckoutStatus `json:"Status"`
}

type ProjectStatusResponse struct {
	Services []*ServiceStatus `json:"services"`
}

type ReplicaStatus struct {
	Date   string            `json:"date"`
	Errors []*ContainerError `json:"errors"`
	Ready  bool              `json:"ready"`
}

type ServiceStatus struct {
	Name     string           `json:"name"`
	Replicas []*ReplicaStatus `json:"replicas"`
	State    ServiceState     `json:"state"`
}

// Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
type StringComparisonExp struct {
	Eq  *string `json:"_eq,omitempty"`
	Gt  *string `json:"_gt,omitempty"`
	Gte *string `json:"_gte,omitempty"`
	// does the column match the given case-insensitive pattern
	Ilike *string  `json:"_ilike,omitempty"`
	In    []string `json:"_in,omitempty"`
	// does the column match the given POSIX regular expression, case insensitive
	Iregex *string `json:"_iregex,omitempty"`
	IsNull *bool   `json:"_is_null,omitempty"`
	// does the column match the given pattern
	Like *string `json:"_like,omitempty"`
	Lt   *string `json:"_lt,omitempty"`
	Lte  *string `json:"_lte,omitempty"`
	Neq  *string `json:"_neq,omitempty"`
	// does the column NOT match the given case-insensitive pattern
	Nilike *string  `json:"_nilike,omitempty"`
	Nin    []string `json:"_nin,omitempty"`
	// does the column NOT match the given POSIX regular expression, case insensitive
	Niregex *string `json:"_niregex,omitempty"`
	// does the column NOT match the given pattern
	Nlike *string `json:"_nlike,omitempty"`
	// does the column NOT match the given POSIX regular expression, case sensitive
	Nregex *string `json:"_nregex,omitempty"`
	// does the column NOT match the given SQL regular expression
	Nsimilar *string `json:"_nsimilar,omitempty"`
	// does the column match the given POSIX regular expression, case sensitive
	Regex *string `json:"_regex,omitempty"`
	// does the column match the given SQL regular expression
	Similar *string `json:"_similar,omitempty"`
}

type UsageSummary struct {
	Egress               string `json:"Egress"`
	FunctionsInvocations string `json:"FunctionsInvocations"`
	ID                   string `json:"ID"`
	LambdaUsageSeconds   string `json:"LambdaUsageSeconds"`
	PostgresVolumeUsage  string `json:"PostgresVolumeUsage"`
	TotalRequests        string `json:"TotalRequests"`
}

// columns and relationships of "announcements"
type Announcements struct {
	Content   string     `json:"content"`
	CreatedAt time.Time  `json:"createdAt"`
	ExpiresAt *time.Time `json:"expiresAt,omitempty"`
	Href      string     `json:"href"`
	ID        string     `json:"id"`
	// An array relationship
	Read      []*AnnouncementsRead `json:"read"`
	UpdatedAt time.Time            `json:"updatedAt"`
}

// Boolean expression to filter rows from the table "announcements". All fields are combined with a logical 'AND'.
type AnnouncementsBoolExp struct {
	And       []*AnnouncementsBoolExp   `json:"_and,omitempty"`
	Not       *AnnouncementsBoolExp     `json:"_not,omitempty"`
	Or        []*AnnouncementsBoolExp   `json:"_or,omitempty"`
	Content   *StringComparisonExp      `json:"content,omitempty"`
	CreatedAt *TimestamptzComparisonExp `json:"createdAt,omitempty"`
	ExpiresAt *TimestamptzComparisonExp `json:"expiresAt,omitempty"`
	Href      *StringComparisonExp      `json:"href,omitempty"`
	ID        *UUIDComparisonExp        `json:"id,omitempty"`
	Read      *AnnouncementsReadBoolExp `json:"read,omitempty"`
	UpdatedAt *TimestamptzComparisonExp `json:"updatedAt,omitempty"`
}

// Ordering options when selecting data from "announcements".
type AnnouncementsOrderBy struct {
	Content       *OrderBy                           `json:"content,omitempty"`
	CreatedAt     *OrderBy                           `json:"createdAt,omitempty"`
	ExpiresAt     *OrderBy                           `json:"expiresAt,omitempty"`
	Href          *OrderBy                           `json:"href,omitempty"`
	ID            *OrderBy                           `json:"id,omitempty"`
	ReadAggregate *AnnouncementsReadAggregateOrderBy `json:"read_aggregate,omitempty"`
	UpdatedAt     *OrderBy                           `json:"updatedAt,omitempty"`
}

// columns and relationships of "announcements_read"
type AnnouncementsRead struct {
	AnnouncementID string    `json:"announcementID"`
	CreatedAt      time.Time `json:"createdAt"`
	ID             string    `json:"id"`
	UserID         string    `json:"userID"`
}

// order by aggregate values of table "announcements_read"
type AnnouncementsReadAggregateOrderBy struct {
	Count *OrderBy                     `json:"count,omitempty"`
	Max   *AnnouncementsReadMaxOrderBy `json:"max,omitempty"`
	Min   *AnnouncementsReadMinOrderBy `json:"min,omitempty"`
}

// Boolean expression to filter rows from the table "announcements_read". All fields are combined with a logical 'AND'.
type AnnouncementsReadBoolExp struct {
	And            []*AnnouncementsReadBoolExp `json:"_and,omitempty"`
	Not            *AnnouncementsReadBoolExp   `json:"_not,omitempty"`
	Or             []*AnnouncementsReadBoolExp `json:"_or,omitempty"`
	AnnouncementID *UUIDComparisonExp          `json:"announcementID,omitempty"`
	CreatedAt      *TimestamptzComparisonExp   `json:"createdAt,omitempty"`
	ID             *UUIDComparisonExp          `json:"id,omitempty"`
	UserID         *UUIDComparisonExp          `json:"userID,omitempty"`
}

// input type for inserting data into table "announcements_read"
type AnnouncementsReadInsertInput struct {
	AnnouncementID *string `json:"announcementID,omitempty"`
}

// order by max() on columns of table "announcements_read"
type AnnouncementsReadMaxOrderBy struct {
	AnnouncementID *OrderBy `json:"announcementID,omitempty"`
	CreatedAt      *OrderBy `json:"createdAt,omitempty"`
	ID             *OrderBy `json:"id,omitempty"`
	UserID         *OrderBy `json:"userID,omitempty"`
}

// order by min() on columns of table "announcements_read"
type AnnouncementsReadMinOrderBy struct {
	AnnouncementID *OrderBy `json:"announcementID,omitempty"`
	CreatedAt      *OrderBy `json:"createdAt,omitempty"`
	ID             *OrderBy `json:"id,omitempty"`
	UserID         *OrderBy `json:"userID,omitempty"`
}

// response of any mutation on the table "announcements_read"
type AnnouncementsReadMutationResponse struct {
	// number of rows affected by the mutation
	AffectedRows int64 `json:"affected_rows"`
	// data from the rows affected by the mutation
	Returning []*AnnouncementsRead `json:"returning"`
}

// on_conflict condition type for table "announcements_read"
type AnnouncementsReadOnConflict struct {
	Constraint    AnnouncementsReadConstraint     `json:"constraint"`
	UpdateColumns []AnnouncementsReadUpdateColumn `json:"update_columns"`
	Where         *AnnouncementsReadBoolExp       `json:"where,omitempty"`
}

// Ordering options when selecting data from "announcements_read".
type AnnouncementsReadOrderBy struct {
	AnnouncementID *OrderBy `json:"announcementID,omitempty"`
	CreatedAt      *OrderBy `json:"createdAt,omitempty"`
	ID             *OrderBy `json:"id,omitempty"`
	UserID         *OrderBy `json:"userID,omitempty"`
}

// Streaming cursor of the table "announcements_read"
type AnnouncementsReadStreamCursorInput struct {
	// Stream column input with initial value
	InitialValue *AnnouncementsReadStreamCursorValueInput `json:"initial_value"`
	// cursor ordering
	Ordering *CursorOrdering `json:"ordering,omitempty"`
}

// Initial value of the column from where the streaming should start
type AnnouncementsReadStreamCursorValueInput struct {
	AnnouncementID *string    `json:"announcementID,omitempty"`
	CreatedAt      *time.Time `json:"createdAt,omitempty"`
	ID             *string    `json:"id,omitempty"`
	UserID         *string    `json:"userID,omitempty"`
}

// Streaming cursor of the table "announcements"
type AnnouncementsStreamCursorInput struct {
	// Stream column input with initial value
	InitialValue *AnnouncementsStreamCursorValueInput `json:"initial_value"`
	// cursor ordering
	Ordering *CursorOrdering `json:"ordering,omitempty"`
}

// Initial value of the column from where the streaming should start
type AnnouncementsStreamCursorValueInput struct {
	Content   *string    `json:"content,omitempty"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	ExpiresAt *time.Time `json:"expiresAt,omitempty"`
	Href      *string    `json:"href,omitempty"`
	ID        *string    `json:"id,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
}

// columns and relationships of "app_state_history"
type AppStateHistory struct {
	// An object relationship
	App       *Apps     `json:"app"`
	AppID     string    `json:"appId"`
	CreatedAt time.Time `json:"createdAt"`
	ID        string    `json:"id"`
	Message   *string   `json:"message,omitempty"`
	StateID   int64     `json:"stateId"`
}

// order by aggregate values of table "app_state_history"
type AppStateHistoryAggregateOrderBy struct {
	Avg        *AppStateHistoryAvgOrderBy        `json:"avg,omitempty"`
	Count      *OrderBy                          `json:"count,omitempty"`
	Max        *AppStateHistoryMaxOrderBy        `json:"max,omitempty"`
	Min        *AppStateHistoryMinOrderBy        `json:"min,omitempty"`
	Stddev     *AppStateHistoryStddevOrderBy     `json:"stddev,omitempty"`
	StddevPop  *AppStateHistoryStddevPopOrderBy  `json:"stddev_pop,omitempty"`
	StddevSamp *AppStateHistoryStddevSampOrderBy `json:"stddev_samp,omitempty"`
	Sum        *AppStateHistorySumOrderBy        `json:"sum,omitempty"`
	VarPop     *AppStateHistoryVarPopOrderBy     `json:"var_pop,omitempty"`
	VarSamp    *AppStateHistoryVarSampOrderBy    `json:"var_samp,omitempty"`
	Variance   *AppStateHistoryVarianceOrderBy   `json:"variance,omitempty"`
}

// order by avg() on columns of table "app_state_history"
type AppStateHistoryAvgOrderBy struct {
	StateID *OrderBy `json:"stateId,omitempty"`
}

// Boolean expression to filter rows from the table "app_state_history". All fields are combined with a logical 'AND'.
type AppStateHistoryBoolExp struct {
	And       []*AppStateHistoryBoolExp `json:"_and,omitempty"`
	Not       *AppStateHistoryBoolExp   `json:"_not,omitempty"`
	Or        []*AppStateHistoryBoolExp `json:"_or,omitempty"`
	App       *AppsBoolExp              `json:"app,omitempty"`
	AppID     *UUIDComparisonExp        `json:"appId,omitempty"`
	CreatedAt *TimestamptzComparisonExp `json:"createdAt,omitempty"`
	ID        *UUIDComparisonExp        `json:"id,omitempty"`
	Message   *StringComparisonExp      `json:"message,omitempty"`
	StateID   *IntComparisonExp         `json:"stateId,omitempty"`
}

// order by max() on columns of table "app_state_history"
type AppStateHistoryMaxOrderBy struct {
	AppID     *OrderBy `json:"appId,omitempty"`
	CreatedAt *OrderBy `json:"createdAt,omitempty"`
	ID        *OrderBy `json:"id,omitempty"`
	Message   *OrderBy `json:"message,omitempty"`
	StateID   *OrderBy `json:"stateId,omitempty"`
}

// order by min() on columns of table "app_state_history"
type AppStateHistoryMinOrderBy struct {
	AppID     *OrderBy `json:"appId,omitempty"`
	CreatedAt *OrderBy `json:"createdAt,omitempty"`
	ID        *OrderBy `json:"id,omitempty"`
	Message   *OrderBy `json:"message,omitempty"`
	StateID   *OrderBy `json:"stateId,omitempty"`
}

// Ordering options when selecting data from "app_state_history".
type AppStateHistoryOrderBy struct {
	App       *AppsOrderBy `json:"app,omitempty"`
	AppID     *OrderBy     `json:"appId,omitempty"`
	CreatedAt *OrderBy     `json:"createdAt,omitempty"`
	ID        *OrderBy     `json:"id,omitempty"`
	Message   *OrderBy     `json:"message,omitempty"`
	StateID   *OrderBy     `json:"stateId,omitempty"`
}

// order by stddev() on columns of table "app_state_history"
type AppStateHistoryStddevOrderBy struct {
	StateID *OrderBy `json:"stateId,omitempty"`
}

// order by stddev_pop() on columns of table "app_state_history"
type AppStateHistoryStddevPopOrderBy struct {
	StateID *OrderBy `json:"stateId,omitempty"`
}

// order by stddev_samp() on columns of table "app_state_history"
type AppStateHistoryStddevSampOrderBy struct {
	StateID *OrderBy `json:"stateId,omitempty"`
}

// Streaming cursor of the table "appStateHistory"
type AppStateHistoryStreamCursorInput struct {
	// Stream column input with initial value
	InitialValue *AppStateHistoryStreamCursorValueInput `json:"initial_value"`
	// cursor ordering
	Ordering *CursorOrdering `json:"ordering,omitempty"`
}

// Initial value of the column from where the streaming should start
type AppStateHistoryStreamCursorValueInput struct {
	AppID     *string    `json:"appId,omitempty"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	ID        *string    `json:"id,omitempty"`
	Message   *string    `json:"message,omitempty"`
	StateID   *int64     `json:"stateId,omitempty"`
}

// order by sum() on columns of table "app_state_history"
type AppStateHistorySumOrderBy struct {
	StateID *OrderBy `json:"stateId,omitempty"`
}

// order by var_pop() on columns of table "app_state_history"
type AppStateHistoryVarPopOrderBy struct {
	StateID *OrderBy `json:"stateId,omitempty"`
}

// order by var_samp() on columns of table "app_state_history"
type AppStateHistoryVarSampOrderBy struct {
	StateID *OrderBy `json:"stateId,omitempty"`
}

// order by variance() on columns of table "app_state_history"
type AppStateHistoryVarianceOrderBy struct {
	StateID *OrderBy `json:"stateId,omitempty"`
}

// columns and relationships of "apps"
type Apps struct {
	AppSecrets []*ConfigEnvironmentVariable `json:"appSecrets"`
	// An array relationship
	AppStates        []*AppStateHistory `json:"appStates"`
	AutomaticDeploys bool               `json:"automaticDeploys"`
	// An array relationship
	Backups   []*Backups    `json:"backups"`
	Config    *ConfigConfig `json:"config,omitempty"`
	CreatedAt time.Time     `json:"createdAt"`
	// An object relationship
	Creator       *Users  `json:"creator,omitempty"`
	CreatorUserID *string `json:"creatorUserId,omitempty"`
	// An array relationship
	Deployments  []*Deployments `json:"deployments"`
	DesiredState int64          `json:"desiredState"`
	// An array relationship
	FeatureFlags []*FeatureFlags `json:"featureFlags"`
	// An object relationship
	GithubRepository   *GithubRepositories `json:"githubRepository,omitempty"`
	GithubRepositoryID *string             `json:"githubRepositoryId,omitempty"`
	ID                 string              `json:"id"`
	IsLocked           *bool               `json:"isLocked,omitempty"`
	IsLockedReason     *string             `json:"isLockedReason,omitempty"`
	// An object relationship
	LegacyPlan        *Plans         `json:"legacyPlan,omitempty"`
	MetadataFunctions map[string]any `json:"metadataFunctions"`
	Name              string         `json:"name"`
	NhostBaseFolder   string         `json:"nhostBaseFolder"`
	// An object relationship
	Organization   *Organizations `json:"organization,omitempty"`
	OrganizationID *string        `json:"organizationID,omitempty"`
	// An object relationship
	Region                     *Regions `json:"region"`
	RepositoryProductionBranch string   `json:"repositoryProductionBranch"`
	// An array relationship
	RunServices []*RunService `json:"runServices"`
	// An aggregate relationship
	RunServicesAggregate *RunServiceAggregate `json:"runServices_aggregate"`
	Slug                 string               `json:"slug"`
	Subdomain            string               `json:"subdomain"`
	SystemConfig         *ConfigSystemConfig  `json:"systemConfig,omitempty"`
	UpdatedAt            time.Time            `json:"updatedAt"`
	// An object relationship
	Workspace   *Workspaces `json:"workspace,omitempty"`
	WorkspaceID *string     `json:"workspaceId,omitempty"`
}

// order by aggregate values of table "apps"
type AppsAggregateOrderBy struct {
	Avg        *AppsAvgOrderBy        `json:"avg,omitempty"`
	Count      *OrderBy               `json:"count,omitempty"`
	Max        *AppsMaxOrderBy        `json:"max,omitempty"`
	Min        *AppsMinOrderBy        `json:"min,omitempty"`
	Stddev     *AppsStddevOrderBy     `json:"stddev,omitempty"`
	StddevPop  *AppsStddevPopOrderBy  `json:"stddev_pop,omitempty"`
	StddevSamp *AppsStddevSampOrderBy `json:"stddev_samp,omitempty"`
	Sum        *AppsSumOrderBy        `json:"sum,omitempty"`
	VarPop     *AppsVarPopOrderBy     `json:"var_pop,omitempty"`
	VarSamp    *AppsVarSampOrderBy    `json:"var_samp,omitempty"`
	Variance   *AppsVarianceOrderBy   `json:"variance,omitempty"`
}

// input type for inserting array relation for remote table "apps"
type AppsArrRelInsertInput struct {
	Data []*AppsInsertInput `json:"data"`
	// upsert condition
	OnConflict *AppsOnConflict `json:"on_conflict,omitempty"`
}

// order by avg() on columns of table "apps"
type AppsAvgOrderBy struct {
	DesiredState *OrderBy `json:"desiredState,omitempty"`
}

// Boolean expression to filter rows from the table "apps". All fields are combined with a logical 'AND'.
type AppsBoolExp struct {
	And                        []*AppsBoolExp              `json:"_and,omitempty"`
	Not                        *AppsBoolExp                `json:"_not,omitempty"`
	Or                         []*AppsBoolExp              `json:"_or,omitempty"`
	AppStates                  *AppStateHistoryBoolExp     `json:"appStates,omitempty"`
	AutomaticDeploys           *BooleanComparisonExp       `json:"automaticDeploys,omitempty"`
	Backups                    *BackupsBoolExp             `json:"backups,omitempty"`
	CreatedAt                  *TimestamptzComparisonExp   `json:"createdAt,omitempty"`
	Creator                    *UsersBoolExp               `json:"creator,omitempty"`
	CreatorUserID              *UUIDComparisonExp          `json:"creatorUserId,omitempty"`
	Deployments                *DeploymentsBoolExp         `json:"deployments,omitempty"`
	DesiredState               *IntComparisonExp           `json:"desiredState,omitempty"`
	FeatureFlags               *FeatureFlagsBoolExp        `json:"featureFlags,omitempty"`
	GithubRepository           *GithubRepositoriesBoolExp  `json:"githubRepository,omitempty"`
	GithubRepositoryID         *UUIDComparisonExp          `json:"githubRepositoryId,omitempty"`
	ID                         *UUIDComparisonExp          `json:"id,omitempty"`
	IsLocked                   *BooleanComparisonExp       `json:"isLocked,omitempty"`
	IsLockedReason             *StringComparisonExp        `json:"isLockedReason,omitempty"`
	LegacyPlan                 *PlansBoolExp               `json:"legacyPlan,omitempty"`
	MetadataFunctions          *JsonbComparisonExp         `json:"metadataFunctions,omitempty"`
	Name                       *StringComparisonExp        `json:"name,omitempty"`
	NhostBaseFolder            *StringComparisonExp        `json:"nhostBaseFolder,omitempty"`
	Organization               *OrganizationsBoolExp       `json:"organization,omitempty"`
	OrganizationID             *UUIDComparisonExp          `json:"organizationID,omitempty"`
	Region                     *RegionsBoolExp             `json:"region,omitempty"`
	RepositoryProductionBranch *StringComparisonExp        `json:"repositoryProductionBranch,omitempty"`
	RunServices                *RunServiceBoolExp          `json:"runServices,omitempty"`
	RunServicesAggregate       *RunServiceAggregateBoolExp `json:"runServices_aggregate,omitempty"`
	Slug                       *StringComparisonExp        `json:"slug,omitempty"`
	Subdomain                  *StringComparisonExp        `json:"subdomain,omitempty"`
	UpdatedAt                  *TimestamptzComparisonExp   `json:"updatedAt,omitempty"`
	Workspace                  *WorkspacesBoolExp          `json:"workspace,omitempty"`
	WorkspaceID                *UUIDComparisonExp          `json:"workspaceId,omitempty"`
}

// input type for incrementing numeric columns in table "apps"
type AppsIncInput struct {
	DesiredState *int64 `json:"desiredState,omitempty"`
}

// input type for inserting data into table "apps"
type AppsInsertInput struct {
	Deployments    *DeploymentsArrRelInsertInput  `json:"deployments,omitempty"`
	FeatureFlags   *FeatureFlagsArrRelInsertInput `json:"featureFlags,omitempty"`
	Name           *string                        `json:"name,omitempty"`
	OrganizationID *string                        `json:"organizationID,omitempty"`
	RegionID       *string                        `json:"regionId,omitempty"`
	Slug           *string                        `json:"slug,omitempty"`
	Workspace      *WorkspacesObjRelInsertInput   `json:"workspace,omitempty"`
}

// order by max() on columns of table "apps"
type AppsMaxOrderBy struct {
	CreatedAt                  *OrderBy `json:"createdAt,omitempty"`
	CreatorUserID              *OrderBy `json:"creatorUserId,omitempty"`
	DesiredState               *OrderBy `json:"desiredState,omitempty"`
	GithubRepositoryID         *OrderBy `json:"githubRepositoryId,omitempty"`
	ID                         *OrderBy `json:"id,omitempty"`
	IsLockedReason             *OrderBy `json:"isLockedReason,omitempty"`
	Name                       *OrderBy `json:"name,omitempty"`
	NhostBaseFolder            *OrderBy `json:"nhostBaseFolder,omitempty"`
	OrganizationID             *OrderBy `json:"organizationID,omitempty"`
	RepositoryProductionBranch *OrderBy `json:"repositoryProductionBranch,omitempty"`
	Slug                       *OrderBy `json:"slug,omitempty"`
	Subdomain                  *OrderBy `json:"subdomain,omitempty"`
	UpdatedAt                  *OrderBy `json:"updatedAt,omitempty"`
	WorkspaceID                *OrderBy `json:"workspaceId,omitempty"`
}

// order by min() on columns of table "apps"
type AppsMinOrderBy struct {
	CreatedAt                  *OrderBy `json:"createdAt,omitempty"`
	CreatorUserID              *OrderBy `json:"creatorUserId,omitempty"`
	DesiredState               *OrderBy `json:"desiredState,omitempty"`
	GithubRepositoryID         *OrderBy `json:"githubRepositoryId,omitempty"`
	ID                         *OrderBy `json:"id,omitempty"`
	IsLockedReason             *OrderBy `json:"isLockedReason,omitempty"`
	Name                       *OrderBy `json:"name,omitempty"`
	NhostBaseFolder            *OrderBy `json:"nhostBaseFolder,omitempty"`
	OrganizationID             *OrderBy `json:"organizationID,omitempty"`
	RepositoryProductionBranch *OrderBy `json:"repositoryProductionBranch,omitempty"`
	Slug                       *OrderBy `json:"slug,omitempty"`
	Subdomain                  *OrderBy `json:"subdomain,omitempty"`
	UpdatedAt                  *OrderBy `json:"updatedAt,omitempty"`
	WorkspaceID                *OrderBy `json:"workspaceId,omitempty"`
}

// response of any mutation on the table "apps"
type AppsMutationResponse struct {
	// number of rows affected by the mutation
	AffectedRows int64 `json:"affected_rows"`
	// data from the rows affected by the mutation
	Returning []*Apps `json:"returning"`
}

// input type for inserting object relation for remote table "apps"
type AppsObjRelInsertInput struct {
	Data *AppsInsertInput `json:"data"`
	// upsert condition
	OnConflict *AppsOnConflict `json:"on_conflict,omitempty"`
}

// on_conflict condition type for table "apps"
type AppsOnConflict struct {
	Constraint    AppsConstraint     `json:"constraint"`
	UpdateColumns []AppsUpdateColumn `json:"update_columns"`
	Where         *AppsBoolExp       `json:"where,omitempty"`
}

// Ordering options when selecting data from "apps".
type AppsOrderBy struct {
	AppStatesAggregate         *AppStateHistoryAggregateOrderBy `json:"appStates_aggregate,omitempty"`
	AutomaticDeploys           *OrderBy                         `json:"automaticDeploys,omitempty"`
	BackupsAggregate           *BackupsAggregateOrderBy         `json:"backups_aggregate,omitempty"`
	CreatedAt                  *OrderBy                         `json:"createdAt,omitempty"`
	Creator                    *UsersOrderBy                    `json:"creator,omitempty"`
	CreatorUserID              *OrderBy                         `json:"creatorUserId,omitempty"`
	DeploymentsAggregate       *DeploymentsAggregateOrderBy     `json:"deployments_aggregate,omitempty"`
	DesiredState               *OrderBy                         `json:"desiredState,omitempty"`
	FeatureFlagsAggregate      *FeatureFlagsAggregateOrderBy    `json:"featureFlags_aggregate,omitempty"`
	GithubRepository           *GithubRepositoriesOrderBy       `json:"githubRepository,omitempty"`
	GithubRepositoryID         *OrderBy                         `json:"githubRepositoryId,omitempty"`
	ID                         *OrderBy                         `json:"id,omitempty"`
	IsLocked                   *OrderBy                         `json:"isLocked,omitempty"`
	IsLockedReason             *OrderBy                         `json:"isLockedReason,omitempty"`
	LegacyPlan                 *PlansOrderBy                    `json:"legacyPlan,omitempty"`
	MetadataFunctions          *OrderBy                         `json:"metadataFunctions,omitempty"`
	Name                       *OrderBy                         `json:"name,omitempty"`
	NhostBaseFolder            *OrderBy                         `json:"nhostBaseFolder,omitempty"`
	Organization               *OrganizationsOrderBy            `json:"organization,omitempty"`
	OrganizationID             *OrderBy                         `json:"organizationID,omitempty"`
	Region                     *RegionsOrderBy                  `json:"region,omitempty"`
	RepositoryProductionBranch *OrderBy                         `json:"repositoryProductionBranch,omitempty"`
	RunServicesAggregate       *RunServiceAggregateOrderBy      `json:"runServices_aggregate,omitempty"`
	Slug                       *OrderBy                         `json:"slug,omitempty"`
	Subdomain                  *OrderBy                         `json:"subdomain,omitempty"`
	UpdatedAt                  *OrderBy                         `json:"updatedAt,omitempty"`
	Workspace                  *WorkspacesOrderBy               `json:"workspace,omitempty"`
	WorkspaceID                *OrderBy                         `json:"workspaceId,omitempty"`
}

// primary key columns input for table: apps
type AppsPkColumnsInput struct {
	ID string `json:"id"`
}

// input type for updating data in table "apps"
type AppsSetInput struct {
	AutomaticDeploys           *bool   `json:"automaticDeploys,omitempty"`
	DesiredState               *int64  `json:"desiredState,omitempty"`
	GithubRepositoryID         *string `json:"githubRepositoryId,omitempty"`
	Name                       *string `json:"name,omitempty"`
	NhostBaseFolder            *string `json:"nhostBaseFolder,omitempty"`
	RepositoryProductionBranch *string `json:"repositoryProductionBranch,omitempty"`
	Slug                       *string `json:"slug,omitempty"`
}

// order by stddev() on columns of table "apps"
type AppsStddevOrderBy struct {
	DesiredState *OrderBy `json:"desiredState,omitempty"`
}

// order by stddev_pop() on columns of table "apps"
type AppsStddevPopOrderBy struct {
	DesiredState *OrderBy `json:"desiredState,omitempty"`
}

// order by stddev_samp() on columns of table "apps"
type AppsStddevSampOrderBy struct {
	DesiredState *OrderBy `json:"desiredState,omitempty"`
}

// Streaming cursor of the table "apps"
type AppsStreamCursorInput struct {
	// Stream column input with initial value
	InitialValue *AppsStreamCursorValueInput `json:"initial_value"`
	// cursor ordering
	Ordering *CursorOrdering `json:"ordering,omitempty"`
}

// Initial value of the column from where the streaming should start
type AppsStreamCursorValueInput struct {
	AutomaticDeploys           *bool          `json:"automaticDeploys,omitempty"`
	CreatedAt                  *time.Time     `json:"createdAt,omitempty"`
	CreatorUserID              *string        `json:"creatorUserId,omitempty"`
	DesiredState               *int64         `json:"desiredState,omitempty"`
	GithubRepositoryID         *string        `json:"githubRepositoryId,omitempty"`
	ID                         *string        `json:"id,omitempty"`
	IsLocked                   *bool          `json:"isLocked,omitempty"`
	IsLockedReason             *string        `json:"isLockedReason,omitempty"`
	MetadataFunctions          map[string]any `json:"metadataFunctions,omitempty"`
	Name                       *string        `json:"name,omitempty"`
	NhostBaseFolder            *string        `json:"nhostBaseFolder,omitempty"`
	OrganizationID             *string        `json:"organizationID,omitempty"`
	RepositoryProductionBranch *string        `json:"repositoryProductionBranch,omitempty"`
	Slug                       *string        `json:"slug,omitempty"`
	Subdomain                  *string        `json:"subdomain,omitempty"`
	UpdatedAt                  *time.Time     `json:"updatedAt,omitempty"`
	WorkspaceID                *string        `json:"workspaceId,omitempty"`
}

// order by sum() on columns of table "apps"
type AppsSumOrderBy struct {
	DesiredState *OrderBy `json:"desiredState,omitempty"`
}

type AppsUpdates struct {
	// increments the numeric columns with given value of the filtered values
	Inc *AppsIncInput `json:"_inc,omitempty"`
	// sets the columns of the filtered rows to the given values
	Set *AppsSetInput `json:"_set,omitempty"`
	// filter the rows which have to be updated
	Where *AppsBoolExp `json:"where"`
}

// order by var_pop() on columns of table "apps"
type AppsVarPopOrderBy struct {
	DesiredState *OrderBy `json:"desiredState,omitempty"`
}

// order by var_samp() on columns of table "apps"
type AppsVarSampOrderBy struct {
	DesiredState *OrderBy `json:"desiredState,omitempty"`
}

// order by variance() on columns of table "apps"
type AppsVarianceOrderBy struct {
	DesiredState *OrderBy `json:"desiredState,omitempty"`
}

// Boolean expression to compare columns of type "authRefreshTokenTypes_enum". All fields are combined with logical 'AND'.
type AuthRefreshTokenTypesEnumComparisonExp struct {
	Eq     *AuthRefreshTokenTypesEnum  `json:"_eq,omitempty"`
	In     []AuthRefreshTokenTypesEnum `json:"_in,omitempty"`
	IsNull *bool                       `json:"_is_null,omitempty"`
	Neq    *AuthRefreshTokenTypesEnum  `json:"_neq,omitempty"`
	Nin    []AuthRefreshTokenTypesEnum `json:"_nin,omitempty"`
}

// User refresh tokens. Hasura auth uses them to rotate new access tokens as long as the refresh token is not expired. Don't modify its structure as Hasura Auth relies on it to function properly.
type AuthRefreshTokens struct {
	CreatedAt time.Time                 `json:"createdAt"`
	ExpiresAt time.Time                 `json:"expiresAt"`
	ID        string                    `json:"id"`
	Metadata  map[string]any            `json:"metadata,omitempty"`
	Type      AuthRefreshTokenTypesEnum `json:"type"`
	// An object relationship
	User   *Users `json:"user"`
	UserID string `json:"userId"`
}

// order by aggregate values of table "auth.refresh_tokens"
type AuthRefreshTokensAggregateOrderBy struct {
	Count *OrderBy                     `json:"count,omitempty"`
	Max   *AuthRefreshTokensMaxOrderBy `json:"max,omitempty"`
	Min   *AuthRefreshTokensMinOrderBy `json:"min,omitempty"`
}

// Boolean expression to filter rows from the table "auth.refresh_tokens". All fields are combined with a logical 'AND'.
type AuthRefreshTokensBoolExp struct {
	And       []*AuthRefreshTokensBoolExp             `json:"_and,omitempty"`
	Not       *AuthRefreshTokensBoolExp               `json:"_not,omitempty"`
	Or        []*AuthRefreshTokensBoolExp             `json:"_or,omitempty"`
	CreatedAt *TimestamptzComparisonExp               `json:"createdAt,omitempty"`
	ExpiresAt *TimestamptzComparisonExp               `json:"expiresAt,omitempty"`
	ID        *UUIDComparisonExp                      `json:"id,omitempty"`
	Metadata  *JsonbComparisonExp                     `json:"metadata,omitempty"`
	Type      *AuthRefreshTokenTypesEnumComparisonExp `json:"type,omitempty"`
	User      *UsersBoolExp                           `json:"user,omitempty"`
	UserID    *UUIDComparisonExp                      `json:"userId,omitempty"`
}

// order by max() on columns of table "auth.refresh_tokens"
type AuthRefreshTokensMaxOrderBy struct {
	CreatedAt *OrderBy `json:"createdAt,omitempty"`
	ExpiresAt *OrderBy `json:"expiresAt,omitempty"`
	ID        *OrderBy `json:"id,omitempty"`
	UserID    *OrderBy `json:"userId,omitempty"`
}

// order by min() on columns of table "auth.refresh_tokens"
type AuthRefreshTokensMinOrderBy struct {
	CreatedAt *OrderBy `json:"createdAt,omitempty"`
	ExpiresAt *OrderBy `json:"expiresAt,omitempty"`
	ID        *OrderBy `json:"id,omitempty"`
	UserID    *OrderBy `json:"userId,omitempty"`
}

// response of any mutation on the table "auth.refresh_tokens"
type AuthRefreshTokensMutationResponse struct {
	// number of rows affected by the mutation
	AffectedRows int64 `json:"affected_rows"`
	// data from the rows affected by the mutation
	Returning []*AuthRefreshTokens `json:"returning"`
}

// Ordering options when selecting data from "auth.refresh_tokens".
type AuthRefreshTokensOrderBy struct {
	CreatedAt *OrderBy      `json:"createdAt,omitempty"`
	ExpiresAt *OrderBy      `json:"expiresAt,omitempty"`
	ID        *OrderBy      `json:"id,omitempty"`
	Metadata  *OrderBy      `json:"metadata,omitempty"`
	Type      *OrderBy      `json:"type,omitempty"`
	User      *UsersOrderBy `json:"user,omitempty"`
	UserID    *OrderBy      `json:"userId,omitempty"`
}

// Streaming cursor of the table "authRefreshTokens"
type AuthRefreshTokensStreamCursorInput struct {
	// Stream column input with initial value
	InitialValue *AuthRefreshTokensStreamCursorValueInput `json:"initial_value"`
	// cursor ordering
	Ordering *CursorOrdering `json:"ordering,omitempty"`
}

// Initial value of the column from where the streaming should start
type AuthRefreshTokensStreamCursorValueInput struct {
	CreatedAt *time.Time                 `json:"createdAt,omitempty"`
	ExpiresAt *time.Time                 `json:"expiresAt,omitempty"`
	ID        *string                    `json:"id,omitempty"`
	Metadata  map[string]any             `json:"metadata,omitempty"`
	Type      *AuthRefreshTokenTypesEnum `json:"type,omitempty"`
	UserID    *string                    `json:"userId,omitempty"`
}

// Active providers for a given user. Don't modify its structure as Hasura Auth relies on it to function properly.
type AuthUserProviders struct {
	ID         string `json:"id"`
	ProviderID string `json:"providerId"`
	// An object relationship
	User *Users `json:"user"`
}

// order by aggregate values of table "auth.user_providers"
type AuthUserProvidersAggregateOrderBy struct {
	Count *OrderBy                     `json:"count,omitempty"`
	Max   *AuthUserProvidersMaxOrderBy `json:"max,omitempty"`
	Min   *AuthUserProvidersMinOrderBy `json:"min,omitempty"`
}

// Boolean expression to filter rows from the table "auth.user_providers". All fields are combined with a logical 'AND'.
type AuthUserProvidersBoolExp struct {
	And        []*AuthUserProvidersBoolExp `json:"_and,omitempty"`
	Not        *AuthUserProvidersBoolExp   `json:"_not,omitempty"`
	Or         []*AuthUserProvidersBoolExp `json:"_or,omitempty"`
	ID         *UUIDComparisonExp          `json:"id,omitempty"`
	ProviderID *StringComparisonExp        `json:"providerId,omitempty"`
	User       *UsersBoolExp               `json:"user,omitempty"`
}

// order by max() on columns of table "auth.user_providers"
type AuthUserProvidersMaxOrderBy struct {
	ID         *OrderBy `json:"id,omitempty"`
	ProviderID *OrderBy `json:"providerId,omitempty"`
}

// order by min() on columns of table "auth.user_providers"
type AuthUserProvidersMinOrderBy struct {
	ID         *OrderBy `json:"id,omitempty"`
	ProviderID *OrderBy `json:"providerId,omitempty"`
}

// Ordering options when selecting data from "auth.user_providers".
type AuthUserProvidersOrderBy struct {
	ID         *OrderBy      `json:"id,omitempty"`
	ProviderID *OrderBy      `json:"providerId,omitempty"`
	User       *UsersOrderBy `json:"user,omitempty"`
}

// Streaming cursor of the table "authUserProviders"
type AuthUserProvidersStreamCursorInput struct {
	// Stream column input with initial value
	InitialValue *AuthUserProvidersStreamCursorValueInput `json:"initial_value"`
	// cursor ordering
	Ordering *CursorOrdering `json:"ordering,omitempty"`
}

// Initial value of the column from where the streaming should start
type AuthUserProvidersStreamCursorValueInput struct {
	ID         *string `json:"id,omitempty"`
	ProviderID *string `json:"providerId,omitempty"`
}

// User webauthn security keys. Don't modify its structure as Hasura Auth relies on it to function properly.
type AuthUserSecurityKeys struct {
	ID       string  `json:"id"`
	Nickname *string `json:"nickname,omitempty"`
	// An object relationship
	User   *Users `json:"user"`
	UserID string `json:"userId"`
}

// order by aggregate values of table "auth.user_security_keys"
type AuthUserSecurityKeysAggregateOrderBy struct {
	Count *OrderBy                        `json:"count,omitempty"`
	Max   *AuthUserSecurityKeysMaxOrderBy `json:"max,omitempty"`
	Min   *AuthUserSecurityKeysMinOrderBy `json:"min,omitempty"`
}

// Boolean expression to filter rows from the table "auth.user_security_keys". All fields are combined with a logical 'AND'.
type AuthUserSecurityKeysBoolExp struct {
	And      []*AuthUserSecurityKeysBoolExp `json:"_and,omitempty"`
	Not      *AuthUserSecurityKeysBoolExp   `json:"_not,omitempty"`
	Or       []*AuthUserSecurityKeysBoolExp `json:"_or,omitempty"`
	ID       *UUIDComparisonExp             `json:"id,omitempty"`
	Nickname *StringComparisonExp           `json:"nickname,omitempty"`
	User     *UsersBoolExp                  `json:"user,omitempty"`
	UserID   *UUIDComparisonExp             `json:"userId,omitempty"`
}

// order by max() on columns of table "auth.user_security_keys"
type AuthUserSecurityKeysMaxOrderBy struct {
	ID       *OrderBy `json:"id,omitempty"`
	Nickname *OrderBy `json:"nickname,omitempty"`
	UserID   *OrderBy `json:"userId,omitempty"`
}

// order by min() on columns of table "auth.user_security_keys"
type AuthUserSecurityKeysMinOrderBy struct {
	ID       *OrderBy `json:"id,omitempty"`
	Nickname *OrderBy `json:"nickname,omitempty"`
	UserID   *OrderBy `json:"userId,omitempty"`
}

// response of any mutation on the table "auth.user_security_keys"
type AuthUserSecurityKeysMutationResponse struct {
	// number of rows affected by the mutation
	AffectedRows int64 `json:"affected_rows"`
	// data from the rows affected by the mutation
	Returning []*AuthUserSecurityKeys `json:"returning"`
}

// Ordering options when selecting data from "auth.user_security_keys".
type AuthUserSecurityKeysOrderBy struct {
	ID       *OrderBy      `json:"id,omitempty"`
	Nickname *OrderBy      `json:"nickname,omitempty"`
	User     *UsersOrderBy `json:"user,omitempty"`
	UserID   *OrderBy      `json:"userId,omitempty"`
}

// Streaming cursor of the table "authUserSecurityKeys"
type AuthUserSecurityKeysStreamCursorInput struct {
	// Stream column input with initial value
	InitialValue *AuthUserSecurityKeysStreamCursorValueInput `json:"initial_value"`
	// cursor ordering
	Ordering *CursorOrdering `json:"ordering,omitempty"`
}

// Initial value of the column from where the streaming should start
type AuthUserSecurityKeysStreamCursorValueInput struct {
	ID       *string `json:"id,omitempty"`
	Nickname *string `json:"nickname,omitempty"`
	UserID   *string `json:"userId,omitempty"`
}

// columns and relationships of "backups"
type Backups struct {
	// An object relationship
	App         *Apps      `json:"app"`
	AppID       string     `json:"appId"`
	CompletedAt *time.Time `json:"completedAt,omitempty"`
	CreatedAt   time.Time  `json:"createdAt"`
	ID          string     `json:"id"`
	Size        int64      `json:"size"`
}

// order by aggregate values of table "backups"
type BackupsAggregateOrderBy struct {
	Avg        *BackupsAvgOrderBy        `json:"avg,omitempty"`
	Count      *OrderBy                  `json:"count,omitempty"`
	Max        *BackupsMaxOrderBy        `json:"max,omitempty"`
	Min        *BackupsMinOrderBy        `json:"min,omitempty"`
	Stddev     *BackupsStddevOrderBy     `json:"stddev,omitempty"`
	StddevPop  *BackupsStddevPopOrderBy  `json:"stddev_pop,omitempty"`
	StddevSamp *BackupsStddevSampOrderBy `json:"stddev_samp,omitempty"`
	Sum        *BackupsSumOrderBy        `json:"sum,omitempty"`
	VarPop     *BackupsVarPopOrderBy     `json:"var_pop,omitempty"`
	VarSamp    *BackupsVarSampOrderBy    `json:"var_samp,omitempty"`
	Variance   *BackupsVarianceOrderBy   `json:"variance,omitempty"`
}

// order by avg() on columns of table "backups"
type BackupsAvgOrderBy struct {
	Size *OrderBy `json:"size,omitempty"`
}

// Boolean expression to filter rows from the table "backups". All fields are combined with a logical 'AND'.
type BackupsBoolExp struct {
	And         []*BackupsBoolExp         `json:"_and,omitempty"`
	Not         *BackupsBoolExp           `json:"_not,omitempty"`
	Or          []*BackupsBoolExp         `json:"_or,omitempty"`
	App         *AppsBoolExp              `json:"app,omitempty"`
	AppID       *UUIDComparisonExp        `json:"appId,omitempty"`
	CompletedAt *TimestamptzComparisonExp `json:"completedAt,omitempty"`
	CreatedAt   *TimestamptzComparisonExp `json:"createdAt,omitempty"`
	ID          *UUIDComparisonExp        `json:"id,omitempty"`
	Size        *BigintComparisonExp      `json:"size,omitempty"`
}

// order by max() on columns of table "backups"
type BackupsMaxOrderBy struct {
	AppID       *OrderBy `json:"appId,omitempty"`
	CompletedAt *OrderBy `json:"completedAt,omitempty"`
	CreatedAt   *OrderBy `json:"createdAt,omitempty"`
	ID          *OrderBy `json:"id,omitempty"`
	Size        *OrderBy `json:"size,omitempty"`
}

// order by min() on columns of table "backups"
type BackupsMinOrderBy struct {
	AppID       *OrderBy `json:"appId,omitempty"`
	CompletedAt *OrderBy `json:"completedAt,omitempty"`
	CreatedAt   *OrderBy `json:"createdAt,omitempty"`
	ID          *OrderBy `json:"id,omitempty"`
	Size        *OrderBy `json:"size,omitempty"`
}

// Ordering options when selecting data from "backups".
type BackupsOrderBy struct {
	App         *AppsOrderBy `json:"app,omitempty"`
	AppID       *OrderBy     `json:"appId,omitempty"`
	CompletedAt *OrderBy     `json:"completedAt,omitempty"`
	CreatedAt   *OrderBy     `json:"createdAt,omitempty"`
	ID          *OrderBy     `json:"id,omitempty"`
	Size        *OrderBy     `json:"size,omitempty"`
}

// order by stddev() on columns of table "backups"
type BackupsStddevOrderBy struct {
	Size *OrderBy `json:"size,omitempty"`
}

// order by stddev_pop() on columns of table "backups"
type BackupsStddevPopOrderBy struct {
	Size *OrderBy `json:"size,omitempty"`
}

// order by stddev_samp() on columns of table "backups"
type BackupsStddevSampOrderBy struct {
	Size *OrderBy `json:"size,omitempty"`
}

// Streaming cursor of the table "backups"
type BackupsStreamCursorInput struct {
	// Stream column input with initial value
	InitialValue *BackupsStreamCursorValueInput `json:"initial_value"`
	// cursor ordering
	Ordering *CursorOrdering `json:"ordering,omitempty"`
}

// Initial value of the column from where the streaming should start
type BackupsStreamCursorValueInput struct {
	AppID       *string    `json:"appId,omitempty"`
	CompletedAt *time.Time `json:"completedAt,omitempty"`
	CreatedAt   *time.Time `json:"createdAt,omitempty"`
	ID          *string    `json:"id,omitempty"`
	Size        *int64     `json:"size,omitempty"`
}

// order by sum() on columns of table "backups"
type BackupsSumOrderBy struct {
	Size *OrderBy `json:"size,omitempty"`
}

// order by var_pop() on columns of table "backups"
type BackupsVarPopOrderBy struct {
	Size *OrderBy `json:"size,omitempty"`
}

// order by var_samp() on columns of table "backups"
type BackupsVarSampOrderBy struct {
	Size *OrderBy `json:"size,omitempty"`
}

// order by variance() on columns of table "backups"
type BackupsVarianceOrderBy struct {
	Size *OrderBy `json:"size,omitempty"`
}

// Boolean expression to compare columns of type "bigint". All fields are combined with logical 'AND'.
type BigintComparisonExp struct {
	Eq     *int64  `json:"_eq,omitempty"`
	Gt     *int64  `json:"_gt,omitempty"`
	Gte    *int64  `json:"_gte,omitempty"`
	In     []int64 `json:"_in,omitempty"`
	IsNull *bool   `json:"_is_null,omitempty"`
	Lt     *int64  `json:"_lt,omitempty"`
	Lte    *int64  `json:"_lte,omitempty"`
	Neq    *int64  `json:"_neq,omitempty"`
	Nin    []int64 `json:"_nin,omitempty"`
}

// Boolean expression to compare columns of type "bpchar". All fields are combined with logical 'AND'.
type BpcharComparisonExp struct {
	Eq  *string `json:"_eq,omitempty"`
	Gt  *string `json:"_gt,omitempty"`
	Gte *string `json:"_gte,omitempty"`
	// does the column match the given case-insensitive pattern
	Ilike *string  `json:"_ilike,omitempty"`
	In    []string `json:"_in,omitempty"`
	// does the column match the given POSIX regular expression, case insensitive
	Iregex *string `json:"_iregex,omitempty"`
	IsNull *bool   `json:"_is_null,omitempty"`
	// does the column match the given pattern
	Like *string `json:"_like,omitempty"`
	Lt   *string `json:"_lt,omitempty"`
	Lte  *string `json:"_lte,omitempty"`
	Neq  *string `json:"_neq,omitempty"`
	// does the column NOT match the given case-insensitive pattern
	Nilike *string  `json:"_nilike,omitempty"`
	Nin    []string `json:"_nin,omitempty"`
	// does the column NOT match the given POSIX regular expression, case insensitive
	Niregex *string `json:"_niregex,omitempty"`
	// does the column NOT match the given pattern
	Nlike *string `json:"_nlike,omitempty"`
	// does the column NOT match the given POSIX regular expression, case sensitive
	Nregex *string `json:"_nregex,omitempty"`
	// does the column NOT match the given SQL regular expression
	Nsimilar *string `json:"_nsimilar,omitempty"`
	// does the column match the given POSIX regular expression, case sensitive
	Regex *string `json:"_regex,omitempty"`
	// does the column match the given SQL regular expression
	Similar *string `json:"_similar,omitempty"`
}

// Boolean expression to compare columns of type "citext". All fields are combined with logical 'AND'.
type CitextComparisonExp struct {
	Eq  *string `json:"_eq,omitempty"`
	Gt  *string `json:"_gt,omitempty"`
	Gte *string `json:"_gte,omitempty"`
	// does the column match the given case-insensitive pattern
	Ilike *string  `json:"_ilike,omitempty"`
	In    []string `json:"_in,omitempty"`
	// does the column match the given POSIX regular expression, case insensitive
	Iregex *string `json:"_iregex,omitempty"`
	IsNull *bool   `json:"_is_null,omitempty"`
	// does the column match the given pattern
	Like *string `json:"_like,omitempty"`
	Lt   *string `json:"_lt,omitempty"`
	Lte  *string `json:"_lte,omitempty"`
	Neq  *string `json:"_neq,omitempty"`
	// does the column NOT match the given case-insensitive pattern
	Nilike *string  `json:"_nilike,omitempty"`
	Nin    []string `json:"_nin,omitempty"`
	// does the column NOT match the given POSIX regular expression, case insensitive
	Niregex *string `json:"_niregex,omitempty"`
	// does the column NOT match the given pattern
	Nlike *string `json:"_nlike,omitempty"`
	// does the column NOT match the given POSIX regular expression, case sensitive
	Nregex *string `json:"_nregex,omitempty"`
	// does the column NOT match the given SQL regular expression
	Nsimilar *string `json:"_nsimilar,omitempty"`
	// does the column match the given POSIX regular expression, case sensitive
	Regex *string `json:"_regex,omitempty"`
	// does the column match the given SQL regular expression
	Similar *string `json:"_similar,omitempty"`
}

// columns and relationships of "cli_tokens"
type CliTokens struct {
	CreatedAt time.Time `json:"createdAt"`
	ID        string    `json:"id"`
	UpdatedAt time.Time `json:"updatedAt"`
	// An object relationship
	User *Users `json:"user"`
}

// order by aggregate values of table "cli_tokens"
type CliTokensAggregateOrderBy struct {
	Count *OrderBy             `json:"count,omitempty"`
	Max   *CliTokensMaxOrderBy `json:"max,omitempty"`
	Min   *CliTokensMinOrderBy `json:"min,omitempty"`
}

// Boolean expression to filter rows from the table "cli_tokens". All fields are combined with a logical 'AND'.
type CliTokensBoolExp struct {
	And       []*CliTokensBoolExp       `json:"_and,omitempty"`
	Not       *CliTokensBoolExp         `json:"_not,omitempty"`
	Or        []*CliTokensBoolExp       `json:"_or,omitempty"`
	CreatedAt *TimestamptzComparisonExp `json:"createdAt,omitempty"`
	ID        *UUIDComparisonExp        `json:"id,omitempty"`
	UpdatedAt *TimestamptzComparisonExp `json:"updatedAt,omitempty"`
	User      *UsersBoolExp             `json:"user,omitempty"`
}

// order by max() on columns of table "cli_tokens"
type CliTokensMaxOrderBy struct {
	CreatedAt *OrderBy `json:"createdAt,omitempty"`
	ID        *OrderBy `json:"id,omitempty"`
	UpdatedAt *OrderBy `json:"updatedAt,omitempty"`
}

// order by min() on columns of table "cli_tokens"
type CliTokensMinOrderBy struct {
	CreatedAt *OrderBy `json:"createdAt,omitempty"`
	ID        *OrderBy `json:"id,omitempty"`
	UpdatedAt *OrderBy `json:"updatedAt,omitempty"`
}

// response of any mutation on the table "cli_tokens"
type CliTokensMutationResponse struct {
	// number of rows affected by the mutation
	AffectedRows int64 `json:"affected_rows"`
	// data from the rows affected by the mutation
	Returning []*CliTokens `json:"returning"`
}

// Ordering options when selecting data from "cli_tokens".
type CliTokensOrderBy struct {
	CreatedAt *OrderBy      `json:"createdAt,omitempty"`
	ID        *OrderBy      `json:"id,omitempty"`
	UpdatedAt *OrderBy      `json:"updatedAt,omitempty"`
	User      *UsersOrderBy `json:"user,omitempty"`
}

// Streaming cursor of the table "cliTokens"
type CliTokensStreamCursorInput struct {
	// Stream column input with initial value
	InitialValue *CliTokensStreamCursorValueInput `json:"initial_value"`
	// cursor ordering
	Ordering *CursorOrdering `json:"ordering,omitempty"`
}

// Initial value of the column from where the streaming should start
type CliTokensStreamCursorValueInput struct {
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	ID        *string    `json:"id,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
}

// columns and relationships of "continents"
type Continents struct {
	// Continent code
	Code string `json:"code"`
	// An array relationship
	Countries []*Countries `json:"countries"`
	// Continent name
	Name *string `json:"name,omitempty"`
}

// Boolean expression to filter rows from the table "continents". All fields are combined with a logical 'AND'.
type ContinentsBoolExp struct {
	And       []*ContinentsBoolExp `json:"_and,omitempty"`
	Not       *ContinentsBoolExp   `json:"_not,omitempty"`
	Or        []*ContinentsBoolExp `json:"_or,omitempty"`
	Code      *BpcharComparisonExp `json:"code,omitempty"`
	Countries *CountriesBoolExp    `json:"countries,omitempty"`
	Name      *StringComparisonExp `json:"name,omitempty"`
}

// Ordering options when selecting data from "continents".
type ContinentsOrderBy struct {
	Code               *OrderBy                   `json:"code,omitempty"`
	CountriesAggregate *CountriesAggregateOrderBy `json:"countries_aggregate,omitempty"`
	Name               *OrderBy                   `json:"name,omitempty"`
}

// Streaming cursor of the table "continents"
type ContinentsStreamCursorInput struct {
	// Stream column input with initial value
	InitialValue *ContinentsStreamCursorValueInput `json:"initial_value"`
	// cursor ordering
	Ordering *CursorOrdering `json:"ordering,omitempty"`
}

// Initial value of the column from where the streaming should start
type ContinentsStreamCursorValueInput struct {
	// Continent code
	Code *string `json:"code,omitempty"`
	// Continent name
	Name *string `json:"name,omitempty"`
}

// columns and relationships of "countries"
type Countries struct {
	// Two-letter country code (ISO 3166-1 alpha-2)
	Code string `json:"code"`
	// An object relationship
	Continent     *Continents `json:"continent"`
	ContinentCode string      `json:"continentCode"`
	EmojiFlag     *string     `json:"emojiFlag,omitempty"`
	// An array relationship
	Locations []*Regions `json:"locations"`
	// English country name
	Name string `json:"name"`
	// An array relationship
	Workspaces []*Workspaces `json:"workspaces"`
}

// order by aggregate values of table "countries"
type CountriesAggregateOrderBy struct {
	Count *OrderBy             `json:"count,omitempty"`
	Max   *CountriesMaxOrderBy `json:"max,omitempty"`
	Min   *CountriesMinOrderBy `json:"min,omitempty"`
}

// Boolean expression to filter rows from the table "countries". All fields are combined with a logical 'AND'.
type CountriesBoolExp struct {
	And           []*CountriesBoolExp  `json:"_and,omitempty"`
	Not           *CountriesBoolExp    `json:"_not,omitempty"`
	Or            []*CountriesBoolExp  `json:"_or,omitempty"`
	Code          *BpcharComparisonExp `json:"code,omitempty"`
	Continent     *ContinentsBoolExp   `json:"continent,omitempty"`
	ContinentCode *BpcharComparisonExp `json:"continentCode,omitempty"`
	EmojiFlag     *StringComparisonExp `json:"emojiFlag,omitempty"`
	Locations     *RegionsBoolExp      `json:"locations,omitempty"`
	Name          *StringComparisonExp `json:"name,omitempty"`
	Workspaces    *WorkspacesBoolExp   `json:"workspaces,omitempty"`
}

// order by max() on columns of table "countries"
type CountriesMaxOrderBy struct {
	// Two-letter country code (ISO 3166-1 alpha-2)
	Code          *OrderBy `json:"code,omitempty"`
	ContinentCode *OrderBy `json:"continentCode,omitempty"`
	EmojiFlag     *OrderBy `json:"emojiFlag,omitempty"`
	// English country name
	Name *OrderBy `json:"name,omitempty"`
}

// order by min() on columns of table "countries"
type CountriesMinOrderBy struct {
	// Two-letter country code (ISO 3166-1 alpha-2)
	Code          *OrderBy `json:"code,omitempty"`
	ContinentCode *OrderBy `json:"continentCode,omitempty"`
	EmojiFlag     *OrderBy `json:"emojiFlag,omitempty"`
	// English country name
	Name *OrderBy `json:"name,omitempty"`
}

// Ordering options when selecting data from "countries".
type CountriesOrderBy struct {
	Code                *OrderBy                    `json:"code,omitempty"`
	Continent           *ContinentsOrderBy          `json:"continent,omitempty"`
	ContinentCode       *OrderBy                    `json:"continentCode,omitempty"`
	EmojiFlag           *OrderBy                    `json:"emojiFlag,omitempty"`
	LocationsAggregate  *RegionsAggregateOrderBy    `json:"locations_aggregate,omitempty"`
	Name                *OrderBy                    `json:"name,omitempty"`
	WorkspacesAggregate *WorkspacesAggregateOrderBy `json:"workspaces_aggregate,omitempty"`
}

// Streaming cursor of the table "countries"
type CountriesStreamCursorInput struct {
	// Stream column input with initial value
	InitialValue *CountriesStreamCursorValueInput `json:"initial_value"`
	// cursor ordering
	Ordering *CursorOrdering `json:"ordering,omitempty"`
}

// Initial value of the column from where the streaming should start
type CountriesStreamCursorValueInput struct {
	// Two-letter country code (ISO 3166-1 alpha-2)
	Code          *string `json:"code,omitempty"`
	ContinentCode *string `json:"continentCode,omitempty"`
	EmojiFlag     *string `json:"emojiFlag,omitempty"`
	// English country name
	Name *string `json:"name,omitempty"`
}

// columns and relationships of "deployment_logs"
type DeploymentLogs struct {
	CreatedAt time.Time `json:"createdAt"`
	// An object relationship
	Deployment   *Deployments `json:"deployment"`
	DeploymentID string       `json:"deploymentId"`
	ID           string       `json:"id"`
	Message      string       `json:"message"`
}

// order by aggregate values of table "deployment_logs"
type DeploymentLogsAggregateOrderBy struct {
	Count *OrderBy                  `json:"count,omitempty"`
	Max   *DeploymentLogsMaxOrderBy `json:"max,omitempty"`
	Min   *DeploymentLogsMinOrderBy `json:"min,omitempty"`
}

// Boolean expression to filter rows from the table "deployment_logs". All fields are combined with a logical 'AND'.
type DeploymentLogsBoolExp struct {
	And          []*DeploymentLogsBoolExp  `json:"_and,omitempty"`
	Not          *DeploymentLogsBoolExp    `json:"_not,omitempty"`
	Or           []*DeploymentLogsBoolExp  `json:"_or,omitempty"`
	CreatedAt    *TimestamptzComparisonExp `json:"createdAt,omitempty"`
	Deployment   *DeploymentsBoolExp       `json:"deployment,omitempty"`
	DeploymentID *UUIDComparisonExp        `json:"deploymentId,omitempty"`
	ID           *UUIDComparisonExp        `json:"id,omitempty"`
	Message      *StringComparisonExp      `json:"message,omitempty"`
}

// order by max() on columns of table "deployment_logs"
type DeploymentLogsMaxOrderBy struct {
	CreatedAt    *OrderBy `json:"createdAt,omitempty"`
	DeploymentID *OrderBy `json:"deploymentId,omitempty"`
	ID           *OrderBy `json:"id,omitempty"`
	Message      *OrderBy `json:"message,omitempty"`
}

// order by min() on columns of table "deployment_logs"
type DeploymentLogsMinOrderBy struct {
	CreatedAt    *OrderBy `json:"createdAt,omitempty"`
	DeploymentID *OrderBy `json:"deploymentId,omitempty"`
	ID           *OrderBy `json:"id,omitempty"`
	Message      *OrderBy `json:"message,omitempty"`
}

// Ordering options when selecting data from "deployment_logs".
type DeploymentLogsOrderBy struct {
	CreatedAt    *OrderBy            `json:"createdAt,omitempty"`
	Deployment   *DeploymentsOrderBy `json:"deployment,omitempty"`
	DeploymentID *OrderBy            `json:"deploymentId,omitempty"`
	ID           *OrderBy            `json:"id,omitempty"`
	Message      *OrderBy            `json:"message,omitempty"`
}

// Streaming cursor of the table "deploymentLogs"
type DeploymentLogsStreamCursorInput struct {
	// Stream column input with initial value
	InitialValue *DeploymentLogsStreamCursorValueInput `json:"initial_value"`
	// cursor ordering
	Ordering *CursorOrdering `json:"ordering,omitempty"`
}

// Initial value of the column from where the streaming should start
type DeploymentLogsStreamCursorValueInput struct {
	CreatedAt    *time.Time `json:"createdAt,omitempty"`
	DeploymentID *string    `json:"deploymentId,omitempty"`
	ID           *string    `json:"id,omitempty"`
	Message      *string    `json:"message,omitempty"`
}

// Table that keeps track of deployments done by watchtower
type Deployments struct {
	// An object relationship
	App                 *Apps      `json:"app"`
	AppID               string     `json:"appId"`
	CommitMessage       *string    `json:"commitMessage,omitempty"`
	CommitSha           string     `json:"commitSHA"`
	CommitUserAvatarURL *string    `json:"commitUserAvatarUrl,omitempty"`
	CommitUserName      *string    `json:"commitUserName,omitempty"`
	DeploymentEndedAt   *time.Time `json:"deploymentEndedAt,omitempty"`
	// An array relationship
	DeploymentLogs      []*DeploymentLogs `json:"deploymentLogs"`
	DeploymentStartedAt *time.Time        `json:"deploymentStartedAt,omitempty"`
	DeploymentStatus    *string           `json:"deploymentStatus,omitempty"`
	FunctionsEndedAt    *time.Time        `json:"functionsEndedAt,omitempty"`
	FunctionsStartedAt  *time.Time        `json:"functionsStartedAt,omitempty"`
	FunctionsStatus     *string           `json:"functionsStatus,omitempty"`
	ID                  string            `json:"id"`
	MetadataEndedAt     *time.Time        `json:"metadataEndedAt,omitempty"`
	MetadataStartedAt   *time.Time        `json:"metadataStartedAt,omitempty"`
	MetadataStatus      *string           `json:"metadataStatus,omitempty"`
	MigrationsEndedAt   *time.Time        `json:"migrationsEndedAt,omitempty"`
	MigrationsStartedAt *time.Time        `json:"migrationsStartedAt,omitempty"`
	MigrationsStatus    *string           `json:"migrationsStatus,omitempty"`
}

// order by aggregate values of table "deployments"
type DeploymentsAggregateOrderBy struct {
	Count *OrderBy               `json:"count,omitempty"`
	Max   *DeploymentsMaxOrderBy `json:"max,omitempty"`
	Min   *DeploymentsMinOrderBy `json:"min,omitempty"`
}

// input type for inserting array relation for remote table "deployments"
type DeploymentsArrRelInsertInput struct {
	Data []*DeploymentsInsertInput `json:"data"`
	// upsert condition
	OnConflict *DeploymentsOnConflict `json:"on_conflict,omitempty"`
}

// Boolean expression to filter rows from the table "deployments". All fields are combined with a logical 'AND'.
type DeploymentsBoolExp struct {
	And                 []*DeploymentsBoolExp     `json:"_and,omitempty"`
	Not                 *DeploymentsBoolExp       `json:"_not,omitempty"`
	Or                  []*DeploymentsBoolExp     `json:"_or,omitempty"`
	App                 *AppsBoolExp              `json:"app,omitempty"`
	AppID               *UUIDComparisonExp        `json:"appId,omitempty"`
	CommitMessage       *StringComparisonExp      `json:"commitMessage,omitempty"`
	CommitSha           *StringComparisonExp      `json:"commitSHA,omitempty"`
	CommitUserAvatarURL *StringComparisonExp      `json:"commitUserAvatarUrl,omitempty"`
	CommitUserName      *StringComparisonExp      `json:"commitUserName,omitempty"`
	DeploymentEndedAt   *TimestamptzComparisonExp `json:"deploymentEndedAt,omitempty"`
	DeploymentLogs      *DeploymentLogsBoolExp    `json:"deploymentLogs,omitempty"`
	DeploymentStartedAt *TimestamptzComparisonExp `json:"deploymentStartedAt,omitempty"`
	DeploymentStatus    *StringComparisonExp      `json:"deploymentStatus,omitempty"`
	FunctionsEndedAt    *TimestamptzComparisonExp `json:"functionsEndedAt,omitempty"`
	FunctionsStartedAt  *TimestamptzComparisonExp `json:"functionsStartedAt,omitempty"`
	FunctionsStatus     *StringComparisonExp      `json:"functionsStatus,omitempty"`
	ID                  *UUIDComparisonExp        `json:"id,omitempty"`
	MetadataEndedAt     *TimestamptzComparisonExp `json:"metadataEndedAt,omitempty"`
	MetadataStartedAt   *TimestamptzComparisonExp `json:"metadataStartedAt,omitempty"`
	MetadataStatus      *StringComparisonExp      `json:"metadataStatus,omitempty"`
	MigrationsEndedAt   *TimestamptzComparisonExp `json:"migrationsEndedAt,omitempty"`
	MigrationsStartedAt *TimestamptzComparisonExp `json:"migrationsStartedAt,omitempty"`
	MigrationsStatus    *StringComparisonExp      `json:"migrationsStatus,omitempty"`
}

// input type for inserting data into table "deployments"
type DeploymentsInsertInput struct {
	App                 *AppsObjRelInsertInput `json:"app,omitempty"`
	AppID               *string                `json:"appId,omitempty"`
	CommitMessage       *string                `json:"commitMessage,omitempty"`
	CommitSha           *string                `json:"commitSHA,omitempty"`
	CommitUserAvatarURL *string                `json:"commitUserAvatarUrl,omitempty"`
	CommitUserName      *string                `json:"commitUserName,omitempty"`
	DeploymentStatus    *string                `json:"deploymentStatus,omitempty"`
}

// order by max() on columns of table "deployments"
type DeploymentsMaxOrderBy struct {
	AppID               *OrderBy `json:"appId,omitempty"`
	CommitMessage       *OrderBy `json:"commitMessage,omitempty"`
	CommitSha           *OrderBy `json:"commitSHA,omitempty"`
	CommitUserAvatarURL *OrderBy `json:"commitUserAvatarUrl,omitempty"`
	CommitUserName      *OrderBy `json:"commitUserName,omitempty"`
	DeploymentEndedAt   *OrderBy `json:"deploymentEndedAt,omitempty"`
	DeploymentStartedAt *OrderBy `json:"deploymentStartedAt,omitempty"`
	DeploymentStatus    *OrderBy `json:"deploymentStatus,omitempty"`
	FunctionsEndedAt    *OrderBy `json:"functionsEndedAt,omitempty"`
	FunctionsStartedAt  *OrderBy `json:"functionsStartedAt,omitempty"`
	FunctionsStatus     *OrderBy `json:"functionsStatus,omitempty"`
	ID                  *OrderBy `json:"id,omitempty"`
	MetadataEndedAt     *OrderBy `json:"metadataEndedAt,omitempty"`
	MetadataStartedAt   *OrderBy `json:"metadataStartedAt,omitempty"`
	MetadataStatus      *OrderBy `json:"metadataStatus,omitempty"`
	MigrationsEndedAt   *OrderBy `json:"migrationsEndedAt,omitempty"`
	MigrationsStartedAt *OrderBy `json:"migrationsStartedAt,omitempty"`
	MigrationsStatus    *OrderBy `json:"migrationsStatus,omitempty"`
}

// order by min() on columns of table "deployments"
type DeploymentsMinOrderBy struct {
	AppID               *OrderBy `json:"appId,omitempty"`
	CommitMessage       *OrderBy `json:"commitMessage,omitempty"`
	CommitSha           *OrderBy `json:"commitSHA,omitempty"`
	CommitUserAvatarURL *OrderBy `json:"commitUserAvatarUrl,omitempty"`
	CommitUserName      *OrderBy `json:"commitUserName,omitempty"`
	DeploymentEndedAt   *OrderBy `json:"deploymentEndedAt,omitempty"`
	DeploymentStartedAt *OrderBy `json:"deploymentStartedAt,omitempty"`
	DeploymentStatus    *OrderBy `json:"deploymentStatus,omitempty"`
	FunctionsEndedAt    *OrderBy `json:"functionsEndedAt,omitempty"`
	FunctionsStartedAt  *OrderBy `json:"functionsStartedAt,omitempty"`
	FunctionsStatus     *OrderBy `json:"functionsStatus,omitempty"`
	ID                  *OrderBy `json:"id,omitempty"`
	MetadataEndedAt     *OrderBy `json:"metadataEndedAt,omitempty"`
	MetadataStartedAt   *OrderBy `json:"metadataStartedAt,omitempty"`
	MetadataStatus      *OrderBy `json:"metadataStatus,omitempty"`
	MigrationsEndedAt   *OrderBy `json:"migrationsEndedAt,omitempty"`
	MigrationsStartedAt *OrderBy `json:"migrationsStartedAt,omitempty"`
	MigrationsStatus    *OrderBy `json:"migrationsStatus,omitempty"`
}

// response of any mutation on the table "deployments"
type DeploymentsMutationResponse struct {
	// number of rows affected by the mutation
	AffectedRows int64 `json:"affected_rows"`
	// data from the rows affected by the mutation
	Returning []*Deployments `json:"returning"`
}

// on_conflict condition type for table "deployments"
type DeploymentsOnConflict struct {
	Constraint    DeploymentsConstraint     `json:"constraint"`
	UpdateColumns []DeploymentsUpdateColumn `json:"update_columns"`
	Where         *DeploymentsBoolExp       `json:"where,omitempty"`
}

// Ordering options when selecting data from "deployments".
type DeploymentsOrderBy struct {
	App                     *AppsOrderBy                    `json:"app,omitempty"`
	AppID                   *OrderBy                        `json:"appId,omitempty"`
	CommitMessage           *OrderBy                        `json:"commitMessage,omitempty"`
	CommitSha               *OrderBy                        `json:"commitSHA,omitempty"`
	CommitUserAvatarURL     *OrderBy                        `json:"commitUserAvatarUrl,omitempty"`
	CommitUserName          *OrderBy                        `json:"commitUserName,omitempty"`
	DeploymentEndedAt       *OrderBy                        `json:"deploymentEndedAt,omitempty"`
	DeploymentLogsAggregate *DeploymentLogsAggregateOrderBy `json:"deploymentLogs_aggregate,omitempty"`
	DeploymentStartedAt     *OrderBy                        `json:"deploymentStartedAt,omitempty"`
	DeploymentStatus        *OrderBy                        `json:"deploymentStatus,omitempty"`
	FunctionsEndedAt        *OrderBy                        `json:"functionsEndedAt,omitempty"`
	FunctionsStartedAt      *OrderBy                        `json:"functionsStartedAt,omitempty"`
	FunctionsStatus         *OrderBy                        `json:"functionsStatus,omitempty"`
	ID                      *OrderBy                        `json:"id,omitempty"`
	MetadataEndedAt         *OrderBy                        `json:"metadataEndedAt,omitempty"`
	MetadataStartedAt       *OrderBy                        `json:"metadataStartedAt,omitempty"`
	MetadataStatus          *OrderBy                        `json:"metadataStatus,omitempty"`
	MigrationsEndedAt       *OrderBy                        `json:"migrationsEndedAt,omitempty"`
	MigrationsStartedAt     *OrderBy                        `json:"migrationsStartedAt,omitempty"`
	MigrationsStatus        *OrderBy                        `json:"migrationsStatus,omitempty"`
}

// Streaming cursor of the table "deployments"
type DeploymentsStreamCursorInput struct {
	// Stream column input with initial value
	InitialValue *DeploymentsStreamCursorValueInput `json:"initial_value"`
	// cursor ordering
	Ordering *CursorOrdering `json:"ordering,omitempty"`
}

// Initial value of the column from where the streaming should start
type DeploymentsStreamCursorValueInput struct {
	AppID               *string    `json:"appId,omitempty"`
	CommitMessage       *string    `json:"commitMessage,omitempty"`
	CommitSha           *string    `json:"commitSHA,omitempty"`
	CommitUserAvatarURL *string    `json:"commitUserAvatarUrl,omitempty"`
	CommitUserName      *string    `json:"commitUserName,omitempty"`
	DeploymentEndedAt   *time.Time `json:"deploymentEndedAt,omitempty"`
	DeploymentStartedAt *time.Time `json:"deploymentStartedAt,omitempty"`
	DeploymentStatus    *string    `json:"deploymentStatus,omitempty"`
	FunctionsEndedAt    *time.Time `json:"functionsEndedAt,omitempty"`
	FunctionsStartedAt  *time.Time `json:"functionsStartedAt,omitempty"`
	FunctionsStatus     *string    `json:"functionsStatus,omitempty"`
	ID                  *string    `json:"id,omitempty"`
	MetadataEndedAt     *time.Time `json:"metadataEndedAt,omitempty"`
	MetadataStartedAt   *time.Time `json:"metadataStartedAt,omitempty"`
	MetadataStatus      *string    `json:"metadataStatus,omitempty"`
	MigrationsEndedAt   *time.Time `json:"migrationsEndedAt,omitempty"`
	MigrationsStartedAt *time.Time `json:"migrationsStartedAt,omitempty"`
	MigrationsStatus    *string    `json:"migrationsStatus,omitempty"`
}

// columns and relationships of "feature_flags"
type FeatureFlags struct {
	// An object relationship
	App         *Apps  `json:"app"`
	AppID       string `json:"appId"`
	Description string `json:"description"`
	ID          string `json:"id"`
	Name        string `json:"name"`
	Value       string `json:"value"`
}

// order by aggregate values of table "feature_flags"
type FeatureFlagsAggregateOrderBy struct {
	Count *OrderBy                `json:"count,omitempty"`
	Max   *FeatureFlagsMaxOrderBy `json:"max,omitempty"`
	Min   *FeatureFlagsMinOrderBy `json:"min,omitempty"`
}

// input type for inserting array relation for remote table "feature_flags"
type FeatureFlagsArrRelInsertInput struct {
	Data []*FeatureFlagsInsertInput `json:"data"`
	// upsert condition
	OnConflict *FeatureFlagsOnConflict `json:"on_conflict,omitempty"`
}

// Boolean expression to filter rows from the table "feature_flags". All fields are combined with a logical 'AND'.
type FeatureFlagsBoolExp struct {
	And         []*FeatureFlagsBoolExp `json:"_and,omitempty"`
	Not         *FeatureFlagsBoolExp   `json:"_not,omitempty"`
	Or          []*FeatureFlagsBoolExp `json:"_or,omitempty"`
	App         *AppsBoolExp           `json:"app,omitempty"`
	AppID       *UUIDComparisonExp     `json:"appId,omitempty"`
	Description *StringComparisonExp   `json:"description,omitempty"`
	ID          *UUIDComparisonExp     `json:"id,omitempty"`
	Name        *StringComparisonExp   `json:"name,omitempty"`
	Value       *StringComparisonExp   `json:"value,omitempty"`
}

// input type for inserting data into table "feature_flags"
type FeatureFlagsInsertInput struct {
	App         *AppsObjRelInsertInput `json:"app,omitempty"`
	AppID       *string                `json:"appId,omitempty"`
	Description *string                `json:"description,omitempty"`
	Name        *string                `json:"name,omitempty"`
	Value       *string                `json:"value,omitempty"`
}

// order by max() on columns of table "feature_flags"
type FeatureFlagsMaxOrderBy struct {
	AppID       *OrderBy `json:"appId,omitempty"`
	Description *OrderBy `json:"description,omitempty"`
	ID          *OrderBy `json:"id,omitempty"`
	Name        *OrderBy `json:"name,omitempty"`
	Value       *OrderBy `json:"value,omitempty"`
}

// order by min() on columns of table "feature_flags"
type FeatureFlagsMinOrderBy struct {
	AppID       *OrderBy `json:"appId,omitempty"`
	Description *OrderBy `json:"description,omitempty"`
	ID          *OrderBy `json:"id,omitempty"`
	Name        *OrderBy `json:"name,omitempty"`
	Value       *OrderBy `json:"value,omitempty"`
}

// response of any mutation on the table "feature_flags"
type FeatureFlagsMutationResponse struct {
	// number of rows affected by the mutation
	AffectedRows int64 `json:"affected_rows"`
	// data from the rows affected by the mutation
	Returning []*FeatureFlags `json:"returning"`
}

// on_conflict condition type for table "feature_flags"
type FeatureFlagsOnConflict struct {
	Constraint    FeatureFlagsConstraint     `json:"constraint"`
	UpdateColumns []FeatureFlagsUpdateColumn `json:"update_columns"`
	Where         *FeatureFlagsBoolExp       `json:"where,omitempty"`
}

// Ordering options when selecting data from "feature_flags".
type FeatureFlagsOrderBy struct {
	App         *AppsOrderBy `json:"app,omitempty"`
	AppID       *OrderBy     `json:"appId,omitempty"`
	Description *OrderBy     `json:"description,omitempty"`
	ID          *OrderBy     `json:"id,omitempty"`
	Name        *OrderBy     `json:"name,omitempty"`
	Value       *OrderBy     `json:"value,omitempty"`
}

// Streaming cursor of the table "featureFlags"
type FeatureFlagsStreamCursorInput struct {
	// Stream column input with initial value
	InitialValue *FeatureFlagsStreamCursorValueInput `json:"initial_value"`
	// cursor ordering
	Ordering *CursorOrdering `json:"ordering,omitempty"`
}

// Initial value of the column from where the streaming should start
type FeatureFlagsStreamCursorValueInput struct {
	AppID       *string `json:"appId,omitempty"`
	Description *string `json:"description,omitempty"`
	ID          *string `json:"id,omitempty"`
	Name        *string `json:"name,omitempty"`
	Value       *string `json:"value,omitempty"`
}

// columns and relationships of "storage.files"
type Files struct {
	BucketID         string         `json:"bucketId"`
	CreatedAt        time.Time      `json:"createdAt"`
	Etag             *string        `json:"etag,omitempty"`
	ID               string         `json:"id"`
	IsUploaded       *bool          `json:"isUploaded,omitempty"`
	Metadata         map[string]any `json:"metadata,omitempty"`
	MimeType         *string        `json:"mimeType,omitempty"`
	Name             *string        `json:"name,omitempty"`
	Size             *int64         `json:"size,omitempty"`
	UpdatedAt        time.Time      `json:"updatedAt"`
	UploadedByUserID *string        `json:"uploadedByUserId,omitempty"`
}

// Boolean expression to filter rows from the table "storage.files". All fields are combined with a logical 'AND'.
type FilesBoolExp struct {
	And              []*FilesBoolExp           `json:"_and,omitempty"`
	Not              *FilesBoolExp             `json:"_not,omitempty"`
	Or               []*FilesBoolExp           `json:"_or,omitempty"`
	BucketID         *StringComparisonExp      `json:"bucketId,omitempty"`
	CreatedAt        *TimestamptzComparisonExp `json:"createdAt,omitempty"`
	Etag             *StringComparisonExp      `json:"etag,omitempty"`
	ID               *UUIDComparisonExp        `json:"id,omitempty"`
	IsUploaded       *BooleanComparisonExp     `json:"isUploaded,omitempty"`
	Metadata         *JsonbComparisonExp       `json:"metadata,omitempty"`
	MimeType         *StringComparisonExp      `json:"mimeType,omitempty"`
	Name             *StringComparisonExp      `json:"name,omitempty"`
	Size             *IntComparisonExp         `json:"size,omitempty"`
	UpdatedAt        *TimestamptzComparisonExp `json:"updatedAt,omitempty"`
	UploadedByUserID *UUIDComparisonExp        `json:"uploadedByUserId,omitempty"`
}

// Ordering options when selecting data from "storage.files".
type FilesOrderBy struct {
	BucketID         *OrderBy `json:"bucketId,omitempty"`
	CreatedAt        *OrderBy `json:"createdAt,omitempty"`
	Etag             *OrderBy `json:"etag,omitempty"`
	ID               *OrderBy `json:"id,omitempty"`
	IsUploaded       *OrderBy `json:"isUploaded,omitempty"`
	Metadata         *OrderBy `json:"metadata,omitempty"`
	MimeType         *OrderBy `json:"mimeType,omitempty"`
	Name             *OrderBy `json:"name,omitempty"`
	Size             *OrderBy `json:"size,omitempty"`
	UpdatedAt        *OrderBy `json:"updatedAt,omitempty"`
	UploadedByUserID *OrderBy `json:"uploadedByUserId,omitempty"`
}

// Streaming cursor of the table "files"
type FilesStreamCursorInput struct {
	// Stream column input with initial value
	InitialValue *FilesStreamCursorValueInput `json:"initial_value"`
	// cursor ordering
	Ordering *CursorOrdering `json:"ordering,omitempty"`
}

// Initial value of the column from where the streaming should start
type FilesStreamCursorValueInput struct {
	BucketID         *string        `json:"bucketId,omitempty"`
	CreatedAt        *time.Time     `json:"createdAt,omitempty"`
	Etag             *string        `json:"etag,omitempty"`
	ID               *string        `json:"id,omitempty"`
	IsUploaded       *bool          `json:"isUploaded,omitempty"`
	Metadata         map[string]any `json:"metadata,omitempty"`
	MimeType         *string        `json:"mimeType,omitempty"`
	Name             *string        `json:"name,omitempty"`
	Size             *int64         `json:"size,omitempty"`
	UpdatedAt        *time.Time     `json:"updatedAt,omitempty"`
	UploadedByUserID *string        `json:"uploadedByUserId,omitempty"`
}

// columns and relationships of "github_app_installations"
type GithubAppInstallations struct {
	AccountAvatarURL *string   `json:"accountAvatarUrl,omitempty"`
	AccountLogin     *string   `json:"accountLogin,omitempty"`
	AccountType      *string   `json:"accountType,omitempty"`
	CreatedAt        time.Time `json:"createdAt"`
	// An array relationship
	GithubRepositories []*GithubRepositories `json:"githubRepositories"`
	ID                 string                `json:"id"`
	UpdatedAt          time.Time             `json:"updatedAt"`
	// An object relationship
	User *Users `json:"user,omitempty"`
}

// order by aggregate values of table "github_app_installations"
type GithubAppInstallationsAggregateOrderBy struct {
	Count *OrderBy                          `json:"count,omitempty"`
	Max   *GithubAppInstallationsMaxOrderBy `json:"max,omitempty"`
	Min   *GithubAppInstallationsMinOrderBy `json:"min,omitempty"`
}

// Boolean expression to filter rows from the table "github_app_installations". All fields are combined with a logical 'AND'.
type GithubAppInstallationsBoolExp struct {
	And                []*GithubAppInstallationsBoolExp `json:"_and,omitempty"`
	Not                *GithubAppInstallationsBoolExp   `json:"_not,omitempty"`
	Or                 []*GithubAppInstallationsBoolExp `json:"_or,omitempty"`
	AccountAvatarURL   *StringComparisonExp             `json:"accountAvatarUrl,omitempty"`
	AccountLogin       *StringComparisonExp             `json:"accountLogin,omitempty"`
	AccountType        *StringComparisonExp             `json:"accountType,omitempty"`
	CreatedAt          *TimestamptzComparisonExp        `json:"createdAt,omitempty"`
	GithubRepositories *GithubRepositoriesBoolExp       `json:"githubRepositories,omitempty"`
	ID                 *UUIDComparisonExp               `json:"id,omitempty"`
	UpdatedAt          *TimestamptzComparisonExp        `json:"updatedAt,omitempty"`
	User               *UsersBoolExp                    `json:"user,omitempty"`
}

// input type for inserting data into table "github_app_installations"
type GithubAppInstallationsInsertInput struct {
	AccountAvatarURL                *string        `json:"accountAvatarUrl,omitempty"`
	AccountLogin                    *string        `json:"accountLogin,omitempty"`
	AccountNodeID                   *string        `json:"accountNodeId,omitempty"`
	AccountType                     *string        `json:"accountType,omitempty"`
	ExternalGithubAppInstallationID *int64         `json:"externalGithubAppInstallationId,omitempty"`
	GithubData                      map[string]any `json:"githubData,omitempty"`
	UserID                          *string        `json:"userId,omitempty"`
}

// order by max() on columns of table "github_app_installations"
type GithubAppInstallationsMaxOrderBy struct {
	AccountAvatarURL *OrderBy `json:"accountAvatarUrl,omitempty"`
	AccountLogin     *OrderBy `json:"accountLogin,omitempty"`
	AccountType      *OrderBy `json:"accountType,omitempty"`
	CreatedAt        *OrderBy `json:"createdAt,omitempty"`
	ID               *OrderBy `json:"id,omitempty"`
	UpdatedAt        *OrderBy `json:"updatedAt,omitempty"`
}

// order by min() on columns of table "github_app_installations"
type GithubAppInstallationsMinOrderBy struct {
	AccountAvatarURL *OrderBy `json:"accountAvatarUrl,omitempty"`
	AccountLogin     *OrderBy `json:"accountLogin,omitempty"`
	AccountType      *OrderBy `json:"accountType,omitempty"`
	CreatedAt        *OrderBy `json:"createdAt,omitempty"`
	ID               *OrderBy `json:"id,omitempty"`
	UpdatedAt        *OrderBy `json:"updatedAt,omitempty"`
}

// response of any mutation on the table "github_app_installations"
type GithubAppInstallationsMutationResponse struct {
	// number of rows affected by the mutation
	AffectedRows int64 `json:"affected_rows"`
	// data from the rows affected by the mutation
	Returning []*GithubAppInstallations `json:"returning"`
}

// on_conflict condition type for table "github_app_installations"
type GithubAppInstallationsOnConflict struct {
	Constraint    GithubAppInstallationsConstraint     `json:"constraint"`
	UpdateColumns []GithubAppInstallationsUpdateColumn `json:"update_columns"`
	Where         *GithubAppInstallationsBoolExp       `json:"where,omitempty"`
}

// Ordering options when selecting data from "github_app_installations".
type GithubAppInstallationsOrderBy struct {
	AccountAvatarURL            *OrderBy                            `json:"accountAvatarUrl,omitempty"`
	AccountLogin                *OrderBy                            `json:"accountLogin,omitempty"`
	AccountType                 *OrderBy                            `json:"accountType,omitempty"`
	CreatedAt                   *OrderBy                            `json:"createdAt,omitempty"`
	GithubRepositoriesAggregate *GithubRepositoriesAggregateOrderBy `json:"githubRepositories_aggregate,omitempty"`
	ID                          *OrderBy                            `json:"id,omitempty"`
	UpdatedAt                   *OrderBy                            `json:"updatedAt,omitempty"`
	User                        *UsersOrderBy                       `json:"user,omitempty"`
}

// primary key columns input for table: github_app_installations
type GithubAppInstallationsPkColumnsInput struct {
	ID string `json:"id"`
}

// Streaming cursor of the table "githubAppInstallations"
type GithubAppInstallationsStreamCursorInput struct {
	// Stream column input with initial value
	InitialValue *GithubAppInstallationsStreamCursorValueInput `json:"initial_value"`
	// cursor ordering
	Ordering *CursorOrdering `json:"ordering,omitempty"`
}

// Initial value of the column from where the streaming should start
type GithubAppInstallationsStreamCursorValueInput struct {
	AccountAvatarURL *string    `json:"accountAvatarUrl,omitempty"`
	AccountLogin     *string    `json:"accountLogin,omitempty"`
	AccountType      *string    `json:"accountType,omitempty"`
	CreatedAt        *time.Time `json:"createdAt,omitempty"`
	ID               *string    `json:"id,omitempty"`
	UpdatedAt        *time.Time `json:"updatedAt,omitempty"`
}

type GithubAppInstallationsUpdates struct {
	// filter the rows which have to be updated
	Where *GithubAppInstallationsBoolExp `json:"where"`
}

// columns and relationships of "github_repositories"
type GithubRepositories struct {
	// An array relationship
	Apps      []*Apps   `json:"apps"`
	CreatedAt time.Time `json:"createdAt"`
	FullName  string    `json:"fullName"`
	// An object relationship
	GithubAppInstallation *GithubAppInstallations `json:"githubAppInstallation"`
	ID                    string                  `json:"id"`
	Name                  string                  `json:"name"`
	Private               bool                    `json:"private"`
	UpdatedAt             time.Time               `json:"updatedAt"`
}

// order by aggregate values of table "github_repositories"
type GithubRepositoriesAggregateOrderBy struct {
	Count *OrderBy                      `json:"count,omitempty"`
	Max   *GithubRepositoriesMaxOrderBy `json:"max,omitempty"`
	Min   *GithubRepositoriesMinOrderBy `json:"min,omitempty"`
}

// Boolean expression to filter rows from the table "github_repositories". All fields are combined with a logical 'AND'.
type GithubRepositoriesBoolExp struct {
	And                   []*GithubRepositoriesBoolExp   `json:"_and,omitempty"`
	Not                   *GithubRepositoriesBoolExp     `json:"_not,omitempty"`
	Or                    []*GithubRepositoriesBoolExp   `json:"_or,omitempty"`
	Apps                  *AppsBoolExp                   `json:"apps,omitempty"`
	CreatedAt             *TimestamptzComparisonExp      `json:"createdAt,omitempty"`
	FullName              *StringComparisonExp           `json:"fullName,omitempty"`
	GithubAppInstallation *GithubAppInstallationsBoolExp `json:"githubAppInstallation,omitempty"`
	ID                    *UUIDComparisonExp             `json:"id,omitempty"`
	Name                  *StringComparisonExp           `json:"name,omitempty"`
	Private               *BooleanComparisonExp          `json:"private,omitempty"`
	UpdatedAt             *TimestamptzComparisonExp      `json:"updatedAt,omitempty"`
}

// order by max() on columns of table "github_repositories"
type GithubRepositoriesMaxOrderBy struct {
	CreatedAt *OrderBy `json:"createdAt,omitempty"`
	FullName  *OrderBy `json:"fullName,omitempty"`
	ID        *OrderBy `json:"id,omitempty"`
	Name      *OrderBy `json:"name,omitempty"`
	UpdatedAt *OrderBy `json:"updatedAt,omitempty"`
}

// order by min() on columns of table "github_repositories"
type GithubRepositoriesMinOrderBy struct {
	CreatedAt *OrderBy `json:"createdAt,omitempty"`
	FullName  *OrderBy `json:"fullName,omitempty"`
	ID        *OrderBy `json:"id,omitempty"`
	Name      *OrderBy `json:"name,omitempty"`
	UpdatedAt *OrderBy `json:"updatedAt,omitempty"`
}

// Ordering options when selecting data from "github_repositories".
type GithubRepositoriesOrderBy struct {
	AppsAggregate         *AppsAggregateOrderBy          `json:"apps_aggregate,omitempty"`
	CreatedAt             *OrderBy                       `json:"createdAt,omitempty"`
	FullName              *OrderBy                       `json:"fullName,omitempty"`
	GithubAppInstallation *GithubAppInstallationsOrderBy `json:"githubAppInstallation,omitempty"`
	ID                    *OrderBy                       `json:"id,omitempty"`
	Name                  *OrderBy                       `json:"name,omitempty"`
	Private               *OrderBy                       `json:"private,omitempty"`
	UpdatedAt             *OrderBy                       `json:"updatedAt,omitempty"`
}

// Streaming cursor of the table "githubRepositories"
type GithubRepositoriesStreamCursorInput struct {
	// Stream column input with initial value
	InitialValue *GithubRepositoriesStreamCursorValueInput `json:"initial_value"`
	// cursor ordering
	Ordering *CursorOrdering `json:"ordering,omitempty"`
}

// Initial value of the column from where the streaming should start
type GithubRepositoriesStreamCursorValueInput struct {
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	FullName  *string    `json:"fullName,omitempty"`
	ID        *string    `json:"id,omitempty"`
	Name      *string    `json:"name,omitempty"`
	Private   *bool      `json:"private,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
}

type JsonbCastExp struct {
	String *StringComparisonExp `json:"String,omitempty"`
}

// Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'.
type JsonbComparisonExp struct {
	Cast *JsonbCastExp `json:"_cast,omitempty"`
	// is the column contained in the given json value
	ContainedIn map[string]any `json:"_contained_in,omitempty"`
	// does the column contain the given json value at the top level
	Contains map[string]any `json:"_contains,omitempty"`
	Eq       map[string]any `json:"_eq,omitempty"`
	Gt       map[string]any `json:"_gt,omitempty"`
	Gte      map[string]any `json:"_gte,omitempty"`
	// does the string exist as a top-level key in the column
	HasKey *string `json:"_has_key,omitempty"`
	// do all of these strings exist as top-level keys in the column
	HasKeysAll []string `json:"_has_keys_all,omitempty"`
	// do any of these strings exist as top-level keys in the column
	HasKeysAny []string         `json:"_has_keys_any,omitempty"`
	In         []map[string]any `json:"_in,omitempty"`
	IsNull     *bool            `json:"_is_null,omitempty"`
	Lt         map[string]any   `json:"_lt,omitempty"`
	Lte        map[string]any   `json:"_lte,omitempty"`
	Neq        map[string]any   `json:"_neq,omitempty"`
	Nin        []map[string]any `json:"_nin,omitempty"`
}

// mutation root
type MutationRoot struct {
}

type OrganizationMemberInviteAcceptArgs struct {
	ID *string `json:"id,omitempty"`
}

// Boolean expression to compare columns of type "organization_costs_thresholds_enum". All fields are combined with logical 'AND'.
type OrganizationCostsThresholdsEnumComparisonExp struct {
	Eq     *OrganizationCostsThresholdsEnum  `json:"_eq,omitempty"`
	In     []OrganizationCostsThresholdsEnum `json:"_in,omitempty"`
	IsNull *bool                             `json:"_is_null,omitempty"`
	Neq    *OrganizationCostsThresholdsEnum  `json:"_neq,omitempty"`
	Nin    []OrganizationCostsThresholdsEnum `json:"_nin,omitempty"`
}

// columns and relationships of "organization_member_invites"
type OrganizationMemberInvites struct {
	CreatedAt time.Time `json:"createdAt"`
	Email     string    `json:"email"`
	ID        string    `json:"id"`
	// An object relationship
	Organization   *Organizations              `json:"organization"`
	OrganizationID string                      `json:"organizationID"`
	Role           OrganizationMembersRoleEnum `json:"role"`
	UpdateAt       time.Time                   `json:"updateAt"`
	// An object relationship
	User *Users `json:"user,omitempty"`
}

// order by aggregate values of table "organization_member_invites"
type OrganizationMemberInvitesAggregateOrderBy struct {
	Count *OrderBy                             `json:"count,omitempty"`
	Max   *OrganizationMemberInvitesMaxOrderBy `json:"max,omitempty"`
	Min   *OrganizationMemberInvitesMinOrderBy `json:"min,omitempty"`
}

// Boolean expression to filter rows from the table "organization_member_invites". All fields are combined with a logical 'AND'.
type OrganizationMemberInvitesBoolExp struct {
	And            []*OrganizationMemberInvitesBoolExp       `json:"_and,omitempty"`
	Not            *OrganizationMemberInvitesBoolExp         `json:"_not,omitempty"`
	Or             []*OrganizationMemberInvitesBoolExp       `json:"_or,omitempty"`
	CreatedAt      *TimestamptzComparisonExp                 `json:"createdAt,omitempty"`
	Email          *CitextComparisonExp                      `json:"email,omitempty"`
	ID             *UUIDComparisonExp                        `json:"id,omitempty"`
	Organization   *OrganizationsBoolExp                     `json:"organization,omitempty"`
	OrganizationID *UUIDComparisonExp                        `json:"organizationID,omitempty"`
	Role           *OrganizationMembersRoleEnumComparisonExp `json:"role,omitempty"`
	UpdateAt       *TimestamptzComparisonExp                 `json:"updateAt,omitempty"`
	User           *UsersBoolExp                             `json:"user,omitempty"`
}

// input type for inserting data into table "organization_member_invites"
type OrganizationMemberInvitesInsertInput struct {
	Email          *string                      `json:"email,omitempty"`
	OrganizationID *string                      `json:"organizationID,omitempty"`
	Role           *OrganizationMembersRoleEnum `json:"role,omitempty"`
}

// order by max() on columns of table "organization_member_invites"
type OrganizationMemberInvitesMaxOrderBy struct {
	CreatedAt      *OrderBy `json:"createdAt,omitempty"`
	Email          *OrderBy `json:"email,omitempty"`
	ID             *OrderBy `json:"id,omitempty"`
	OrganizationID *OrderBy `json:"organizationID,omitempty"`
	UpdateAt       *OrderBy `json:"updateAt,omitempty"`
}

// order by min() on columns of table "organization_member_invites"
type OrganizationMemberInvitesMinOrderBy struct {
	CreatedAt      *OrderBy `json:"createdAt,omitempty"`
	Email          *OrderBy `json:"email,omitempty"`
	ID             *OrderBy `json:"id,omitempty"`
	OrganizationID *OrderBy `json:"organizationID,omitempty"`
	UpdateAt       *OrderBy `json:"updateAt,omitempty"`
}

// response of any mutation on the table "organization_member_invites"
type OrganizationMemberInvitesMutationResponse struct {
	// number of rows affected by the mutation
	AffectedRows int64 `json:"affected_rows"`
	// data from the rows affected by the mutation
	Returning []*OrganizationMemberInvites `json:"returning"`
}

// on_conflict condition type for table "organization_member_invites"
type OrganizationMemberInvitesOnConflict struct {
	Constraint    OrganizationMemberInvitesConstraint     `json:"constraint"`
	UpdateColumns []OrganizationMemberInvitesUpdateColumn `json:"update_columns"`
	Where         *OrganizationMemberInvitesBoolExp       `json:"where,omitempty"`
}

// Ordering options when selecting data from "organization_member_invites".
type OrganizationMemberInvitesOrderBy struct {
	CreatedAt      *OrderBy              `json:"createdAt,omitempty"`
	Email          *OrderBy              `json:"email,omitempty"`
	ID             *OrderBy              `json:"id,omitempty"`
	Organization   *OrganizationsOrderBy `json:"organization,omitempty"`
	OrganizationID *OrderBy              `json:"organizationID,omitempty"`
	Role           *OrderBy              `json:"role,omitempty"`
	UpdateAt       *OrderBy              `json:"updateAt,omitempty"`
	User           *UsersOrderBy         `json:"user,omitempty"`
}

// primary key columns input for table: organization_member_invites
type OrganizationMemberInvitesPkColumnsInput struct {
	ID string `json:"id"`
}

// input type for updating data in table "organization_member_invites"
type OrganizationMemberInvitesSetInput struct {
	Role *OrganizationMembersRoleEnum `json:"role,omitempty"`
}

// Streaming cursor of the table "organization_member_invites"
type OrganizationMemberInvitesStreamCursorInput struct {
	// Stream column input with initial value
	InitialValue *OrganizationMemberInvitesStreamCursorValueInput `json:"initial_value"`
	// cursor ordering
	Ordering *CursorOrdering `json:"ordering,omitempty"`
}

// Initial value of the column from where the streaming should start
type OrganizationMemberInvitesStreamCursorValueInput struct {
	CreatedAt      *time.Time                   `json:"createdAt,omitempty"`
	Email          *string                      `json:"email,omitempty"`
	ID             *string                      `json:"id,omitempty"`
	OrganizationID *string                      `json:"organizationID,omitempty"`
	Role           *OrganizationMembersRoleEnum `json:"role,omitempty"`
	UpdateAt       *time.Time                   `json:"updateAt,omitempty"`
}

type OrganizationMemberInvitesUpdates struct {
	// sets the columns of the filtered rows to the given values
	Set *OrganizationMemberInvitesSetInput `json:"_set,omitempty"`
	// filter the rows which have to be updated
	Where *OrganizationMemberInvitesBoolExp `json:"where"`
}

// columns and relationships of "organization_members"
type OrganizationMembers struct {
	CreatedAt time.Time `json:"createdAt"`
	ID        string    `json:"id"`
	// An object relationship
	Organization  *Organizations              `json:"organization"`
	OrganizatonID string                      `json:"organizatonID"`
	Role          OrganizationMembersRoleEnum `json:"role"`
	UpdatedAt     time.Time                   `json:"updatedAt"`
	// An object relationship
	User   *Users `json:"user"`
	UserID string `json:"userID"`
}

// order by aggregate values of table "organization_members"
type OrganizationMembersAggregateOrderBy struct {
	Count *OrderBy                       `json:"count,omitempty"`
	Max   *OrganizationMembersMaxOrderBy `json:"max,omitempty"`
	Min   *OrganizationMembersMinOrderBy `json:"min,omitempty"`
}

// Boolean expression to filter rows from the table "organization_members". All fields are combined with a logical 'AND'.
type OrganizationMembersBoolExp struct {
	And           []*OrganizationMembersBoolExp             `json:"_and,omitempty"`
	Not           *OrganizationMembersBoolExp               `json:"_not,omitempty"`
	Or            []*OrganizationMembersBoolExp             `json:"_or,omitempty"`
	CreatedAt     *TimestamptzComparisonExp                 `json:"createdAt,omitempty"`
	ID            *UUIDComparisonExp                        `json:"id,omitempty"`
	Organization  *OrganizationsBoolExp                     `json:"organization,omitempty"`
	OrganizatonID *UUIDComparisonExp                        `json:"organizatonID,omitempty"`
	Role          *OrganizationMembersRoleEnumComparisonExp `json:"role,omitempty"`
	UpdatedAt     *TimestamptzComparisonExp                 `json:"updatedAt,omitempty"`
	User          *UsersBoolExp                             `json:"user,omitempty"`
	UserID        *UUIDComparisonExp                        `json:"userID,omitempty"`
}

// order by max() on columns of table "organization_members"
type OrganizationMembersMaxOrderBy struct {
	CreatedAt     *OrderBy `json:"createdAt,omitempty"`
	ID            *OrderBy `json:"id,omitempty"`
	OrganizatonID *OrderBy `json:"organizatonID,omitempty"`
	UpdatedAt     *OrderBy `json:"updatedAt,omitempty"`
	UserID        *OrderBy `json:"userID,omitempty"`
}

// order by min() on columns of table "organization_members"
type OrganizationMembersMinOrderBy struct {
	CreatedAt     *OrderBy `json:"createdAt,omitempty"`
	ID            *OrderBy `json:"id,omitempty"`
	OrganizatonID *OrderBy `json:"organizatonID,omitempty"`
	UpdatedAt     *OrderBy `json:"updatedAt,omitempty"`
	UserID        *OrderBy `json:"userID,omitempty"`
}

// response of any mutation on the table "organization_members"
type OrganizationMembersMutationResponse struct {
	// number of rows affected by the mutation
	AffectedRows int64 `json:"affected_rows"`
	// data from the rows affected by the mutation
	Returning []*OrganizationMembers `json:"returning"`
}

// Ordering options when selecting data from "organization_members".
type OrganizationMembersOrderBy struct {
	CreatedAt     *OrderBy              `json:"createdAt,omitempty"`
	ID            *OrderBy              `json:"id,omitempty"`
	Organization  *OrganizationsOrderBy `json:"organization,omitempty"`
	OrganizatonID *OrderBy              `json:"organizatonID,omitempty"`
	Role          *OrderBy              `json:"role,omitempty"`
	UpdatedAt     *OrderBy              `json:"updatedAt,omitempty"`
	User          *UsersOrderBy         `json:"user,omitempty"`
	UserID        *OrderBy              `json:"userID,omitempty"`
}

// primary key columns input for table: organization_members
type OrganizationMembersPkColumnsInput struct {
	ID string `json:"id"`
}

// Boolean expression to compare columns of type "organization_members_role_enum". All fields are combined with logical 'AND'.
type OrganizationMembersRoleEnumComparisonExp struct {
	Eq     *OrganizationMembersRoleEnum  `json:"_eq,omitempty"`
	In     []OrganizationMembersRoleEnum `json:"_in,omitempty"`
	IsNull *bool                         `json:"_is_null,omitempty"`
	Neq    *OrganizationMembersRoleEnum  `json:"_neq,omitempty"`
	Nin    []OrganizationMembersRoleEnum `json:"_nin,omitempty"`
}

// input type for updating data in table "organization_members"
type OrganizationMembersSetInput struct {
	Role *OrganizationMembersRoleEnum `json:"role,omitempty"`
}

// Streaming cursor of the table "organization_members"
type OrganizationMembersStreamCursorInput struct {
	// Stream column input with initial value
	InitialValue *OrganizationMembersStreamCursorValueInput `json:"initial_value"`
	// cursor ordering
	Ordering *CursorOrdering `json:"ordering,omitempty"`
}

// Initial value of the column from where the streaming should start
type OrganizationMembersStreamCursorValueInput struct {
	CreatedAt     *time.Time                   `json:"createdAt,omitempty"`
	ID            *string                      `json:"id,omitempty"`
	OrganizatonID *string                      `json:"organizatonID,omitempty"`
	Role          *OrganizationMembersRoleEnum `json:"role,omitempty"`
	UpdatedAt     *time.Time                   `json:"updatedAt,omitempty"`
	UserID        *string                      `json:"userID,omitempty"`
}

type OrganizationMembersUpdates struct {
	// sets the columns of the filtered rows to the given values
	Set *OrganizationMembersSetInput `json:"_set,omitempty"`
	// filter the rows which have to be updated
	Where *OrganizationMembersBoolExp `json:"where"`
}

// columns and relationships of "organization_new_request"
type OrganizationNewRequest struct {
	CreatedAt time.Time `json:"createdAt"`
	ID        string    `json:"id"`
	Name      string    `json:"name"`
	// An object relationship
	Plan      *Plans `json:"plan"`
	PlanID    string `json:"planID"`
	SessionID string `json:"sessionID"`
	// An object relationship
	User   *Users `json:"user"`
	UserID string `json:"userID"`
}

// Boolean expression to filter rows from the table "organization_new_request". All fields are combined with a logical 'AND'.
type OrganizationNewRequestBoolExp struct {
	And       []*OrganizationNewRequestBoolExp `json:"_and,omitempty"`
	Not       *OrganizationNewRequestBoolExp   `json:"_not,omitempty"`
	Or        []*OrganizationNewRequestBoolExp `json:"_or,omitempty"`
	CreatedAt *TimestamptzComparisonExp        `json:"createdAt,omitempty"`
	ID        *UUIDComparisonExp               `json:"id,omitempty"`
	Name      *StringComparisonExp             `json:"name,omitempty"`
	Plan      *PlansBoolExp                    `json:"plan,omitempty"`
	PlanID    *UUIDComparisonExp               `json:"planID,omitempty"`
	SessionID *StringComparisonExp             `json:"sessionID,omitempty"`
	User      *UsersBoolExp                    `json:"user,omitempty"`
	UserID    *UUIDComparisonExp               `json:"userID,omitempty"`
}

// Ordering options when selecting data from "organization_new_request".
type OrganizationNewRequestOrderBy struct {
	CreatedAt *OrderBy      `json:"createdAt,omitempty"`
	ID        *OrderBy      `json:"id,omitempty"`
	Name      *OrderBy      `json:"name,omitempty"`
	Plan      *PlansOrderBy `json:"plan,omitempty"`
	PlanID    *OrderBy      `json:"planID,omitempty"`
	SessionID *OrderBy      `json:"sessionID,omitempty"`
	User      *UsersOrderBy `json:"user,omitempty"`
	UserID    *OrderBy      `json:"userID,omitempty"`
}

// Streaming cursor of the table "organization_new_request"
type OrganizationNewRequestStreamCursorInput struct {
	// Stream column input with initial value
	InitialValue *OrganizationNewRequestStreamCursorValueInput `json:"initial_value"`
	// cursor ordering
	Ordering *CursorOrdering `json:"ordering,omitempty"`
}

// Initial value of the column from where the streaming should start
type OrganizationNewRequestStreamCursorValueInput struct {
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	ID        *string    `json:"id,omitempty"`
	Name      *string    `json:"name,omitempty"`
	PlanID    *string    `json:"planID,omitempty"`
	SessionID *string    `json:"sessionID,omitempty"`
	UserID    *string    `json:"userID,omitempty"`
}

// Boolean expression to compare columns of type "organization_status_enum". All fields are combined with logical 'AND'.
type OrganizationStatusEnumComparisonExp struct {
	Eq     *OrganizationStatusEnum  `json:"_eq,omitempty"`
	In     []OrganizationStatusEnum `json:"_in,omitempty"`
	IsNull *bool                    `json:"_is_null,omitempty"`
	Neq    *OrganizationStatusEnum  `json:"_neq,omitempty"`
	Nin    []OrganizationStatusEnum `json:"_nin,omitempty"`
}

// columns and relationships of "organizations"
type Organizations struct {
	// An array relationship
	AllowedPrivateRegions []*RegionsAllowedOrganization `json:"allowedPrivateRegions"`
	// An array relationship
	Apps             []*Apps                         `json:"apps"`
	CreatedAt        time.Time                       `json:"createdAt"`
	CurrentThreshold OrganizationCostsThresholdsEnum `json:"current_threshold"`
	ID               string                          `json:"id"`
	// An array relationship
	Invites []*OrganizationMemberInvites `json:"invites"`
	// An array relationship
	Members []*OrganizationMembers `json:"members"`
	Name    string                 `json:"name"`
	// An object relationship
	Plan      *Plans                 `json:"plan"`
	PlanID    string                 `json:"planID"`
	Slug      string                 `json:"slug"`
	Status    OrganizationStatusEnum `json:"status"`
	Threshold int64                  `json:"threshold"`
	UpdatedAt time.Time              `json:"updatedAt"`
}

// order by aggregate values of table "organizations"
type OrganizationsAggregateOrderBy struct {
	Avg        *OrganizationsAvgOrderBy        `json:"avg,omitempty"`
	Count      *OrderBy                        `json:"count,omitempty"`
	Max        *OrganizationsMaxOrderBy        `json:"max,omitempty"`
	Min        *OrganizationsMinOrderBy        `json:"min,omitempty"`
	Stddev     *OrganizationsStddevOrderBy     `json:"stddev,omitempty"`
	StddevPop  *OrganizationsStddevPopOrderBy  `json:"stddev_pop,omitempty"`
	StddevSamp *OrganizationsStddevSampOrderBy `json:"stddev_samp,omitempty"`
	Sum        *OrganizationsSumOrderBy        `json:"sum,omitempty"`
	VarPop     *OrganizationsVarPopOrderBy     `json:"var_pop,omitempty"`
	VarSamp    *OrganizationsVarSampOrderBy    `json:"var_samp,omitempty"`
	Variance   *OrganizationsVarianceOrderBy   `json:"variance,omitempty"`
}

// order by avg() on columns of table "organizations"
type OrganizationsAvgOrderBy struct {
	Threshold *OrderBy `json:"threshold,omitempty"`
}

// Boolean expression to filter rows from the table "organizations". All fields are combined with a logical 'AND'.
type OrganizationsBoolExp struct {
	And                   []*OrganizationsBoolExp                       `json:"_and,omitempty"`
	Not                   *OrganizationsBoolExp                         `json:"_not,omitempty"`
	Or                    []*OrganizationsBoolExp                       `json:"_or,omitempty"`
	AllowedPrivateRegions *RegionsAllowedOrganizationBoolExp            `json:"allowedPrivateRegions,omitempty"`
	Apps                  *AppsBoolExp                                  `json:"apps,omitempty"`
	CreatedAt             *TimestamptzComparisonExp                     `json:"createdAt,omitempty"`
	CurrentThreshold      *OrganizationCostsThresholdsEnumComparisonExp `json:"current_threshold,omitempty"`
	ID                    *UUIDComparisonExp                            `json:"id,omitempty"`
	Invites               *OrganizationMemberInvitesBoolExp             `json:"invites,omitempty"`
	Members               *OrganizationMembersBoolExp                   `json:"members,omitempty"`
	Name                  *StringComparisonExp                          `json:"name,omitempty"`
	Plan                  *PlansBoolExp                                 `json:"plan,omitempty"`
	PlanID                *UUIDComparisonExp                            `json:"planID,omitempty"`
	Slug                  *StringComparisonExp                          `json:"slug,omitempty"`
	Status                *OrganizationStatusEnumComparisonExp          `json:"status,omitempty"`
	Threshold             *IntComparisonExp                             `json:"threshold,omitempty"`
	UpdatedAt             *TimestamptzComparisonExp                     `json:"updatedAt,omitempty"`
}

// input type for incrementing numeric columns in table "organizations"
type OrganizationsIncInput struct {
	Threshold *int64 `json:"threshold,omitempty"`
}

// order by max() on columns of table "organizations"
type OrganizationsMaxOrderBy struct {
	CreatedAt *OrderBy `json:"createdAt,omitempty"`
	ID        *OrderBy `json:"id,omitempty"`
	Name      *OrderBy `json:"name,omitempty"`
	PlanID    *OrderBy `json:"planID,omitempty"`
	Slug      *OrderBy `json:"slug,omitempty"`
	Threshold *OrderBy `json:"threshold,omitempty"`
	UpdatedAt *OrderBy `json:"updatedAt,omitempty"`
}

// order by min() on columns of table "organizations"
type OrganizationsMinOrderBy struct {
	CreatedAt *OrderBy `json:"createdAt,omitempty"`
	ID        *OrderBy `json:"id,omitempty"`
	Name      *OrderBy `json:"name,omitempty"`
	PlanID    *OrderBy `json:"planID,omitempty"`
	Slug      *OrderBy `json:"slug,omitempty"`
	Threshold *OrderBy `json:"threshold,omitempty"`
	UpdatedAt *OrderBy `json:"updatedAt,omitempty"`
}

// response of any mutation on the table "organizations"
type OrganizationsMutationResponse struct {
	// number of rows affected by the mutation
	AffectedRows int64 `json:"affected_rows"`
	// data from the rows affected by the mutation
	Returning []*Organizations `json:"returning"`
}

// Ordering options when selecting data from "organizations".
type OrganizationsOrderBy struct {
	AllowedPrivateRegionsAggregate *RegionsAllowedOrganizationAggregateOrderBy `json:"allowedPrivateRegions_aggregate,omitempty"`
	AppsAggregate                  *AppsAggregateOrderBy                       `json:"apps_aggregate,omitempty"`
	CreatedAt                      *OrderBy                                    `json:"createdAt,omitempty"`
	CurrentThreshold               *OrderBy                                    `json:"current_threshold,omitempty"`
	ID                             *OrderBy                                    `json:"id,omitempty"`
	InvitesAggregate               *OrganizationMemberInvitesAggregateOrderBy  `json:"invites_aggregate,omitempty"`
	MembersAggregate               *OrganizationMembersAggregateOrderBy        `json:"members_aggregate,omitempty"`
	Name                           *OrderBy                                    `json:"name,omitempty"`
	Plan                           *PlansOrderBy                               `json:"plan,omitempty"`
	PlanID                         *OrderBy                                    `json:"planID,omitempty"`
	Slug                           *OrderBy                                    `json:"slug,omitempty"`
	Status                         *OrderBy                                    `json:"status,omitempty"`
	Threshold                      *OrderBy                                    `json:"threshold,omitempty"`
	UpdatedAt                      *OrderBy                                    `json:"updatedAt,omitempty"`
}

// primary key columns input for table: organizations
type OrganizationsPkColumnsInput struct {
	ID string `json:"id"`
}

// input type for updating data in table "organizations"
type OrganizationsSetInput struct {
	Name      *string `json:"name,omitempty"`
	Threshold *int64  `json:"threshold,omitempty"`
}

// order by stddev() on columns of table "organizations"
type OrganizationsStddevOrderBy struct {
	Threshold *OrderBy `json:"threshold,omitempty"`
}

// order by stddev_pop() on columns of table "organizations"
type OrganizationsStddevPopOrderBy struct {
	Threshold *OrderBy `json:"threshold,omitempty"`
}

// order by stddev_samp() on columns of table "organizations"
type OrganizationsStddevSampOrderBy struct {
	Threshold *OrderBy `json:"threshold,omitempty"`
}

// Streaming cursor of the table "organizations"
type OrganizationsStreamCursorInput struct {
	// Stream column input with initial value
	InitialValue *OrganizationsStreamCursorValueInput `json:"initial_value"`
	// cursor ordering
	Ordering *CursorOrdering `json:"ordering,omitempty"`
}

// Initial value of the column from where the streaming should start
type OrganizationsStreamCursorValueInput struct {
	CreatedAt        *time.Time                       `json:"createdAt,omitempty"`
	CurrentThreshold *OrganizationCostsThresholdsEnum `json:"current_threshold,omitempty"`
	ID               *string                          `json:"id,omitempty"`
	Name             *string                          `json:"name,omitempty"`
	PlanID           *string                          `json:"planID,omitempty"`
	Slug             *string                          `json:"slug,omitempty"`
	Status           *OrganizationStatusEnum          `json:"status,omitempty"`
	Threshold        *int64                           `json:"threshold,omitempty"`
	UpdatedAt        *time.Time                       `json:"updatedAt,omitempty"`
}

// order by sum() on columns of table "organizations"
type OrganizationsSumOrderBy struct {
	Threshold *OrderBy `json:"threshold,omitempty"`
}

type OrganizationsUpdates struct {
	// increments the numeric columns with given value of the filtered values
	Inc *OrganizationsIncInput `json:"_inc,omitempty"`
	// sets the columns of the filtered rows to the given values
	Set *OrganizationsSetInput `json:"_set,omitempty"`
	// filter the rows which have to be updated
	Where *OrganizationsBoolExp `json:"where"`
}

// order by var_pop() on columns of table "organizations"
type OrganizationsVarPopOrderBy struct {
	Threshold *OrderBy `json:"threshold,omitempty"`
}

// order by var_samp() on columns of table "organizations"
type OrganizationsVarSampOrderBy struct {
	Threshold *OrderBy `json:"threshold,omitempty"`
}

// order by variance() on columns of table "organizations"
type OrganizationsVarianceOrderBy struct {
	Threshold *OrderBy `json:"threshold,omitempty"`
}

// columns and relationships of "payment_methods"
type PaymentMethods struct {
	AddedByUserID         string    `json:"addedByUserId"`
	CardBrand             string    `json:"cardBrand"`
	CardExpMonth          int64     `json:"cardExpMonth"`
	CardExpYear           int64     `json:"cardExpYear"`
	CardLast4             string    `json:"cardLast4"`
	CreatedAt             time.Time `json:"createdAt"`
	ID                    string    `json:"id"`
	IsDefault             bool      `json:"isDefault"`
	StripePaymentMethodID string    `json:"stripePaymentMethodId"`
	// An object relationship
	User *Users `json:"user"`
	// An object relationship
	Workspace   *Workspaces `json:"workspace"`
	WorkspaceID string      `json:"workspaceId"`
}

// order by aggregate values of table "payment_methods"
type PaymentMethodsAggregateOrderBy struct {
	Avg        *PaymentMethodsAvgOrderBy        `json:"avg,omitempty"`
	Count      *OrderBy                         `json:"count,omitempty"`
	Max        *PaymentMethodsMaxOrderBy        `json:"max,omitempty"`
	Min        *PaymentMethodsMinOrderBy        `json:"min,omitempty"`
	Stddev     *PaymentMethodsStddevOrderBy     `json:"stddev,omitempty"`
	StddevPop  *PaymentMethodsStddevPopOrderBy  `json:"stddev_pop,omitempty"`
	StddevSamp *PaymentMethodsStddevSampOrderBy `json:"stddev_samp,omitempty"`
	Sum        *PaymentMethodsSumOrderBy        `json:"sum,omitempty"`
	VarPop     *PaymentMethodsVarPopOrderBy     `json:"var_pop,omitempty"`
	VarSamp    *PaymentMethodsVarSampOrderBy    `json:"var_samp,omitempty"`
	Variance   *PaymentMethodsVarianceOrderBy   `json:"variance,omitempty"`
}

// input type for inserting array relation for remote table "payment_methods"
type PaymentMethodsArrRelInsertInput struct {
	Data []*PaymentMethodsInsertInput `json:"data"`
	// upsert condition
	OnConflict *PaymentMethodsOnConflict `json:"on_conflict,omitempty"`
}

// order by avg() on columns of table "payment_methods"
type PaymentMethodsAvgOrderBy struct {
	CardExpMonth *OrderBy `json:"cardExpMonth,omitempty"`
	CardExpYear  *OrderBy `json:"cardExpYear,omitempty"`
}

// Boolean expression to filter rows from the table "payment_methods". All fields are combined with a logical 'AND'.
type PaymentMethodsBoolExp struct {
	And                   []*PaymentMethodsBoolExp  `json:"_and,omitempty"`
	Not                   *PaymentMethodsBoolExp    `json:"_not,omitempty"`
	Or                    []*PaymentMethodsBoolExp  `json:"_or,omitempty"`
	AddedByUserID         *UUIDComparisonExp        `json:"addedByUserId,omitempty"`
	CardBrand             *StringComparisonExp      `json:"cardBrand,omitempty"`
	CardExpMonth          *IntComparisonExp         `json:"cardExpMonth,omitempty"`
	CardExpYear           *IntComparisonExp         `json:"cardExpYear,omitempty"`
	CardLast4             *StringComparisonExp      `json:"cardLast4,omitempty"`
	CreatedAt             *TimestamptzComparisonExp `json:"createdAt,omitempty"`
	ID                    *UUIDComparisonExp        `json:"id,omitempty"`
	IsDefault             *BooleanComparisonExp     `json:"isDefault,omitempty"`
	StripePaymentMethodID *StringComparisonExp      `json:"stripePaymentMethodId,omitempty"`
	User                  *UsersBoolExp             `json:"user,omitempty"`
	Workspace             *WorkspacesBoolExp        `json:"workspace,omitempty"`
	WorkspaceID           *UUIDComparisonExp        `json:"workspaceId,omitempty"`
}

// input type for inserting data into table "payment_methods"
type PaymentMethodsInsertInput struct {
	CardBrand             *string                      `json:"cardBrand,omitempty"`
	CardExpMonth          *int64                       `json:"cardExpMonth,omitempty"`
	CardExpYear           *int64                       `json:"cardExpYear,omitempty"`
	CardLast4             *string                      `json:"cardLast4,omitempty"`
	IsDefault             *bool                        `json:"isDefault,omitempty"`
	StripePaymentMethodID *string                      `json:"stripePaymentMethodId,omitempty"`
	Workspace             *WorkspacesObjRelInsertInput `json:"workspace,omitempty"`
	WorkspaceID           *string                      `json:"workspaceId,omitempty"`
}

// order by max() on columns of table "payment_methods"
type PaymentMethodsMaxOrderBy struct {
	AddedByUserID         *OrderBy `json:"addedByUserId,omitempty"`
	CardBrand             *OrderBy `json:"cardBrand,omitempty"`
	CardExpMonth          *OrderBy `json:"cardExpMonth,omitempty"`
	CardExpYear           *OrderBy `json:"cardExpYear,omitempty"`
	CardLast4             *OrderBy `json:"cardLast4,omitempty"`
	CreatedAt             *OrderBy `json:"createdAt,omitempty"`
	ID                    *OrderBy `json:"id,omitempty"`
	StripePaymentMethodID *OrderBy `json:"stripePaymentMethodId,omitempty"`
	WorkspaceID           *OrderBy `json:"workspaceId,omitempty"`
}

// order by min() on columns of table "payment_methods"
type PaymentMethodsMinOrderBy struct {
	AddedByUserID         *OrderBy `json:"addedByUserId,omitempty"`
	CardBrand             *OrderBy `json:"cardBrand,omitempty"`
	CardExpMonth          *OrderBy `json:"cardExpMonth,omitempty"`
	CardExpYear           *OrderBy `json:"cardExpYear,omitempty"`
	CardLast4             *OrderBy `json:"cardLast4,omitempty"`
	CreatedAt             *OrderBy `json:"createdAt,omitempty"`
	ID                    *OrderBy `json:"id,omitempty"`
	StripePaymentMethodID *OrderBy `json:"stripePaymentMethodId,omitempty"`
	WorkspaceID           *OrderBy `json:"workspaceId,omitempty"`
}

// response of any mutation on the table "payment_methods"
type PaymentMethodsMutationResponse struct {
	// number of rows affected by the mutation
	AffectedRows int64 `json:"affected_rows"`
	// data from the rows affected by the mutation
	Returning []*PaymentMethods `json:"returning"`
}

// input type for inserting object relation for remote table "payment_methods"
type PaymentMethodsObjRelInsertInput struct {
	Data *PaymentMethodsInsertInput `json:"data"`
	// upsert condition
	OnConflict *PaymentMethodsOnConflict `json:"on_conflict,omitempty"`
}

// on_conflict condition type for table "payment_methods"
type PaymentMethodsOnConflict struct {
	Constraint    PaymentMethodsConstraint     `json:"constraint"`
	UpdateColumns []PaymentMethodsUpdateColumn `json:"update_columns"`
	Where         *PaymentMethodsBoolExp       `json:"where,omitempty"`
}

// Ordering options when selecting data from "payment_methods".
type PaymentMethodsOrderBy struct {
	AddedByUserID         *OrderBy           `json:"addedByUserId,omitempty"`
	CardBrand             *OrderBy           `json:"cardBrand,omitempty"`
	CardExpMonth          *OrderBy           `json:"cardExpMonth,omitempty"`
	CardExpYear           *OrderBy           `json:"cardExpYear,omitempty"`
	CardLast4             *OrderBy           `json:"cardLast4,omitempty"`
	CreatedAt             *OrderBy           `json:"createdAt,omitempty"`
	ID                    *OrderBy           `json:"id,omitempty"`
	IsDefault             *OrderBy           `json:"isDefault,omitempty"`
	StripePaymentMethodID *OrderBy           `json:"stripePaymentMethodId,omitempty"`
	User                  *UsersOrderBy      `json:"user,omitempty"`
	Workspace             *WorkspacesOrderBy `json:"workspace,omitempty"`
	WorkspaceID           *OrderBy           `json:"workspaceId,omitempty"`
}

// primary key columns input for table: payment_methods
type PaymentMethodsPkColumnsInput struct {
	ID string `json:"id"`
}

// input type for updating data in table "payment_methods"
type PaymentMethodsSetInput struct {
	IsDefault *bool `json:"isDefault,omitempty"`
}

// order by stddev() on columns of table "payment_methods"
type PaymentMethodsStddevOrderBy struct {
	CardExpMonth *OrderBy `json:"cardExpMonth,omitempty"`
	CardExpYear  *OrderBy `json:"cardExpYear,omitempty"`
}

// order by stddev_pop() on columns of table "payment_methods"
type PaymentMethodsStddevPopOrderBy struct {
	CardExpMonth *OrderBy `json:"cardExpMonth,omitempty"`
	CardExpYear  *OrderBy `json:"cardExpYear,omitempty"`
}

// order by stddev_samp() on columns of table "payment_methods"
type PaymentMethodsStddevSampOrderBy struct {
	CardExpMonth *OrderBy `json:"cardExpMonth,omitempty"`
	CardExpYear  *OrderBy `json:"cardExpYear,omitempty"`
}

// Streaming cursor of the table "paymentMethods"
type PaymentMethodsStreamCursorInput struct {
	// Stream column input with initial value
	InitialValue *PaymentMethodsStreamCursorValueInput `json:"initial_value"`
	// cursor ordering
	Ordering *CursorOrdering `json:"ordering,omitempty"`
}

// Initial value of the column from where the streaming should start
type PaymentMethodsStreamCursorValueInput struct {
	AddedByUserID         *string    `json:"addedByUserId,omitempty"`
	CardBrand             *string    `json:"cardBrand,omitempty"`
	CardExpMonth          *int64     `json:"cardExpMonth,omitempty"`
	CardExpYear           *int64     `json:"cardExpYear,omitempty"`
	CardLast4             *string    `json:"cardLast4,omitempty"`
	CreatedAt             *time.Time `json:"createdAt,omitempty"`
	ID                    *string    `json:"id,omitempty"`
	IsDefault             *bool      `json:"isDefault,omitempty"`
	StripePaymentMethodID *string    `json:"stripePaymentMethodId,omitempty"`
	WorkspaceID           *string    `json:"workspaceId,omitempty"`
}

// order by sum() on columns of table "payment_methods"
type PaymentMethodsSumOrderBy struct {
	CardExpMonth *OrderBy `json:"cardExpMonth,omitempty"`
	CardExpYear  *OrderBy `json:"cardExpYear,omitempty"`
}

type PaymentMethodsUpdates struct {
	// sets the columns of the filtered rows to the given values
	Set *PaymentMethodsSetInput `json:"_set,omitempty"`
	// filter the rows which have to be updated
	Where *PaymentMethodsBoolExp `json:"where"`
}

// order by var_pop() on columns of table "payment_methods"
type PaymentMethodsVarPopOrderBy struct {
	CardExpMonth *OrderBy `json:"cardExpMonth,omitempty"`
	CardExpYear  *OrderBy `json:"cardExpYear,omitempty"`
}

// order by var_samp() on columns of table "payment_methods"
type PaymentMethodsVarSampOrderBy struct {
	CardExpMonth *OrderBy `json:"cardExpMonth,omitempty"`
	CardExpYear  *OrderBy `json:"cardExpYear,omitempty"`
}

// order by variance() on columns of table "payment_methods"
type PaymentMethodsVarianceOrderBy struct {
	CardExpMonth *OrderBy `json:"cardExpMonth,omitempty"`
	CardExpYear  *OrderBy `json:"cardExpYear,omitempty"`
}

// columns and relationships of "plans"
type Plans struct {
	// An array relationship
	Apps                               []*Apps   `json:"apps"`
	CreatedAt                          time.Time `json:"createdAt"`
	Deprecated                         bool      `json:"deprecated"`
	FeatureBackupEnabled               bool      `json:"featureBackupEnabled"`
	FeatureCustomDomainsEnabled        bool      `json:"featureCustomDomainsEnabled"`
	FeatureCustomEmailTemplatesEnabled bool      `json:"featureCustomEmailTemplatesEnabled"`
	FeatureMaxDbSize                   int64     `json:"featureMaxDbSize"`
	ID                                 string    `json:"id"`
	Individual                         bool      `json:"individual"`
	IsDefault                          bool      `json:"isDefault"`
	IsFree                             bool      `json:"isFree"`
	IsPublic                           bool      `json:"isPublic"`
	Name                               string    `json:"name"`
	// An array relationship
	Organizations []*Organizations `json:"organizations"`
	Price         int64            `json:"price"`
	Sort          int64            `json:"sort"`
	UpatedAt      time.Time        `json:"upatedAt"`
}

// Boolean expression to filter rows from the table "plans". All fields are combined with a logical 'AND'.
type PlansBoolExp struct {
	And                                []*PlansBoolExp           `json:"_and,omitempty"`
	Not                                *PlansBoolExp             `json:"_not,omitempty"`
	Or                                 []*PlansBoolExp           `json:"_or,omitempty"`
	Apps                               *AppsBoolExp              `json:"apps,omitempty"`
	CreatedAt                          *TimestamptzComparisonExp `json:"createdAt,omitempty"`
	Deprecated                         *BooleanComparisonExp     `json:"deprecated,omitempty"`
	FeatureBackupEnabled               *BooleanComparisonExp     `json:"featureBackupEnabled,omitempty"`
	FeatureCustomDomainsEnabled        *BooleanComparisonExp     `json:"featureCustomDomainsEnabled,omitempty"`
	FeatureCustomEmailTemplatesEnabled *BooleanComparisonExp     `json:"featureCustomEmailTemplatesEnabled,omitempty"`
	FeatureMaxDbSize                   *IntComparisonExp         `json:"featureMaxDbSize,omitempty"`
	ID                                 *UUIDComparisonExp        `json:"id,omitempty"`
	Individual                         *BooleanComparisonExp     `json:"individual,omitempty"`
	IsDefault                          *BooleanComparisonExp     `json:"isDefault,omitempty"`
	IsFree                             *BooleanComparisonExp     `json:"isFree,omitempty"`
	IsPublic                           *BooleanComparisonExp     `json:"isPublic,omitempty"`
	Name                               *StringComparisonExp      `json:"name,omitempty"`
	Organizations                      *OrganizationsBoolExp     `json:"organizations,omitempty"`
	Price                              *IntComparisonExp         `json:"price,omitempty"`
	Sort                               *IntComparisonExp         `json:"sort,omitempty"`
	UpatedAt                           *TimestamptzComparisonExp `json:"upatedAt,omitempty"`
}

// Ordering options when selecting data from "plans".
type PlansOrderBy struct {
	AppsAggregate                      *AppsAggregateOrderBy          `json:"apps_aggregate,omitempty"`
	CreatedAt                          *OrderBy                       `json:"createdAt,omitempty"`
	Deprecated                         *OrderBy                       `json:"deprecated,omitempty"`
	FeatureBackupEnabled               *OrderBy                       `json:"featureBackupEnabled,omitempty"`
	FeatureCustomDomainsEnabled        *OrderBy                       `json:"featureCustomDomainsEnabled,omitempty"`
	FeatureCustomEmailTemplatesEnabled *OrderBy                       `json:"featureCustomEmailTemplatesEnabled,omitempty"`
	FeatureMaxDbSize                   *OrderBy                       `json:"featureMaxDbSize,omitempty"`
	ID                                 *OrderBy                       `json:"id,omitempty"`
	Individual                         *OrderBy                       `json:"individual,omitempty"`
	IsDefault                          *OrderBy                       `json:"isDefault,omitempty"`
	IsFree                             *OrderBy                       `json:"isFree,omitempty"`
	IsPublic                           *OrderBy                       `json:"isPublic,omitempty"`
	Name                               *OrderBy                       `json:"name,omitempty"`
	OrganizationsAggregate             *OrganizationsAggregateOrderBy `json:"organizations_aggregate,omitempty"`
	Price                              *OrderBy                       `json:"price,omitempty"`
	Sort                               *OrderBy                       `json:"sort,omitempty"`
	UpatedAt                           *OrderBy                       `json:"upatedAt,omitempty"`
}

// Streaming cursor of the table "plans"
type PlansStreamCursorInput struct {
	// Stream column input with initial value
	InitialValue *PlansStreamCursorValueInput `json:"initial_value"`
	// cursor ordering
	Ordering *CursorOrdering `json:"ordering,omitempty"`
}

// Initial value of the column from where the streaming should start
type PlansStreamCursorValueInput struct {
	CreatedAt                          *time.Time `json:"createdAt,omitempty"`
	Deprecated                         *bool      `json:"deprecated,omitempty"`
	FeatureBackupEnabled               *bool      `json:"featureBackupEnabled,omitempty"`
	FeatureCustomDomainsEnabled        *bool      `json:"featureCustomDomainsEnabled,omitempty"`
	FeatureCustomEmailTemplatesEnabled *bool      `json:"featureCustomEmailTemplatesEnabled,omitempty"`
	FeatureMaxDbSize                   *int64     `json:"featureMaxDbSize,omitempty"`
	ID                                 *string    `json:"id,omitempty"`
	Individual                         *bool      `json:"individual,omitempty"`
	IsDefault                          *bool      `json:"isDefault,omitempty"`
	IsFree                             *bool      `json:"isFree,omitempty"`
	IsPublic                           *bool      `json:"isPublic,omitempty"`
	Name                               *string    `json:"name,omitempty"`
	Price                              *int64     `json:"price,omitempty"`
	Sort                               *int64     `json:"sort,omitempty"`
	UpatedAt                           *time.Time `json:"upatedAt,omitempty"`
}

type QueryRoot struct {
}

// Boolean expression to compare columns of type "region_type_enum". All fields are combined with logical 'AND'.
type RegionTypeEnumComparisonExp struct {
	Eq     *RegionTypeEnum  `json:"_eq,omitempty"`
	In     []RegionTypeEnum `json:"_in,omitempty"`
	IsNull *bool            `json:"_is_null,omitempty"`
	Neq    *RegionTypeEnum  `json:"_neq,omitempty"`
	Nin    []RegionTypeEnum `json:"_nin,omitempty"`
}

// columns and relationships of "regions"
type Regions struct {
	Active bool `json:"active"`
	// An array relationship
	AllowedOrganizations []*RegionsAllowedOrganization `json:"allowedOrganizations"`
	// An object relationship
	AllowedWorkspaces *RegionsAllowedWorkspace `json:"allowedWorkspaces,omitempty"`
	// An array relationship
	Apps    []*Apps `json:"apps"`
	AWSName string  `json:"awsName"`
	City    string  `json:"city"`
	// An object relationship
	Country         *Countries `json:"country"`
	CountryCode     string     `json:"countryCode"`
	Description     *string    `json:"description,omitempty"`
	Domain          string     `json:"domain"`
	ID              string     `json:"id"`
	IsGdprCompliant bool       `json:"isGdprCompliant"`
	Name            string     `json:"name"`
	// An array relationship
	RegionsAllowedWorkspaces []*RegionsAllowedWorkspace `json:"regions_allowed_workspaces"`
	Type                     RegionTypeEnum             `json:"type"`
}

// order by aggregate values of table "regions"
type RegionsAggregateOrderBy struct {
	Count *OrderBy           `json:"count,omitempty"`
	Max   *RegionsMaxOrderBy `json:"max,omitempty"`
	Min   *RegionsMinOrderBy `json:"min,omitempty"`
}

// columns and relationships of "regions_allowed_organization"
type RegionsAllowedOrganization struct {
	CreatedAt   time.Time `json:"createdAt"`
	Description string    `json:"description"`
	ID          string    `json:"id"`
	// An object relationship
	Organization   *Organizations `json:"organization"`
	OrganizationID string         `json:"organizationID"`
	// An object relationship
	Region    *Regions  `json:"region"`
	RegionID  string    `json:"regionID"`
	UpdatedAt time.Time `json:"updatedAt"`
}

// order by aggregate values of table "regions_allowed_organization"
type RegionsAllowedOrganizationAggregateOrderBy struct {
	Count *OrderBy                              `json:"count,omitempty"`
	Max   *RegionsAllowedOrganizationMaxOrderBy `json:"max,omitempty"`
	Min   *RegionsAllowedOrganizationMinOrderBy `json:"min,omitempty"`
}

// Boolean expression to filter rows from the table "regions_allowed_organization". All fields are combined with a logical 'AND'.
type RegionsAllowedOrganizationBoolExp struct {
	And            []*RegionsAllowedOrganizationBoolExp `json:"_and,omitempty"`
	Not            *RegionsAllowedOrganizationBoolExp   `json:"_not,omitempty"`
	Or             []*RegionsAllowedOrganizationBoolExp `json:"_or,omitempty"`
	CreatedAt      *TimestamptzComparisonExp            `json:"createdAt,omitempty"`
	Description    *StringComparisonExp                 `json:"description,omitempty"`
	ID             *UUIDComparisonExp                   `json:"id,omitempty"`
	Organization   *OrganizationsBoolExp                `json:"organization,omitempty"`
	OrganizationID *UUIDComparisonExp                   `json:"organizationID,omitempty"`
	Region         *RegionsBoolExp                      `json:"region,omitempty"`
	RegionID       *UUIDComparisonExp                   `json:"regionID,omitempty"`
	UpdatedAt      *TimestamptzComparisonExp            `json:"updatedAt,omitempty"`
}

// order by max() on columns of table "regions_allowed_organization"
type RegionsAllowedOrganizationMaxOrderBy struct {
	CreatedAt      *OrderBy `json:"createdAt,omitempty"`
	Description    *OrderBy `json:"description,omitempty"`
	ID             *OrderBy `json:"id,omitempty"`
	OrganizationID *OrderBy `json:"organizationID,omitempty"`
	RegionID       *OrderBy `json:"regionID,omitempty"`
	UpdatedAt      *OrderBy `json:"updatedAt,omitempty"`
}

// order by min() on columns of table "regions_allowed_organization"
type RegionsAllowedOrganizationMinOrderBy struct {
	CreatedAt      *OrderBy `json:"createdAt,omitempty"`
	Description    *OrderBy `json:"description,omitempty"`
	ID             *OrderBy `json:"id,omitempty"`
	OrganizationID *OrderBy `json:"organizationID,omitempty"`
	RegionID       *OrderBy `json:"regionID,omitempty"`
	UpdatedAt      *OrderBy `json:"updatedAt,omitempty"`
}

// Ordering options when selecting data from "regions_allowed_organization".
type RegionsAllowedOrganizationOrderBy struct {
	CreatedAt      *OrderBy              `json:"createdAt,omitempty"`
	Description    *OrderBy              `json:"description,omitempty"`
	ID             *OrderBy              `json:"id,omitempty"`
	Organization   *OrganizationsOrderBy `json:"organization,omitempty"`
	OrganizationID *OrderBy              `json:"organizationID,omitempty"`
	Region         *RegionsOrderBy       `json:"region,omitempty"`
	RegionID       *OrderBy              `json:"regionID,omitempty"`
	UpdatedAt      *OrderBy              `json:"updatedAt,omitempty"`
}

// Streaming cursor of the table "regions_allowed_organization"
type RegionsAllowedOrganizationStreamCursorInput struct {
	// Stream column input with initial value
	InitialValue *RegionsAllowedOrganizationStreamCursorValueInput `json:"initial_value"`
	// cursor ordering
	Ordering *CursorOrdering `json:"ordering,omitempty"`
}

// Initial value of the column from where the streaming should start
type RegionsAllowedOrganizationStreamCursorValueInput struct {
	CreatedAt      *time.Time `json:"createdAt,omitempty"`
	Description    *string    `json:"description,omitempty"`
	ID             *string    `json:"id,omitempty"`
	OrganizationID *string    `json:"organizationID,omitempty"`
	RegionID       *string    `json:"regionID,omitempty"`
	UpdatedAt      *time.Time `json:"updatedAt,omitempty"`
}

// columns and relationships of "regions_allowed_workspace"
type RegionsAllowedWorkspace struct {
	CreatedAt   time.Time `json:"created_at"`
	Description string    `json:"description"`
	ID          string    `json:"id"`
	// An object relationship
	Region    *Regions  `json:"region,omitempty"`
	RegionID  string    `json:"region_id"`
	UpdatedAt time.Time `json:"updated_at"`
	// An object relationship
	Workspace   *Workspaces `json:"workspace,omitempty"`
	WorkspaceID string      `json:"workspace_id"`
}

// order by aggregate values of table "regions_allowed_workspace"
type RegionsAllowedWorkspaceAggregateOrderBy struct {
	Count *OrderBy                           `json:"count,omitempty"`
	Max   *RegionsAllowedWorkspaceMaxOrderBy `json:"max,omitempty"`
	Min   *RegionsAllowedWorkspaceMinOrderBy `json:"min,omitempty"`
}

// Boolean expression to filter rows from the table "regions_allowed_workspace". All fields are combined with a logical 'AND'.
type RegionsAllowedWorkspaceBoolExp struct {
	And         []*RegionsAllowedWorkspaceBoolExp `json:"_and,omitempty"`
	Not         *RegionsAllowedWorkspaceBoolExp   `json:"_not,omitempty"`
	Or          []*RegionsAllowedWorkspaceBoolExp `json:"_or,omitempty"`
	CreatedAt   *TimestamptzComparisonExp         `json:"created_at,omitempty"`
	Description *StringComparisonExp              `json:"description,omitempty"`
	ID          *UUIDComparisonExp                `json:"id,omitempty"`
	Region      *RegionsBoolExp                   `json:"region,omitempty"`
	RegionID    *UUIDComparisonExp                `json:"region_id,omitempty"`
	UpdatedAt   *TimestamptzComparisonExp         `json:"updated_at,omitempty"`
	Workspace   *WorkspacesBoolExp                `json:"workspace,omitempty"`
	WorkspaceID *UUIDComparisonExp                `json:"workspace_id,omitempty"`
}

// order by max() on columns of table "regions_allowed_workspace"
type RegionsAllowedWorkspaceMaxOrderBy struct {
	CreatedAt   *OrderBy `json:"created_at,omitempty"`
	Description *OrderBy `json:"description,omitempty"`
	ID          *OrderBy `json:"id,omitempty"`
	RegionID    *OrderBy `json:"region_id,omitempty"`
	UpdatedAt   *OrderBy `json:"updated_at,omitempty"`
	WorkspaceID *OrderBy `json:"workspace_id,omitempty"`
}

// order by min() on columns of table "regions_allowed_workspace"
type RegionsAllowedWorkspaceMinOrderBy struct {
	CreatedAt   *OrderBy `json:"created_at,omitempty"`
	Description *OrderBy `json:"description,omitempty"`
	ID          *OrderBy `json:"id,omitempty"`
	RegionID    *OrderBy `json:"region_id,omitempty"`
	UpdatedAt   *OrderBy `json:"updated_at,omitempty"`
	WorkspaceID *OrderBy `json:"workspace_id,omitempty"`
}

// Ordering options when selecting data from "regions_allowed_workspace".
type RegionsAllowedWorkspaceOrderBy struct {
	CreatedAt   *OrderBy           `json:"created_at,omitempty"`
	Description *OrderBy           `json:"description,omitempty"`
	ID          *OrderBy           `json:"id,omitempty"`
	Region      *RegionsOrderBy    `json:"region,omitempty"`
	RegionID    *OrderBy           `json:"region_id,omitempty"`
	UpdatedAt   *OrderBy           `json:"updated_at,omitempty"`
	Workspace   *WorkspacesOrderBy `json:"workspace,omitempty"`
	WorkspaceID *OrderBy           `json:"workspace_id,omitempty"`
}

// Streaming cursor of the table "regions_allowed_workspace"
type RegionsAllowedWorkspaceStreamCursorInput struct {
	// Stream column input with initial value
	InitialValue *RegionsAllowedWorkspaceStreamCursorValueInput `json:"initial_value"`
	// cursor ordering
	Ordering *CursorOrdering `json:"ordering,omitempty"`
}

// Initial value of the column from where the streaming should start
type RegionsAllowedWorkspaceStreamCursorValueInput struct {
	CreatedAt   *time.Time `json:"created_at,omitempty"`
	Description *string    `json:"description,omitempty"`
	ID          *string    `json:"id,omitempty"`
	RegionID    *string    `json:"region_id,omitempty"`
	UpdatedAt   *time.Time `json:"updated_at,omitempty"`
	WorkspaceID *string    `json:"workspace_id,omitempty"`
}

// Boolean expression to filter rows from the table "regions". All fields are combined with a logical 'AND'.
type RegionsBoolExp struct {
	And                      []*RegionsBoolExp                  `json:"_and,omitempty"`
	Not                      *RegionsBoolExp                    `json:"_not,omitempty"`
	Or                       []*RegionsBoolExp                  `json:"_or,omitempty"`
	Active                   *BooleanComparisonExp              `json:"active,omitempty"`
	AllowedOrganizations     *RegionsAllowedOrganizationBoolExp `json:"allowedOrganizations,omitempty"`
	AllowedWorkspaces        *RegionsAllowedWorkspaceBoolExp    `json:"allowedWorkspaces,omitempty"`
	Apps                     *AppsBoolExp                       `json:"apps,omitempty"`
	AWSName                  *StringComparisonExp               `json:"awsName,omitempty"`
	City                     *StringComparisonExp               `json:"city,omitempty"`
	Country                  *CountriesBoolExp                  `json:"country,omitempty"`
	CountryCode              *StringComparisonExp               `json:"countryCode,omitempty"`
	Description              *StringComparisonExp               `json:"description,omitempty"`
	Domain                   *StringComparisonExp               `json:"domain,omitempty"`
	ID                       *UUIDComparisonExp                 `json:"id,omitempty"`
	IsGdprCompliant          *BooleanComparisonExp              `json:"isGdprCompliant,omitempty"`
	Name                     *StringComparisonExp               `json:"name,omitempty"`
	RegionsAllowedWorkspaces *RegionsAllowedWorkspaceBoolExp    `json:"regions_allowed_workspaces,omitempty"`
	Type                     *RegionTypeEnumComparisonExp       `json:"type,omitempty"`
}

// order by max() on columns of table "regions"
type RegionsMaxOrderBy struct {
	AWSName     *OrderBy `json:"awsName,omitempty"`
	City        *OrderBy `json:"city,omitempty"`
	CountryCode *OrderBy `json:"countryCode,omitempty"`
	Description *OrderBy `json:"description,omitempty"`
	Domain      *OrderBy `json:"domain,omitempty"`
	ID          *OrderBy `json:"id,omitempty"`
	Name        *OrderBy `json:"name,omitempty"`
}

// order by min() on columns of table "regions"
type RegionsMinOrderBy struct {
	AWSName     *OrderBy `json:"awsName,omitempty"`
	City        *OrderBy `json:"city,omitempty"`
	CountryCode *OrderBy `json:"countryCode,omitempty"`
	Description *OrderBy `json:"description,omitempty"`
	Domain      *OrderBy `json:"domain,omitempty"`
	ID          *OrderBy `json:"id,omitempty"`
	Name        *OrderBy `json:"name,omitempty"`
}

// Ordering options when selecting data from "regions".
type RegionsOrderBy struct {
	Active                            *OrderBy                                    `json:"active,omitempty"`
	AllowedOrganizationsAggregate     *RegionsAllowedOrganizationAggregateOrderBy `json:"allowedOrganizations_aggregate,omitempty"`
	AllowedWorkspaces                 *RegionsAllowedWorkspaceOrderBy             `json:"allowedWorkspaces,omitempty"`
	AppsAggregate                     *AppsAggregateOrderBy                       `json:"apps_aggregate,omitempty"`
	AWSName                           *OrderBy                                    `json:"awsName,omitempty"`
	City                              *OrderBy                                    `json:"city,omitempty"`
	Country                           *CountriesOrderBy                           `json:"country,omitempty"`
	CountryCode                       *OrderBy                                    `json:"countryCode,omitempty"`
	Description                       *OrderBy                                    `json:"description,omitempty"`
	Domain                            *OrderBy                                    `json:"domain,omitempty"`
	ID                                *OrderBy                                    `json:"id,omitempty"`
	IsGdprCompliant                   *OrderBy                                    `json:"isGdprCompliant,omitempty"`
	Name                              *OrderBy                                    `json:"name,omitempty"`
	RegionsAllowedWorkspacesAggregate *RegionsAllowedWorkspaceAggregateOrderBy    `json:"regions_allowed_workspaces_aggregate,omitempty"`
	Type                              *OrderBy                                    `json:"type,omitempty"`
}

// Streaming cursor of the table "regions"
type RegionsStreamCursorInput struct {
	// Stream column input with initial value
	InitialValue *RegionsStreamCursorValueInput `json:"initial_value"`
	// cursor ordering
	Ordering *CursorOrdering `json:"ordering,omitempty"`
}

// Initial value of the column from where the streaming should start
type RegionsStreamCursorValueInput struct {
	Active          *bool           `json:"active,omitempty"`
	AWSName         *string         `json:"awsName,omitempty"`
	City            *string         `json:"city,omitempty"`
	CountryCode     *string         `json:"countryCode,omitempty"`
	Description     *string         `json:"description,omitempty"`
	Domain          *string         `json:"domain,omitempty"`
	ID              *string         `json:"id,omitempty"`
	IsGdprCompliant *bool           `json:"isGdprCompliant,omitempty"`
	Name            *string         `json:"name,omitempty"`
	Type            *RegionTypeEnum `json:"type,omitempty"`
}

// columns and relationships of "run_service"
type RunService struct {
	// An object relationship
	App       *Apps                   `json:"app"`
	AppID     string                  `json:"appID"`
	Config    *ConfigRunServiceConfig `json:"config,omitempty"`
	CreatedAt time.Time               `json:"createdAt"`
	ID        string                  `json:"id"`
	Subdomain string                  `json:"subdomain"`
	UpdatedAt time.Time               `json:"updatedAt"`
}

// aggregated selection of "run_service"
type RunServiceAggregate struct {
	Aggregate *RunServiceAggregateFields `json:"aggregate,omitempty"`
	Nodes     []*RunService              `json:"nodes"`
}

type RunServiceAggregateBoolExp struct {
	Count *RunServiceAggregateBoolExpCount `json:"count,omitempty"`
}

type RunServiceAggregateBoolExpCount struct {
	Arguments []RunServiceSelectColumn `json:"arguments,omitempty"`
	Distinct  *bool                    `json:"distinct,omitempty"`
	Filter    *RunServiceBoolExp       `json:"filter,omitempty"`
	Predicate *IntComparisonExp        `json:"predicate"`
}

// aggregate fields of "run_service"
type RunServiceAggregateFields struct {
	Count int64                `json:"count"`
	Max   *RunServiceMaxFields `json:"max,omitempty"`
	Min   *RunServiceMinFields `json:"min,omitempty"`
}

// order by aggregate values of table "run_service"
type RunServiceAggregateOrderBy struct {
	Count *OrderBy              `json:"count,omitempty"`
	Max   *RunServiceMaxOrderBy `json:"max,omitempty"`
	Min   *RunServiceMinOrderBy `json:"min,omitempty"`
}

// Boolean expression to filter rows from the table "run_service". All fields are combined with a logical 'AND'.
type RunServiceBoolExp struct {
	And       []*RunServiceBoolExp      `json:"_and,omitempty"`
	Not       *RunServiceBoolExp        `json:"_not,omitempty"`
	Or        []*RunServiceBoolExp      `json:"_or,omitempty"`
	App       *AppsBoolExp              `json:"app,omitempty"`
	AppID     *UUIDComparisonExp        `json:"appID,omitempty"`
	CreatedAt *TimestamptzComparisonExp `json:"createdAt,omitempty"`
	ID        *UUIDComparisonExp        `json:"id,omitempty"`
	Subdomain *StringComparisonExp      `json:"subdomain,omitempty"`
	UpdatedAt *TimestamptzComparisonExp `json:"updatedAt,omitempty"`
}

// aggregate max on columns
type RunServiceMaxFields struct {
	AppID     *string    `json:"appID,omitempty"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	ID        *string    `json:"id,omitempty"`
	Subdomain *string    `json:"subdomain,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
}

// order by max() on columns of table "run_service"
type RunServiceMaxOrderBy struct {
	AppID     *OrderBy `json:"appID,omitempty"`
	CreatedAt *OrderBy `json:"createdAt,omitempty"`
	ID        *OrderBy `json:"id,omitempty"`
	Subdomain *OrderBy `json:"subdomain,omitempty"`
	UpdatedAt *OrderBy `json:"updatedAt,omitempty"`
}

// aggregate min on columns
type RunServiceMinFields struct {
	AppID     *string    `json:"appID,omitempty"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	ID        *string    `json:"id,omitempty"`
	Subdomain *string    `json:"subdomain,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
}

// order by min() on columns of table "run_service"
type RunServiceMinOrderBy struct {
	AppID     *OrderBy `json:"appID,omitempty"`
	CreatedAt *OrderBy `json:"createdAt,omitempty"`
	ID        *OrderBy `json:"id,omitempty"`
	Subdomain *OrderBy `json:"subdomain,omitempty"`
	UpdatedAt *OrderBy `json:"updatedAt,omitempty"`
}

// response of any mutation on the table "run_service"
type RunServiceMutationResponse struct {
	// number of rows affected by the mutation
	AffectedRows int64 `json:"affected_rows"`
	// data from the rows affected by the mutation
	Returning []*RunService `json:"returning"`
}

// Ordering options when selecting data from "run_service".
type RunServiceOrderBy struct {
	App       *AppsOrderBy `json:"app,omitempty"`
	AppID     *OrderBy     `json:"appID,omitempty"`
	CreatedAt *OrderBy     `json:"createdAt,omitempty"`
	ID        *OrderBy     `json:"id,omitempty"`
	Subdomain *OrderBy     `json:"subdomain,omitempty"`
	UpdatedAt *OrderBy     `json:"updatedAt,omitempty"`
}

// Streaming cursor of the table "run_service"
type RunServiceStreamCursorInput struct {
	// Stream column input with initial value
	InitialValue *RunServiceStreamCursorValueInput `json:"initial_value"`
	// cursor ordering
	Ordering *CursorOrdering `json:"ordering,omitempty"`
}

// Initial value of the column from where the streaming should start
type RunServiceStreamCursorValueInput struct {
	AppID     *string    `json:"appID,omitempty"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	ID        *string    `json:"id,omitempty"`
	Subdomain *string    `json:"subdomain,omitempty"`
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
}

// Boolean expression to compare columns of type "software_type_enum". All fields are combined with logical 'AND'.
type SoftwareTypeEnumComparisonExp struct {
	Eq     *SoftwareTypeEnum  `json:"_eq,omitempty"`
	In     []SoftwareTypeEnum `json:"_in,omitempty"`
	IsNull *bool              `json:"_is_null,omitempty"`
	Neq    *SoftwareTypeEnum  `json:"_neq,omitempty"`
	Nin    []SoftwareTypeEnum `json:"_nin,omitempty"`
}

// columns and relationships of "software_versions"
type SoftwareVersions struct {
	ID       string           `json:"id"`
	Software SoftwareTypeEnum `json:"software"`
	Version  string           `json:"version"`
}

// Boolean expression to filter rows from the table "software_versions". All fields are combined with a logical 'AND'.
type SoftwareVersionsBoolExp struct {
	And      []*SoftwareVersionsBoolExp     `json:"_and,omitempty"`
	Not      *SoftwareVersionsBoolExp       `json:"_not,omitempty"`
	Or       []*SoftwareVersionsBoolExp     `json:"_or,omitempty"`
	ID       *UUIDComparisonExp             `json:"id,omitempty"`
	Software *SoftwareTypeEnumComparisonExp `json:"software,omitempty"`
	Version  *StringComparisonExp           `json:"version,omitempty"`
}

// Ordering options when selecting data from "software_versions".
type SoftwareVersionsOrderBy struct {
	ID       *OrderBy `json:"id,omitempty"`
	Software *OrderBy `json:"software,omitempty"`
	Version  *OrderBy `json:"version,omitempty"`
}

// Streaming cursor of the table "software_versions"
type SoftwareVersionsStreamCursorInput struct {
	// Stream column input with initial value
	InitialValue *SoftwareVersionsStreamCursorValueInput `json:"initial_value"`
	// cursor ordering
	Ordering *CursorOrdering `json:"ordering,omitempty"`
}

// Initial value of the column from where the streaming should start
type SoftwareVersionsStreamCursorValueInput struct {
	ID       *string           `json:"id,omitempty"`
	Software *SoftwareTypeEnum `json:"software,omitempty"`
	Version  *string           `json:"version,omitempty"`
}

type SubscriptionRoot struct {
	// fetch data from the table: "announcements_read" using primary key columns
	AnnouncementRead *AnnouncementsRead `json:"announcementRead,omitempty"`
	// fetch data from the table: "announcements"
	Announcements []*Announcements `json:"announcements"`
	// fetch data from the table: "announcements_read"
	AnnouncementsRead []*AnnouncementsRead `json:"announcementsRead"`
	// fetch data from the table in a streaming manner: "announcements_read"
	AnnouncementsReadStream []*AnnouncementsRead `json:"announcementsReadStream"`
	// fetch data from the table: "announcements" using primary key columns
	AnnouncementsByPk *Announcements `json:"announcements_by_pk,omitempty"`
	// fetch data from the table in a streaming manner: "announcements"
	AnnouncementsStream []*Announcements `json:"announcements_stream"`
	// fetch data from the table: "apps" using primary key columns
	App *Apps `json:"app,omitempty"`
	// fetch data from the table: "app_state_history"
	AppStateHistories []*AppStateHistory `json:"appStateHistories"`
	// fetch data from the table: "app_state_history" using primary key columns
	AppStateHistory *AppStateHistory `json:"appStateHistory,omitempty"`
	// fetch data from the table in a streaming manner: "app_state_history"
	AppStateHistoryStream []*AppStateHistory `json:"appStateHistory_stream"`
	// An array relationship
	Apps []*Apps `json:"apps"`
	// fetch data from the table in a streaming manner: "apps"
	AppsStream []*Apps `json:"apps_stream"`
	// fetch data from the table: "auth.refresh_tokens" using primary key columns
	AuthRefreshToken *AuthRefreshTokens `json:"authRefreshToken,omitempty"`
	// fetch data from the table: "auth.refresh_tokens"
	AuthRefreshTokens []*AuthRefreshTokens `json:"authRefreshTokens"`
	// fetch data from the table in a streaming manner: "auth.refresh_tokens"
	AuthRefreshTokensStream []*AuthRefreshTokens `json:"authRefreshTokens_stream"`
	// fetch data from the table: "auth.user_providers" using primary key columns
	AuthUserProvider *AuthUserProviders `json:"authUserProvider,omitempty"`
	// fetch data from the table: "auth.user_providers"
	AuthUserProviders []*AuthUserProviders `json:"authUserProviders"`
	// fetch data from the table in a streaming manner: "auth.user_providers"
	AuthUserProvidersStream []*AuthUserProviders `json:"authUserProviders_stream"`
	// fetch data from the table: "auth.user_security_keys" using primary key columns
	AuthUserSecurityKey *AuthUserSecurityKeys `json:"authUserSecurityKey,omitempty"`
	// fetch data from the table: "auth.user_security_keys"
	AuthUserSecurityKeys []*AuthUserSecurityKeys `json:"authUserSecurityKeys"`
	// fetch data from the table in a streaming manner: "auth.user_security_keys"
	AuthUserSecurityKeysStream []*AuthUserSecurityKeys `json:"authUserSecurityKeys_stream"`
	// fetch data from the table: "backups" using primary key columns
	Backup *Backups `json:"backup,omitempty"`
	// An array relationship
	Backups []*Backups `json:"backups"`
	// fetch data from the table in a streaming manner: "backups"
	BackupsStream []*Backups `json:"backups_stream"`
	// fetch data from the table: "cli_tokens" using primary key columns
	CliToken *CliTokens `json:"cliToken,omitempty"`
	// An array relationship
	CliTokens []*CliTokens `json:"cliTokens"`
	// fetch data from the table in a streaming manner: "cli_tokens"
	CliTokensStream []*CliTokens `json:"cliTokens_stream"`
	// fetch data from the table: "continents"
	Continents []*Continents `json:"continents"`
	// fetch data from the table: "continents" using primary key columns
	ContinentsByPk *Continents `json:"continents_by_pk,omitempty"`
	// fetch data from the table in a streaming manner: "continents"
	ContinentsStream []*Continents `json:"continents_stream"`
	// An array relationship
	Countries []*Countries `json:"countries"`
	// fetch data from the table: "countries" using primary key columns
	CountriesByPk *Countries `json:"countries_by_pk,omitempty"`
	// fetch data from the table in a streaming manner: "countries"
	CountriesStream []*Countries `json:"countries_stream"`
	// fetch data from the table: "deployments" using primary key columns
	Deployment *Deployments `json:"deployment,omitempty"`
	// fetch data from the table: "deployment_logs" using primary key columns
	DeploymentLog *DeploymentLogs `json:"deploymentLog,omitempty"`
	// An array relationship
	DeploymentLogs []*DeploymentLogs `json:"deploymentLogs"`
	// fetch data from the table in a streaming manner: "deployment_logs"
	DeploymentLogsStream []*DeploymentLogs `json:"deploymentLogs_stream"`
	// An array relationship
	Deployments []*Deployments `json:"deployments"`
	// fetch data from the table in a streaming manner: "deployments"
	DeploymentsStream []*Deployments `json:"deployments_stream"`
	// fetch data from the table: "feature_flags" using primary key columns
	FeatureFlag *FeatureFlags `json:"featureFlag,omitempty"`
	// An array relationship
	FeatureFlags []*FeatureFlags `json:"featureFlags"`
	// fetch data from the table in a streaming manner: "feature_flags"
	FeatureFlagsStream []*FeatureFlags `json:"featureFlags_stream"`
	// fetch data from the table: "storage.files" using primary key columns
	File *Files `json:"file,omitempty"`
	// fetch data from the table: "storage.files"
	Files []*Files `json:"files"`
	// fetch data from the table in a streaming manner: "storage.files"
	FilesStream []*Files `json:"files_stream"`
	// fetch data from the table: "github_app_installations" using primary key columns
	GithubAppInstallation *GithubAppInstallations `json:"githubAppInstallation,omitempty"`
	// fetch data from the table: "github_app_installations"
	GithubAppInstallations []*GithubAppInstallations `json:"githubAppInstallations"`
	// fetch data from the table in a streaming manner: "github_app_installations"
	GithubAppInstallationsStream []*GithubAppInstallations `json:"githubAppInstallations_stream"`
	// An array relationship
	GithubRepositories []*GithubRepositories `json:"githubRepositories"`
	// fetch data from the table in a streaming manner: "github_repositories"
	GithubRepositoriesStream []*GithubRepositories `json:"githubRepositories_stream"`
	// fetch data from the table: "github_repositories" using primary key columns
	GithubRepository *GithubRepositories `json:"githubRepository,omitempty"`
	// fetch data from the table: "organizations" using primary key columns
	Organization *Organizations `json:"organization,omitempty"`
	// fetch data from the table: "organization_members" using primary key columns
	OrganizationMember *OrganizationMembers `json:"organizationMember,omitempty"`
	// fetch data from the table: "organization_member_invites" using primary key columns
	OrganizationMemberInvite *OrganizationMemberInvites `json:"organizationMemberInvite,omitempty"`
	// fetch data from the table: "organization_member_invites"
	OrganizationMemberInvites []*OrganizationMemberInvites `json:"organizationMemberInvites"`
	// fetch data from the table in a streaming manner: "organization_member_invites"
	OrganizationMemberInvitesStream []*OrganizationMemberInvites `json:"organizationMemberInvitesStream"`
	// fetch data from the table: "organization_members"
	OrganizationMembers []*OrganizationMembers `json:"organizationMembers"`
	// fetch data from the table in a streaming manner: "organization_members"
	OrganizationMembersStream []*OrganizationMembers `json:"organizationMembersStream"`
	// fetch data from the table: "organization_new_request" using primary key columns
	OrganizationNewRequest *OrganizationNewRequest `json:"organizationNewRequest,omitempty"`
	// fetch data from the table: "organization_new_request"
	OrganizationNewRequests []*OrganizationNewRequest `json:"organizationNewRequests"`
	// fetch data from the table in a streaming manner: "organization_new_request"
	OrganizationNewRequestsStream []*OrganizationNewRequest `json:"organizationNewRequestsStream"`
	// An array relationship
	Organizations []*Organizations `json:"organizations"`
	// fetch data from the table in a streaming manner: "organizations"
	OrganizationsSteam []*Organizations `json:"organizationsSteam"`
	// fetch data from the table: "payment_methods" using primary key columns
	PaymentMethod *PaymentMethods `json:"paymentMethod,omitempty"`
	// An array relationship
	PaymentMethods []*PaymentMethods `json:"paymentMethods"`
	// fetch data from the table in a streaming manner: "payment_methods"
	PaymentMethodsStream []*PaymentMethods `json:"paymentMethods_stream"`
	// fetch data from the table: "plans" using primary key columns
	Plan *Plans `json:"plan,omitempty"`
	// fetch data from the table: "plans"
	Plans []*Plans `json:"plans"`
	// fetch data from the table in a streaming manner: "plans"
	PlansStream []*Plans `json:"plans_stream"`
	// fetch data from the table: "regions"
	Regions []*Regions `json:"regions"`
	// fetch data from the table: "regions_allowed_organization" using primary key columns
	RegionsAllowedOrganization *RegionsAllowedOrganization `json:"regionsAllowedOrganization,omitempty"`
	// fetch data from the table: "regions_allowed_organization"
	RegionsAllowedOrganizations []*RegionsAllowedOrganization `json:"regionsAllowedOrganizations"`
	// fetch data from the table in a streaming manner: "regions_allowed_organization"
	RegionsAllowedOrganizationsStream []*RegionsAllowedOrganization `json:"regionsAllowedOrganizationsStream"`
	// fetch data from the table in a streaming manner: "regions_allowed_workspace"
	RegionsAllowedWorkspaceStream []*RegionsAllowedWorkspace `json:"regions_allowed_workspace_stream"`
	// fetch data from the table: "regions" using primary key columns
	RegionsByPk *Regions `json:"regions_by_pk,omitempty"`
	// fetch data from the table in a streaming manner: "regions"
	RegionsStream []*Regions `json:"regions_stream"`
	// fetch data from the table: "run_service" using primary key columns
	RunService *RunService `json:"runService,omitempty"`
	// An array relationship
	RunServices []*RunService `json:"runServices"`
	// fetch aggregated fields from the table: "run_service"
	RunServicesAggregate *RunServiceAggregate `json:"runServicesAggregate"`
	// fetch data from the table in a streaming manner: "run_service"
	RunServiceStream []*RunService `json:"run_service_stream"`
	// fetch data from the table: "regions_allowed_workspace" using primary key columns
	SelectRegionsAllowedWorkspace *RegionsAllowedWorkspace `json:"selectRegionsAllowedWorkspace,omitempty"`
	// fetch data from the table: "regions_allowed_workspace"
	SelectRegionsAllowedWorkspaces []*RegionsAllowedWorkspace `json:"selectRegionsAllowedWorkspaces"`
	// fetch data from the table: "software_versions" using primary key columns
	SoftwareVersion *SoftwareVersions `json:"softwareVersion,omitempty"`
	// fetch data from the table: "software_versions"
	SoftwareVersions []*SoftwareVersions `json:"softwareVersions"`
	// fetch data from the table in a streaming manner: "software_versions"
	SoftwareVersionsStream []*SoftwareVersions `json:"softwareVersionsStream"`
	// fetch data from the table: "auth.users" using primary key columns
	User *Users `json:"user,omitempty"`
	// fetch data from the table: "auth.users"
	Users []*Users `json:"users"`
	// fetch data from the table in a streaming manner: "auth.users"
	UsersStream []*Users `json:"users_stream"`
	// fetch data from the table: "workspaces" using primary key columns
	Workspace *Workspaces `json:"workspace,omitempty"`
	// fetch data from the table: "workspace_members" using primary key columns
	WorkspaceMember *WorkspaceMembers `json:"workspaceMember,omitempty"`
	// fetch data from the table: "workspace_member_invites" using primary key columns
	WorkspaceMemberInvite *WorkspaceMemberInvites `json:"workspaceMemberInvite,omitempty"`
	// An array relationship
	WorkspaceMemberInvites []*WorkspaceMemberInvites `json:"workspaceMemberInvites"`
	// fetch data from the table in a streaming manner: "workspace_member_invites"
	WorkspaceMemberInvitesStream []*WorkspaceMemberInvites `json:"workspaceMemberInvites_stream"`
	// An array relationship
	WorkspaceMembers []*WorkspaceMembers `json:"workspaceMembers"`
	// fetch data from the table in a streaming manner: "workspace_members"
	WorkspaceMembersStream []*WorkspaceMembers `json:"workspaceMembers_stream"`
	// An array relationship
	Workspaces []*Workspaces `json:"workspaces"`
	// fetch data from the table in a streaming manner: "workspaces"
	WorkspacesStream []*Workspaces `json:"workspaces_stream"`
}

// Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
type TimestamptzComparisonExp struct {
	Eq     *time.Time   `json:"_eq,omitempty"`
	Gt     *time.Time   `json:"_gt,omitempty"`
	Gte    *time.Time   `json:"_gte,omitempty"`
	In     []*time.Time `json:"_in,omitempty"`
	IsNull *bool        `json:"_is_null,omitempty"`
	Lt     *time.Time   `json:"_lt,omitempty"`
	Lte    *time.Time   `json:"_lte,omitempty"`
	Neq    *time.Time   `json:"_neq,omitempty"`
	Nin    []*time.Time `json:"_nin,omitempty"`
}

// User account information. Don't modify its structure as Hasura Auth relies on it to function properly.
type Users struct {
	ActiveMfaType *string `json:"activeMfaType,omitempty"`
	// An array relationship
	Apps      []*Apps `json:"apps"`
	AvatarURL string  `json:"avatarUrl"`
	// An array relationship
	CliTokens []*CliTokens `json:"cliTokens"`
	// An array relationship
	CreatorOfWorkspaces []*Workspaces `json:"creatorOfWorkspaces"`
	DisplayName         string        `json:"displayName"`
	Email               *string       `json:"email,omitempty"`
	// An array relationship
	GithubAppInstallations []*GithubAppInstallations `json:"github_app_installations"`
	ID                     string                    `json:"id"`
	// An array relationship
	OrganizationMembership []*OrganizationMembers `json:"organizationMembership"`
	// An array relationship
	PaymentMethods []*PaymentMethods `json:"payment_methods"`
	// An array relationship
	RefreshTokens []*AuthRefreshTokens `json:"refreshTokens"`
	// An array relationship
	SecurityKeys []*AuthUserSecurityKeys `json:"securityKeys"`
	// An array relationship
	UserProviders []*AuthUserProviders `json:"userProviders"`
	// An array relationship
	WorkspaceMemberInvitesByInvitedByUserID []*WorkspaceMemberInvites `json:"workspaceMemberInvitesByInvitedByUserId"`
	// An array relationship
	WorkspaceMembers []*WorkspaceMembers `json:"workspaceMembers"`
	// An array relationship
	WorkspaceMemberInvites []*WorkspaceMemberInvites `json:"workspace_member_invites"`
}

// Boolean expression to filter rows from the table "auth.users". All fields are combined with a logical 'AND'.
type UsersBoolExp struct {
	And                                     []*UsersBoolExp                `json:"_and,omitempty"`
	Not                                     *UsersBoolExp                  `json:"_not,omitempty"`
	Or                                      []*UsersBoolExp                `json:"_or,omitempty"`
	ActiveMfaType                           *StringComparisonExp           `json:"activeMfaType,omitempty"`
	Apps                                    *AppsBoolExp                   `json:"apps,omitempty"`
	AvatarURL                               *StringComparisonExp           `json:"avatarUrl,omitempty"`
	CliTokens                               *CliTokensBoolExp              `json:"cliTokens,omitempty"`
	CreatorOfWorkspaces                     *WorkspacesBoolExp             `json:"creatorOfWorkspaces,omitempty"`
	DisplayName                             *StringComparisonExp           `json:"displayName,omitempty"`
	Email                                   *CitextComparisonExp           `json:"email,omitempty"`
	GithubAppInstallations                  *GithubAppInstallationsBoolExp `json:"github_app_installations,omitempty"`
	ID                                      *UUIDComparisonExp             `json:"id,omitempty"`
	OrganizationMembership                  *OrganizationMembersBoolExp    `json:"organizationMembership,omitempty"`
	PaymentMethods                          *PaymentMethodsBoolExp         `json:"payment_methods,omitempty"`
	RefreshTokens                           *AuthRefreshTokensBoolExp      `json:"refreshTokens,omitempty"`
	SecurityKeys                            *AuthUserSecurityKeysBoolExp   `json:"securityKeys,omitempty"`
	UserProviders                           *AuthUserProvidersBoolExp      `json:"userProviders,omitempty"`
	WorkspaceMemberInvitesByInvitedByUserID *WorkspaceMemberInvitesBoolExp `json:"workspaceMemberInvitesByInvitedByUserId,omitempty"`
	WorkspaceMembers                        *WorkspaceMembersBoolExp       `json:"workspaceMembers,omitempty"`
	WorkspaceMemberInvites                  *WorkspaceMemberInvitesBoolExp `json:"workspace_member_invites,omitempty"`
}

// response of any mutation on the table "auth.users"
type UsersMutationResponse struct {
	// number of rows affected by the mutation
	AffectedRows int64 `json:"affected_rows"`
	// data from the rows affected by the mutation
	Returning []*Users `json:"returning"`
}

// Ordering options when selecting data from "auth.users".
type UsersOrderBy struct {
	ActiveMfaType                                    *OrderBy                                `json:"activeMfaType,omitempty"`
	AppsAggregate                                    *AppsAggregateOrderBy                   `json:"apps_aggregate,omitempty"`
	AvatarURL                                        *OrderBy                                `json:"avatarUrl,omitempty"`
	CliTokensAggregate                               *CliTokensAggregateOrderBy              `json:"cliTokens_aggregate,omitempty"`
	CreatorOfWorkspacesAggregate                     *WorkspacesAggregateOrderBy             `json:"creatorOfWorkspaces_aggregate,omitempty"`
	DisplayName                                      *OrderBy                                `json:"displayName,omitempty"`
	Email                                            *OrderBy                                `json:"email,omitempty"`
	GithubAppInstallationsAggregate                  *GithubAppInstallationsAggregateOrderBy `json:"github_app_installations_aggregate,omitempty"`
	ID                                               *OrderBy                                `json:"id,omitempty"`
	OrganizationMembershipAggregate                  *OrganizationMembersAggregateOrderBy    `json:"organizationMembership_aggregate,omitempty"`
	PaymentMethodsAggregate                          *PaymentMethodsAggregateOrderBy         `json:"payment_methods_aggregate,omitempty"`
	RefreshTokensAggregate                           *AuthRefreshTokensAggregateOrderBy      `json:"refreshTokens_aggregate,omitempty"`
	SecurityKeysAggregate                            *AuthUserSecurityKeysAggregateOrderBy   `json:"securityKeys_aggregate,omitempty"`
	UserProvidersAggregate                           *AuthUserProvidersAggregateOrderBy      `json:"userProviders_aggregate,omitempty"`
	WorkspaceMemberInvitesByInvitedByUserIDAggregate *WorkspaceMemberInvitesAggregateOrderBy `json:"workspaceMemberInvitesByInvitedByUserId_aggregate,omitempty"`
	WorkspaceMembersAggregate                        *WorkspaceMembersAggregateOrderBy       `json:"workspaceMembers_aggregate,omitempty"`
	WorkspaceMemberInvitesAggregate                  *WorkspaceMemberInvitesAggregateOrderBy `json:"workspace_member_invites_aggregate,omitempty"`
}

// primary key columns input for table: auth.users
type UsersPkColumnsInput struct {
	ID string `json:"id"`
}

// input type for updating data in table "auth.users"
type UsersSetInput struct {
	DisplayName *string `json:"displayName,omitempty"`
}

// Streaming cursor of the table "users"
type UsersStreamCursorInput struct {
	// Stream column input with initial value
	InitialValue *UsersStreamCursorValueInput `json:"initial_value"`
	// cursor ordering
	Ordering *CursorOrdering `json:"ordering,omitempty"`
}

// Initial value of the column from where the streaming should start
type UsersStreamCursorValueInput struct {
	ActiveMfaType *string `json:"activeMfaType,omitempty"`
	AvatarURL     *string `json:"avatarUrl,omitempty"`
	DisplayName   *string `json:"displayName,omitempty"`
	Email         *string `json:"email,omitempty"`
	ID            *string `json:"id,omitempty"`
}

type UsersUpdates struct {
	// sets the columns of the filtered rows to the given values
	Set *UsersSetInput `json:"_set,omitempty"`
	// filter the rows which have to be updated
	Where *UsersBoolExp `json:"where"`
}

// Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'.
type UUIDComparisonExp struct {
	Eq     *string  `json:"_eq,omitempty"`
	Gt     *string  `json:"_gt,omitempty"`
	Gte    *string  `json:"_gte,omitempty"`
	In     []string `json:"_in,omitempty"`
	IsNull *bool    `json:"_is_null,omitempty"`
	Lt     *string  `json:"_lt,omitempty"`
	Lte    *string  `json:"_lte,omitempty"`
	Neq    *string  `json:"_neq,omitempty"`
	Nin    []string `json:"_nin,omitempty"`
}

// columns and relationships of "workspace_member_invites"
type WorkspaceMemberInvites struct {
	CreatedAt time.Time `json:"createdAt"`
	Email     string    `json:"email"`
	ID        string    `json:"id"`
	// An object relationship
	InvitedByUser   *Users `json:"invitedByUser"`
	InvitedByUserID string `json:"invitedByUserId"`
	// owner or member
	MemberType string    `json:"memberType"`
	UpdatedAt  time.Time `json:"updatedAt"`
	// An object relationship
	UserByEmail *Users `json:"userByEmail,omitempty"`
	// An object relationship
	Workspace   *Workspaces `json:"workspace"`
	WorkspaceID string      `json:"workspaceId"`
}

// order by aggregate values of table "workspace_member_invites"
type WorkspaceMemberInvitesAggregateOrderBy struct {
	Count *OrderBy                          `json:"count,omitempty"`
	Max   *WorkspaceMemberInvitesMaxOrderBy `json:"max,omitempty"`
	Min   *WorkspaceMemberInvitesMinOrderBy `json:"min,omitempty"`
}

// input type for inserting array relation for remote table "workspace_member_invites"
type WorkspaceMemberInvitesArrRelInsertInput struct {
	Data []*WorkspaceMemberInvitesInsertInput `json:"data"`
	// upsert condition
	OnConflict *WorkspaceMemberInvitesOnConflict `json:"on_conflict,omitempty"`
}

// Boolean expression to filter rows from the table "workspace_member_invites". All fields are combined with a logical 'AND'.
type WorkspaceMemberInvitesBoolExp struct {
	And             []*WorkspaceMemberInvitesBoolExp `json:"_and,omitempty"`
	Not             *WorkspaceMemberInvitesBoolExp   `json:"_not,omitempty"`
	Or              []*WorkspaceMemberInvitesBoolExp `json:"_or,omitempty"`
	CreatedAt       *TimestamptzComparisonExp        `json:"createdAt,omitempty"`
	Email           *CitextComparisonExp             `json:"email,omitempty"`
	ID              *UUIDComparisonExp               `json:"id,omitempty"`
	InvitedByUser   *UsersBoolExp                    `json:"invitedByUser,omitempty"`
	InvitedByUserID *UUIDComparisonExp               `json:"invitedByUserId,omitempty"`
	MemberType      *StringComparisonExp             `json:"memberType,omitempty"`
	UpdatedAt       *TimestamptzComparisonExp        `json:"updatedAt,omitempty"`
	UserByEmail     *UsersBoolExp                    `json:"userByEmail,omitempty"`
	Workspace       *WorkspacesBoolExp               `json:"workspace,omitempty"`
	WorkspaceID     *UUIDComparisonExp               `json:"workspaceId,omitempty"`
}

// input type for inserting data into table "workspace_member_invites"
type WorkspaceMemberInvitesInsertInput struct {
	Email *string `json:"email,omitempty"`
	// owner or member
	MemberType  *string                      `json:"memberType,omitempty"`
	Workspace   *WorkspacesObjRelInsertInput `json:"workspace,omitempty"`
	WorkspaceID *string                      `json:"workspaceId,omitempty"`
}

// order by max() on columns of table "workspace_member_invites"
type WorkspaceMemberInvitesMaxOrderBy struct {
	CreatedAt       *OrderBy `json:"createdAt,omitempty"`
	Email           *OrderBy `json:"email,omitempty"`
	ID              *OrderBy `json:"id,omitempty"`
	InvitedByUserID *OrderBy `json:"invitedByUserId,omitempty"`
	// owner or member
	MemberType  *OrderBy `json:"memberType,omitempty"`
	UpdatedAt   *OrderBy `json:"updatedAt,omitempty"`
	WorkspaceID *OrderBy `json:"workspaceId,omitempty"`
}

// order by min() on columns of table "workspace_member_invites"
type WorkspaceMemberInvitesMinOrderBy struct {
	CreatedAt       *OrderBy `json:"createdAt,omitempty"`
	Email           *OrderBy `json:"email,omitempty"`
	ID              *OrderBy `json:"id,omitempty"`
	InvitedByUserID *OrderBy `json:"invitedByUserId,omitempty"`
	// owner or member
	MemberType  *OrderBy `json:"memberType,omitempty"`
	UpdatedAt   *OrderBy `json:"updatedAt,omitempty"`
	WorkspaceID *OrderBy `json:"workspaceId,omitempty"`
}

// response of any mutation on the table "workspace_member_invites"
type WorkspaceMemberInvitesMutationResponse struct {
	// number of rows affected by the mutation
	AffectedRows int64 `json:"affected_rows"`
	// data from the rows affected by the mutation
	Returning []*WorkspaceMemberInvites `json:"returning"`
}

// on_conflict condition type for table "workspace_member_invites"
type WorkspaceMemberInvitesOnConflict struct {
	Constraint    WorkspaceMemberInvitesConstraint     `json:"constraint"`
	UpdateColumns []WorkspaceMemberInvitesUpdateColumn `json:"update_columns"`
	Where         *WorkspaceMemberInvitesBoolExp       `json:"where,omitempty"`
}

// Ordering options when selecting data from "workspace_member_invites".
type WorkspaceMemberInvitesOrderBy struct {
	CreatedAt       *OrderBy           `json:"createdAt,omitempty"`
	Email           *OrderBy           `json:"email,omitempty"`
	ID              *OrderBy           `json:"id,omitempty"`
	InvitedByUser   *UsersOrderBy      `json:"invitedByUser,omitempty"`
	InvitedByUserID *OrderBy           `json:"invitedByUserId,omitempty"`
	MemberType      *OrderBy           `json:"memberType,omitempty"`
	UpdatedAt       *OrderBy           `json:"updatedAt,omitempty"`
	UserByEmail     *UsersOrderBy      `json:"userByEmail,omitempty"`
	Workspace       *WorkspacesOrderBy `json:"workspace,omitempty"`
	WorkspaceID     *OrderBy           `json:"workspaceId,omitempty"`
}

// primary key columns input for table: workspace_member_invites
type WorkspaceMemberInvitesPkColumnsInput struct {
	ID string `json:"id"`
}

// input type for updating data in table "workspace_member_invites"
type WorkspaceMemberInvitesSetInput struct {
	// owner or member
	MemberType *string `json:"memberType,omitempty"`
}

// Streaming cursor of the table "workspaceMemberInvites"
type WorkspaceMemberInvitesStreamCursorInput struct {
	// Stream column input with initial value
	InitialValue *WorkspaceMemberInvitesStreamCursorValueInput `json:"initial_value"`
	// cursor ordering
	Ordering *CursorOrdering `json:"ordering,omitempty"`
}

// Initial value of the column from where the streaming should start
type WorkspaceMemberInvitesStreamCursorValueInput struct {
	CreatedAt       *time.Time `json:"createdAt,omitempty"`
	Email           *string    `json:"email,omitempty"`
	ID              *string    `json:"id,omitempty"`
	InvitedByUserID *string    `json:"invitedByUserId,omitempty"`
	// owner or member
	MemberType  *string    `json:"memberType,omitempty"`
	UpdatedAt   *time.Time `json:"updatedAt,omitempty"`
	WorkspaceID *string    `json:"workspaceId,omitempty"`
}

type WorkspaceMemberInvitesUpdates struct {
	// sets the columns of the filtered rows to the given values
	Set *WorkspaceMemberInvitesSetInput `json:"_set,omitempty"`
	// filter the rows which have to be updated
	Where *WorkspaceMemberInvitesBoolExp `json:"where"`
}

// columns and relationships of "workspace_members"
type WorkspaceMembers struct {
	CreatedAt time.Time `json:"createdAt"`
	ID        string    `json:"id"`
	// owner or member
	Type      string    `json:"type"`
	UpdatedAt time.Time `json:"updatedAt"`
	// An object relationship
	User   *Users `json:"user"`
	UserID string `json:"userId"`
	// An object relationship
	Workspace   *Workspaces `json:"workspace"`
	WorkspaceID string      `json:"workspaceId"`
}

// order by aggregate values of table "workspace_members"
type WorkspaceMembersAggregateOrderBy struct {
	Count *OrderBy                    `json:"count,omitempty"`
	Max   *WorkspaceMembersMaxOrderBy `json:"max,omitempty"`
	Min   *WorkspaceMembersMinOrderBy `json:"min,omitempty"`
}

// input type for inserting array relation for remote table "workspace_members"
type WorkspaceMembersArrRelInsertInput struct {
	Data []*WorkspaceMembersInsertInput `json:"data"`
	// upsert condition
	OnConflict *WorkspaceMembersOnConflict `json:"on_conflict,omitempty"`
}

// Boolean expression to filter rows from the table "workspace_members". All fields are combined with a logical 'AND'.
type WorkspaceMembersBoolExp struct {
	And         []*WorkspaceMembersBoolExp `json:"_and,omitempty"`
	Not         *WorkspaceMembersBoolExp   `json:"_not,omitempty"`
	Or          []*WorkspaceMembersBoolExp `json:"_or,omitempty"`
	CreatedAt   *TimestamptzComparisonExp  `json:"createdAt,omitempty"`
	ID          *UUIDComparisonExp         `json:"id,omitempty"`
	Type        *StringComparisonExp       `json:"type,omitempty"`
	UpdatedAt   *TimestamptzComparisonExp  `json:"updatedAt,omitempty"`
	User        *UsersBoolExp              `json:"user,omitempty"`
	UserID      *UUIDComparisonExp         `json:"userId,omitempty"`
	Workspace   *WorkspacesBoolExp         `json:"workspace,omitempty"`
	WorkspaceID *UUIDComparisonExp         `json:"workspaceId,omitempty"`
}

// input type for inserting data into table "workspace_members"
type WorkspaceMembersInsertInput struct {
	// owner or member
	Type      *string                      `json:"type,omitempty"`
	UserID    *string                      `json:"userId,omitempty"`
	Workspace *WorkspacesObjRelInsertInput `json:"workspace,omitempty"`
}

// order by max() on columns of table "workspace_members"
type WorkspaceMembersMaxOrderBy struct {
	CreatedAt *OrderBy `json:"createdAt,omitempty"`
	ID        *OrderBy `json:"id,omitempty"`
	// owner or member
	Type        *OrderBy `json:"type,omitempty"`
	UpdatedAt   *OrderBy `json:"updatedAt,omitempty"`
	UserID      *OrderBy `json:"userId,omitempty"`
	WorkspaceID *OrderBy `json:"workspaceId,omitempty"`
}

// order by min() on columns of table "workspace_members"
type WorkspaceMembersMinOrderBy struct {
	CreatedAt *OrderBy `json:"createdAt,omitempty"`
	ID        *OrderBy `json:"id,omitempty"`
	// owner or member
	Type        *OrderBy `json:"type,omitempty"`
	UpdatedAt   *OrderBy `json:"updatedAt,omitempty"`
	UserID      *OrderBy `json:"userId,omitempty"`
	WorkspaceID *OrderBy `json:"workspaceId,omitempty"`
}

// response of any mutation on the table "workspace_members"
type WorkspaceMembersMutationResponse struct {
	// number of rows affected by the mutation
	AffectedRows int64 `json:"affected_rows"`
	// data from the rows affected by the mutation
	Returning []*WorkspaceMembers `json:"returning"`
}

// on_conflict condition type for table "workspace_members"
type WorkspaceMembersOnConflict struct {
	Constraint    WorkspaceMembersConstraint     `json:"constraint"`
	UpdateColumns []WorkspaceMembersUpdateColumn `json:"update_columns"`
	Where         *WorkspaceMembersBoolExp       `json:"where,omitempty"`
}

// Ordering options when selecting data from "workspace_members".
type WorkspaceMembersOrderBy struct {
	CreatedAt   *OrderBy           `json:"createdAt,omitempty"`
	ID          *OrderBy           `json:"id,omitempty"`
	Type        *OrderBy           `json:"type,omitempty"`
	UpdatedAt   *OrderBy           `json:"updatedAt,omitempty"`
	User        *UsersOrderBy      `json:"user,omitempty"`
	UserID      *OrderBy           `json:"userId,omitempty"`
	Workspace   *WorkspacesOrderBy `json:"workspace,omitempty"`
	WorkspaceID *OrderBy           `json:"workspaceId,omitempty"`
}

// primary key columns input for table: workspace_members
type WorkspaceMembersPkColumnsInput struct {
	ID string `json:"id"`
}

// input type for updating data in table "workspace_members"
type WorkspaceMembersSetInput struct {
	// owner or member
	Type *string `json:"type,omitempty"`
}

// Streaming cursor of the table "workspaceMembers"
type WorkspaceMembersStreamCursorInput struct {
	// Stream column input with initial value
	InitialValue *WorkspaceMembersStreamCursorValueInput `json:"initial_value"`
	// cursor ordering
	Ordering *CursorOrdering `json:"ordering,omitempty"`
}

// Initial value of the column from where the streaming should start
type WorkspaceMembersStreamCursorValueInput struct {
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	ID        *string    `json:"id,omitempty"`
	// owner or member
	Type        *string    `json:"type,omitempty"`
	UpdatedAt   *time.Time `json:"updatedAt,omitempty"`
	UserID      *string    `json:"userId,omitempty"`
	WorkspaceID *string    `json:"workspaceId,omitempty"`
}

type WorkspaceMembersUpdates struct {
	// sets the columns of the filtered rows to the given values
	Set *WorkspaceMembersSetInput `json:"_set,omitempty"`
	// filter the rows which have to be updated
	Where *WorkspaceMembersBoolExp `json:"where"`
}

// columns and relationships of "workspaces"
type Workspaces struct {
	// City, district, suburb, town, or village.
	AddressCity string `json:"addressCity"`
	// An object relationship
	AddressCountry *Countries `json:"addressCountry,omitempty"`
	// Two-letter country code (ISO 3166-1 alpha-2).
	AddressCountryCode *string `json:"addressCountryCode,omitempty"`
	// Address line 1 (e.g., street, PO Box, or company name).
	AddressLine1 string `json:"addressLine1"`
	// Address line 2 (e.g., apartment, suite, unit, or building).
	AddressLine2 string `json:"addressLine2"`
	// ZIP or postal code.
	AddressPostalCode string `json:"addressPostalCode"`
	// State, county, province, or region.
	AddressState string `json:"addressState"`
	// An object relationship
	AllowedPrivateRegions *RegionsAllowedWorkspace `json:"allowedPrivateRegions,omitempty"`
	// An array relationship
	Apps        []*Apps   `json:"apps"`
	CompanyName string    `json:"companyName"`
	CreatedAt   time.Time `json:"createdAt"`
	// An object relationship
	CreatorUser   *Users  `json:"creatorUser,omitempty"`
	CreatorUserID *string `json:"creatorUserId,omitempty"`
	Email         string  `json:"email"`
	ID            string  `json:"id"`
	Name          string  `json:"name"`
	// An object relationship
	PaymentMethod *PaymentMethods `json:"paymentMethod,omitempty"`
	// An array relationship
	PaymentMethods []*PaymentMethods `json:"paymentMethods"`
	// An array relationship
	RegionsAllowedWorkspaces []*RegionsAllowedWorkspace `json:"regions_allowed_workspaces"`
	Slug                     string                     `json:"slug"`
	TaxIDType                string                     `json:"taxIdType"`
	TaxIDValue               string                     `json:"taxIdValue"`
	UpdatedAt                time.Time                  `json:"updatedAt"`
	// An array relationship
	WorkspaceMemberInvites []*WorkspaceMemberInvites `json:"workspaceMemberInvites"`
	// An array relationship
	WorkspaceMembers []*WorkspaceMembers `json:"workspaceMembers"`
}

// order by aggregate values of table "workspaces"
type WorkspacesAggregateOrderBy struct {
	Count *OrderBy              `json:"count,omitempty"`
	Max   *WorkspacesMaxOrderBy `json:"max,omitempty"`
	Min   *WorkspacesMinOrderBy `json:"min,omitempty"`
}

// Boolean expression to filter rows from the table "workspaces". All fields are combined with a logical 'AND'.
type WorkspacesBoolExp struct {
	And                      []*WorkspacesBoolExp            `json:"_and,omitempty"`
	Not                      *WorkspacesBoolExp              `json:"_not,omitempty"`
	Or                       []*WorkspacesBoolExp            `json:"_or,omitempty"`
	AddressCity              *StringComparisonExp            `json:"addressCity,omitempty"`
	AddressCountry           *CountriesBoolExp               `json:"addressCountry,omitempty"`
	AddressCountryCode       *StringComparisonExp            `json:"addressCountryCode,omitempty"`
	AddressLine1             *StringComparisonExp            `json:"addressLine1,omitempty"`
	AddressLine2             *StringComparisonExp            `json:"addressLine2,omitempty"`
	AddressPostalCode        *StringComparisonExp            `json:"addressPostalCode,omitempty"`
	AddressState             *StringComparisonExp            `json:"addressState,omitempty"`
	AllowedPrivateRegions    *RegionsAllowedWorkspaceBoolExp `json:"allowedPrivateRegions,omitempty"`
	Apps                     *AppsBoolExp                    `json:"apps,omitempty"`
	CompanyName              *StringComparisonExp            `json:"companyName,omitempty"`
	CreatedAt                *TimestamptzComparisonExp       `json:"createdAt,omitempty"`
	CreatorUser              *UsersBoolExp                   `json:"creatorUser,omitempty"`
	CreatorUserID            *UUIDComparisonExp              `json:"creatorUserId,omitempty"`
	Email                    *StringComparisonExp            `json:"email,omitempty"`
	ID                       *UUIDComparisonExp              `json:"id,omitempty"`
	Name                     *StringComparisonExp            `json:"name,omitempty"`
	PaymentMethod            *PaymentMethodsBoolExp          `json:"paymentMethod,omitempty"`
	PaymentMethods           *PaymentMethodsBoolExp          `json:"paymentMethods,omitempty"`
	RegionsAllowedWorkspaces *RegionsAllowedWorkspaceBoolExp `json:"regions_allowed_workspaces,omitempty"`
	Slug                     *StringComparisonExp            `json:"slug,omitempty"`
	TaxIDType                *StringComparisonExp            `json:"taxIdType,omitempty"`
	TaxIDValue               *StringComparisonExp            `json:"taxIdValue,omitempty"`
	UpdatedAt                *TimestamptzComparisonExp       `json:"updatedAt,omitempty"`
	WorkspaceMemberInvites   *WorkspaceMemberInvitesBoolExp  `json:"workspaceMemberInvites,omitempty"`
	WorkspaceMembers         *WorkspaceMembersBoolExp        `json:"workspaceMembers,omitempty"`
}

// input type for inserting data into table "workspaces"
type WorkspacesInsertInput struct {
	Apps                   *AppsArrRelInsertInput                   `json:"apps,omitempty"`
	CompanyName            *string                                  `json:"companyName,omitempty"`
	Email                  *string                                  `json:"email,omitempty"`
	ID                     *string                                  `json:"id,omitempty"`
	Name                   *string                                  `json:"name,omitempty"`
	PaymentMethod          *PaymentMethodsObjRelInsertInput         `json:"paymentMethod,omitempty"`
	PaymentMethods         *PaymentMethodsArrRelInsertInput         `json:"paymentMethods,omitempty"`
	Slug                   *string                                  `json:"slug,omitempty"`
	WorkspaceMemberInvites *WorkspaceMemberInvitesArrRelInsertInput `json:"workspaceMemberInvites,omitempty"`
	WorkspaceMembers       *WorkspaceMembersArrRelInsertInput       `json:"workspaceMembers,omitempty"`
}

// order by max() on columns of table "workspaces"
type WorkspacesMaxOrderBy struct {
	// City, district, suburb, town, or village.
	AddressCity *OrderBy `json:"addressCity,omitempty"`
	// Two-letter country code (ISO 3166-1 alpha-2).
	AddressCountryCode *OrderBy `json:"addressCountryCode,omitempty"`
	// Address line 1 (e.g., street, PO Box, or company name).
	AddressLine1 *OrderBy `json:"addressLine1,omitempty"`
	// Address line 2 (e.g., apartment, suite, unit, or building).
	AddressLine2 *OrderBy `json:"addressLine2,omitempty"`
	// ZIP or postal code.
	AddressPostalCode *OrderBy `json:"addressPostalCode,omitempty"`
	// State, county, province, or region.
	AddressState  *OrderBy `json:"addressState,omitempty"`
	CompanyName   *OrderBy `json:"companyName,omitempty"`
	CreatedAt     *OrderBy `json:"createdAt,omitempty"`
	CreatorUserID *OrderBy `json:"creatorUserId,omitempty"`
	Email         *OrderBy `json:"email,omitempty"`
	ID            *OrderBy `json:"id,omitempty"`
	Name          *OrderBy `json:"name,omitempty"`
	Slug          *OrderBy `json:"slug,omitempty"`
	TaxIDType     *OrderBy `json:"taxIdType,omitempty"`
	TaxIDValue    *OrderBy `json:"taxIdValue,omitempty"`
	UpdatedAt     *OrderBy `json:"updatedAt,omitempty"`
}

// order by min() on columns of table "workspaces"
type WorkspacesMinOrderBy struct {
	// City, district, suburb, town, or village.
	AddressCity *OrderBy `json:"addressCity,omitempty"`
	// Two-letter country code (ISO 3166-1 alpha-2).
	AddressCountryCode *OrderBy `json:"addressCountryCode,omitempty"`
	// Address line 1 (e.g., street, PO Box, or company name).
	AddressLine1 *OrderBy `json:"addressLine1,omitempty"`
	// Address line 2 (e.g., apartment, suite, unit, or building).
	AddressLine2 *OrderBy `json:"addressLine2,omitempty"`
	// ZIP or postal code.
	AddressPostalCode *OrderBy `json:"addressPostalCode,omitempty"`
	// State, county, province, or region.
	AddressState  *OrderBy `json:"addressState,omitempty"`
	CompanyName   *OrderBy `json:"companyName,omitempty"`
	CreatedAt     *OrderBy `json:"createdAt,omitempty"`
	CreatorUserID *OrderBy `json:"creatorUserId,omitempty"`
	Email         *OrderBy `json:"email,omitempty"`
	ID            *OrderBy `json:"id,omitempty"`
	Name          *OrderBy `json:"name,omitempty"`
	Slug          *OrderBy `json:"slug,omitempty"`
	TaxIDType     *OrderBy `json:"taxIdType,omitempty"`
	TaxIDValue    *OrderBy `json:"taxIdValue,omitempty"`
	UpdatedAt     *OrderBy `json:"updatedAt,omitempty"`
}

// response of any mutation on the table "workspaces"
type WorkspacesMutationResponse struct {
	// number of rows affected by the mutation
	AffectedRows int64 `json:"affected_rows"`
	// data from the rows affected by the mutation
	Returning []*Workspaces `json:"returning"`
}

// input type for inserting object relation for remote table "workspaces"
type WorkspacesObjRelInsertInput struct {
	Data *WorkspacesInsertInput `json:"data"`
	// upsert condition
	OnConflict *WorkspacesOnConflict `json:"on_conflict,omitempty"`
}

// on_conflict condition type for table "workspaces"
type WorkspacesOnConflict struct {
	Constraint    WorkspacesConstraint     `json:"constraint"`
	UpdateColumns []WorkspacesUpdateColumn `json:"update_columns"`
	Where         *WorkspacesBoolExp       `json:"where,omitempty"`
}

// Ordering options when selecting data from "workspaces".
type WorkspacesOrderBy struct {
	AddressCity                       *OrderBy                                 `json:"addressCity,omitempty"`
	AddressCountry                    *CountriesOrderBy                        `json:"addressCountry,omitempty"`
	AddressCountryCode                *OrderBy                                 `json:"addressCountryCode,omitempty"`
	AddressLine1                      *OrderBy                                 `json:"addressLine1,omitempty"`
	AddressLine2                      *OrderBy                                 `json:"addressLine2,omitempty"`
	AddressPostalCode                 *OrderBy                                 `json:"addressPostalCode,omitempty"`
	AddressState                      *OrderBy                                 `json:"addressState,omitempty"`
	AllowedPrivateRegions             *RegionsAllowedWorkspaceOrderBy          `json:"allowedPrivateRegions,omitempty"`
	AppsAggregate                     *AppsAggregateOrderBy                    `json:"apps_aggregate,omitempty"`
	CompanyName                       *OrderBy                                 `json:"companyName,omitempty"`
	CreatedAt                         *OrderBy                                 `json:"createdAt,omitempty"`
	CreatorUser                       *UsersOrderBy                            `json:"creatorUser,omitempty"`
	CreatorUserID                     *OrderBy                                 `json:"creatorUserId,omitempty"`
	Email                             *OrderBy                                 `json:"email,omitempty"`
	ID                                *OrderBy                                 `json:"id,omitempty"`
	Name                              *OrderBy                                 `json:"name,omitempty"`
	PaymentMethod                     *PaymentMethodsOrderBy                   `json:"paymentMethod,omitempty"`
	PaymentMethodsAggregate           *PaymentMethodsAggregateOrderBy          `json:"paymentMethods_aggregate,omitempty"`
	RegionsAllowedWorkspacesAggregate *RegionsAllowedWorkspaceAggregateOrderBy `json:"regions_allowed_workspaces_aggregate,omitempty"`
	Slug                              *OrderBy                                 `json:"slug,omitempty"`
	TaxIDType                         *OrderBy                                 `json:"taxIdType,omitempty"`
	TaxIDValue                        *OrderBy                                 `json:"taxIdValue,omitempty"`
	UpdatedAt                         *OrderBy                                 `json:"updatedAt,omitempty"`
	WorkspaceMemberInvitesAggregate   *WorkspaceMemberInvitesAggregateOrderBy  `json:"workspaceMemberInvites_aggregate,omitempty"`
	WorkspaceMembersAggregate         *WorkspaceMembersAggregateOrderBy        `json:"workspaceMembers_aggregate,omitempty"`
}

// primary key columns input for table: workspaces
type WorkspacesPkColumnsInput struct {
	ID string `json:"id"`
}

// input type for updating data in table "workspaces"
type WorkspacesSetInput struct {
	// City, district, suburb, town, or village.
	AddressCity *string `json:"addressCity,omitempty"`
	// Two-letter country code (ISO 3166-1 alpha-2).
	AddressCountryCode *string `json:"addressCountryCode,omitempty"`
	// Address line 1 (e.g., street, PO Box, or company name).
	AddressLine1 *string `json:"addressLine1,omitempty"`
	// Address line 2 (e.g., apartment, suite, unit, or building).
	AddressLine2 *string `json:"addressLine2,omitempty"`
	// ZIP or postal code.
	AddressPostalCode *string `json:"addressPostalCode,omitempty"`
	// State, county, province, or region.
	AddressState *string `json:"addressState,omitempty"`
	CompanyName  *string `json:"companyName,omitempty"`
	Email        *string `json:"email,omitempty"`
	Name         *string `json:"name,omitempty"`
	Slug         *string `json:"slug,omitempty"`
	TaxIDType    *string `json:"taxIdType,omitempty"`
	TaxIDValue   *string `json:"taxIdValue,omitempty"`
}

// Streaming cursor of the table "workspaces"
type WorkspacesStreamCursorInput struct {
	// Stream column input with initial value
	InitialValue *WorkspacesStreamCursorValueInput `json:"initial_value"`
	// cursor ordering
	Ordering *CursorOrdering `json:"ordering,omitempty"`
}

// Initial value of the column from where the streaming should start
type WorkspacesStreamCursorValueInput struct {
	// City, district, suburb, town, or village.
	AddressCity *string `json:"addressCity,omitempty"`
	// Two-letter country code (ISO 3166-1 alpha-2).
	AddressCountryCode *string `json:"addressCountryCode,omitempty"`
	// Address line 1 (e.g., street, PO Box, or company name).
	AddressLine1 *string `json:"addressLine1,omitempty"`
	// Address line 2 (e.g., apartment, suite, unit, or building).
	AddressLine2 *string `json:"addressLine2,omitempty"`
	// ZIP or postal code.
	AddressPostalCode *string `json:"addressPostalCode,omitempty"`
	// State, county, province, or region.
	AddressState  *string    `json:"addressState,omitempty"`
	CompanyName   *string    `json:"companyName,omitempty"`
	CreatedAt     *time.Time `json:"createdAt,omitempty"`
	CreatorUserID *string    `json:"creatorUserId,omitempty"`
	Email         *string    `json:"email,omitempty"`
	ID            *string    `json:"id,omitempty"`
	Name          *string    `json:"name,omitempty"`
	Slug          *string    `json:"slug,omitempty"`
	TaxIDType     *string    `json:"taxIdType,omitempty"`
	TaxIDValue    *string    `json:"taxIdValue,omitempty"`
	UpdatedAt     *time.Time `json:"updatedAt,omitempty"`
}

type WorkspacesUpdates struct {
	// sets the columns of the filtered rows to the given values
	Set *WorkspacesSetInput `json:"_set,omitempty"`
	// filter the rows which have to be updated
	Where *WorkspacesBoolExp `json:"where"`
}

type CheckoutStatus string

const (
	CheckoutStatusCompleted CheckoutStatus = "COMPLETED"
	CheckoutStatusExpired   CheckoutStatus = "EXPIRED"
	CheckoutStatusOpen      CheckoutStatus = "OPEN"
)

var AllCheckoutStatus = []CheckoutStatus{
	CheckoutStatusCompleted,
	CheckoutStatusExpired,
	CheckoutStatusOpen,
}

func (e CheckoutStatus) IsValid() bool {
	switch e {
	case CheckoutStatusCompleted, CheckoutStatusExpired, CheckoutStatusOpen:
		return true
	}
	return false
}

func (e CheckoutStatus) String() string {
	return string(e)
}

func (e *CheckoutStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CheckoutStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CheckoutStatus", str)
	}
	return nil
}

func (e CheckoutStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *CheckoutStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e CheckoutStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type ServiceState string

const (
	ServiceStateError       ServiceState = "Error"
	ServiceStateNone        ServiceState = "None"
	ServiceStateRunning     ServiceState = "Running"
	ServiceStateUpdateError ServiceState = "UpdateError"
	ServiceStateUpdating    ServiceState = "Updating"
)

var AllServiceState = []ServiceState{
	ServiceStateError,
	ServiceStateNone,
	ServiceStateRunning,
	ServiceStateUpdateError,
	ServiceStateUpdating,
}

func (e ServiceState) IsValid() bool {
	switch e {
	case ServiceStateError, ServiceStateNone, ServiceStateRunning, ServiceStateUpdateError, ServiceStateUpdating:
		return true
	}
	return false
}

func (e ServiceState) String() string {
	return string(e)
}

func (e *ServiceState) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ServiceState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ServiceState", str)
	}
	return nil
}

func (e ServiceState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ServiceState) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ServiceState) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// unique or primary key constraints on table "announcements_read"
type AnnouncementsReadConstraint string

const (
	// unique or primary key constraint on columns "user_id", "announcement_id"
	AnnouncementsReadConstraintAnnouncementsReadAnnouncementIDUserIDKey AnnouncementsReadConstraint = "announcements_read_announcement_id_user_id_key"
	// unique or primary key constraint on columns "id"
	AnnouncementsReadConstraintAnnouncementsReadPkey AnnouncementsReadConstraint = "announcements_read_pkey"
)

var AllAnnouncementsReadConstraint = []AnnouncementsReadConstraint{
	AnnouncementsReadConstraintAnnouncementsReadAnnouncementIDUserIDKey,
	AnnouncementsReadConstraintAnnouncementsReadPkey,
}

func (e AnnouncementsReadConstraint) IsValid() bool {
	switch e {
	case AnnouncementsReadConstraintAnnouncementsReadAnnouncementIDUserIDKey, AnnouncementsReadConstraintAnnouncementsReadPkey:
		return true
	}
	return false
}

func (e AnnouncementsReadConstraint) String() string {
	return string(e)
}

func (e *AnnouncementsReadConstraint) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AnnouncementsReadConstraint(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid announcements_read_constraint", str)
	}
	return nil
}

func (e AnnouncementsReadConstraint) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *AnnouncementsReadConstraint) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e AnnouncementsReadConstraint) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// select columns of table "announcements_read"
type AnnouncementsReadSelectColumn string

const (
	// column name
	AnnouncementsReadSelectColumnAnnouncementID AnnouncementsReadSelectColumn = "announcementID"
	// column name
	AnnouncementsReadSelectColumnCreatedAt AnnouncementsReadSelectColumn = "createdAt"
	// column name
	AnnouncementsReadSelectColumnID AnnouncementsReadSelectColumn = "id"
	// column name
	AnnouncementsReadSelectColumnUserID AnnouncementsReadSelectColumn = "userID"
)

var AllAnnouncementsReadSelectColumn = []AnnouncementsReadSelectColumn{
	AnnouncementsReadSelectColumnAnnouncementID,
	AnnouncementsReadSelectColumnCreatedAt,
	AnnouncementsReadSelectColumnID,
	AnnouncementsReadSelectColumnUserID,
}

func (e AnnouncementsReadSelectColumn) IsValid() bool {
	switch e {
	case AnnouncementsReadSelectColumnAnnouncementID, AnnouncementsReadSelectColumnCreatedAt, AnnouncementsReadSelectColumnID, AnnouncementsReadSelectColumnUserID:
		return true
	}
	return false
}

func (e AnnouncementsReadSelectColumn) String() string {
	return string(e)
}

func (e *AnnouncementsReadSelectColumn) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AnnouncementsReadSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid announcements_read_select_column", str)
	}
	return nil
}

func (e AnnouncementsReadSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *AnnouncementsReadSelectColumn) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e AnnouncementsReadSelectColumn) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// placeholder for update columns of table "announcements_read" (current role has no relevant permissions)
type AnnouncementsReadUpdateColumn string

const (
	// placeholder (do not use)
	AnnouncementsReadUpdateColumnPlaceholder AnnouncementsReadUpdateColumn = "_PLACEHOLDER"
)

var AllAnnouncementsReadUpdateColumn = []AnnouncementsReadUpdateColumn{
	AnnouncementsReadUpdateColumnPlaceholder,
}

func (e AnnouncementsReadUpdateColumn) IsValid() bool {
	switch e {
	case AnnouncementsReadUpdateColumnPlaceholder:
		return true
	}
	return false
}

func (e AnnouncementsReadUpdateColumn) String() string {
	return string(e)
}

func (e *AnnouncementsReadUpdateColumn) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AnnouncementsReadUpdateColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid announcements_read_update_column", str)
	}
	return nil
}

func (e AnnouncementsReadUpdateColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *AnnouncementsReadUpdateColumn) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e AnnouncementsReadUpdateColumn) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// select columns of table "announcements"
type AnnouncementsSelectColumn string

const (
	// column name
	AnnouncementsSelectColumnContent AnnouncementsSelectColumn = "content"
	// column name
	AnnouncementsSelectColumnCreatedAt AnnouncementsSelectColumn = "createdAt"
	// column name
	AnnouncementsSelectColumnExpiresAt AnnouncementsSelectColumn = "expiresAt"
	// column name
	AnnouncementsSelectColumnHref AnnouncementsSelectColumn = "href"
	// column name
	AnnouncementsSelectColumnID AnnouncementsSelectColumn = "id"
	// column name
	AnnouncementsSelectColumnUpdatedAt AnnouncementsSelectColumn = "updatedAt"
)

var AllAnnouncementsSelectColumn = []AnnouncementsSelectColumn{
	AnnouncementsSelectColumnContent,
	AnnouncementsSelectColumnCreatedAt,
	AnnouncementsSelectColumnExpiresAt,
	AnnouncementsSelectColumnHref,
	AnnouncementsSelectColumnID,
	AnnouncementsSelectColumnUpdatedAt,
}

func (e AnnouncementsSelectColumn) IsValid() bool {
	switch e {
	case AnnouncementsSelectColumnContent, AnnouncementsSelectColumnCreatedAt, AnnouncementsSelectColumnExpiresAt, AnnouncementsSelectColumnHref, AnnouncementsSelectColumnID, AnnouncementsSelectColumnUpdatedAt:
		return true
	}
	return false
}

func (e AnnouncementsSelectColumn) String() string {
	return string(e)
}

func (e *AnnouncementsSelectColumn) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AnnouncementsSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid announcements_select_column", str)
	}
	return nil
}

func (e AnnouncementsSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *AnnouncementsSelectColumn) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e AnnouncementsSelectColumn) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// select columns of table "app_state_history"
type AppStateHistorySelectColumn string

const (
	// column name
	AppStateHistorySelectColumnAppID AppStateHistorySelectColumn = "appId"
	// column name
	AppStateHistorySelectColumnCreatedAt AppStateHistorySelectColumn = "createdAt"
	// column name
	AppStateHistorySelectColumnID AppStateHistorySelectColumn = "id"
	// column name
	AppStateHistorySelectColumnMessage AppStateHistorySelectColumn = "message"
	// column name
	AppStateHistorySelectColumnStateID AppStateHistorySelectColumn = "stateId"
)

var AllAppStateHistorySelectColumn = []AppStateHistorySelectColumn{
	AppStateHistorySelectColumnAppID,
	AppStateHistorySelectColumnCreatedAt,
	AppStateHistorySelectColumnID,
	AppStateHistorySelectColumnMessage,
	AppStateHistorySelectColumnStateID,
}

func (e AppStateHistorySelectColumn) IsValid() bool {
	switch e {
	case AppStateHistorySelectColumnAppID, AppStateHistorySelectColumnCreatedAt, AppStateHistorySelectColumnID, AppStateHistorySelectColumnMessage, AppStateHistorySelectColumnStateID:
		return true
	}
	return false
}

func (e AppStateHistorySelectColumn) String() string {
	return string(e)
}

func (e *AppStateHistorySelectColumn) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AppStateHistorySelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid appStateHistory_select_column", str)
	}
	return nil
}

func (e AppStateHistorySelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *AppStateHistorySelectColumn) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e AppStateHistorySelectColumn) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// unique or primary key constraints on table "apps"
type AppsConstraint string

const (
	// unique or primary key constraint on columns "id"
	AppsConstraintAppsPkey AppsConstraint = "apps_pkey"
	// unique or primary key constraint on columns "subdomain"
	AppsConstraintAppsSubdomainKey AppsConstraint = "apps_subdomain_key"
	// unique or primary key constraint on columns "workspace_id", "slug"
	AppsConstraintAppsWorkspaceIDSlugKey AppsConstraint = "apps_workspace_id_slug_key"
)

var AllAppsConstraint = []AppsConstraint{
	AppsConstraintAppsPkey,
	AppsConstraintAppsSubdomainKey,
	AppsConstraintAppsWorkspaceIDSlugKey,
}

func (e AppsConstraint) IsValid() bool {
	switch e {
	case AppsConstraintAppsPkey, AppsConstraintAppsSubdomainKey, AppsConstraintAppsWorkspaceIDSlugKey:
		return true
	}
	return false
}

func (e AppsConstraint) String() string {
	return string(e)
}

func (e *AppsConstraint) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AppsConstraint(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid apps_constraint", str)
	}
	return nil
}

func (e AppsConstraint) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *AppsConstraint) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e AppsConstraint) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// select columns of table "apps"
type AppsSelectColumn string

const (
	// column name
	AppsSelectColumnAutomaticDeploys AppsSelectColumn = "automaticDeploys"
	// column name
	AppsSelectColumnCreatedAt AppsSelectColumn = "createdAt"
	// column name
	AppsSelectColumnCreatorUserID AppsSelectColumn = "creatorUserId"
	// column name
	AppsSelectColumnDesiredState AppsSelectColumn = "desiredState"
	// column name
	AppsSelectColumnGithubRepositoryID AppsSelectColumn = "githubRepositoryId"
	// column name
	AppsSelectColumnID AppsSelectColumn = "id"
	// column name
	AppsSelectColumnIsLocked AppsSelectColumn = "isLocked"
	// column name
	AppsSelectColumnIsLockedReason AppsSelectColumn = "isLockedReason"
	// column name
	AppsSelectColumnMetadataFunctions AppsSelectColumn = "metadataFunctions"
	// column name
	AppsSelectColumnName AppsSelectColumn = "name"
	// column name
	AppsSelectColumnNhostBaseFolder AppsSelectColumn = "nhostBaseFolder"
	// column name
	AppsSelectColumnOrganizationID AppsSelectColumn = "organizationID"
	// column name
	AppsSelectColumnRepositoryProductionBranch AppsSelectColumn = "repositoryProductionBranch"
	// column name
	AppsSelectColumnSlug AppsSelectColumn = "slug"
	// column name
	AppsSelectColumnSubdomain AppsSelectColumn = "subdomain"
	// column name
	AppsSelectColumnUpdatedAt AppsSelectColumn = "updatedAt"
	// column name
	AppsSelectColumnWorkspaceID AppsSelectColumn = "workspaceId"
)

var AllAppsSelectColumn = []AppsSelectColumn{
	AppsSelectColumnAutomaticDeploys,
	AppsSelectColumnCreatedAt,
	AppsSelectColumnCreatorUserID,
	AppsSelectColumnDesiredState,
	AppsSelectColumnGithubRepositoryID,
	AppsSelectColumnID,
	AppsSelectColumnIsLocked,
	AppsSelectColumnIsLockedReason,
	AppsSelectColumnMetadataFunctions,
	AppsSelectColumnName,
	AppsSelectColumnNhostBaseFolder,
	AppsSelectColumnOrganizationID,
	AppsSelectColumnRepositoryProductionBranch,
	AppsSelectColumnSlug,
	AppsSelectColumnSubdomain,
	AppsSelectColumnUpdatedAt,
	AppsSelectColumnWorkspaceID,
}

func (e AppsSelectColumn) IsValid() bool {
	switch e {
	case AppsSelectColumnAutomaticDeploys, AppsSelectColumnCreatedAt, AppsSelectColumnCreatorUserID, AppsSelectColumnDesiredState, AppsSelectColumnGithubRepositoryID, AppsSelectColumnID, AppsSelectColumnIsLocked, AppsSelectColumnIsLockedReason, AppsSelectColumnMetadataFunctions, AppsSelectColumnName, AppsSelectColumnNhostBaseFolder, AppsSelectColumnOrganizationID, AppsSelectColumnRepositoryProductionBranch, AppsSelectColumnSlug, AppsSelectColumnSubdomain, AppsSelectColumnUpdatedAt, AppsSelectColumnWorkspaceID:
		return true
	}
	return false
}

func (e AppsSelectColumn) String() string {
	return string(e)
}

func (e *AppsSelectColumn) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AppsSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid apps_select_column", str)
	}
	return nil
}

func (e AppsSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *AppsSelectColumn) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e AppsSelectColumn) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// update columns of table "apps"
type AppsUpdateColumn string

const (
	// column name
	AppsUpdateColumnAutomaticDeploys AppsUpdateColumn = "automaticDeploys"
	// column name
	AppsUpdateColumnDesiredState AppsUpdateColumn = "desiredState"
	// column name
	AppsUpdateColumnGithubRepositoryID AppsUpdateColumn = "githubRepositoryId"
	// column name
	AppsUpdateColumnName AppsUpdateColumn = "name"
	// column name
	AppsUpdateColumnNhostBaseFolder AppsUpdateColumn = "nhostBaseFolder"
	// column name
	AppsUpdateColumnRepositoryProductionBranch AppsUpdateColumn = "repositoryProductionBranch"
	// column name
	AppsUpdateColumnSlug AppsUpdateColumn = "slug"
)

var AllAppsUpdateColumn = []AppsUpdateColumn{
	AppsUpdateColumnAutomaticDeploys,
	AppsUpdateColumnDesiredState,
	AppsUpdateColumnGithubRepositoryID,
	AppsUpdateColumnName,
	AppsUpdateColumnNhostBaseFolder,
	AppsUpdateColumnRepositoryProductionBranch,
	AppsUpdateColumnSlug,
}

func (e AppsUpdateColumn) IsValid() bool {
	switch e {
	case AppsUpdateColumnAutomaticDeploys, AppsUpdateColumnDesiredState, AppsUpdateColumnGithubRepositoryID, AppsUpdateColumnName, AppsUpdateColumnNhostBaseFolder, AppsUpdateColumnRepositoryProductionBranch, AppsUpdateColumnSlug:
		return true
	}
	return false
}

func (e AppsUpdateColumn) String() string {
	return string(e)
}

func (e *AppsUpdateColumn) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AppsUpdateColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid apps_update_column", str)
	}
	return nil
}

func (e AppsUpdateColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *AppsUpdateColumn) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e AppsUpdateColumn) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type AuthRefreshTokenTypesEnum string

const (
	// Personal access token
	AuthRefreshTokenTypesEnumPat AuthRefreshTokenTypesEnum = "pat"
	// Regular refresh token
	AuthRefreshTokenTypesEnumRegular AuthRefreshTokenTypesEnum = "regular"
)

var AllAuthRefreshTokenTypesEnum = []AuthRefreshTokenTypesEnum{
	AuthRefreshTokenTypesEnumPat,
	AuthRefreshTokenTypesEnumRegular,
}

func (e AuthRefreshTokenTypesEnum) IsValid() bool {
	switch e {
	case AuthRefreshTokenTypesEnumPat, AuthRefreshTokenTypesEnumRegular:
		return true
	}
	return false
}

func (e AuthRefreshTokenTypesEnum) String() string {
	return string(e)
}

func (e *AuthRefreshTokenTypesEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AuthRefreshTokenTypesEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid authRefreshTokenTypes_enum", str)
	}
	return nil
}

func (e AuthRefreshTokenTypesEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *AuthRefreshTokenTypesEnum) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e AuthRefreshTokenTypesEnum) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// select columns of table "auth.refresh_tokens"
type AuthRefreshTokensSelectColumn string

const (
	// column name
	AuthRefreshTokensSelectColumnCreatedAt AuthRefreshTokensSelectColumn = "createdAt"
	// column name
	AuthRefreshTokensSelectColumnExpiresAt AuthRefreshTokensSelectColumn = "expiresAt"
	// column name
	AuthRefreshTokensSelectColumnID AuthRefreshTokensSelectColumn = "id"
	// column name
	AuthRefreshTokensSelectColumnMetadata AuthRefreshTokensSelectColumn = "metadata"
	// column name
	AuthRefreshTokensSelectColumnType AuthRefreshTokensSelectColumn = "type"
	// column name
	AuthRefreshTokensSelectColumnUserID AuthRefreshTokensSelectColumn = "userId"
)

var AllAuthRefreshTokensSelectColumn = []AuthRefreshTokensSelectColumn{
	AuthRefreshTokensSelectColumnCreatedAt,
	AuthRefreshTokensSelectColumnExpiresAt,
	AuthRefreshTokensSelectColumnID,
	AuthRefreshTokensSelectColumnMetadata,
	AuthRefreshTokensSelectColumnType,
	AuthRefreshTokensSelectColumnUserID,
}

func (e AuthRefreshTokensSelectColumn) IsValid() bool {
	switch e {
	case AuthRefreshTokensSelectColumnCreatedAt, AuthRefreshTokensSelectColumnExpiresAt, AuthRefreshTokensSelectColumnID, AuthRefreshTokensSelectColumnMetadata, AuthRefreshTokensSelectColumnType, AuthRefreshTokensSelectColumnUserID:
		return true
	}
	return false
}

func (e AuthRefreshTokensSelectColumn) String() string {
	return string(e)
}

func (e *AuthRefreshTokensSelectColumn) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AuthRefreshTokensSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid authRefreshTokens_select_column", str)
	}
	return nil
}

func (e AuthRefreshTokensSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *AuthRefreshTokensSelectColumn) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e AuthRefreshTokensSelectColumn) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// select columns of table "auth.user_providers"
type AuthUserProvidersSelectColumn string

const (
	// column name
	AuthUserProvidersSelectColumnID AuthUserProvidersSelectColumn = "id"
	// column name
	AuthUserProvidersSelectColumnProviderID AuthUserProvidersSelectColumn = "providerId"
)

var AllAuthUserProvidersSelectColumn = []AuthUserProvidersSelectColumn{
	AuthUserProvidersSelectColumnID,
	AuthUserProvidersSelectColumnProviderID,
}

func (e AuthUserProvidersSelectColumn) IsValid() bool {
	switch e {
	case AuthUserProvidersSelectColumnID, AuthUserProvidersSelectColumnProviderID:
		return true
	}
	return false
}

func (e AuthUserProvidersSelectColumn) String() string {
	return string(e)
}

func (e *AuthUserProvidersSelectColumn) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AuthUserProvidersSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid authUserProviders_select_column", str)
	}
	return nil
}

func (e AuthUserProvidersSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *AuthUserProvidersSelectColumn) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e AuthUserProvidersSelectColumn) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// select columns of table "auth.user_security_keys"
type AuthUserSecurityKeysSelectColumn string

const (
	// column name
	AuthUserSecurityKeysSelectColumnID AuthUserSecurityKeysSelectColumn = "id"
	// column name
	AuthUserSecurityKeysSelectColumnNickname AuthUserSecurityKeysSelectColumn = "nickname"
	// column name
	AuthUserSecurityKeysSelectColumnUserID AuthUserSecurityKeysSelectColumn = "userId"
)

var AllAuthUserSecurityKeysSelectColumn = []AuthUserSecurityKeysSelectColumn{
	AuthUserSecurityKeysSelectColumnID,
	AuthUserSecurityKeysSelectColumnNickname,
	AuthUserSecurityKeysSelectColumnUserID,
}

func (e AuthUserSecurityKeysSelectColumn) IsValid() bool {
	switch e {
	case AuthUserSecurityKeysSelectColumnID, AuthUserSecurityKeysSelectColumnNickname, AuthUserSecurityKeysSelectColumnUserID:
		return true
	}
	return false
}

func (e AuthUserSecurityKeysSelectColumn) String() string {
	return string(e)
}

func (e *AuthUserSecurityKeysSelectColumn) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AuthUserSecurityKeysSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid authUserSecurityKeys_select_column", str)
	}
	return nil
}

func (e AuthUserSecurityKeysSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *AuthUserSecurityKeysSelectColumn) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e AuthUserSecurityKeysSelectColumn) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// select columns of table "backups"
type BackupsSelectColumn string

const (
	// column name
	BackupsSelectColumnAppID BackupsSelectColumn = "appId"
	// column name
	BackupsSelectColumnCompletedAt BackupsSelectColumn = "completedAt"
	// column name
	BackupsSelectColumnCreatedAt BackupsSelectColumn = "createdAt"
	// column name
	BackupsSelectColumnID BackupsSelectColumn = "id"
	// column name
	BackupsSelectColumnSize BackupsSelectColumn = "size"
)

var AllBackupsSelectColumn = []BackupsSelectColumn{
	BackupsSelectColumnAppID,
	BackupsSelectColumnCompletedAt,
	BackupsSelectColumnCreatedAt,
	BackupsSelectColumnID,
	BackupsSelectColumnSize,
}

func (e BackupsSelectColumn) IsValid() bool {
	switch e {
	case BackupsSelectColumnAppID, BackupsSelectColumnCompletedAt, BackupsSelectColumnCreatedAt, BackupsSelectColumnID, BackupsSelectColumnSize:
		return true
	}
	return false
}

func (e BackupsSelectColumn) String() string {
	return string(e)
}

func (e *BackupsSelectColumn) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BackupsSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid backups_select_column", str)
	}
	return nil
}

func (e BackupsSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *BackupsSelectColumn) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e BackupsSelectColumn) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// select columns of table "cli_tokens"
type CliTokensSelectColumn string

const (
	// column name
	CliTokensSelectColumnCreatedAt CliTokensSelectColumn = "createdAt"
	// column name
	CliTokensSelectColumnID CliTokensSelectColumn = "id"
	// column name
	CliTokensSelectColumnUpdatedAt CliTokensSelectColumn = "updatedAt"
)

var AllCliTokensSelectColumn = []CliTokensSelectColumn{
	CliTokensSelectColumnCreatedAt,
	CliTokensSelectColumnID,
	CliTokensSelectColumnUpdatedAt,
}

func (e CliTokensSelectColumn) IsValid() bool {
	switch e {
	case CliTokensSelectColumnCreatedAt, CliTokensSelectColumnID, CliTokensSelectColumnUpdatedAt:
		return true
	}
	return false
}

func (e CliTokensSelectColumn) String() string {
	return string(e)
}

func (e *CliTokensSelectColumn) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CliTokensSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid cliTokens_select_column", str)
	}
	return nil
}

func (e CliTokensSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *CliTokensSelectColumn) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e CliTokensSelectColumn) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// select columns of table "continents"
type ContinentsSelectColumn string

const (
	// column name
	ContinentsSelectColumnCode ContinentsSelectColumn = "code"
	// column name
	ContinentsSelectColumnName ContinentsSelectColumn = "name"
)

var AllContinentsSelectColumn = []ContinentsSelectColumn{
	ContinentsSelectColumnCode,
	ContinentsSelectColumnName,
}

func (e ContinentsSelectColumn) IsValid() bool {
	switch e {
	case ContinentsSelectColumnCode, ContinentsSelectColumnName:
		return true
	}
	return false
}

func (e ContinentsSelectColumn) String() string {
	return string(e)
}

func (e *ContinentsSelectColumn) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ContinentsSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid continents_select_column", str)
	}
	return nil
}

func (e ContinentsSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ContinentsSelectColumn) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ContinentsSelectColumn) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// select columns of table "countries"
type CountriesSelectColumn string

const (
	// column name
	CountriesSelectColumnCode CountriesSelectColumn = "code"
	// column name
	CountriesSelectColumnContinentCode CountriesSelectColumn = "continentCode"
	// column name
	CountriesSelectColumnEmojiFlag CountriesSelectColumn = "emojiFlag"
	// column name
	CountriesSelectColumnName CountriesSelectColumn = "name"
)

var AllCountriesSelectColumn = []CountriesSelectColumn{
	CountriesSelectColumnCode,
	CountriesSelectColumnContinentCode,
	CountriesSelectColumnEmojiFlag,
	CountriesSelectColumnName,
}

func (e CountriesSelectColumn) IsValid() bool {
	switch e {
	case CountriesSelectColumnCode, CountriesSelectColumnContinentCode, CountriesSelectColumnEmojiFlag, CountriesSelectColumnName:
		return true
	}
	return false
}

func (e CountriesSelectColumn) String() string {
	return string(e)
}

func (e *CountriesSelectColumn) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CountriesSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid countries_select_column", str)
	}
	return nil
}

func (e CountriesSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *CountriesSelectColumn) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e CountriesSelectColumn) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// ordering argument of a cursor
type CursorOrdering string

const (
	// ascending ordering of the cursor
	CursorOrderingAsc CursorOrdering = "ASC"
	// descending ordering of the cursor
	CursorOrderingDesc CursorOrdering = "DESC"
)

var AllCursorOrdering = []CursorOrdering{
	CursorOrderingAsc,
	CursorOrderingDesc,
}

func (e CursorOrdering) IsValid() bool {
	switch e {
	case CursorOrderingAsc, CursorOrderingDesc:
		return true
	}
	return false
}

func (e CursorOrdering) String() string {
	return string(e)
}

func (e *CursorOrdering) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CursorOrdering(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid cursor_ordering", str)
	}
	return nil
}

func (e CursorOrdering) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *CursorOrdering) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e CursorOrdering) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// select columns of table "deployment_logs"
type DeploymentLogsSelectColumn string

const (
	// column name
	DeploymentLogsSelectColumnCreatedAt DeploymentLogsSelectColumn = "createdAt"
	// column name
	DeploymentLogsSelectColumnDeploymentID DeploymentLogsSelectColumn = "deploymentId"
	// column name
	DeploymentLogsSelectColumnID DeploymentLogsSelectColumn = "id"
	// column name
	DeploymentLogsSelectColumnMessage DeploymentLogsSelectColumn = "message"
)

var AllDeploymentLogsSelectColumn = []DeploymentLogsSelectColumn{
	DeploymentLogsSelectColumnCreatedAt,
	DeploymentLogsSelectColumnDeploymentID,
	DeploymentLogsSelectColumnID,
	DeploymentLogsSelectColumnMessage,
}

func (e DeploymentLogsSelectColumn) IsValid() bool {
	switch e {
	case DeploymentLogsSelectColumnCreatedAt, DeploymentLogsSelectColumnDeploymentID, DeploymentLogsSelectColumnID, DeploymentLogsSelectColumnMessage:
		return true
	}
	return false
}

func (e DeploymentLogsSelectColumn) String() string {
	return string(e)
}

func (e *DeploymentLogsSelectColumn) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DeploymentLogsSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid deploymentLogs_select_column", str)
	}
	return nil
}

func (e DeploymentLogsSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *DeploymentLogsSelectColumn) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e DeploymentLogsSelectColumn) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// unique or primary key constraints on table "deployments"
type DeploymentsConstraint string

const (
	// unique or primary key constraint on columns "id"
	DeploymentsConstraintDeploymentsPkey DeploymentsConstraint = "deployments_pkey"
)

var AllDeploymentsConstraint = []DeploymentsConstraint{
	DeploymentsConstraintDeploymentsPkey,
}

func (e DeploymentsConstraint) IsValid() bool {
	switch e {
	case DeploymentsConstraintDeploymentsPkey:
		return true
	}
	return false
}

func (e DeploymentsConstraint) String() string {
	return string(e)
}

func (e *DeploymentsConstraint) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DeploymentsConstraint(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid deployments_constraint", str)
	}
	return nil
}

func (e DeploymentsConstraint) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *DeploymentsConstraint) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e DeploymentsConstraint) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// select columns of table "deployments"
type DeploymentsSelectColumn string

const (
	// column name
	DeploymentsSelectColumnAppID DeploymentsSelectColumn = "appId"
	// column name
	DeploymentsSelectColumnCommitMessage DeploymentsSelectColumn = "commitMessage"
	// column name
	DeploymentsSelectColumnCommitSha DeploymentsSelectColumn = "commitSHA"
	// column name
	DeploymentsSelectColumnCommitUserAvatarURL DeploymentsSelectColumn = "commitUserAvatarUrl"
	// column name
	DeploymentsSelectColumnCommitUserName DeploymentsSelectColumn = "commitUserName"
	// column name
	DeploymentsSelectColumnDeploymentEndedAt DeploymentsSelectColumn = "deploymentEndedAt"
	// column name
	DeploymentsSelectColumnDeploymentStartedAt DeploymentsSelectColumn = "deploymentStartedAt"
	// column name
	DeploymentsSelectColumnDeploymentStatus DeploymentsSelectColumn = "deploymentStatus"
	// column name
	DeploymentsSelectColumnFunctionsEndedAt DeploymentsSelectColumn = "functionsEndedAt"
	// column name
	DeploymentsSelectColumnFunctionsStartedAt DeploymentsSelectColumn = "functionsStartedAt"
	// column name
	DeploymentsSelectColumnFunctionsStatus DeploymentsSelectColumn = "functionsStatus"
	// column name
	DeploymentsSelectColumnID DeploymentsSelectColumn = "id"
	// column name
	DeploymentsSelectColumnMetadataEndedAt DeploymentsSelectColumn = "metadataEndedAt"
	// column name
	DeploymentsSelectColumnMetadataStartedAt DeploymentsSelectColumn = "metadataStartedAt"
	// column name
	DeploymentsSelectColumnMetadataStatus DeploymentsSelectColumn = "metadataStatus"
	// column name
	DeploymentsSelectColumnMigrationsEndedAt DeploymentsSelectColumn = "migrationsEndedAt"
	// column name
	DeploymentsSelectColumnMigrationsStartedAt DeploymentsSelectColumn = "migrationsStartedAt"
	// column name
	DeploymentsSelectColumnMigrationsStatus DeploymentsSelectColumn = "migrationsStatus"
)

var AllDeploymentsSelectColumn = []DeploymentsSelectColumn{
	DeploymentsSelectColumnAppID,
	DeploymentsSelectColumnCommitMessage,
	DeploymentsSelectColumnCommitSha,
	DeploymentsSelectColumnCommitUserAvatarURL,
	DeploymentsSelectColumnCommitUserName,
	DeploymentsSelectColumnDeploymentEndedAt,
	DeploymentsSelectColumnDeploymentStartedAt,
	DeploymentsSelectColumnDeploymentStatus,
	DeploymentsSelectColumnFunctionsEndedAt,
	DeploymentsSelectColumnFunctionsStartedAt,
	DeploymentsSelectColumnFunctionsStatus,
	DeploymentsSelectColumnID,
	DeploymentsSelectColumnMetadataEndedAt,
	DeploymentsSelectColumnMetadataStartedAt,
	DeploymentsSelectColumnMetadataStatus,
	DeploymentsSelectColumnMigrationsEndedAt,
	DeploymentsSelectColumnMigrationsStartedAt,
	DeploymentsSelectColumnMigrationsStatus,
}

func (e DeploymentsSelectColumn) IsValid() bool {
	switch e {
	case DeploymentsSelectColumnAppID, DeploymentsSelectColumnCommitMessage, DeploymentsSelectColumnCommitSha, DeploymentsSelectColumnCommitUserAvatarURL, DeploymentsSelectColumnCommitUserName, DeploymentsSelectColumnDeploymentEndedAt, DeploymentsSelectColumnDeploymentStartedAt, DeploymentsSelectColumnDeploymentStatus, DeploymentsSelectColumnFunctionsEndedAt, DeploymentsSelectColumnFunctionsStartedAt, DeploymentsSelectColumnFunctionsStatus, DeploymentsSelectColumnID, DeploymentsSelectColumnMetadataEndedAt, DeploymentsSelectColumnMetadataStartedAt, DeploymentsSelectColumnMetadataStatus, DeploymentsSelectColumnMigrationsEndedAt, DeploymentsSelectColumnMigrationsStartedAt, DeploymentsSelectColumnMigrationsStatus:
		return true
	}
	return false
}

func (e DeploymentsSelectColumn) String() string {
	return string(e)
}

func (e *DeploymentsSelectColumn) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DeploymentsSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid deployments_select_column", str)
	}
	return nil
}

func (e DeploymentsSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *DeploymentsSelectColumn) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e DeploymentsSelectColumn) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// placeholder for update columns of table "deployments" (current role has no relevant permissions)
type DeploymentsUpdateColumn string

const (
	// placeholder (do not use)
	DeploymentsUpdateColumnPlaceholder DeploymentsUpdateColumn = "_PLACEHOLDER"
)

var AllDeploymentsUpdateColumn = []DeploymentsUpdateColumn{
	DeploymentsUpdateColumnPlaceholder,
}

func (e DeploymentsUpdateColumn) IsValid() bool {
	switch e {
	case DeploymentsUpdateColumnPlaceholder:
		return true
	}
	return false
}

func (e DeploymentsUpdateColumn) String() string {
	return string(e)
}

func (e *DeploymentsUpdateColumn) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DeploymentsUpdateColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid deployments_update_column", str)
	}
	return nil
}

func (e DeploymentsUpdateColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *DeploymentsUpdateColumn) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e DeploymentsUpdateColumn) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// unique or primary key constraints on table "feature_flags"
type FeatureFlagsConstraint string

const (
	// unique or primary key constraint on columns "id"
	FeatureFlagsConstraintFeatureFlagsPkey FeatureFlagsConstraint = "feature_flags_pkey"
)

var AllFeatureFlagsConstraint = []FeatureFlagsConstraint{
	FeatureFlagsConstraintFeatureFlagsPkey,
}

func (e FeatureFlagsConstraint) IsValid() bool {
	switch e {
	case FeatureFlagsConstraintFeatureFlagsPkey:
		return true
	}
	return false
}

func (e FeatureFlagsConstraint) String() string {
	return string(e)
}

func (e *FeatureFlagsConstraint) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FeatureFlagsConstraint(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid featureFlags_constraint", str)
	}
	return nil
}

func (e FeatureFlagsConstraint) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *FeatureFlagsConstraint) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e FeatureFlagsConstraint) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// select columns of table "feature_flags"
type FeatureFlagsSelectColumn string

const (
	// column name
	FeatureFlagsSelectColumnAppID FeatureFlagsSelectColumn = "appId"
	// column name
	FeatureFlagsSelectColumnDescription FeatureFlagsSelectColumn = "description"
	// column name
	FeatureFlagsSelectColumnID FeatureFlagsSelectColumn = "id"
	// column name
	FeatureFlagsSelectColumnName FeatureFlagsSelectColumn = "name"
	// column name
	FeatureFlagsSelectColumnValue FeatureFlagsSelectColumn = "value"
)

var AllFeatureFlagsSelectColumn = []FeatureFlagsSelectColumn{
	FeatureFlagsSelectColumnAppID,
	FeatureFlagsSelectColumnDescription,
	FeatureFlagsSelectColumnID,
	FeatureFlagsSelectColumnName,
	FeatureFlagsSelectColumnValue,
}

func (e FeatureFlagsSelectColumn) IsValid() bool {
	switch e {
	case FeatureFlagsSelectColumnAppID, FeatureFlagsSelectColumnDescription, FeatureFlagsSelectColumnID, FeatureFlagsSelectColumnName, FeatureFlagsSelectColumnValue:
		return true
	}
	return false
}

func (e FeatureFlagsSelectColumn) String() string {
	return string(e)
}

func (e *FeatureFlagsSelectColumn) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FeatureFlagsSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid featureFlags_select_column", str)
	}
	return nil
}

func (e FeatureFlagsSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *FeatureFlagsSelectColumn) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e FeatureFlagsSelectColumn) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// placeholder for update columns of table "feature_flags" (current role has no relevant permissions)
type FeatureFlagsUpdateColumn string

const (
	// placeholder (do not use)
	FeatureFlagsUpdateColumnPlaceholder FeatureFlagsUpdateColumn = "_PLACEHOLDER"
)

var AllFeatureFlagsUpdateColumn = []FeatureFlagsUpdateColumn{
	FeatureFlagsUpdateColumnPlaceholder,
}

func (e FeatureFlagsUpdateColumn) IsValid() bool {
	switch e {
	case FeatureFlagsUpdateColumnPlaceholder:
		return true
	}
	return false
}

func (e FeatureFlagsUpdateColumn) String() string {
	return string(e)
}

func (e *FeatureFlagsUpdateColumn) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FeatureFlagsUpdateColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid featureFlags_update_column", str)
	}
	return nil
}

func (e FeatureFlagsUpdateColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *FeatureFlagsUpdateColumn) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e FeatureFlagsUpdateColumn) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// select columns of table "storage.files"
type FilesSelectColumn string

const (
	// column name
	FilesSelectColumnBucketID FilesSelectColumn = "bucketId"
	// column name
	FilesSelectColumnCreatedAt FilesSelectColumn = "createdAt"
	// column name
	FilesSelectColumnEtag FilesSelectColumn = "etag"
	// column name
	FilesSelectColumnID FilesSelectColumn = "id"
	// column name
	FilesSelectColumnIsUploaded FilesSelectColumn = "isUploaded"
	// column name
	FilesSelectColumnMetadata FilesSelectColumn = "metadata"
	// column name
	FilesSelectColumnMimeType FilesSelectColumn = "mimeType"
	// column name
	FilesSelectColumnName FilesSelectColumn = "name"
	// column name
	FilesSelectColumnSize FilesSelectColumn = "size"
	// column name
	FilesSelectColumnUpdatedAt FilesSelectColumn = "updatedAt"
	// column name
	FilesSelectColumnUploadedByUserID FilesSelectColumn = "uploadedByUserId"
)

var AllFilesSelectColumn = []FilesSelectColumn{
	FilesSelectColumnBucketID,
	FilesSelectColumnCreatedAt,
	FilesSelectColumnEtag,
	FilesSelectColumnID,
	FilesSelectColumnIsUploaded,
	FilesSelectColumnMetadata,
	FilesSelectColumnMimeType,
	FilesSelectColumnName,
	FilesSelectColumnSize,
	FilesSelectColumnUpdatedAt,
	FilesSelectColumnUploadedByUserID,
}

func (e FilesSelectColumn) IsValid() bool {
	switch e {
	case FilesSelectColumnBucketID, FilesSelectColumnCreatedAt, FilesSelectColumnEtag, FilesSelectColumnID, FilesSelectColumnIsUploaded, FilesSelectColumnMetadata, FilesSelectColumnMimeType, FilesSelectColumnName, FilesSelectColumnSize, FilesSelectColumnUpdatedAt, FilesSelectColumnUploadedByUserID:
		return true
	}
	return false
}

func (e FilesSelectColumn) String() string {
	return string(e)
}

func (e *FilesSelectColumn) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FilesSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid files_select_column", str)
	}
	return nil
}

func (e FilesSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *FilesSelectColumn) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e FilesSelectColumn) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// unique or primary key constraints on table "github_app_installations"
type GithubAppInstallationsConstraint string

const (
	// unique or primary key constraint on columns "external_github_app_installation_id"
	GithubAppInstallationsConstraintGithubAppInstallationsExternalGithubAppInstallationIKey GithubAppInstallationsConstraint = "github_app_installations_external_github_app_installation_i_key"
	// unique or primary key constraint on columns "id"
	GithubAppInstallationsConstraintGithubAppInstallationsPkey GithubAppInstallationsConstraint = "github_app_installations_pkey"
)

var AllGithubAppInstallationsConstraint = []GithubAppInstallationsConstraint{
	GithubAppInstallationsConstraintGithubAppInstallationsExternalGithubAppInstallationIKey,
	GithubAppInstallationsConstraintGithubAppInstallationsPkey,
}

func (e GithubAppInstallationsConstraint) IsValid() bool {
	switch e {
	case GithubAppInstallationsConstraintGithubAppInstallationsExternalGithubAppInstallationIKey, GithubAppInstallationsConstraintGithubAppInstallationsPkey:
		return true
	}
	return false
}

func (e GithubAppInstallationsConstraint) String() string {
	return string(e)
}

func (e *GithubAppInstallationsConstraint) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GithubAppInstallationsConstraint(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid githubAppInstallations_constraint", str)
	}
	return nil
}

func (e GithubAppInstallationsConstraint) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *GithubAppInstallationsConstraint) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e GithubAppInstallationsConstraint) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// select columns of table "github_app_installations"
type GithubAppInstallationsSelectColumn string

const (
	// column name
	GithubAppInstallationsSelectColumnAccountAvatarURL GithubAppInstallationsSelectColumn = "accountAvatarUrl"
	// column name
	GithubAppInstallationsSelectColumnAccountLogin GithubAppInstallationsSelectColumn = "accountLogin"
	// column name
	GithubAppInstallationsSelectColumnAccountType GithubAppInstallationsSelectColumn = "accountType"
	// column name
	GithubAppInstallationsSelectColumnCreatedAt GithubAppInstallationsSelectColumn = "createdAt"
	// column name
	GithubAppInstallationsSelectColumnID GithubAppInstallationsSelectColumn = "id"
	// column name
	GithubAppInstallationsSelectColumnUpdatedAt GithubAppInstallationsSelectColumn = "updatedAt"
)

var AllGithubAppInstallationsSelectColumn = []GithubAppInstallationsSelectColumn{
	GithubAppInstallationsSelectColumnAccountAvatarURL,
	GithubAppInstallationsSelectColumnAccountLogin,
	GithubAppInstallationsSelectColumnAccountType,
	GithubAppInstallationsSelectColumnCreatedAt,
	GithubAppInstallationsSelectColumnID,
	GithubAppInstallationsSelectColumnUpdatedAt,
}

func (e GithubAppInstallationsSelectColumn) IsValid() bool {
	switch e {
	case GithubAppInstallationsSelectColumnAccountAvatarURL, GithubAppInstallationsSelectColumnAccountLogin, GithubAppInstallationsSelectColumnAccountType, GithubAppInstallationsSelectColumnCreatedAt, GithubAppInstallationsSelectColumnID, GithubAppInstallationsSelectColumnUpdatedAt:
		return true
	}
	return false
}

func (e GithubAppInstallationsSelectColumn) String() string {
	return string(e)
}

func (e *GithubAppInstallationsSelectColumn) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GithubAppInstallationsSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid githubAppInstallations_select_column", str)
	}
	return nil
}

func (e GithubAppInstallationsSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *GithubAppInstallationsSelectColumn) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e GithubAppInstallationsSelectColumn) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// placeholder for update columns of table "github_app_installations" (current role has no relevant permissions)
type GithubAppInstallationsUpdateColumn string

const (
	// placeholder (do not use)
	GithubAppInstallationsUpdateColumnPlaceholder GithubAppInstallationsUpdateColumn = "_PLACEHOLDER"
)

var AllGithubAppInstallationsUpdateColumn = []GithubAppInstallationsUpdateColumn{
	GithubAppInstallationsUpdateColumnPlaceholder,
}

func (e GithubAppInstallationsUpdateColumn) IsValid() bool {
	switch e {
	case GithubAppInstallationsUpdateColumnPlaceholder:
		return true
	}
	return false
}

func (e GithubAppInstallationsUpdateColumn) String() string {
	return string(e)
}

func (e *GithubAppInstallationsUpdateColumn) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GithubAppInstallationsUpdateColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid githubAppInstallations_update_column", str)
	}
	return nil
}

func (e GithubAppInstallationsUpdateColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *GithubAppInstallationsUpdateColumn) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e GithubAppInstallationsUpdateColumn) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// select columns of table "github_repositories"
type GithubRepositoriesSelectColumn string

const (
	// column name
	GithubRepositoriesSelectColumnCreatedAt GithubRepositoriesSelectColumn = "createdAt"
	// column name
	GithubRepositoriesSelectColumnFullName GithubRepositoriesSelectColumn = "fullName"
	// column name
	GithubRepositoriesSelectColumnID GithubRepositoriesSelectColumn = "id"
	// column name
	GithubRepositoriesSelectColumnName GithubRepositoriesSelectColumn = "name"
	// column name
	GithubRepositoriesSelectColumnPrivate GithubRepositoriesSelectColumn = "private"
	// column name
	GithubRepositoriesSelectColumnUpdatedAt GithubRepositoriesSelectColumn = "updatedAt"
)

var AllGithubRepositoriesSelectColumn = []GithubRepositoriesSelectColumn{
	GithubRepositoriesSelectColumnCreatedAt,
	GithubRepositoriesSelectColumnFullName,
	GithubRepositoriesSelectColumnID,
	GithubRepositoriesSelectColumnName,
	GithubRepositoriesSelectColumnPrivate,
	GithubRepositoriesSelectColumnUpdatedAt,
}

func (e GithubRepositoriesSelectColumn) IsValid() bool {
	switch e {
	case GithubRepositoriesSelectColumnCreatedAt, GithubRepositoriesSelectColumnFullName, GithubRepositoriesSelectColumnID, GithubRepositoriesSelectColumnName, GithubRepositoriesSelectColumnPrivate, GithubRepositoriesSelectColumnUpdatedAt:
		return true
	}
	return false
}

func (e GithubRepositoriesSelectColumn) String() string {
	return string(e)
}

func (e *GithubRepositoriesSelectColumn) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GithubRepositoriesSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid githubRepositories_select_column", str)
	}
	return nil
}

func (e GithubRepositoriesSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *GithubRepositoriesSelectColumn) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e GithubRepositoriesSelectColumn) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// column ordering options
type OrderBy string

const (
	// in ascending order, nulls last
	OrderByAsc OrderBy = "asc"
	// in ascending order, nulls first
	OrderByAscNullsFirst OrderBy = "asc_nulls_first"
	// in ascending order, nulls last
	OrderByAscNullsLast OrderBy = "asc_nulls_last"
	// in descending order, nulls first
	OrderByDesc OrderBy = "desc"
	// in descending order, nulls first
	OrderByDescNullsFirst OrderBy = "desc_nulls_first"
	// in descending order, nulls last
	OrderByDescNullsLast OrderBy = "desc_nulls_last"
)

var AllOrderBy = []OrderBy{
	OrderByAsc,
	OrderByAscNullsFirst,
	OrderByAscNullsLast,
	OrderByDesc,
	OrderByDescNullsFirst,
	OrderByDescNullsLast,
}

func (e OrderBy) IsValid() bool {
	switch e {
	case OrderByAsc, OrderByAscNullsFirst, OrderByAscNullsLast, OrderByDesc, OrderByDescNullsFirst, OrderByDescNullsLast:
		return true
	}
	return false
}

func (e OrderBy) String() string {
	return string(e)
}

func (e *OrderBy) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrderBy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid order_by", str)
	}
	return nil
}

func (e OrderBy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *OrderBy) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e OrderBy) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type OrganizationCostsThresholdsEnum string

const (
	// No threshold reached
	OrganizationCostsThresholdsEnumNone OrganizationCostsThresholdsEnum = "NONE"
	// 75% of cost usage reached
	OrganizationCostsThresholdsEnumPercent075 OrganizationCostsThresholdsEnum = "PERCENT_075"
	// 90% of cost usage reached
	OrganizationCostsThresholdsEnumPercent090 OrganizationCostsThresholdsEnum = "PERCENT_090"
	// 100% of cost usage reached
	OrganizationCostsThresholdsEnumPercent100 OrganizationCostsThresholdsEnum = "PERCENT_100"
)

var AllOrganizationCostsThresholdsEnum = []OrganizationCostsThresholdsEnum{
	OrganizationCostsThresholdsEnumNone,
	OrganizationCostsThresholdsEnumPercent075,
	OrganizationCostsThresholdsEnumPercent090,
	OrganizationCostsThresholdsEnumPercent100,
}

func (e OrganizationCostsThresholdsEnum) IsValid() bool {
	switch e {
	case OrganizationCostsThresholdsEnumNone, OrganizationCostsThresholdsEnumPercent075, OrganizationCostsThresholdsEnumPercent090, OrganizationCostsThresholdsEnumPercent100:
		return true
	}
	return false
}

func (e OrganizationCostsThresholdsEnum) String() string {
	return string(e)
}

func (e *OrganizationCostsThresholdsEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrganizationCostsThresholdsEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid organization_costs_thresholds_enum", str)
	}
	return nil
}

func (e OrganizationCostsThresholdsEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *OrganizationCostsThresholdsEnum) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e OrganizationCostsThresholdsEnum) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// unique or primary key constraints on table "organization_member_invites"
type OrganizationMemberInvitesConstraint string

const (
	// unique or primary key constraint on columns "email", "organization_id"
	OrganizationMemberInvitesConstraintOrganizationMemberInvitesOrganizationIDEmailKey OrganizationMemberInvitesConstraint = "organization_member_invites_organization_id_email_key"
	// unique or primary key constraint on columns "id"
	OrganizationMemberInvitesConstraintOrganizationMemberInvitesPkey OrganizationMemberInvitesConstraint = "organization_member_invites_pkey"
)

var AllOrganizationMemberInvitesConstraint = []OrganizationMemberInvitesConstraint{
	OrganizationMemberInvitesConstraintOrganizationMemberInvitesOrganizationIDEmailKey,
	OrganizationMemberInvitesConstraintOrganizationMemberInvitesPkey,
}

func (e OrganizationMemberInvitesConstraint) IsValid() bool {
	switch e {
	case OrganizationMemberInvitesConstraintOrganizationMemberInvitesOrganizationIDEmailKey, OrganizationMemberInvitesConstraintOrganizationMemberInvitesPkey:
		return true
	}
	return false
}

func (e OrganizationMemberInvitesConstraint) String() string {
	return string(e)
}

func (e *OrganizationMemberInvitesConstraint) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrganizationMemberInvitesConstraint(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid organization_member_invites_constraint", str)
	}
	return nil
}

func (e OrganizationMemberInvitesConstraint) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *OrganizationMemberInvitesConstraint) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e OrganizationMemberInvitesConstraint) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// select columns of table "organization_member_invites"
type OrganizationMemberInvitesSelectColumn string

const (
	// column name
	OrganizationMemberInvitesSelectColumnCreatedAt OrganizationMemberInvitesSelectColumn = "createdAt"
	// column name
	OrganizationMemberInvitesSelectColumnEmail OrganizationMemberInvitesSelectColumn = "email"
	// column name
	OrganizationMemberInvitesSelectColumnID OrganizationMemberInvitesSelectColumn = "id"
	// column name
	OrganizationMemberInvitesSelectColumnOrganizationID OrganizationMemberInvitesSelectColumn = "organizationID"
	// column name
	OrganizationMemberInvitesSelectColumnRole OrganizationMemberInvitesSelectColumn = "role"
	// column name
	OrganizationMemberInvitesSelectColumnUpdateAt OrganizationMemberInvitesSelectColumn = "updateAt"
)

var AllOrganizationMemberInvitesSelectColumn = []OrganizationMemberInvitesSelectColumn{
	OrganizationMemberInvitesSelectColumnCreatedAt,
	OrganizationMemberInvitesSelectColumnEmail,
	OrganizationMemberInvitesSelectColumnID,
	OrganizationMemberInvitesSelectColumnOrganizationID,
	OrganizationMemberInvitesSelectColumnRole,
	OrganizationMemberInvitesSelectColumnUpdateAt,
}

func (e OrganizationMemberInvitesSelectColumn) IsValid() bool {
	switch e {
	case OrganizationMemberInvitesSelectColumnCreatedAt, OrganizationMemberInvitesSelectColumnEmail, OrganizationMemberInvitesSelectColumnID, OrganizationMemberInvitesSelectColumnOrganizationID, OrganizationMemberInvitesSelectColumnRole, OrganizationMemberInvitesSelectColumnUpdateAt:
		return true
	}
	return false
}

func (e OrganizationMemberInvitesSelectColumn) String() string {
	return string(e)
}

func (e *OrganizationMemberInvitesSelectColumn) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrganizationMemberInvitesSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid organization_member_invites_select_column", str)
	}
	return nil
}

func (e OrganizationMemberInvitesSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *OrganizationMemberInvitesSelectColumn) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e OrganizationMemberInvitesSelectColumn) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// update columns of table "organization_member_invites"
type OrganizationMemberInvitesUpdateColumn string

const (
	// column name
	OrganizationMemberInvitesUpdateColumnRole OrganizationMemberInvitesUpdateColumn = "role"
)

var AllOrganizationMemberInvitesUpdateColumn = []OrganizationMemberInvitesUpdateColumn{
	OrganizationMemberInvitesUpdateColumnRole,
}

func (e OrganizationMemberInvitesUpdateColumn) IsValid() bool {
	switch e {
	case OrganizationMemberInvitesUpdateColumnRole:
		return true
	}
	return false
}

func (e OrganizationMemberInvitesUpdateColumn) String() string {
	return string(e)
}

func (e *OrganizationMemberInvitesUpdateColumn) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrganizationMemberInvitesUpdateColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid organization_member_invites_update_column", str)
	}
	return nil
}

func (e OrganizationMemberInvitesUpdateColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *OrganizationMemberInvitesUpdateColumn) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e OrganizationMemberInvitesUpdateColumn) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type OrganizationMembersRoleEnum string

const (
	// Administrator
	OrganizationMembersRoleEnumAdmin OrganizationMembersRoleEnum = "ADMIN"
	// User
	OrganizationMembersRoleEnumUser OrganizationMembersRoleEnum = "USER"
)

var AllOrganizationMembersRoleEnum = []OrganizationMembersRoleEnum{
	OrganizationMembersRoleEnumAdmin,
	OrganizationMembersRoleEnumUser,
}

func (e OrganizationMembersRoleEnum) IsValid() bool {
	switch e {
	case OrganizationMembersRoleEnumAdmin, OrganizationMembersRoleEnumUser:
		return true
	}
	return false
}

func (e OrganizationMembersRoleEnum) String() string {
	return string(e)
}

func (e *OrganizationMembersRoleEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrganizationMembersRoleEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid organization_members_role_enum", str)
	}
	return nil
}

func (e OrganizationMembersRoleEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *OrganizationMembersRoleEnum) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e OrganizationMembersRoleEnum) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// select columns of table "organization_members"
type OrganizationMembersSelectColumn string

const (
	// column name
	OrganizationMembersSelectColumnCreatedAt OrganizationMembersSelectColumn = "createdAt"
	// column name
	OrganizationMembersSelectColumnID OrganizationMembersSelectColumn = "id"
	// column name
	OrganizationMembersSelectColumnOrganizatonID OrganizationMembersSelectColumn = "organizatonID"
	// column name
	OrganizationMembersSelectColumnRole OrganizationMembersSelectColumn = "role"
	// column name
	OrganizationMembersSelectColumnUpdatedAt OrganizationMembersSelectColumn = "updatedAt"
	// column name
	OrganizationMembersSelectColumnUserID OrganizationMembersSelectColumn = "userID"
)

var AllOrganizationMembersSelectColumn = []OrganizationMembersSelectColumn{
	OrganizationMembersSelectColumnCreatedAt,
	OrganizationMembersSelectColumnID,
	OrganizationMembersSelectColumnOrganizatonID,
	OrganizationMembersSelectColumnRole,
	OrganizationMembersSelectColumnUpdatedAt,
	OrganizationMembersSelectColumnUserID,
}

func (e OrganizationMembersSelectColumn) IsValid() bool {
	switch e {
	case OrganizationMembersSelectColumnCreatedAt, OrganizationMembersSelectColumnID, OrganizationMembersSelectColumnOrganizatonID, OrganizationMembersSelectColumnRole, OrganizationMembersSelectColumnUpdatedAt, OrganizationMembersSelectColumnUserID:
		return true
	}
	return false
}

func (e OrganizationMembersSelectColumn) String() string {
	return string(e)
}

func (e *OrganizationMembersSelectColumn) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrganizationMembersSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid organization_members_select_column", str)
	}
	return nil
}

func (e OrganizationMembersSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *OrganizationMembersSelectColumn) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e OrganizationMembersSelectColumn) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// select columns of table "organization_new_request"
type OrganizationNewRequestSelectColumn string

const (
	// column name
	OrganizationNewRequestSelectColumnCreatedAt OrganizationNewRequestSelectColumn = "createdAt"
	// column name
	OrganizationNewRequestSelectColumnID OrganizationNewRequestSelectColumn = "id"
	// column name
	OrganizationNewRequestSelectColumnName OrganizationNewRequestSelectColumn = "name"
	// column name
	OrganizationNewRequestSelectColumnPlanID OrganizationNewRequestSelectColumn = "planID"
	// column name
	OrganizationNewRequestSelectColumnSessionID OrganizationNewRequestSelectColumn = "sessionID"
	// column name
	OrganizationNewRequestSelectColumnUserID OrganizationNewRequestSelectColumn = "userID"
)

var AllOrganizationNewRequestSelectColumn = []OrganizationNewRequestSelectColumn{
	OrganizationNewRequestSelectColumnCreatedAt,
	OrganizationNewRequestSelectColumnID,
	OrganizationNewRequestSelectColumnName,
	OrganizationNewRequestSelectColumnPlanID,
	OrganizationNewRequestSelectColumnSessionID,
	OrganizationNewRequestSelectColumnUserID,
}

func (e OrganizationNewRequestSelectColumn) IsValid() bool {
	switch e {
	case OrganizationNewRequestSelectColumnCreatedAt, OrganizationNewRequestSelectColumnID, OrganizationNewRequestSelectColumnName, OrganizationNewRequestSelectColumnPlanID, OrganizationNewRequestSelectColumnSessionID, OrganizationNewRequestSelectColumnUserID:
		return true
	}
	return false
}

func (e OrganizationNewRequestSelectColumn) String() string {
	return string(e)
}

func (e *OrganizationNewRequestSelectColumn) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrganizationNewRequestSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid organization_new_request_select_column", str)
	}
	return nil
}

func (e OrganizationNewRequestSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *OrganizationNewRequestSelectColumn) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e OrganizationNewRequestSelectColumn) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type OrganizationStatusEnum string

const (
	// Allowance for the organization has been exceeded. Allowance will be reset at the end of the month.
	OrganizationStatusEnumAllowanceExceeded OrganizationStatusEnum = "ALLOWANCE_EXCEEDED"
	// Organization is cancelled. Contact support.
	OrganizationStatusEnumCancelled OrganizationStatusEnum = "CANCELLED"
	// Organization is disabled and all resources have been suspended
	OrganizationStatusEnumDisabled OrganizationStatusEnum = "DISABLED"
	// Organization is locked and changes to resources are not allowed
	OrganizationStatusEnumLocked OrganizationStatusEnum = "LOCKED"
	// Organization is healthy
	OrganizationStatusEnumOk OrganizationStatusEnum = "OK"
)

var AllOrganizationStatusEnum = []OrganizationStatusEnum{
	OrganizationStatusEnumAllowanceExceeded,
	OrganizationStatusEnumCancelled,
	OrganizationStatusEnumDisabled,
	OrganizationStatusEnumLocked,
	OrganizationStatusEnumOk,
}

func (e OrganizationStatusEnum) IsValid() bool {
	switch e {
	case OrganizationStatusEnumAllowanceExceeded, OrganizationStatusEnumCancelled, OrganizationStatusEnumDisabled, OrganizationStatusEnumLocked, OrganizationStatusEnumOk:
		return true
	}
	return false
}

func (e OrganizationStatusEnum) String() string {
	return string(e)
}

func (e *OrganizationStatusEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrganizationStatusEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid organization_status_enum", str)
	}
	return nil
}

func (e OrganizationStatusEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *OrganizationStatusEnum) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e OrganizationStatusEnum) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// select columns of table "organizations"
type OrganizationsSelectColumn string

const (
	// column name
	OrganizationsSelectColumnCreatedAt OrganizationsSelectColumn = "createdAt"
	// column name
	OrganizationsSelectColumnCurrentThreshold OrganizationsSelectColumn = "current_threshold"
	// column name
	OrganizationsSelectColumnID OrganizationsSelectColumn = "id"
	// column name
	OrganizationsSelectColumnName OrganizationsSelectColumn = "name"
	// column name
	OrganizationsSelectColumnPlanID OrganizationsSelectColumn = "planID"
	// column name
	OrganizationsSelectColumnSlug OrganizationsSelectColumn = "slug"
	// column name
	OrganizationsSelectColumnStatus OrganizationsSelectColumn = "status"
	// column name
	OrganizationsSelectColumnThreshold OrganizationsSelectColumn = "threshold"
	// column name
	OrganizationsSelectColumnUpdatedAt OrganizationsSelectColumn = "updatedAt"
)

var AllOrganizationsSelectColumn = []OrganizationsSelectColumn{
	OrganizationsSelectColumnCreatedAt,
	OrganizationsSelectColumnCurrentThreshold,
	OrganizationsSelectColumnID,
	OrganizationsSelectColumnName,
	OrganizationsSelectColumnPlanID,
	OrganizationsSelectColumnSlug,
	OrganizationsSelectColumnStatus,
	OrganizationsSelectColumnThreshold,
	OrganizationsSelectColumnUpdatedAt,
}

func (e OrganizationsSelectColumn) IsValid() bool {
	switch e {
	case OrganizationsSelectColumnCreatedAt, OrganizationsSelectColumnCurrentThreshold, OrganizationsSelectColumnID, OrganizationsSelectColumnName, OrganizationsSelectColumnPlanID, OrganizationsSelectColumnSlug, OrganizationsSelectColumnStatus, OrganizationsSelectColumnThreshold, OrganizationsSelectColumnUpdatedAt:
		return true
	}
	return false
}

func (e OrganizationsSelectColumn) String() string {
	return string(e)
}

func (e *OrganizationsSelectColumn) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrganizationsSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid organizations_select_column", str)
	}
	return nil
}

func (e OrganizationsSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *OrganizationsSelectColumn) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e OrganizationsSelectColumn) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// unique or primary key constraints on table "payment_methods"
type PaymentMethodsConstraint string

const (
	// unique or primary key constraint on columns "id"
	PaymentMethodsConstraintPaymentMethodsPkey PaymentMethodsConstraint = "payment_methods_pkey"
)

var AllPaymentMethodsConstraint = []PaymentMethodsConstraint{
	PaymentMethodsConstraintPaymentMethodsPkey,
}

func (e PaymentMethodsConstraint) IsValid() bool {
	switch e {
	case PaymentMethodsConstraintPaymentMethodsPkey:
		return true
	}
	return false
}

func (e PaymentMethodsConstraint) String() string {
	return string(e)
}

func (e *PaymentMethodsConstraint) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PaymentMethodsConstraint(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid paymentMethods_constraint", str)
	}
	return nil
}

func (e PaymentMethodsConstraint) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *PaymentMethodsConstraint) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e PaymentMethodsConstraint) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// select columns of table "payment_methods"
type PaymentMethodsSelectColumn string

const (
	// column name
	PaymentMethodsSelectColumnAddedByUserID PaymentMethodsSelectColumn = "addedByUserId"
	// column name
	PaymentMethodsSelectColumnCardBrand PaymentMethodsSelectColumn = "cardBrand"
	// column name
	PaymentMethodsSelectColumnCardExpMonth PaymentMethodsSelectColumn = "cardExpMonth"
	// column name
	PaymentMethodsSelectColumnCardExpYear PaymentMethodsSelectColumn = "cardExpYear"
	// column name
	PaymentMethodsSelectColumnCardLast4 PaymentMethodsSelectColumn = "cardLast4"
	// column name
	PaymentMethodsSelectColumnCreatedAt PaymentMethodsSelectColumn = "createdAt"
	// column name
	PaymentMethodsSelectColumnID PaymentMethodsSelectColumn = "id"
	// column name
	PaymentMethodsSelectColumnIsDefault PaymentMethodsSelectColumn = "isDefault"
	// column name
	PaymentMethodsSelectColumnStripePaymentMethodID PaymentMethodsSelectColumn = "stripePaymentMethodId"
	// column name
	PaymentMethodsSelectColumnWorkspaceID PaymentMethodsSelectColumn = "workspaceId"
)

var AllPaymentMethodsSelectColumn = []PaymentMethodsSelectColumn{
	PaymentMethodsSelectColumnAddedByUserID,
	PaymentMethodsSelectColumnCardBrand,
	PaymentMethodsSelectColumnCardExpMonth,
	PaymentMethodsSelectColumnCardExpYear,
	PaymentMethodsSelectColumnCardLast4,
	PaymentMethodsSelectColumnCreatedAt,
	PaymentMethodsSelectColumnID,
	PaymentMethodsSelectColumnIsDefault,
	PaymentMethodsSelectColumnStripePaymentMethodID,
	PaymentMethodsSelectColumnWorkspaceID,
}

func (e PaymentMethodsSelectColumn) IsValid() bool {
	switch e {
	case PaymentMethodsSelectColumnAddedByUserID, PaymentMethodsSelectColumnCardBrand, PaymentMethodsSelectColumnCardExpMonth, PaymentMethodsSelectColumnCardExpYear, PaymentMethodsSelectColumnCardLast4, PaymentMethodsSelectColumnCreatedAt, PaymentMethodsSelectColumnID, PaymentMethodsSelectColumnIsDefault, PaymentMethodsSelectColumnStripePaymentMethodID, PaymentMethodsSelectColumnWorkspaceID:
		return true
	}
	return false
}

func (e PaymentMethodsSelectColumn) String() string {
	return string(e)
}

func (e *PaymentMethodsSelectColumn) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PaymentMethodsSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid paymentMethods_select_column", str)
	}
	return nil
}

func (e PaymentMethodsSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *PaymentMethodsSelectColumn) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e PaymentMethodsSelectColumn) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// update columns of table "payment_methods"
type PaymentMethodsUpdateColumn string

const (
	// column name
	PaymentMethodsUpdateColumnIsDefault PaymentMethodsUpdateColumn = "isDefault"
)

var AllPaymentMethodsUpdateColumn = []PaymentMethodsUpdateColumn{
	PaymentMethodsUpdateColumnIsDefault,
}

func (e PaymentMethodsUpdateColumn) IsValid() bool {
	switch e {
	case PaymentMethodsUpdateColumnIsDefault:
		return true
	}
	return false
}

func (e PaymentMethodsUpdateColumn) String() string {
	return string(e)
}

func (e *PaymentMethodsUpdateColumn) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PaymentMethodsUpdateColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid paymentMethods_update_column", str)
	}
	return nil
}

func (e PaymentMethodsUpdateColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *PaymentMethodsUpdateColumn) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e PaymentMethodsUpdateColumn) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// select columns of table "plans"
type PlansSelectColumn string

const (
	// column name
	PlansSelectColumnCreatedAt PlansSelectColumn = "createdAt"
	// column name
	PlansSelectColumnDeprecated PlansSelectColumn = "deprecated"
	// column name
	PlansSelectColumnFeatureBackupEnabled PlansSelectColumn = "featureBackupEnabled"
	// column name
	PlansSelectColumnFeatureCustomDomainsEnabled PlansSelectColumn = "featureCustomDomainsEnabled"
	// column name
	PlansSelectColumnFeatureCustomEmailTemplatesEnabled PlansSelectColumn = "featureCustomEmailTemplatesEnabled"
	// column name
	PlansSelectColumnFeatureMaxDbSize PlansSelectColumn = "featureMaxDbSize"
	// column name
	PlansSelectColumnID PlansSelectColumn = "id"
	// column name
	PlansSelectColumnIndividual PlansSelectColumn = "individual"
	// column name
	PlansSelectColumnIsDefault PlansSelectColumn = "isDefault"
	// column name
	PlansSelectColumnIsFree PlansSelectColumn = "isFree"
	// column name
	PlansSelectColumnIsPublic PlansSelectColumn = "isPublic"
	// column name
	PlansSelectColumnName PlansSelectColumn = "name"
	// column name
	PlansSelectColumnPrice PlansSelectColumn = "price"
	// column name
	PlansSelectColumnSort PlansSelectColumn = "sort"
	// column name
	PlansSelectColumnUpatedAt PlansSelectColumn = "upatedAt"
)

var AllPlansSelectColumn = []PlansSelectColumn{
	PlansSelectColumnCreatedAt,
	PlansSelectColumnDeprecated,
	PlansSelectColumnFeatureBackupEnabled,
	PlansSelectColumnFeatureCustomDomainsEnabled,
	PlansSelectColumnFeatureCustomEmailTemplatesEnabled,
	PlansSelectColumnFeatureMaxDbSize,
	PlansSelectColumnID,
	PlansSelectColumnIndividual,
	PlansSelectColumnIsDefault,
	PlansSelectColumnIsFree,
	PlansSelectColumnIsPublic,
	PlansSelectColumnName,
	PlansSelectColumnPrice,
	PlansSelectColumnSort,
	PlansSelectColumnUpatedAt,
}

func (e PlansSelectColumn) IsValid() bool {
	switch e {
	case PlansSelectColumnCreatedAt, PlansSelectColumnDeprecated, PlansSelectColumnFeatureBackupEnabled, PlansSelectColumnFeatureCustomDomainsEnabled, PlansSelectColumnFeatureCustomEmailTemplatesEnabled, PlansSelectColumnFeatureMaxDbSize, PlansSelectColumnID, PlansSelectColumnIndividual, PlansSelectColumnIsDefault, PlansSelectColumnIsFree, PlansSelectColumnIsPublic, PlansSelectColumnName, PlansSelectColumnPrice, PlansSelectColumnSort, PlansSelectColumnUpatedAt:
		return true
	}
	return false
}

func (e PlansSelectColumn) String() string {
	return string(e)
}

func (e *PlansSelectColumn) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PlansSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid plans_select_column", str)
	}
	return nil
}

func (e PlansSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *PlansSelectColumn) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e PlansSelectColumn) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type RegionTypeEnum string

const (
	// Private region available to selected workspaces
	RegionTypeEnumPrivate RegionTypeEnum = "private"
	// Public region available to all Nhost projects
	RegionTypeEnumPublic RegionTypeEnum = "public"
)

var AllRegionTypeEnum = []RegionTypeEnum{
	RegionTypeEnumPrivate,
	RegionTypeEnumPublic,
}

func (e RegionTypeEnum) IsValid() bool {
	switch e {
	case RegionTypeEnumPrivate, RegionTypeEnumPublic:
		return true
	}
	return false
}

func (e RegionTypeEnum) String() string {
	return string(e)
}

func (e *RegionTypeEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RegionTypeEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid region_type_enum", str)
	}
	return nil
}

func (e RegionTypeEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *RegionTypeEnum) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e RegionTypeEnum) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// select columns of table "regions_allowed_organization"
type RegionsAllowedOrganizationSelectColumn string

const (
	// column name
	RegionsAllowedOrganizationSelectColumnCreatedAt RegionsAllowedOrganizationSelectColumn = "createdAt"
	// column name
	RegionsAllowedOrganizationSelectColumnDescription RegionsAllowedOrganizationSelectColumn = "description"
	// column name
	RegionsAllowedOrganizationSelectColumnID RegionsAllowedOrganizationSelectColumn = "id"
	// column name
	RegionsAllowedOrganizationSelectColumnOrganizationID RegionsAllowedOrganizationSelectColumn = "organizationID"
	// column name
	RegionsAllowedOrganizationSelectColumnRegionID RegionsAllowedOrganizationSelectColumn = "regionID"
	// column name
	RegionsAllowedOrganizationSelectColumnUpdatedAt RegionsAllowedOrganizationSelectColumn = "updatedAt"
)

var AllRegionsAllowedOrganizationSelectColumn = []RegionsAllowedOrganizationSelectColumn{
	RegionsAllowedOrganizationSelectColumnCreatedAt,
	RegionsAllowedOrganizationSelectColumnDescription,
	RegionsAllowedOrganizationSelectColumnID,
	RegionsAllowedOrganizationSelectColumnOrganizationID,
	RegionsAllowedOrganizationSelectColumnRegionID,
	RegionsAllowedOrganizationSelectColumnUpdatedAt,
}

func (e RegionsAllowedOrganizationSelectColumn) IsValid() bool {
	switch e {
	case RegionsAllowedOrganizationSelectColumnCreatedAt, RegionsAllowedOrganizationSelectColumnDescription, RegionsAllowedOrganizationSelectColumnID, RegionsAllowedOrganizationSelectColumnOrganizationID, RegionsAllowedOrganizationSelectColumnRegionID, RegionsAllowedOrganizationSelectColumnUpdatedAt:
		return true
	}
	return false
}

func (e RegionsAllowedOrganizationSelectColumn) String() string {
	return string(e)
}

func (e *RegionsAllowedOrganizationSelectColumn) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RegionsAllowedOrganizationSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid regions_allowed_organization_select_column", str)
	}
	return nil
}

func (e RegionsAllowedOrganizationSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *RegionsAllowedOrganizationSelectColumn) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e RegionsAllowedOrganizationSelectColumn) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// select columns of table "regions_allowed_workspace"
type RegionsAllowedWorkspaceSelectColumn string

const (
	// column name
	RegionsAllowedWorkspaceSelectColumnCreatedAt RegionsAllowedWorkspaceSelectColumn = "created_at"
	// column name
	RegionsAllowedWorkspaceSelectColumnDescription RegionsAllowedWorkspaceSelectColumn = "description"
	// column name
	RegionsAllowedWorkspaceSelectColumnID RegionsAllowedWorkspaceSelectColumn = "id"
	// column name
	RegionsAllowedWorkspaceSelectColumnRegionID RegionsAllowedWorkspaceSelectColumn = "region_id"
	// column name
	RegionsAllowedWorkspaceSelectColumnUpdatedAt RegionsAllowedWorkspaceSelectColumn = "updated_at"
	// column name
	RegionsAllowedWorkspaceSelectColumnWorkspaceID RegionsAllowedWorkspaceSelectColumn = "workspace_id"
)

var AllRegionsAllowedWorkspaceSelectColumn = []RegionsAllowedWorkspaceSelectColumn{
	RegionsAllowedWorkspaceSelectColumnCreatedAt,
	RegionsAllowedWorkspaceSelectColumnDescription,
	RegionsAllowedWorkspaceSelectColumnID,
	RegionsAllowedWorkspaceSelectColumnRegionID,
	RegionsAllowedWorkspaceSelectColumnUpdatedAt,
	RegionsAllowedWorkspaceSelectColumnWorkspaceID,
}

func (e RegionsAllowedWorkspaceSelectColumn) IsValid() bool {
	switch e {
	case RegionsAllowedWorkspaceSelectColumnCreatedAt, RegionsAllowedWorkspaceSelectColumnDescription, RegionsAllowedWorkspaceSelectColumnID, RegionsAllowedWorkspaceSelectColumnRegionID, RegionsAllowedWorkspaceSelectColumnUpdatedAt, RegionsAllowedWorkspaceSelectColumnWorkspaceID:
		return true
	}
	return false
}

func (e RegionsAllowedWorkspaceSelectColumn) String() string {
	return string(e)
}

func (e *RegionsAllowedWorkspaceSelectColumn) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RegionsAllowedWorkspaceSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid regions_allowed_workspace_select_column", str)
	}
	return nil
}

func (e RegionsAllowedWorkspaceSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *RegionsAllowedWorkspaceSelectColumn) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e RegionsAllowedWorkspaceSelectColumn) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// select columns of table "regions"
type RegionsSelectColumn string

const (
	// column name
	RegionsSelectColumnActive RegionsSelectColumn = "active"
	// column name
	RegionsSelectColumnAWSName RegionsSelectColumn = "awsName"
	// column name
	RegionsSelectColumnCity RegionsSelectColumn = "city"
	// column name
	RegionsSelectColumnCountryCode RegionsSelectColumn = "countryCode"
	// column name
	RegionsSelectColumnDescription RegionsSelectColumn = "description"
	// column name
	RegionsSelectColumnDomain RegionsSelectColumn = "domain"
	// column name
	RegionsSelectColumnID RegionsSelectColumn = "id"
	// column name
	RegionsSelectColumnIsGdprCompliant RegionsSelectColumn = "isGdprCompliant"
	// column name
	RegionsSelectColumnName RegionsSelectColumn = "name"
	// column name
	RegionsSelectColumnType RegionsSelectColumn = "type"
)

var AllRegionsSelectColumn = []RegionsSelectColumn{
	RegionsSelectColumnActive,
	RegionsSelectColumnAWSName,
	RegionsSelectColumnCity,
	RegionsSelectColumnCountryCode,
	RegionsSelectColumnDescription,
	RegionsSelectColumnDomain,
	RegionsSelectColumnID,
	RegionsSelectColumnIsGdprCompliant,
	RegionsSelectColumnName,
	RegionsSelectColumnType,
}

func (e RegionsSelectColumn) IsValid() bool {
	switch e {
	case RegionsSelectColumnActive, RegionsSelectColumnAWSName, RegionsSelectColumnCity, RegionsSelectColumnCountryCode, RegionsSelectColumnDescription, RegionsSelectColumnDomain, RegionsSelectColumnID, RegionsSelectColumnIsGdprCompliant, RegionsSelectColumnName, RegionsSelectColumnType:
		return true
	}
	return false
}

func (e RegionsSelectColumn) String() string {
	return string(e)
}

func (e *RegionsSelectColumn) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RegionsSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid regions_select_column", str)
	}
	return nil
}

func (e RegionsSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *RegionsSelectColumn) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e RegionsSelectColumn) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// select columns of table "run_service"
type RunServiceSelectColumn string

const (
	// column name
	RunServiceSelectColumnAppID RunServiceSelectColumn = "appID"
	// column name
	RunServiceSelectColumnCreatedAt RunServiceSelectColumn = "createdAt"
	// column name
	RunServiceSelectColumnID RunServiceSelectColumn = "id"
	// column name
	RunServiceSelectColumnSubdomain RunServiceSelectColumn = "subdomain"
	// column name
	RunServiceSelectColumnUpdatedAt RunServiceSelectColumn = "updatedAt"
)

var AllRunServiceSelectColumn = []RunServiceSelectColumn{
	RunServiceSelectColumnAppID,
	RunServiceSelectColumnCreatedAt,
	RunServiceSelectColumnID,
	RunServiceSelectColumnSubdomain,
	RunServiceSelectColumnUpdatedAt,
}

func (e RunServiceSelectColumn) IsValid() bool {
	switch e {
	case RunServiceSelectColumnAppID, RunServiceSelectColumnCreatedAt, RunServiceSelectColumnID, RunServiceSelectColumnSubdomain, RunServiceSelectColumnUpdatedAt:
		return true
	}
	return false
}

func (e RunServiceSelectColumn) String() string {
	return string(e)
}

func (e *RunServiceSelectColumn) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RunServiceSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid run_service_select_column", str)
	}
	return nil
}

func (e RunServiceSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *RunServiceSelectColumn) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e RunServiceSelectColumn) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type SoftwareTypeEnum string

const (
	// Hasura Auth
	SoftwareTypeEnumAuth SoftwareTypeEnum = "Auth"
	// Nhost AI service
	SoftwareTypeEnumGraphite SoftwareTypeEnum = "Graphite"
	// Hasura GraphQL Engine
	SoftwareTypeEnumHasura SoftwareTypeEnum = "Hasura"
	// PostgreSQL Database
	SoftwareTypeEnumPostgreSQL SoftwareTypeEnum = "PostgreSQL"
	// Hasura Storage
	SoftwareTypeEnumStorage SoftwareTypeEnum = "Storage"
)

var AllSoftwareTypeEnum = []SoftwareTypeEnum{
	SoftwareTypeEnumAuth,
	SoftwareTypeEnumGraphite,
	SoftwareTypeEnumHasura,
	SoftwareTypeEnumPostgreSQL,
	SoftwareTypeEnumStorage,
}

func (e SoftwareTypeEnum) IsValid() bool {
	switch e {
	case SoftwareTypeEnumAuth, SoftwareTypeEnumGraphite, SoftwareTypeEnumHasura, SoftwareTypeEnumPostgreSQL, SoftwareTypeEnumStorage:
		return true
	}
	return false
}

func (e SoftwareTypeEnum) String() string {
	return string(e)
}

func (e *SoftwareTypeEnum) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SoftwareTypeEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid software_type_enum", str)
	}
	return nil
}

func (e SoftwareTypeEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *SoftwareTypeEnum) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e SoftwareTypeEnum) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// select columns of table "software_versions"
type SoftwareVersionsSelectColumn string

const (
	// column name
	SoftwareVersionsSelectColumnID SoftwareVersionsSelectColumn = "id"
	// column name
	SoftwareVersionsSelectColumnSoftware SoftwareVersionsSelectColumn = "software"
	// column name
	SoftwareVersionsSelectColumnVersion SoftwareVersionsSelectColumn = "version"
)

var AllSoftwareVersionsSelectColumn = []SoftwareVersionsSelectColumn{
	SoftwareVersionsSelectColumnID,
	SoftwareVersionsSelectColumnSoftware,
	SoftwareVersionsSelectColumnVersion,
}

func (e SoftwareVersionsSelectColumn) IsValid() bool {
	switch e {
	case SoftwareVersionsSelectColumnID, SoftwareVersionsSelectColumnSoftware, SoftwareVersionsSelectColumnVersion:
		return true
	}
	return false
}

func (e SoftwareVersionsSelectColumn) String() string {
	return string(e)
}

func (e *SoftwareVersionsSelectColumn) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SoftwareVersionsSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid software_versions_select_column", str)
	}
	return nil
}

func (e SoftwareVersionsSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *SoftwareVersionsSelectColumn) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e SoftwareVersionsSelectColumn) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// select columns of table "auth.users"
type UsersSelectColumn string

const (
	// column name
	UsersSelectColumnActiveMfaType UsersSelectColumn = "activeMfaType"
	// column name
	UsersSelectColumnAvatarURL UsersSelectColumn = "avatarUrl"
	// column name
	UsersSelectColumnDisplayName UsersSelectColumn = "displayName"
	// column name
	UsersSelectColumnEmail UsersSelectColumn = "email"
	// column name
	UsersSelectColumnID UsersSelectColumn = "id"
)

var AllUsersSelectColumn = []UsersSelectColumn{
	UsersSelectColumnActiveMfaType,
	UsersSelectColumnAvatarURL,
	UsersSelectColumnDisplayName,
	UsersSelectColumnEmail,
	UsersSelectColumnID,
}

func (e UsersSelectColumn) IsValid() bool {
	switch e {
	case UsersSelectColumnActiveMfaType, UsersSelectColumnAvatarURL, UsersSelectColumnDisplayName, UsersSelectColumnEmail, UsersSelectColumnID:
		return true
	}
	return false
}

func (e UsersSelectColumn) String() string {
	return string(e)
}

func (e *UsersSelectColumn) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UsersSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid users_select_column", str)
	}
	return nil
}

func (e UsersSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *UsersSelectColumn) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e UsersSelectColumn) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// unique or primary key constraints on table "workspace_member_invites"
type WorkspaceMemberInvitesConstraint string

const (
	// unique or primary key constraint on columns "email", "workspace_id"
	WorkspaceMemberInvitesConstraintWorkspaceMemberInvitesEmailWorkspaceIDKey WorkspaceMemberInvitesConstraint = "workspace_member_invites_email_workspace_id_key"
	// unique or primary key constraint on columns "id"
	WorkspaceMemberInvitesConstraintWorkspaceMemberInvitesPkey WorkspaceMemberInvitesConstraint = "workspace_member_invites_pkey"
)

var AllWorkspaceMemberInvitesConstraint = []WorkspaceMemberInvitesConstraint{
	WorkspaceMemberInvitesConstraintWorkspaceMemberInvitesEmailWorkspaceIDKey,
	WorkspaceMemberInvitesConstraintWorkspaceMemberInvitesPkey,
}

func (e WorkspaceMemberInvitesConstraint) IsValid() bool {
	switch e {
	case WorkspaceMemberInvitesConstraintWorkspaceMemberInvitesEmailWorkspaceIDKey, WorkspaceMemberInvitesConstraintWorkspaceMemberInvitesPkey:
		return true
	}
	return false
}

func (e WorkspaceMemberInvitesConstraint) String() string {
	return string(e)
}

func (e *WorkspaceMemberInvitesConstraint) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WorkspaceMemberInvitesConstraint(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid workspaceMemberInvites_constraint", str)
	}
	return nil
}

func (e WorkspaceMemberInvitesConstraint) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *WorkspaceMemberInvitesConstraint) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e WorkspaceMemberInvitesConstraint) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// select columns of table "workspace_member_invites"
type WorkspaceMemberInvitesSelectColumn string

const (
	// column name
	WorkspaceMemberInvitesSelectColumnCreatedAt WorkspaceMemberInvitesSelectColumn = "createdAt"
	// column name
	WorkspaceMemberInvitesSelectColumnEmail WorkspaceMemberInvitesSelectColumn = "email"
	// column name
	WorkspaceMemberInvitesSelectColumnID WorkspaceMemberInvitesSelectColumn = "id"
	// column name
	WorkspaceMemberInvitesSelectColumnInvitedByUserID WorkspaceMemberInvitesSelectColumn = "invitedByUserId"
	// column name
	WorkspaceMemberInvitesSelectColumnMemberType WorkspaceMemberInvitesSelectColumn = "memberType"
	// column name
	WorkspaceMemberInvitesSelectColumnUpdatedAt WorkspaceMemberInvitesSelectColumn = "updatedAt"
	// column name
	WorkspaceMemberInvitesSelectColumnWorkspaceID WorkspaceMemberInvitesSelectColumn = "workspaceId"
)

var AllWorkspaceMemberInvitesSelectColumn = []WorkspaceMemberInvitesSelectColumn{
	WorkspaceMemberInvitesSelectColumnCreatedAt,
	WorkspaceMemberInvitesSelectColumnEmail,
	WorkspaceMemberInvitesSelectColumnID,
	WorkspaceMemberInvitesSelectColumnInvitedByUserID,
	WorkspaceMemberInvitesSelectColumnMemberType,
	WorkspaceMemberInvitesSelectColumnUpdatedAt,
	WorkspaceMemberInvitesSelectColumnWorkspaceID,
}

func (e WorkspaceMemberInvitesSelectColumn) IsValid() bool {
	switch e {
	case WorkspaceMemberInvitesSelectColumnCreatedAt, WorkspaceMemberInvitesSelectColumnEmail, WorkspaceMemberInvitesSelectColumnID, WorkspaceMemberInvitesSelectColumnInvitedByUserID, WorkspaceMemberInvitesSelectColumnMemberType, WorkspaceMemberInvitesSelectColumnUpdatedAt, WorkspaceMemberInvitesSelectColumnWorkspaceID:
		return true
	}
	return false
}

func (e WorkspaceMemberInvitesSelectColumn) String() string {
	return string(e)
}

func (e *WorkspaceMemberInvitesSelectColumn) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WorkspaceMemberInvitesSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid workspaceMemberInvites_select_column", str)
	}
	return nil
}

func (e WorkspaceMemberInvitesSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *WorkspaceMemberInvitesSelectColumn) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e WorkspaceMemberInvitesSelectColumn) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// update columns of table "workspace_member_invites"
type WorkspaceMemberInvitesUpdateColumn string

const (
	// column name
	WorkspaceMemberInvitesUpdateColumnMemberType WorkspaceMemberInvitesUpdateColumn = "memberType"
)

var AllWorkspaceMemberInvitesUpdateColumn = []WorkspaceMemberInvitesUpdateColumn{
	WorkspaceMemberInvitesUpdateColumnMemberType,
}

func (e WorkspaceMemberInvitesUpdateColumn) IsValid() bool {
	switch e {
	case WorkspaceMemberInvitesUpdateColumnMemberType:
		return true
	}
	return false
}

func (e WorkspaceMemberInvitesUpdateColumn) String() string {
	return string(e)
}

func (e *WorkspaceMemberInvitesUpdateColumn) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WorkspaceMemberInvitesUpdateColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid workspaceMemberInvites_update_column", str)
	}
	return nil
}

func (e WorkspaceMemberInvitesUpdateColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *WorkspaceMemberInvitesUpdateColumn) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e WorkspaceMemberInvitesUpdateColumn) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// unique or primary key constraints on table "workspace_members"
type WorkspaceMembersConstraint string

const (
	// unique or primary key constraint on columns "id"
	WorkspaceMembersConstraintWorkspaceMembersPkey WorkspaceMembersConstraint = "workspace_members_pkey"
	// unique or primary key constraint on columns "user_id", "workspace_id"
	WorkspaceMembersConstraintWorkspaceMembersUserIDWorkspaceIDKey WorkspaceMembersConstraint = "workspace_members_user_id_workspace_id_key"
)

var AllWorkspaceMembersConstraint = []WorkspaceMembersConstraint{
	WorkspaceMembersConstraintWorkspaceMembersPkey,
	WorkspaceMembersConstraintWorkspaceMembersUserIDWorkspaceIDKey,
}

func (e WorkspaceMembersConstraint) IsValid() bool {
	switch e {
	case WorkspaceMembersConstraintWorkspaceMembersPkey, WorkspaceMembersConstraintWorkspaceMembersUserIDWorkspaceIDKey:
		return true
	}
	return false
}

func (e WorkspaceMembersConstraint) String() string {
	return string(e)
}

func (e *WorkspaceMembersConstraint) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WorkspaceMembersConstraint(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid workspaceMembers_constraint", str)
	}
	return nil
}

func (e WorkspaceMembersConstraint) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *WorkspaceMembersConstraint) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e WorkspaceMembersConstraint) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// select columns of table "workspace_members"
type WorkspaceMembersSelectColumn string

const (
	// column name
	WorkspaceMembersSelectColumnCreatedAt WorkspaceMembersSelectColumn = "createdAt"
	// column name
	WorkspaceMembersSelectColumnID WorkspaceMembersSelectColumn = "id"
	// column name
	WorkspaceMembersSelectColumnType WorkspaceMembersSelectColumn = "type"
	// column name
	WorkspaceMembersSelectColumnUpdatedAt WorkspaceMembersSelectColumn = "updatedAt"
	// column name
	WorkspaceMembersSelectColumnUserID WorkspaceMembersSelectColumn = "userId"
	// column name
	WorkspaceMembersSelectColumnWorkspaceID WorkspaceMembersSelectColumn = "workspaceId"
)

var AllWorkspaceMembersSelectColumn = []WorkspaceMembersSelectColumn{
	WorkspaceMembersSelectColumnCreatedAt,
	WorkspaceMembersSelectColumnID,
	WorkspaceMembersSelectColumnType,
	WorkspaceMembersSelectColumnUpdatedAt,
	WorkspaceMembersSelectColumnUserID,
	WorkspaceMembersSelectColumnWorkspaceID,
}

func (e WorkspaceMembersSelectColumn) IsValid() bool {
	switch e {
	case WorkspaceMembersSelectColumnCreatedAt, WorkspaceMembersSelectColumnID, WorkspaceMembersSelectColumnType, WorkspaceMembersSelectColumnUpdatedAt, WorkspaceMembersSelectColumnUserID, WorkspaceMembersSelectColumnWorkspaceID:
		return true
	}
	return false
}

func (e WorkspaceMembersSelectColumn) String() string {
	return string(e)
}

func (e *WorkspaceMembersSelectColumn) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WorkspaceMembersSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid workspaceMembers_select_column", str)
	}
	return nil
}

func (e WorkspaceMembersSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *WorkspaceMembersSelectColumn) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e WorkspaceMembersSelectColumn) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// update columns of table "workspace_members"
type WorkspaceMembersUpdateColumn string

const (
	// column name
	WorkspaceMembersUpdateColumnType WorkspaceMembersUpdateColumn = "type"
)

var AllWorkspaceMembersUpdateColumn = []WorkspaceMembersUpdateColumn{
	WorkspaceMembersUpdateColumnType,
}

func (e WorkspaceMembersUpdateColumn) IsValid() bool {
	switch e {
	case WorkspaceMembersUpdateColumnType:
		return true
	}
	return false
}

func (e WorkspaceMembersUpdateColumn) String() string {
	return string(e)
}

func (e *WorkspaceMembersUpdateColumn) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WorkspaceMembersUpdateColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid workspaceMembers_update_column", str)
	}
	return nil
}

func (e WorkspaceMembersUpdateColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *WorkspaceMembersUpdateColumn) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e WorkspaceMembersUpdateColumn) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// unique or primary key constraints on table "workspaces"
type WorkspacesConstraint string

const (
	// unique or primary key constraint on columns "id"
	WorkspacesConstraintWorkspacesPkey WorkspacesConstraint = "workspaces_pkey"
	// unique or primary key constraint on columns "slug"
	WorkspacesConstraintWorkspacesSlugKey WorkspacesConstraint = "workspaces_slug_key"
)

var AllWorkspacesConstraint = []WorkspacesConstraint{
	WorkspacesConstraintWorkspacesPkey,
	WorkspacesConstraintWorkspacesSlugKey,
}

func (e WorkspacesConstraint) IsValid() bool {
	switch e {
	case WorkspacesConstraintWorkspacesPkey, WorkspacesConstraintWorkspacesSlugKey:
		return true
	}
	return false
}

func (e WorkspacesConstraint) String() string {
	return string(e)
}

func (e *WorkspacesConstraint) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WorkspacesConstraint(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid workspaces_constraint", str)
	}
	return nil
}

func (e WorkspacesConstraint) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *WorkspacesConstraint) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e WorkspacesConstraint) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// select columns of table "workspaces"
type WorkspacesSelectColumn string

const (
	// column name
	WorkspacesSelectColumnAddressCity WorkspacesSelectColumn = "addressCity"
	// column name
	WorkspacesSelectColumnAddressCountryCode WorkspacesSelectColumn = "addressCountryCode"
	// column name
	WorkspacesSelectColumnAddressLine1 WorkspacesSelectColumn = "addressLine1"
	// column name
	WorkspacesSelectColumnAddressLine2 WorkspacesSelectColumn = "addressLine2"
	// column name
	WorkspacesSelectColumnAddressPostalCode WorkspacesSelectColumn = "addressPostalCode"
	// column name
	WorkspacesSelectColumnAddressState WorkspacesSelectColumn = "addressState"
	// column name
	WorkspacesSelectColumnCompanyName WorkspacesSelectColumn = "companyName"
	// column name
	WorkspacesSelectColumnCreatedAt WorkspacesSelectColumn = "createdAt"
	// column name
	WorkspacesSelectColumnCreatorUserID WorkspacesSelectColumn = "creatorUserId"
	// column name
	WorkspacesSelectColumnEmail WorkspacesSelectColumn = "email"
	// column name
	WorkspacesSelectColumnID WorkspacesSelectColumn = "id"
	// column name
	WorkspacesSelectColumnName WorkspacesSelectColumn = "name"
	// column name
	WorkspacesSelectColumnSlug WorkspacesSelectColumn = "slug"
	// column name
	WorkspacesSelectColumnTaxIDType WorkspacesSelectColumn = "taxIdType"
	// column name
	WorkspacesSelectColumnTaxIDValue WorkspacesSelectColumn = "taxIdValue"
	// column name
	WorkspacesSelectColumnUpdatedAt WorkspacesSelectColumn = "updatedAt"
)

var AllWorkspacesSelectColumn = []WorkspacesSelectColumn{
	WorkspacesSelectColumnAddressCity,
	WorkspacesSelectColumnAddressCountryCode,
	WorkspacesSelectColumnAddressLine1,
	WorkspacesSelectColumnAddressLine2,
	WorkspacesSelectColumnAddressPostalCode,
	WorkspacesSelectColumnAddressState,
	WorkspacesSelectColumnCompanyName,
	WorkspacesSelectColumnCreatedAt,
	WorkspacesSelectColumnCreatorUserID,
	WorkspacesSelectColumnEmail,
	WorkspacesSelectColumnID,
	WorkspacesSelectColumnName,
	WorkspacesSelectColumnSlug,
	WorkspacesSelectColumnTaxIDType,
	WorkspacesSelectColumnTaxIDValue,
	WorkspacesSelectColumnUpdatedAt,
}

func (e WorkspacesSelectColumn) IsValid() bool {
	switch e {
	case WorkspacesSelectColumnAddressCity, WorkspacesSelectColumnAddressCountryCode, WorkspacesSelectColumnAddressLine1, WorkspacesSelectColumnAddressLine2, WorkspacesSelectColumnAddressPostalCode, WorkspacesSelectColumnAddressState, WorkspacesSelectColumnCompanyName, WorkspacesSelectColumnCreatedAt, WorkspacesSelectColumnCreatorUserID, WorkspacesSelectColumnEmail, WorkspacesSelectColumnID, WorkspacesSelectColumnName, WorkspacesSelectColumnSlug, WorkspacesSelectColumnTaxIDType, WorkspacesSelectColumnTaxIDValue, WorkspacesSelectColumnUpdatedAt:
		return true
	}
	return false
}

func (e WorkspacesSelectColumn) String() string {
	return string(e)
}

func (e *WorkspacesSelectColumn) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WorkspacesSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid workspaces_select_column", str)
	}
	return nil
}

func (e WorkspacesSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *WorkspacesSelectColumn) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e WorkspacesSelectColumn) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// update columns of table "workspaces"
type WorkspacesUpdateColumn string

const (
	// column name
	WorkspacesUpdateColumnAddressCity WorkspacesUpdateColumn = "addressCity"
	// column name
	WorkspacesUpdateColumnAddressCountryCode WorkspacesUpdateColumn = "addressCountryCode"
	// column name
	WorkspacesUpdateColumnAddressLine1 WorkspacesUpdateColumn = "addressLine1"
	// column name
	WorkspacesUpdateColumnAddressLine2 WorkspacesUpdateColumn = "addressLine2"
	// column name
	WorkspacesUpdateColumnAddressPostalCode WorkspacesUpdateColumn = "addressPostalCode"
	// column name
	WorkspacesUpdateColumnAddressState WorkspacesUpdateColumn = "addressState"
	// column name
	WorkspacesUpdateColumnCompanyName WorkspacesUpdateColumn = "companyName"
	// column name
	WorkspacesUpdateColumnEmail WorkspacesUpdateColumn = "email"
	// column name
	WorkspacesUpdateColumnName WorkspacesUpdateColumn = "name"
	// column name
	WorkspacesUpdateColumnSlug WorkspacesUpdateColumn = "slug"
	// column name
	WorkspacesUpdateColumnTaxIDType WorkspacesUpdateColumn = "taxIdType"
	// column name
	WorkspacesUpdateColumnTaxIDValue WorkspacesUpdateColumn = "taxIdValue"
)

var AllWorkspacesUpdateColumn = []WorkspacesUpdateColumn{
	WorkspacesUpdateColumnAddressCity,
	WorkspacesUpdateColumnAddressCountryCode,
	WorkspacesUpdateColumnAddressLine1,
	WorkspacesUpdateColumnAddressLine2,
	WorkspacesUpdateColumnAddressPostalCode,
	WorkspacesUpdateColumnAddressState,
	WorkspacesUpdateColumnCompanyName,
	WorkspacesUpdateColumnEmail,
	WorkspacesUpdateColumnName,
	WorkspacesUpdateColumnSlug,
	WorkspacesUpdateColumnTaxIDType,
	WorkspacesUpdateColumnTaxIDValue,
}

func (e WorkspacesUpdateColumn) IsValid() bool {
	switch e {
	case WorkspacesUpdateColumnAddressCity, WorkspacesUpdateColumnAddressCountryCode, WorkspacesUpdateColumnAddressLine1, WorkspacesUpdateColumnAddressLine2, WorkspacesUpdateColumnAddressPostalCode, WorkspacesUpdateColumnAddressState, WorkspacesUpdateColumnCompanyName, WorkspacesUpdateColumnEmail, WorkspacesUpdateColumnName, WorkspacesUpdateColumnSlug, WorkspacesUpdateColumnTaxIDType, WorkspacesUpdateColumnTaxIDValue:
		return true
	}
	return false
}

func (e WorkspacesUpdateColumn) String() string {
	return string(e)
}

func (e *WorkspacesUpdateColumn) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WorkspacesUpdateColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid workspaces_update_column", str)
	}
	return nil
}

func (e WorkspacesUpdateColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *WorkspacesUpdateColumn) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e WorkspacesUpdateColumn) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}
